/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var functions = __webpack_require__(/*! firebase-functions */ \"./src/node_modules/firebase-functions/lib/index.js\");\n\nvar cheerio = __webpack_require__(/*! cheerio */ \"./src/node_modules/cheerio/lib/index.js\");\n\nvar fetch = __webpack_require__(/*! node-fetch */ \"node-fetch\");\n\nvar _require = __webpack_require__(/*! lodash */ \"lodash\"),\n    intersection = _require.intersection;\n\nvar getRecipe = function getRecipe(body) {\n  var $ = cheerio.load(body);\n  var payload = $('script[type=\"application/ld+json\"]'); // TODO: Handle this case\n\n  if (payload.length > 1) {\n    return Promise.reject('Found more than one result for payload.');\n  }\n\n  var json = payload.html().trim();\n\n  if (json[json.length - 1] !== \"}\" && json[json.length - 1] !== \"]\") {\n    if (json[json.length - 2] === \"}\") {\n      json = String(json).substring(0, json.length - 1);\n    } else {\n      return Promise.reject('Unable to parse recipe');\n    }\n  }\n\n  var tree = JSON.parse(json);\n\n  if (Object.keys(tree).includes(\"@type\") && tree[\"@type\"] === \"Recipe\") {\n    return Promise.resolve(tree);\n  }\n\n  if (Object.keys(tree).includes(\"@graph\")) {\n    tree = tree[\"@graph\"];\n  }\n\n  var asJson = Array.from(tree).filter(function (item) {\n    return Object.keys(item).includes('@type');\n  }).filter(function (item) {\n    return item['@type'] === \"Recipe\";\n  });\n\n  if (asJson.length > 0) {\n    return Promise.resolve(asJson[0]);\n  } else {\n    return Promise.reject('Unable to grab recipe');\n  }\n};\n\nvar formatResponse = function formatResponse(ld) {\n  var instructions = ld.recipeInstructions;\n\n  if (Array.isArray(instructions)) {\n    var instructionTypes = ld.recipeInstructions.filter(function (instruction) {\n      return instruction.itemListElement && Array.isArray(instruction.itemListElement);\n    }); // If all the instructions are of type 'HowToSection'...\n\n    if (instructionTypes.length === ld.recipeInstructions.length) {\n      instructions = ld.recipeInstructions.map(function (instruction) {\n        return instruction.itemListElement.flat();\n      }).flat();\n    }\n  } else if (typeof instructions === 'string') {\n    instructions = instructions.split('. ').filter(function (instruction) {\n      return !!instruction;\n    }).map(function (instruction) {\n      return {\n        text: instruction.trim()\n      };\n    });\n  }\n\n  return {\n    title: ld.name,\n    instructions: instructions,\n    ingredients: ld.recipeIngredient\n  };\n};\n\nvar constructUrl = function constructUrl(url) {\n  if (url.startsWith('http://') || url.startsWith('https://')) {\n    return url;\n  } else {\n    return \"https://\".concat(url);\n  }\n};\n\nexports.main = functions.https.onRequest(function (req, res) {\n  var url = req.query.url;\n  res.header('Access-Control-Allow-Origin', '*');\n  res.header('Content-Type', 'application/json');\n\n  if (!url) {\n    res.send(JSON.stringify({\n      \"error\": \"No URL to extract.\"\n    }));\n  }\n\n  fetch(constructUrl(url)).then(function (r) {\n    return r.text();\n  }).then(getRecipe).then(function (r) {\n    res.send(JSON.stringify(formatResponse(r)));\n  })[\"catch\"](function (err) {\n    console.error(err);\n    res.status(500);\n    res.send(JSON.stringify({\n      \"error\": err\n    }));\n  });\n});\nexports.ssr = functions.https.onRequest(function (req, res) {});\n\n//# sourceURL=webpack://shorter.recipes/./src/index.js?");

/***/ }),

/***/ "./src/node_modules/@firebase/app/dist/index.esm.js":
/*!**********************************************************!*\
  !*** ./src/node_modules/@firebase/app/dist/index.esm.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"firebase\": () => (/* binding */ firebase$1)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"tslib\");\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tslib__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/util */ \"./src/node_modules/@firebase/util/dist/index.esm.js\");\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/component */ \"./src/node_modules/@firebase/component/dist/index.esm.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @firebase/logger */ \"./src/node_modules/@firebase/logger/dist/index.esm.js\");\n\n\n\n\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar _a;\r\nvar ERRORS = (_a = {},\r\n    _a[\"no-app\" /* NO_APP */] = \"No Firebase App '{$appName}' has been created - \" +\r\n        'call Firebase App.initializeApp()',\r\n    _a[\"bad-app-name\" /* BAD_APP_NAME */] = \"Illegal App name: '{$appName}\",\r\n    _a[\"duplicate-app\" /* DUPLICATE_APP */] = \"Firebase App named '{$appName}' already exists\",\r\n    _a[\"app-deleted\" /* APP_DELETED */] = \"Firebase App named '{$appName}' already deleted\",\r\n    _a[\"invalid-app-argument\" /* INVALID_APP_ARGUMENT */] = 'firebase.{$appName}() takes either no argument or a ' +\r\n        'Firebase App instance.',\r\n    _a[\"invalid-log-argument\" /* INVALID_LOG_ARGUMENT */] = 'First argument to `onLog` must be null or a function.',\r\n    _a);\r\nvar ERROR_FACTORY = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.ErrorFactory('app', 'Firebase', ERRORS);\n\nvar name$1 = \"@firebase/app\";\nvar version = \"0.6.11\";\n\nvar name$2 = \"@firebase/analytics\";\n\nvar name$3 = \"@firebase/auth\";\n\nvar name$4 = \"@firebase/database\";\n\nvar name$5 = \"@firebase/functions\";\n\nvar name$6 = \"@firebase/installations\";\n\nvar name$7 = \"@firebase/messaging\";\n\nvar name$8 = \"@firebase/performance\";\n\nvar name$9 = \"@firebase/remote-config\";\n\nvar name$a = \"@firebase/storage\";\n\nvar name$b = \"@firebase/firestore\";\n\nvar name$c = \"firebase-wrapper\";\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar _a$1;\r\nvar DEFAULT_ENTRY_NAME = '[DEFAULT]';\r\nvar PLATFORM_LOG_STRING = (_a$1 = {},\r\n    _a$1[name$1] = 'fire-core',\r\n    _a$1[name$2] = 'fire-analytics',\r\n    _a$1[name$3] = 'fire-auth',\r\n    _a$1[name$4] = 'fire-rtdb',\r\n    _a$1[name$5] = 'fire-fn',\r\n    _a$1[name$6] = 'fire-iid',\r\n    _a$1[name$7] = 'fire-fcm',\r\n    _a$1[name$8] = 'fire-perf',\r\n    _a$1[name$9] = 'fire-rc',\r\n    _a$1[name$a] = 'fire-gcs',\r\n    _a$1[name$b] = 'fire-fst',\r\n    _a$1['fire-js'] = 'fire-js',\r\n    _a$1[name$c] = 'fire-js-all',\r\n    _a$1);\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar logger = new _firebase_logger__WEBPACK_IMPORTED_MODULE_3__.Logger('@firebase/app');\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Global context object for a collection of services using\r\n * a shared authentication state.\r\n */\r\nvar FirebaseAppImpl = /** @class */ (function () {\r\n    function FirebaseAppImpl(options, config, firebase_) {\r\n        var e_1, _a;\r\n        var _this = this;\r\n        this.firebase_ = firebase_;\r\n        this.isDeleted_ = false;\r\n        this.name_ = config.name;\r\n        this.automaticDataCollectionEnabled_ =\r\n            config.automaticDataCollectionEnabled || false;\r\n        this.options_ = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.deepCopy)(options);\r\n        this.container = new _firebase_component__WEBPACK_IMPORTED_MODULE_2__.ComponentContainer(config.name);\r\n        // add itself to container\r\n        this._addComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_2__.Component('app', function () { return _this; }, \"PUBLIC\" /* PUBLIC */));\r\n        try {\r\n            // populate ComponentContainer with existing components\r\n            for (var _b = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__values)(this.firebase_.INTERNAL.components.values()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var component = _c.value;\r\n                this._addComponent(component);\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n    }\r\n    Object.defineProperty(FirebaseAppImpl.prototype, \"automaticDataCollectionEnabled\", {\r\n        get: function () {\r\n            this.checkDestroyed_();\r\n            return this.automaticDataCollectionEnabled_;\r\n        },\r\n        set: function (val) {\r\n            this.checkDestroyed_();\r\n            this.automaticDataCollectionEnabled_ = val;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(FirebaseAppImpl.prototype, \"name\", {\r\n        get: function () {\r\n            this.checkDestroyed_();\r\n            return this.name_;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(FirebaseAppImpl.prototype, \"options\", {\r\n        get: function () {\r\n            this.checkDestroyed_();\r\n            return this.options_;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    FirebaseAppImpl.prototype.delete = function () {\r\n        var _this = this;\r\n        return new Promise(function (resolve) {\r\n            _this.checkDestroyed_();\r\n            resolve();\r\n        })\r\n            .then(function () {\r\n            _this.firebase_.INTERNAL.removeApp(_this.name_);\r\n            return Promise.all(_this.container.getProviders().map(function (provider) { return provider.delete(); }));\r\n        })\r\n            .then(function () {\r\n            _this.isDeleted_ = true;\r\n        });\r\n    };\r\n    /**\r\n     * Return a service instance associated with this app (creating it\r\n     * on demand), identified by the passed instanceIdentifier.\r\n     *\r\n     * NOTE: Currently storage and functions are the only ones that are leveraging this\r\n     * functionality. They invoke it by calling:\r\n     *\r\n     * ```javascript\r\n     * firebase.app().storage('STORAGE BUCKET ID')\r\n     * ```\r\n     *\r\n     * The service name is passed to this already\r\n     * @internal\r\n     */\r\n    FirebaseAppImpl.prototype._getService = function (name, instanceIdentifier) {\r\n        if (instanceIdentifier === void 0) { instanceIdentifier = DEFAULT_ENTRY_NAME; }\r\n        this.checkDestroyed_();\r\n        // getImmediate will always succeed because _getService is only called for registered components.\r\n        return this.container.getProvider(name).getImmediate({\r\n            identifier: instanceIdentifier\r\n        });\r\n    };\r\n    /**\r\n     * Remove a service instance from the cache, so we will create a new instance for this service\r\n     * when people try to get this service again.\r\n     *\r\n     * NOTE: currently only firestore is using this functionality to support firestore shutdown.\r\n     *\r\n     * @param name The service name\r\n     * @param instanceIdentifier instance identifier in case multiple instances are allowed\r\n     * @internal\r\n     */\r\n    FirebaseAppImpl.prototype._removeServiceInstance = function (name, instanceIdentifier) {\r\n        if (instanceIdentifier === void 0) { instanceIdentifier = DEFAULT_ENTRY_NAME; }\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        this.container.getProvider(name).clearInstance(instanceIdentifier);\r\n    };\r\n    /**\r\n     * @param component the component being added to this app's container\r\n     */\r\n    FirebaseAppImpl.prototype._addComponent = function (component) {\r\n        try {\r\n            this.container.addComponent(component);\r\n        }\r\n        catch (e) {\r\n            logger.debug(\"Component \" + component.name + \" failed to register with FirebaseApp \" + this.name, e);\r\n        }\r\n    };\r\n    FirebaseAppImpl.prototype._addOrOverwriteComponent = function (component) {\r\n        this.container.addOrOverwriteComponent(component);\r\n    };\r\n    /**\r\n     * This function will throw an Error if the App has already been deleted -\r\n     * use before performing API actions on the App.\r\n     */\r\n    FirebaseAppImpl.prototype.checkDestroyed_ = function () {\r\n        if (this.isDeleted_) {\r\n            throw ERROR_FACTORY.create(\"app-deleted\" /* APP_DELETED */, { appName: this.name_ });\r\n        }\r\n    };\r\n    return FirebaseAppImpl;\r\n}());\r\n// Prevent dead-code elimination of these methods w/o invalid property\r\n// copying.\r\n(FirebaseAppImpl.prototype.name && FirebaseAppImpl.prototype.options) ||\r\n    FirebaseAppImpl.prototype.delete ||\r\n    console.log('dc');\n\nvar version$1 = \"7.20.0\";\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Because auth can't share code with other components, we attach the utility functions\r\n * in an internal namespace to share code.\r\n * This function return a firebase namespace object without\r\n * any utility functions, so it can be shared between the regular firebaseNamespace and\r\n * the lite version.\r\n */\r\nfunction createFirebaseNamespaceCore(firebaseAppImpl) {\r\n    var apps = {};\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    var components = new Map();\r\n    // A namespace is a plain JavaScript Object.\r\n    var namespace = {\r\n        // Hack to prevent Babel from modifying the object returned\r\n        // as the firebase namespace.\r\n        // @ts-ignore\r\n        __esModule: true,\r\n        initializeApp: initializeApp,\r\n        // @ts-ignore\r\n        app: app,\r\n        registerVersion: registerVersion,\r\n        setLogLevel: _firebase_logger__WEBPACK_IMPORTED_MODULE_3__.setLogLevel,\r\n        onLog: onLog,\r\n        // @ts-ignore\r\n        apps: null,\r\n        SDK_VERSION: version$1,\r\n        INTERNAL: {\r\n            registerComponent: registerComponent,\r\n            removeApp: removeApp,\r\n            components: components,\r\n            useAsService: useAsService\r\n        }\r\n    };\r\n    // Inject a circular default export to allow Babel users who were previously\r\n    // using:\r\n    //\r\n    //   import firebase from 'firebase';\r\n    //   which becomes: var firebase = require('firebase').default;\r\n    //\r\n    // instead of\r\n    //\r\n    //   import * as firebase from 'firebase';\r\n    //   which becomes: var firebase = require('firebase');\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    namespace['default'] = namespace;\r\n    // firebase.apps is a read-only getter.\r\n    Object.defineProperty(namespace, 'apps', {\r\n        get: getApps\r\n    });\r\n    /**\r\n     * Called by App.delete() - but before any services associated with the App\r\n     * are deleted.\r\n     */\r\n    function removeApp(name) {\r\n        delete apps[name];\r\n    }\r\n    /**\r\n     * Get the App object for a given name (or DEFAULT).\r\n     */\r\n    function app(name) {\r\n        name = name || DEFAULT_ENTRY_NAME;\r\n        if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.contains)(apps, name)) {\r\n            throw ERROR_FACTORY.create(\"no-app\" /* NO_APP */, { appName: name });\r\n        }\r\n        return apps[name];\r\n    }\r\n    // @ts-ignore\r\n    app['App'] = firebaseAppImpl;\r\n    function initializeApp(options, rawConfig) {\r\n        if (rawConfig === void 0) { rawConfig = {}; }\r\n        if (typeof rawConfig !== 'object' || rawConfig === null) {\r\n            var name_1 = rawConfig;\r\n            rawConfig = { name: name_1 };\r\n        }\r\n        var config = rawConfig;\r\n        if (config.name === undefined) {\r\n            config.name = DEFAULT_ENTRY_NAME;\r\n        }\r\n        var name = config.name;\r\n        if (typeof name !== 'string' || !name) {\r\n            throw ERROR_FACTORY.create(\"bad-app-name\" /* BAD_APP_NAME */, {\r\n                appName: String(name)\r\n            });\r\n        }\r\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.contains)(apps, name)) {\r\n            throw ERROR_FACTORY.create(\"duplicate-app\" /* DUPLICATE_APP */, { appName: name });\r\n        }\r\n        var app = new firebaseAppImpl(options, config, namespace);\r\n        apps[name] = app;\r\n        return app;\r\n    }\r\n    /*\r\n     * Return an array of all the non-deleted FirebaseApps.\r\n     */\r\n    function getApps() {\r\n        // Make a copy so caller cannot mutate the apps list.\r\n        return Object.keys(apps).map(function (name) { return apps[name]; });\r\n    }\r\n    function registerComponent(component) {\r\n        var e_1, _a;\r\n        var componentName = component.name;\r\n        if (components.has(componentName)) {\r\n            logger.debug(\"There were multiple attempts to register component \" + componentName + \".\");\r\n            return component.type === \"PUBLIC\" /* PUBLIC */\r\n                ? // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                    namespace[componentName]\r\n                : null;\r\n        }\r\n        components.set(componentName, component);\r\n        // create service namespace for public components\r\n        if (component.type === \"PUBLIC\" /* PUBLIC */) {\r\n            // The Service namespace is an accessor function ...\r\n            var serviceNamespace = function (appArg) {\r\n                if (appArg === void 0) { appArg = app(); }\r\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                if (typeof appArg[componentName] !== 'function') {\r\n                    // Invalid argument.\r\n                    // This happens in the following case: firebase.storage('gs:/')\r\n                    throw ERROR_FACTORY.create(\"invalid-app-argument\" /* INVALID_APP_ARGUMENT */, {\r\n                        appName: componentName\r\n                    });\r\n                }\r\n                // Forward service instance lookup to the FirebaseApp.\r\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                return appArg[componentName]();\r\n            };\r\n            // ... and a container for service-level properties.\r\n            if (component.serviceProps !== undefined) {\r\n                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.deepExtend)(serviceNamespace, component.serviceProps);\r\n            }\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            namespace[componentName] = serviceNamespace;\r\n            // Patch the FirebaseAppImpl prototype\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            firebaseAppImpl.prototype[componentName] =\r\n                // TODO: The eslint disable can be removed and the 'ignoreRestArgs'\r\n                // option added to the no-explicit-any rule when ESlint releases it.\r\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                function () {\r\n                    var args = [];\r\n                    for (var _i = 0; _i < arguments.length; _i++) {\r\n                        args[_i] = arguments[_i];\r\n                    }\r\n                    var serviceFxn = this._getService.bind(this, componentName);\r\n                    return serviceFxn.apply(this, component.multipleInstances ? args : []);\r\n                };\r\n        }\r\n        try {\r\n            // add the component to existing app instances\r\n            for (var _b = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__values)(Object.keys(apps)), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var appName = _c.value;\r\n                apps[appName]._addComponent(component);\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n        return component.type === \"PUBLIC\" /* PUBLIC */\r\n            ? // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                namespace[componentName]\r\n            : null;\r\n    }\r\n    function registerVersion(libraryKeyOrName, version, variant) {\r\n        var _a;\r\n        // TODO: We can use this check to whitelist strings when/if we set up\r\n        // a good whitelist system.\r\n        var library = (_a = PLATFORM_LOG_STRING[libraryKeyOrName]) !== null && _a !== void 0 ? _a : libraryKeyOrName;\r\n        if (variant) {\r\n            library += \"-\" + variant;\r\n        }\r\n        var libraryMismatch = library.match(/\\s|\\//);\r\n        var versionMismatch = version.match(/\\s|\\//);\r\n        if (libraryMismatch || versionMismatch) {\r\n            var warning = [\r\n                \"Unable to register library \\\"\" + library + \"\\\" with version \\\"\" + version + \"\\\":\"\r\n            ];\r\n            if (libraryMismatch) {\r\n                warning.push(\"library name \\\"\" + library + \"\\\" contains illegal characters (whitespace or \\\"/\\\")\");\r\n            }\r\n            if (libraryMismatch && versionMismatch) {\r\n                warning.push('and');\r\n            }\r\n            if (versionMismatch) {\r\n                warning.push(\"version name \\\"\" + version + \"\\\" contains illegal characters (whitespace or \\\"/\\\")\");\r\n            }\r\n            logger.warn(warning.join(' '));\r\n            return;\r\n        }\r\n        registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_2__.Component(library + \"-version\", function () { return ({ library: library, version: version }); }, \"VERSION\" /* VERSION */));\r\n    }\r\n    function onLog(logCallback, options) {\r\n        if (logCallback !== null && typeof logCallback !== 'function') {\r\n            throw ERROR_FACTORY.create(\"invalid-log-argument\" /* INVALID_LOG_ARGUMENT */, {\r\n                appName: name\r\n            });\r\n        }\r\n        (0,_firebase_logger__WEBPACK_IMPORTED_MODULE_3__.setUserLogHandler)(logCallback, options);\r\n    }\r\n    // Map the requested service to a registered service name\r\n    // (used to map auth to serverAuth service when needed).\r\n    function useAsService(app, name) {\r\n        if (name === 'serverAuth') {\r\n            return null;\r\n        }\r\n        var useService = name;\r\n        return useService;\r\n    }\r\n    return namespace;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Return a firebase namespace object.\r\n *\r\n * In production, this will be called exactly once and the result\r\n * assigned to the 'firebase' global.  It may be called multiple times\r\n * in unit tests.\r\n */\r\nfunction createFirebaseNamespace() {\r\n    var namespace = createFirebaseNamespaceCore(FirebaseAppImpl);\r\n    namespace.INTERNAL = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)({}, namespace.INTERNAL), { createFirebaseNamespace: createFirebaseNamespace,\r\n        extendNamespace: extendNamespace,\r\n        createSubscribe: _firebase_util__WEBPACK_IMPORTED_MODULE_1__.createSubscribe,\r\n        ErrorFactory: _firebase_util__WEBPACK_IMPORTED_MODULE_1__.ErrorFactory,\r\n        deepExtend: _firebase_util__WEBPACK_IMPORTED_MODULE_1__.deepExtend });\r\n    /**\r\n     * Patch the top-level firebase namespace with additional properties.\r\n     *\r\n     * firebase.INTERNAL.extendNamespace()\r\n     */\r\n    function extendNamespace(props) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.deepExtend)(namespace, props);\r\n    }\r\n    return namespace;\r\n}\r\nvar firebase = createFirebaseNamespace();\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar PlatformLoggerService = /** @class */ (function () {\r\n    function PlatformLoggerService(container) {\r\n        this.container = container;\r\n    }\r\n    // In initial implementation, this will be called by installations on\r\n    // auth token refresh, and installations will send this string.\r\n    PlatformLoggerService.prototype.getPlatformInfoString = function () {\r\n        var providers = this.container.getProviders();\r\n        // Loop through providers and get library/version pairs from any that are\r\n        // version components.\r\n        return providers\r\n            .map(function (provider) {\r\n            if (isVersionServiceProvider(provider)) {\r\n                var service = provider.getImmediate();\r\n                return service.library + \"/\" + service.version;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        })\r\n            .filter(function (logString) { return logString; })\r\n            .join(' ');\r\n    };\r\n    return PlatformLoggerService;\r\n}());\r\n/**\r\n *\r\n * @param provider check if this provider provides a VersionService\r\n *\r\n * NOTE: Using Provider<'app-version'> is a hack to indicate that the provider\r\n * provides VersionService. The provider is not necessarily a 'app-version'\r\n * provider.\r\n */\r\nfunction isVersionServiceProvider(provider) {\r\n    var component = provider.getComponent();\r\n    return (component === null || component === void 0 ? void 0 : component.type) === \"VERSION\" /* VERSION */;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction registerCoreComponents(firebase, variant) {\r\n    firebase.INTERNAL.registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_2__.Component('platform-logger', function (container) { return new PlatformLoggerService(container); }, \"PRIVATE\" /* PRIVATE */));\r\n    // Register `app` package.\r\n    firebase.registerVersion(name$1, version, variant);\r\n    // Register platform SDK identifier (no version).\r\n    firebase.registerVersion('fire-js', '');\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// Firebase Lite detection test\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nif ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isBrowser)() && self.firebase !== undefined) {\r\n    logger.warn(\"\\n    Warning: Firebase is already defined in the global scope. Please make sure\\n    Firebase library is only loaded once.\\n  \");\r\n    // eslint-disable-next-line\r\n    var sdkVersion = self.firebase.SDK_VERSION;\r\n    if (sdkVersion && sdkVersion.indexOf('LITE') >= 0) {\r\n        logger.warn(\"\\n    Warning: You are trying to load Firebase while using Firebase Performance standalone script.\\n    You should load Firebase Performance with this instance of Firebase to avoid loading duplicate code.\\n    \");\r\n    }\r\n}\r\nvar initializeApp = firebase.initializeApp;\r\n// TODO: This disable can be removed and the 'ignoreRestArgs' option added to\r\n// the no-explicit-any rule when ESlint releases it.\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nfirebase.initializeApp = function () {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n    // Environment check before initializing app\r\n    // Do the check in initializeApp, so people have a chance to disable it by setting logLevel\r\n    // in @firebase/logger\r\n    if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isNode)()) {\r\n        logger.warn(\"\\n      Warning: This is a browser-targeted Firebase bundle but it appears it is being\\n      run in a Node environment.  If running in a Node environment, make sure you\\n      are using the bundle specified by the \\\"main\\\" field in package.json.\\n      \\n      If you are using Webpack, you can specify \\\"main\\\" as the first item in\\n      \\\"resolve.mainFields\\\":\\n      https://webpack.js.org/configuration/resolve/#resolvemainfields\\n      \\n      If using Rollup, use the rollup-plugin-node-resolve plugin and specify \\\"main\\\"\\n      as the first item in \\\"mainFields\\\", e.g. ['main', 'module'].\\n      https://github.com/rollup/rollup-plugin-node-resolve\\n      \");\r\n    }\r\n    return initializeApp.apply(undefined, args);\r\n};\r\nvar firebase$1 = firebase;\r\nregisterCoreComponents(firebase$1);\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (firebase$1);\n\n//# sourceMappingURL=index.esm.js.map\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@firebase/app/dist/index.esm.js?");

/***/ }),

/***/ "./src/node_modules/@firebase/component/dist/index.esm.js":
/*!****************************************************************!*\
  !*** ./src/node_modules/@firebase/component/dist/index.esm.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Component\": () => (/* binding */ Component),\n/* harmony export */   \"ComponentContainer\": () => (/* binding */ ComponentContainer),\n/* harmony export */   \"Provider\": () => (/* binding */ Provider)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"tslib\");\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tslib__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/util */ \"./src/node_modules/@firebase/util/dist/index.esm.js\");\n\n\n\n/**\r\n * Component for service name T, e.g. `auth`, `auth-internal`\r\n */\r\nvar Component = /** @class */ (function () {\r\n    /**\r\n     *\r\n     * @param name The public service name, e.g. app, auth, firestore, database\r\n     * @param instanceFactory Service factory responsible for creating the public interface\r\n     * @param type whether the service provided by the component is public or private\r\n     */\r\n    function Component(name, instanceFactory, type) {\r\n        this.name = name;\r\n        this.instanceFactory = instanceFactory;\r\n        this.type = type;\r\n        this.multipleInstances = false;\r\n        /**\r\n         * Properties to be added to the service namespace\r\n         */\r\n        this.serviceProps = {};\r\n        this.instantiationMode = \"LAZY\" /* LAZY */;\r\n    }\r\n    Component.prototype.setInstantiationMode = function (mode) {\r\n        this.instantiationMode = mode;\r\n        return this;\r\n    };\r\n    Component.prototype.setMultipleInstances = function (multipleInstances) {\r\n        this.multipleInstances = multipleInstances;\r\n        return this;\r\n    };\r\n    Component.prototype.setServiceProps = function (props) {\r\n        this.serviceProps = props;\r\n        return this;\r\n    };\r\n    return Component;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar DEFAULT_ENTRY_NAME = '[DEFAULT]';\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Provider for instance for service name T, e.g. 'auth', 'auth-internal'\r\n * NameServiceMapping[T] is an alias for the type of the instance\r\n */\r\nvar Provider = /** @class */ (function () {\r\n    function Provider(name, container) {\r\n        this.name = name;\r\n        this.container = container;\r\n        this.component = null;\r\n        this.instances = new Map();\r\n        this.instancesDeferred = new Map();\r\n    }\r\n    /**\r\n     * @param identifier A provider can provide mulitple instances of a service\r\n     * if this.component.multipleInstances is true.\r\n     */\r\n    Provider.prototype.get = function (identifier) {\r\n        if (identifier === void 0) { identifier = DEFAULT_ENTRY_NAME; }\r\n        // if multipleInstances is not supported, use the default name\r\n        var normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\r\n        if (!this.instancesDeferred.has(normalizedIdentifier)) {\r\n            var deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.Deferred();\r\n            this.instancesDeferred.set(normalizedIdentifier, deferred);\r\n            // If the service instance is available, resolve the promise with it immediately\r\n            try {\r\n                var instance = this.getOrInitializeService(normalizedIdentifier);\r\n                if (instance) {\r\n                    deferred.resolve(instance);\r\n                }\r\n            }\r\n            catch (e) {\r\n                // when the instance factory throws an exception during get(), it should not cause\r\n                // a fatal error. We just return the unresolved promise in this case.\r\n            }\r\n        }\r\n        return this.instancesDeferred.get(normalizedIdentifier).promise;\r\n    };\r\n    Provider.prototype.getImmediate = function (options) {\r\n        var _a = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__assign)({ identifier: DEFAULT_ENTRY_NAME, optional: false }, options), identifier = _a.identifier, optional = _a.optional;\r\n        // if multipleInstances is not supported, use the default name\r\n        var normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\r\n        try {\r\n            var instance = this.getOrInitializeService(normalizedIdentifier);\r\n            if (!instance) {\r\n                if (optional) {\r\n                    return null;\r\n                }\r\n                throw Error(\"Service \" + this.name + \" is not available\");\r\n            }\r\n            return instance;\r\n        }\r\n        catch (e) {\r\n            if (optional) {\r\n                return null;\r\n            }\r\n            else {\r\n                throw e;\r\n            }\r\n        }\r\n    };\r\n    Provider.prototype.getComponent = function () {\r\n        return this.component;\r\n    };\r\n    Provider.prototype.setComponent = function (component) {\r\n        var e_1, _a;\r\n        if (component.name !== this.name) {\r\n            throw Error(\"Mismatching Component \" + component.name + \" for Provider \" + this.name + \".\");\r\n        }\r\n        if (this.component) {\r\n            throw Error(\"Component for \" + this.name + \" has already been provided\");\r\n        }\r\n        this.component = component;\r\n        // if the service is eager, initialize the default instance\r\n        if (isComponentEager(component)) {\r\n            try {\r\n                this.getOrInitializeService(DEFAULT_ENTRY_NAME);\r\n            }\r\n            catch (e) {\r\n                // when the instance factory for an eager Component throws an exception during the eager\r\n                // initialization, it should not cause a fatal error.\r\n                // TODO: Investigate if we need to make it configurable, because some component may want to cause\r\n                // a fatal error in this case?\r\n            }\r\n        }\r\n        try {\r\n            // Create service instances for the pending promises and resolve them\r\n            // NOTE: if this.multipleInstances is false, only the default instance will be created\r\n            // and all promises with resolve with it regardless of the identifier.\r\n            for (var _b = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__values)(this.instancesDeferred.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var _d = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__read)(_c.value, 2), instanceIdentifier = _d[0], instanceDeferred = _d[1];\r\n                var normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\r\n                try {\r\n                    // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.\r\n                    var instance = this.getOrInitializeService(normalizedIdentifier);\r\n                    instanceDeferred.resolve(instance);\r\n                }\r\n                catch (e) {\r\n                    // when the instance factory throws an exception, it should not cause\r\n                    // a fatal error. We just leave the promise unresolved.\r\n                }\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n    };\r\n    Provider.prototype.clearInstance = function (identifier) {\r\n        if (identifier === void 0) { identifier = DEFAULT_ENTRY_NAME; }\r\n        this.instancesDeferred.delete(identifier);\r\n        this.instances.delete(identifier);\r\n    };\r\n    // app.delete() will call this method on every provider to delete the services\r\n    // TODO: should we mark the provider as deleted?\r\n    Provider.prototype.delete = function () {\r\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function () {\r\n            var services;\r\n            return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__generator)(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        services = Array.from(this.instances.values());\r\n                        return [4 /*yield*/, Promise.all((0,tslib__WEBPACK_IMPORTED_MODULE_0__.__spread)(services\r\n                                .filter(function (service) { return 'INTERNAL' in service; }) // legacy services\r\n                                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                                .map(function (service) { return service.INTERNAL.delete(); }), services\r\n                                .filter(function (service) { return '_delete' in service; }) // modularized services\r\n                                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                                .map(function (service) { return service._delete(); })))];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Provider.prototype.isComponentSet = function () {\r\n        return this.component != null;\r\n    };\r\n    Provider.prototype.getOrInitializeService = function (identifier) {\r\n        var instance = this.instances.get(identifier);\r\n        if (!instance && this.component) {\r\n            instance = this.component.instanceFactory(this.container, normalizeIdentifierForFactory(identifier));\r\n            this.instances.set(identifier, instance);\r\n        }\r\n        return instance || null;\r\n    };\r\n    Provider.prototype.normalizeInstanceIdentifier = function (identifier) {\r\n        if (this.component) {\r\n            return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;\r\n        }\r\n        else {\r\n            return identifier; // assume multiple instances are supported before the component is provided.\r\n        }\r\n    };\r\n    return Provider;\r\n}());\r\n// undefined should be passed to the service factory for the default instance\r\nfunction normalizeIdentifierForFactory(identifier) {\r\n    return identifier === DEFAULT_ENTRY_NAME ? undefined : identifier;\r\n}\r\nfunction isComponentEager(component) {\r\n    return component.instantiationMode === \"EAGER\" /* EAGER */;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`\r\n */\r\nvar ComponentContainer = /** @class */ (function () {\r\n    function ComponentContainer(name) {\r\n        this.name = name;\r\n        this.providers = new Map();\r\n    }\r\n    /**\r\n     *\r\n     * @param component Component being added\r\n     * @param overwrite When a component with the same name has already been registered,\r\n     * if overwrite is true: overwrite the existing component with the new component and create a new\r\n     * provider with the new component. It can be useful in tests where you want to use different mocks\r\n     * for different tests.\r\n     * if overwrite is false: throw an exception\r\n     */\r\n    ComponentContainer.prototype.addComponent = function (component) {\r\n        var provider = this.getProvider(component.name);\r\n        if (provider.isComponentSet()) {\r\n            throw new Error(\"Component \" + component.name + \" has already been registered with \" + this.name);\r\n        }\r\n        provider.setComponent(component);\r\n    };\r\n    ComponentContainer.prototype.addOrOverwriteComponent = function (component) {\r\n        var provider = this.getProvider(component.name);\r\n        if (provider.isComponentSet()) {\r\n            // delete the existing provider from the container, so we can register the new component\r\n            this.providers.delete(component.name);\r\n        }\r\n        this.addComponent(component);\r\n    };\r\n    /**\r\n     * getProvider provides a type safe interface where it can only be called with a field name\r\n     * present in NameServiceMapping interface.\r\n     *\r\n     * Firebase SDKs providing services should extend NameServiceMapping interface to register\r\n     * themselves.\r\n     */\r\n    ComponentContainer.prototype.getProvider = function (name) {\r\n        if (this.providers.has(name)) {\r\n            return this.providers.get(name);\r\n        }\r\n        // create a Provider for a service that hasn't registered with Firebase\r\n        var provider = new Provider(name, this);\r\n        this.providers.set(name, provider);\r\n        return provider;\r\n    };\r\n    ComponentContainer.prototype.getProviders = function () {\r\n        return Array.from(this.providers.values());\r\n    };\r\n    return ComponentContainer;\r\n}());\n\n\n//# sourceMappingURL=index.esm.js.map\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@firebase/component/dist/index.esm.js?");

/***/ }),

/***/ "./src/node_modules/@firebase/database/dist/index.esm.js":
/*!***************************************************************!*\
  !*** ./src/node_modules/@firebase/database/dist/index.esm.js ***!
  \***************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DataSnapshot\": () => (/* binding */ DataSnapshot),\n/* harmony export */   \"Database\": () => (/* binding */ Database),\n/* harmony export */   \"OnDisconnect\": () => (/* binding */ OnDisconnect),\n/* harmony export */   \"Query\": () => (/* binding */ Query),\n/* harmony export */   \"Reference\": () => (/* binding */ Reference),\n/* harmony export */   \"ServerValue\": () => (/* binding */ ServerValue),\n/* harmony export */   \"enableLogging\": () => (/* binding */ enableLogging),\n/* harmony export */   \"registerDatabase\": () => (/* binding */ registerDatabase)\n/* harmony export */ });\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/app */ \"./src/node_modules/@firebase/app/dist/index.esm.js\");\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ \"tslib\");\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(tslib__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/util */ \"./src/node_modules/@firebase/util/dist/index.esm.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @firebase/logger */ \"./src/node_modules/@firebase/logger/dist/index.esm.js\");\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @firebase/component */ \"./src/node_modules/@firebase/component/dist/index.esm.js\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n\n\n\n\n\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Wraps a DOM Storage object and:\r\n * - automatically encode objects as JSON strings before storing them to allow us to store arbitrary types.\r\n * - prefixes names with \"firebase:\" to avoid collisions with app data.\r\n *\r\n * We automatically (see storage.js) create two such wrappers, one for sessionStorage,\r\n * and one for localStorage.\r\n *\r\n * @constructor\r\n */\r\nvar DOMStorageWrapper = /** @class */ (function () {\r\n    /**\r\n     * @param {Storage} domStorage_ The underlying storage object (e.g. localStorage or sessionStorage)\r\n     */\r\n    function DOMStorageWrapper(domStorage_) {\r\n        this.domStorage_ = domStorage_;\r\n        // Use a prefix to avoid collisions with other stuff saved by the app.\r\n        this.prefix_ = 'firebase:';\r\n    }\r\n    /**\r\n     * @param {string} key The key to save the value under\r\n     * @param {?Object} value The value being stored, or null to remove the key.\r\n     */\r\n    DOMStorageWrapper.prototype.set = function (key, value) {\r\n        if (value == null) {\r\n            this.domStorage_.removeItem(this.prefixedName_(key));\r\n        }\r\n        else {\r\n            this.domStorage_.setItem(this.prefixedName_(key), (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(value));\r\n        }\r\n    };\r\n    /**\r\n     * @param {string} key\r\n     * @return {*} The value that was stored under this key, or null\r\n     */\r\n    DOMStorageWrapper.prototype.get = function (key) {\r\n        var storedVal = this.domStorage_.getItem(this.prefixedName_(key));\r\n        if (storedVal == null) {\r\n            return null;\r\n        }\r\n        else {\r\n            return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.jsonEval)(storedVal);\r\n        }\r\n    };\r\n    /**\r\n     * @param {string} key\r\n     */\r\n    DOMStorageWrapper.prototype.remove = function (key) {\r\n        this.domStorage_.removeItem(this.prefixedName_(key));\r\n    };\r\n    /**\r\n     * @param {string} name\r\n     * @return {string}\r\n     */\r\n    DOMStorageWrapper.prototype.prefixedName_ = function (name) {\r\n        return this.prefix_ + name;\r\n    };\r\n    DOMStorageWrapper.prototype.toString = function () {\r\n        return this.domStorage_.toString();\r\n    };\r\n    return DOMStorageWrapper;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An in-memory storage implementation that matches the API of DOMStorageWrapper\r\n * (TODO: create interface for both to implement).\r\n *\r\n * @constructor\r\n */\r\nvar MemoryStorage = /** @class */ (function () {\r\n    function MemoryStorage() {\r\n        this.cache_ = {};\r\n        this.isInMemoryStorage = true;\r\n    }\r\n    MemoryStorage.prototype.set = function (key, value) {\r\n        if (value == null) {\r\n            delete this.cache_[key];\r\n        }\r\n        else {\r\n            this.cache_[key] = value;\r\n        }\r\n    };\r\n    MemoryStorage.prototype.get = function (key) {\r\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(this.cache_, key)) {\r\n            return this.cache_[key];\r\n        }\r\n        return null;\r\n    };\r\n    MemoryStorage.prototype.remove = function (key) {\r\n        delete this.cache_[key];\r\n    };\r\n    return MemoryStorage;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Helper to create a DOMStorageWrapper or else fall back to MemoryStorage.\r\n * TODO: Once MemoryStorage and DOMStorageWrapper have a shared interface this method annotation should change\r\n * to reflect this type\r\n *\r\n * @param {string} domStorageName Name of the underlying storage object\r\n *   (e.g. 'localStorage' or 'sessionStorage').\r\n * @return {?} Turning off type information until a common interface is defined.\r\n */\r\nvar createStoragefor = function (domStorageName) {\r\n    try {\r\n        // NOTE: just accessing \"localStorage\" or \"window['localStorage']\" may throw a security exception,\r\n        // so it must be inside the try/catch.\r\n        if (typeof window !== 'undefined' &&\r\n            typeof window[domStorageName] !== 'undefined') {\r\n            // Need to test cache. Just because it's here doesn't mean it works\r\n            var domStorage = window[domStorageName];\r\n            domStorage.setItem('firebase:sentinel', 'cache');\r\n            domStorage.removeItem('firebase:sentinel');\r\n            return new DOMStorageWrapper(domStorage);\r\n        }\r\n    }\r\n    catch (e) { }\r\n    // Failed to create wrapper.  Just return in-memory storage.\r\n    // TODO: log?\r\n    return new MemoryStorage();\r\n};\r\n/** A storage object that lasts across sessions */\r\nvar PersistentStorage = createStoragefor('localStorage');\r\n/** A storage object that only lasts one session */\r\nvar SessionStorage = createStoragefor('sessionStorage');\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar logClient = new _firebase_logger__WEBPACK_IMPORTED_MODULE_3__.Logger('@firebase/database');\r\n/**\r\n * Returns a locally-unique ID (generated by just incrementing up from 0 each time its called).\r\n * @type {function(): number} Generated ID.\r\n */\r\nvar LUIDGenerator = (function () {\r\n    var id = 1;\r\n    return function () {\r\n        return id++;\r\n    };\r\n})();\r\n/**\r\n * Sha1 hash of the input string\r\n * @param {!string} str The string to hash\r\n * @return {!string} The resulting hash\r\n */\r\nvar sha1 = function (str) {\r\n    var utf8Bytes = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringToByteArray)(str);\r\n    var sha1 = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Sha1();\r\n    sha1.update(utf8Bytes);\r\n    var sha1Bytes = sha1.digest();\r\n    return _firebase_util__WEBPACK_IMPORTED_MODULE_2__.base64.encodeByteArray(sha1Bytes);\r\n};\r\n/**\r\n * @param {...*} varArgs\r\n * @return {string}\r\n * @private\r\n */\r\nvar buildLogMessage_ = function () {\r\n    var varArgs = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        varArgs[_i] = arguments[_i];\r\n    }\r\n    var message = '';\r\n    for (var i = 0; i < varArgs.length; i++) {\r\n        var arg = varArgs[i];\r\n        if (Array.isArray(arg) ||\r\n            (arg &&\r\n                typeof arg === 'object' &&\r\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                typeof arg.length === 'number')) {\r\n            message += buildLogMessage_.apply(null, arg);\r\n        }\r\n        else if (typeof arg === 'object') {\r\n            message += (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(arg);\r\n        }\r\n        else {\r\n            message += arg;\r\n        }\r\n        message += ' ';\r\n    }\r\n    return message;\r\n};\r\n/**\r\n * Use this for all debug messages in Firebase.\r\n * @type {?function(string)}\r\n */\r\nvar logger = null;\r\n/**\r\n * Flag to check for log availability on first log message\r\n * @type {boolean}\r\n * @private\r\n */\r\nvar firstLog_ = true;\r\n/**\r\n * The implementation of Firebase.enableLogging (defined here to break dependencies)\r\n * @param {boolean|?function(string)} logger_ A flag to turn on logging, or a custom logger\r\n * @param {boolean=} persistent Whether or not to persist logging settings across refreshes\r\n */\r\nvar enableLogging = function (logger_, persistent) {\r\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(!persistent || logger_ === true || logger_ === false, \"Can't turn on custom loggers persistently.\");\r\n    if (logger_ === true) {\r\n        logClient.logLevel = _firebase_logger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.VERBOSE;\r\n        logger = logClient.log.bind(logClient);\r\n        if (persistent) {\r\n            SessionStorage.set('logging_enabled', true);\r\n        }\r\n    }\r\n    else if (typeof logger_ === 'function') {\r\n        logger = logger_;\r\n    }\r\n    else {\r\n        logger = null;\r\n        SessionStorage.remove('logging_enabled');\r\n    }\r\n};\r\n/**\r\n *\r\n * @param {...(string|Arguments)} varArgs\r\n */\r\nvar log = function () {\r\n    var varArgs = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        varArgs[_i] = arguments[_i];\r\n    }\r\n    if (firstLog_ === true) {\r\n        firstLog_ = false;\r\n        if (logger === null && SessionStorage.get('logging_enabled') === true) {\r\n            enableLogging(true);\r\n        }\r\n    }\r\n    if (logger) {\r\n        var message = buildLogMessage_.apply(null, varArgs);\r\n        logger(message);\r\n    }\r\n};\r\n/**\r\n * @param {!string} prefix\r\n * @return {function(...[*])}\r\n */\r\nvar logWrapper = function (prefix) {\r\n    return function () {\r\n        var varArgs = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            varArgs[_i] = arguments[_i];\r\n        }\r\n        log.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spread)([prefix], varArgs));\r\n    };\r\n};\r\n/**\r\n * @param {...string} varArgs\r\n */\r\nvar error = function () {\r\n    var varArgs = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        varArgs[_i] = arguments[_i];\r\n    }\r\n    var message = 'FIREBASE INTERNAL ERROR: ' + buildLogMessage_.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spread)(varArgs));\r\n    logClient.error(message);\r\n};\r\n/**\r\n * @param {...string} varArgs\r\n */\r\nvar fatal = function () {\r\n    var varArgs = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        varArgs[_i] = arguments[_i];\r\n    }\r\n    var message = \"FIREBASE FATAL ERROR: \" + buildLogMessage_.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spread)(varArgs));\r\n    logClient.error(message);\r\n    throw new Error(message);\r\n};\r\n/**\r\n * @param {...*} varArgs\r\n */\r\nvar warn = function () {\r\n    var varArgs = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        varArgs[_i] = arguments[_i];\r\n    }\r\n    var message = 'FIREBASE WARNING: ' + buildLogMessage_.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spread)(varArgs));\r\n    logClient.warn(message);\r\n};\r\n/**\r\n * Logs a warning if the containing page uses https. Called when a call to new Firebase\r\n * does not use https.\r\n */\r\nvar warnIfPageIsSecure = function () {\r\n    // Be very careful accessing browser globals. Who knows what may or may not exist.\r\n    if (typeof window !== 'undefined' &&\r\n        window.location &&\r\n        window.location.protocol &&\r\n        window.location.protocol.indexOf('https:') !== -1) {\r\n        warn('Insecure Firebase access from a secure page. ' +\r\n            'Please use https in calls to new Firebase().');\r\n    }\r\n};\r\n/**\r\n * Returns true if data is NaN, or +/- Infinity.\r\n * @param {*} data\r\n * @return {boolean}\r\n */\r\nvar isInvalidJSONNumber = function (data) {\r\n    return (typeof data === 'number' &&\r\n        (data !== data || // NaN\r\n            data === Number.POSITIVE_INFINITY ||\r\n            data === Number.NEGATIVE_INFINITY));\r\n};\r\n/**\r\n * @param {function()} fn\r\n */\r\nvar executeWhenDOMReady = function (fn) {\r\n    if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isNodeSdk)() || document.readyState === 'complete') {\r\n        fn();\r\n    }\r\n    else {\r\n        // Modeled after jQuery. Try DOMContentLoaded and onreadystatechange (which\r\n        // fire before onload), but fall back to onload.\r\n        var called_1 = false;\r\n        var wrappedFn_1 = function () {\r\n            if (!document.body) {\r\n                setTimeout(wrappedFn_1, Math.floor(10));\r\n                return;\r\n            }\r\n            if (!called_1) {\r\n                called_1 = true;\r\n                fn();\r\n            }\r\n        };\r\n        if (document.addEventListener) {\r\n            document.addEventListener('DOMContentLoaded', wrappedFn_1, false);\r\n            // fallback to onload.\r\n            window.addEventListener('load', wrappedFn_1, false);\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        }\r\n        else if (document.attachEvent) {\r\n            // IE.\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            document.attachEvent('onreadystatechange', function () {\r\n                if (document.readyState === 'complete') {\r\n                    wrappedFn_1();\r\n                }\r\n            });\r\n            // fallback to onload.\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            window.attachEvent('onload', wrappedFn_1);\r\n            // jQuery has an extra hack for IE that we could employ (based on\r\n            // http://javascript.nwbox.com/IEContentLoaded/) But it looks really old.\r\n            // I'm hoping we don't need it.\r\n        }\r\n    }\r\n};\r\n/**\r\n * Minimum key name. Invalid for actual data, used as a marker to sort before any valid names\r\n * @type {!string}\r\n */\r\nvar MIN_NAME = '[MIN_NAME]';\r\n/**\r\n * Maximum key name. Invalid for actual data, used as a marker to sort above any valid names\r\n * @type {!string}\r\n */\r\nvar MAX_NAME = '[MAX_NAME]';\r\n/**\r\n * Compares valid Firebase key names, plus min and max name\r\n * @param {!string} a\r\n * @param {!string} b\r\n * @return {!number}\r\n */\r\nvar nameCompare = function (a, b) {\r\n    if (a === b) {\r\n        return 0;\r\n    }\r\n    else if (a === MIN_NAME || b === MAX_NAME) {\r\n        return -1;\r\n    }\r\n    else if (b === MIN_NAME || a === MAX_NAME) {\r\n        return 1;\r\n    }\r\n    else {\r\n        var aAsInt = tryParseInt(a), bAsInt = tryParseInt(b);\r\n        if (aAsInt !== null) {\r\n            if (bAsInt !== null) {\r\n                return aAsInt - bAsInt === 0 ? a.length - b.length : aAsInt - bAsInt;\r\n            }\r\n            else {\r\n                return -1;\r\n            }\r\n        }\r\n        else if (bAsInt !== null) {\r\n            return 1;\r\n        }\r\n        else {\r\n            return a < b ? -1 : 1;\r\n        }\r\n    }\r\n};\r\n/**\r\n * @param {!string} a\r\n * @param {!string} b\r\n * @return {!number} comparison result.\r\n */\r\nvar stringCompare = function (a, b) {\r\n    if (a === b) {\r\n        return 0;\r\n    }\r\n    else if (a < b) {\r\n        return -1;\r\n    }\r\n    else {\r\n        return 1;\r\n    }\r\n};\r\n/**\r\n * @param {string} key\r\n * @param {Object} obj\r\n * @return {*}\r\n */\r\nvar requireKey = function (key, obj) {\r\n    if (obj && key in obj) {\r\n        return obj[key];\r\n    }\r\n    else {\r\n        throw new Error('Missing required key (' + key + ') in object: ' + (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(obj));\r\n    }\r\n};\r\n/**\r\n * @param {*} obj\r\n * @return {string}\r\n */\r\nvar ObjectToUniqueKey = function (obj) {\r\n    if (typeof obj !== 'object' || obj === null) {\r\n        return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(obj);\r\n    }\r\n    var keys = [];\r\n    // eslint-disable-next-line guard-for-in\r\n    for (var k in obj) {\r\n        keys.push(k);\r\n    }\r\n    // Export as json, but with the keys sorted.\r\n    keys.sort();\r\n    var key = '{';\r\n    for (var i = 0; i < keys.length; i++) {\r\n        if (i !== 0) {\r\n            key += ',';\r\n        }\r\n        key += (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(keys[i]);\r\n        key += ':';\r\n        key += ObjectToUniqueKey(obj[keys[i]]);\r\n    }\r\n    key += '}';\r\n    return key;\r\n};\r\n/**\r\n * Splits a string into a number of smaller segments of maximum size\r\n * @param {!string} str The string\r\n * @param {!number} segsize The maximum number of chars in the string.\r\n * @return {Array.<string>} The string, split into appropriately-sized chunks\r\n */\r\nvar splitStringBySize = function (str, segsize) {\r\n    var len = str.length;\r\n    if (len <= segsize) {\r\n        return [str];\r\n    }\r\n    var dataSegs = [];\r\n    for (var c = 0; c < len; c += segsize) {\r\n        if (c + segsize > len) {\r\n            dataSegs.push(str.substring(c, len));\r\n        }\r\n        else {\r\n            dataSegs.push(str.substring(c, c + segsize));\r\n        }\r\n    }\r\n    return dataSegs;\r\n};\r\n/**\r\n * Apply a function to each (key, value) pair in an object or\r\n * apply a function to each (index, value) pair in an array\r\n * @param obj The object or array to iterate over\r\n * @param fn The function to apply\r\n */\r\nfunction each(obj, fn) {\r\n    for (var key in obj) {\r\n        if (obj.hasOwnProperty(key)) {\r\n            fn(key, obj[key]);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Borrowed from http://hg.secondlife.com/llsd/src/tip/js/typedarray.js (MIT License)\r\n * I made one modification at the end and removed the NaN / Infinity\r\n * handling (since it seemed broken [caused an overflow] and we don't need it).  See MJL comments.\r\n * @param {!number} v A double\r\n * @return {string}\r\n */\r\nvar doubleToIEEE754String = function (v) {\r\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(!isInvalidJSONNumber(v), 'Invalid JSON number'); // MJL\r\n    var ebits = 11, fbits = 52;\r\n    var bias = (1 << (ebits - 1)) - 1;\r\n    var s, e, f, ln, i;\r\n    // Compute sign, exponent, fraction\r\n    // Skip NaN / Infinity handling --MJL.\r\n    if (v === 0) {\r\n        e = 0;\r\n        f = 0;\r\n        s = 1 / v === -Infinity ? 1 : 0;\r\n    }\r\n    else {\r\n        s = v < 0;\r\n        v = Math.abs(v);\r\n        if (v >= Math.pow(2, 1 - bias)) {\r\n            // Normalized\r\n            ln = Math.min(Math.floor(Math.log(v) / Math.LN2), bias);\r\n            e = ln + bias;\r\n            f = Math.round(v * Math.pow(2, fbits - ln) - Math.pow(2, fbits));\r\n        }\r\n        else {\r\n            // Denormalized\r\n            e = 0;\r\n            f = Math.round(v / Math.pow(2, 1 - bias - fbits));\r\n        }\r\n    }\r\n    // Pack sign, exponent, fraction\r\n    var bits = [];\r\n    for (i = fbits; i; i -= 1) {\r\n        bits.push(f % 2 ? 1 : 0);\r\n        f = Math.floor(f / 2);\r\n    }\r\n    for (i = ebits; i; i -= 1) {\r\n        bits.push(e % 2 ? 1 : 0);\r\n        e = Math.floor(e / 2);\r\n    }\r\n    bits.push(s ? 1 : 0);\r\n    bits.reverse();\r\n    var str = bits.join('');\r\n    // Return the data as a hex string. --MJL\r\n    var hexByteString = '';\r\n    for (i = 0; i < 64; i += 8) {\r\n        var hexByte = parseInt(str.substr(i, 8), 2).toString(16);\r\n        if (hexByte.length === 1) {\r\n            hexByte = '0' + hexByte;\r\n        }\r\n        hexByteString = hexByteString + hexByte;\r\n    }\r\n    return hexByteString.toLowerCase();\r\n};\r\n/**\r\n * Used to detect if we're in a Chrome content script (which executes in an\r\n * isolated environment where long-polling doesn't work).\r\n * @return {boolean}\r\n */\r\nvar isChromeExtensionContentScript = function () {\r\n    return !!(typeof window === 'object' &&\r\n        window['chrome'] &&\r\n        window['chrome']['extension'] &&\r\n        !/^chrome/.test(window.location.href));\r\n};\r\n/**\r\n * Used to detect if we're in a Windows 8 Store app.\r\n * @return {boolean}\r\n */\r\nvar isWindowsStoreApp = function () {\r\n    // Check for the presence of a couple WinRT globals\r\n    return typeof Windows === 'object' && typeof Windows.UI === 'object';\r\n};\r\n/**\r\n * Converts a server error code to a Javascript Error\r\n * @param {!string} code\r\n * @param {!Query} query\r\n * @return {Error}\r\n */\r\nvar errorForServerCode = function (code, query) {\r\n    var reason = 'Unknown Error';\r\n    if (code === 'too_big') {\r\n        reason =\r\n            'The data requested exceeds the maximum size ' +\r\n                'that can be accessed with a single request.';\r\n    }\r\n    else if (code === 'permission_denied') {\r\n        reason = \"Client doesn't have permission to access the desired data.\";\r\n    }\r\n    else if (code === 'unavailable') {\r\n        reason = 'The service is unavailable';\r\n    }\r\n    var error = new Error(code + ' at ' + query.path.toString() + ': ' + reason);\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    error.code = code.toUpperCase();\r\n    return error;\r\n};\r\n/**\r\n * Used to test for integer-looking strings\r\n * @type {RegExp}\r\n * @private\r\n */\r\nvar INTEGER_REGEXP_ = new RegExp('^-?(0*)\\\\d{1,10}$');\r\n/**\r\n * If the string contains a 32-bit integer, return it.  Else return null.\r\n * @param {!string} str\r\n * @return {?number}\r\n */\r\nvar tryParseInt = function (str) {\r\n    if (INTEGER_REGEXP_.test(str)) {\r\n        var intVal = Number(str);\r\n        if (intVal >= -2147483648 && intVal <= 2147483647) {\r\n            return intVal;\r\n        }\r\n    }\r\n    return null;\r\n};\r\n/**\r\n * Helper to run some code but catch any exceptions and re-throw them later.\r\n * Useful for preventing user callbacks from breaking internal code.\r\n *\r\n * Re-throwing the exception from a setTimeout is a little evil, but it's very\r\n * convenient (we don't have to try to figure out when is a safe point to\r\n * re-throw it), and the behavior seems reasonable:\r\n *\r\n * * If you aren't pausing on exceptions, you get an error in the console with\r\n *   the correct stack trace.\r\n * * If you're pausing on all exceptions, the debugger will pause on your\r\n *   exception and then again when we rethrow it.\r\n * * If you're only pausing on uncaught exceptions, the debugger will only pause\r\n *   on us re-throwing it.\r\n *\r\n * @param {!function()} fn The code to guard.\r\n */\r\nvar exceptionGuard = function (fn) {\r\n    try {\r\n        fn();\r\n    }\r\n    catch (e) {\r\n        // Re-throw exception when it's safe.\r\n        setTimeout(function () {\r\n            // It used to be that \"throw e\" would result in a good console error with\r\n            // relevant context, but as of Chrome 39, you just get the firebase.js\r\n            // file/line number where we re-throw it, which is useless. So we log\r\n            // e.stack explicitly.\r\n            var stack = e.stack || '';\r\n            warn('Exception was thrown by user callback.', stack);\r\n            throw e;\r\n        }, Math.floor(0));\r\n    }\r\n};\r\n/**\r\n * @return {boolean} true if we think we're currently being crawled.\r\n */\r\nvar beingCrawled = function () {\r\n    var userAgent = (typeof window === 'object' &&\r\n        window['navigator'] &&\r\n        window['navigator']['userAgent']) ||\r\n        '';\r\n    // For now we whitelist the most popular crawlers.  We should refine this to be the set of crawlers we\r\n    // believe to support JavaScript/AJAX rendering.\r\n    // NOTE: Google Webmaster Tools doesn't really belong, but their \"This is how a visitor to your website\r\n    // would have seen the page\" is flaky if we don't treat it as a crawler.\r\n    return (userAgent.search(/googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i) >= 0);\r\n};\r\n/**\r\n * Same as setTimeout() except on Node.JS it will /not/ prevent the process from exiting.\r\n *\r\n * It is removed with clearTimeout() as normal.\r\n *\r\n * @param {Function} fn Function to run.\r\n * @param {number} time Milliseconds to wait before running.\r\n * @return {number|Object} The setTimeout() return value.\r\n */\r\nvar setTimeoutNonBlocking = function (fn, time) {\r\n    var timeout = setTimeout(fn, time);\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    if (typeof timeout === 'object' && timeout['unref']) {\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        timeout['unref']();\r\n    }\r\n    return timeout;\r\n};\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An immutable object representing a parsed path.  It's immutable so that you\r\n * can pass them around to other functions without worrying about them changing\r\n * it.\r\n */\r\nvar Path = /** @class */ (function () {\r\n    /**\r\n     * @param {string|Array.<string>} pathOrString Path string to parse,\r\n     *      or another path, or the raw tokens array\r\n     * @param {number=} pieceNum\r\n     */\r\n    function Path(pathOrString, pieceNum) {\r\n        if (pieceNum === void 0) {\r\n            this.pieces_ = pathOrString.split('/');\r\n            // Remove empty pieces.\r\n            var copyTo = 0;\r\n            for (var i = 0; i < this.pieces_.length; i++) {\r\n                if (this.pieces_[i].length > 0) {\r\n                    this.pieces_[copyTo] = this.pieces_[i];\r\n                    copyTo++;\r\n                }\r\n            }\r\n            this.pieces_.length = copyTo;\r\n            this.pieceNum_ = 0;\r\n        }\r\n        else {\r\n            this.pieces_ = pathOrString;\r\n            this.pieceNum_ = pieceNum;\r\n        }\r\n    }\r\n    Object.defineProperty(Path, \"Empty\", {\r\n        /**\r\n         * Singleton to represent an empty path\r\n         *\r\n         * @const\r\n         */\r\n        get: function () {\r\n            return new Path('');\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Path.prototype.getFront = function () {\r\n        if (this.pieceNum_ >= this.pieces_.length) {\r\n            return null;\r\n        }\r\n        return this.pieces_[this.pieceNum_];\r\n    };\r\n    /**\r\n     * @return {number} The number of segments in this path\r\n     */\r\n    Path.prototype.getLength = function () {\r\n        return this.pieces_.length - this.pieceNum_;\r\n    };\r\n    /**\r\n     * @return {!Path}\r\n     */\r\n    Path.prototype.popFront = function () {\r\n        var pieceNum = this.pieceNum_;\r\n        if (pieceNum < this.pieces_.length) {\r\n            pieceNum++;\r\n        }\r\n        return new Path(this.pieces_, pieceNum);\r\n    };\r\n    /**\r\n     * @return {?string}\r\n     */\r\n    Path.prototype.getBack = function () {\r\n        if (this.pieceNum_ < this.pieces_.length) {\r\n            return this.pieces_[this.pieces_.length - 1];\r\n        }\r\n        return null;\r\n    };\r\n    Path.prototype.toString = function () {\r\n        var pathString = '';\r\n        for (var i = this.pieceNum_; i < this.pieces_.length; i++) {\r\n            if (this.pieces_[i] !== '') {\r\n                pathString += '/' + this.pieces_[i];\r\n            }\r\n        }\r\n        return pathString || '/';\r\n    };\r\n    Path.prototype.toUrlEncodedString = function () {\r\n        var pathString = '';\r\n        for (var i = this.pieceNum_; i < this.pieces_.length; i++) {\r\n            if (this.pieces_[i] !== '') {\r\n                pathString += '/' + encodeURIComponent(String(this.pieces_[i]));\r\n            }\r\n        }\r\n        return pathString || '/';\r\n    };\r\n    /**\r\n     * Shallow copy of the parts of the path.\r\n     *\r\n     * @param {number=} begin\r\n     * @return {!Array<string>}\r\n     */\r\n    Path.prototype.slice = function (begin) {\r\n        if (begin === void 0) { begin = 0; }\r\n        return this.pieces_.slice(this.pieceNum_ + begin);\r\n    };\r\n    /**\r\n     * @return {?Path}\r\n     */\r\n    Path.prototype.parent = function () {\r\n        if (this.pieceNum_ >= this.pieces_.length) {\r\n            return null;\r\n        }\r\n        var pieces = [];\r\n        for (var i = this.pieceNum_; i < this.pieces_.length - 1; i++) {\r\n            pieces.push(this.pieces_[i]);\r\n        }\r\n        return new Path(pieces, 0);\r\n    };\r\n    /**\r\n     * @param {string|!Path} childPathObj\r\n     * @return {!Path}\r\n     */\r\n    Path.prototype.child = function (childPathObj) {\r\n        var pieces = [];\r\n        for (var i = this.pieceNum_; i < this.pieces_.length; i++) {\r\n            pieces.push(this.pieces_[i]);\r\n        }\r\n        if (childPathObj instanceof Path) {\r\n            for (var i = childPathObj.pieceNum_; i < childPathObj.pieces_.length; i++) {\r\n                pieces.push(childPathObj.pieces_[i]);\r\n            }\r\n        }\r\n        else {\r\n            var childPieces = childPathObj.split('/');\r\n            for (var i = 0; i < childPieces.length; i++) {\r\n                if (childPieces[i].length > 0) {\r\n                    pieces.push(childPieces[i]);\r\n                }\r\n            }\r\n        }\r\n        return new Path(pieces, 0);\r\n    };\r\n    /**\r\n     * @return {boolean} True if there are no segments in this path\r\n     */\r\n    Path.prototype.isEmpty = function () {\r\n        return this.pieceNum_ >= this.pieces_.length;\r\n    };\r\n    /**\r\n     * @param {!Path} outerPath\r\n     * @param {!Path} innerPath\r\n     * @return {!Path} The path from outerPath to innerPath\r\n     */\r\n    Path.relativePath = function (outerPath, innerPath) {\r\n        var outer = outerPath.getFront(), inner = innerPath.getFront();\r\n        if (outer === null) {\r\n            return innerPath;\r\n        }\r\n        else if (outer === inner) {\r\n            return Path.relativePath(outerPath.popFront(), innerPath.popFront());\r\n        }\r\n        else {\r\n            throw new Error('INTERNAL ERROR: innerPath (' +\r\n                innerPath +\r\n                ') is not within ' +\r\n                'outerPath (' +\r\n                outerPath +\r\n                ')');\r\n        }\r\n    };\r\n    /**\r\n     * @param {!Path} left\r\n     * @param {!Path} right\r\n     * @return {number} -1, 0, 1 if left is less, equal, or greater than the right.\r\n     */\r\n    Path.comparePaths = function (left, right) {\r\n        var leftKeys = left.slice();\r\n        var rightKeys = right.slice();\r\n        for (var i = 0; i < leftKeys.length && i < rightKeys.length; i++) {\r\n            var cmp = nameCompare(leftKeys[i], rightKeys[i]);\r\n            if (cmp !== 0) {\r\n                return cmp;\r\n            }\r\n        }\r\n        if (leftKeys.length === rightKeys.length) {\r\n            return 0;\r\n        }\r\n        return leftKeys.length < rightKeys.length ? -1 : 1;\r\n    };\r\n    /**\r\n     *\r\n     * @param {Path} other\r\n     * @return {boolean} true if paths are the same.\r\n     */\r\n    Path.prototype.equals = function (other) {\r\n        if (this.getLength() !== other.getLength()) {\r\n            return false;\r\n        }\r\n        for (var i = this.pieceNum_, j = other.pieceNum_; i <= this.pieces_.length; i++, j++) {\r\n            if (this.pieces_[i] !== other.pieces_[j]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    /**\r\n     *\r\n     * @param {!Path} other\r\n     * @return {boolean} True if this path is a parent (or the same as) other\r\n     */\r\n    Path.prototype.contains = function (other) {\r\n        var i = this.pieceNum_;\r\n        var j = other.pieceNum_;\r\n        if (this.getLength() > other.getLength()) {\r\n            return false;\r\n        }\r\n        while (i < this.pieces_.length) {\r\n            if (this.pieces_[i] !== other.pieces_[j]) {\r\n                return false;\r\n            }\r\n            ++i;\r\n            ++j;\r\n        }\r\n        return true;\r\n    };\r\n    return Path;\r\n}()); // end Path\r\n/**\r\n * Dynamic (mutable) path used to count path lengths.\r\n *\r\n * This class is used to efficiently check paths for valid\r\n * length (in UTF8 bytes) and depth (used in path validation).\r\n *\r\n * Throws Error exception if path is ever invalid.\r\n *\r\n * The definition of a path always begins with '/'.\r\n */\r\nvar ValidationPath = /** @class */ (function () {\r\n    /**\r\n     * @param {!Path} path Initial Path.\r\n     * @param {string} errorPrefix_ Prefix for any error messages.\r\n     */\r\n    function ValidationPath(path, errorPrefix_) {\r\n        this.errorPrefix_ = errorPrefix_;\r\n        /** @type {!Array<string>} */\r\n        this.parts_ = path.slice();\r\n        /** @type {number} Initialize to number of '/' chars needed in path. */\r\n        this.byteLength_ = Math.max(1, this.parts_.length);\r\n        for (var i = 0; i < this.parts_.length; i++) {\r\n            this.byteLength_ += (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringLength)(this.parts_[i]);\r\n        }\r\n        this.checkValid_();\r\n    }\r\n    Object.defineProperty(ValidationPath, \"MAX_PATH_DEPTH\", {\r\n        /** @const {number} Maximum key depth. */\r\n        get: function () {\r\n            return 32;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ValidationPath, \"MAX_PATH_LENGTH_BYTES\", {\r\n        /** @const {number} Maximum number of (UTF8) bytes in a Firebase path. */\r\n        get: function () {\r\n            return 768;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /** @param {string} child */\r\n    ValidationPath.prototype.push = function (child) {\r\n        // Count the needed '/'\r\n        if (this.parts_.length > 0) {\r\n            this.byteLength_ += 1;\r\n        }\r\n        this.parts_.push(child);\r\n        this.byteLength_ += (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringLength)(child);\r\n        this.checkValid_();\r\n    };\r\n    ValidationPath.prototype.pop = function () {\r\n        var last = this.parts_.pop();\r\n        this.byteLength_ -= (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringLength)(last);\r\n        // Un-count the previous '/'\r\n        if (this.parts_.length > 0) {\r\n            this.byteLength_ -= 1;\r\n        }\r\n    };\r\n    ValidationPath.prototype.checkValid_ = function () {\r\n        if (this.byteLength_ > ValidationPath.MAX_PATH_LENGTH_BYTES) {\r\n            throw new Error(this.errorPrefix_ +\r\n                'has a key path longer than ' +\r\n                ValidationPath.MAX_PATH_LENGTH_BYTES +\r\n                ' bytes (' +\r\n                this.byteLength_ +\r\n                ').');\r\n        }\r\n        if (this.parts_.length > ValidationPath.MAX_PATH_DEPTH) {\r\n            throw new Error(this.errorPrefix_ +\r\n                'path specified exceeds the maximum depth that can be written (' +\r\n                ValidationPath.MAX_PATH_DEPTH +\r\n                ') or object contains a cycle ' +\r\n                this.toErrorString());\r\n        }\r\n    };\r\n    /**\r\n     * String for use in error messages - uses '.' notation for path.\r\n     *\r\n     * @return {string}\r\n     */\r\n    ValidationPath.prototype.toErrorString = function () {\r\n        if (this.parts_.length === 0) {\r\n            return '';\r\n        }\r\n        return \"in property '\" + this.parts_.join('.') + \"'\";\r\n    };\r\n    return ValidationPath;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar PROTOCOL_VERSION = '5';\r\nvar VERSION_PARAM = 'v';\r\nvar TRANSPORT_SESSION_PARAM = 's';\r\nvar REFERER_PARAM = 'r';\r\nvar FORGE_REF = 'f';\r\nvar FORGE_DOMAIN = 'firebaseio.com';\r\nvar LAST_SESSION_PARAM = 'ls';\r\nvar APPLICATION_ID_PARAM = 'p';\r\nvar WEBSOCKET = 'websocket';\r\nvar LONG_POLLING = 'long_polling';\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A class that holds metadata about a Repo object\r\n *\r\n * @constructor\r\n */\r\nvar RepoInfo = /** @class */ (function () {\r\n    /**\r\n     * @param host Hostname portion of the url for the repo\r\n     * @param secure Whether or not this repo is accessed over ssl\r\n     * @param namespace The namespace represented by the repo\r\n     * @param webSocketOnly Whether to prefer websockets over all other transports (used by Nest).\r\n     * @param nodeAdmin Whether this instance uses Admin SDK credentials\r\n     * @param persistenceKey Override the default session persistence storage key\r\n     */\r\n    function RepoInfo(host, secure, namespace, webSocketOnly, nodeAdmin, persistenceKey, includeNamespaceInQueryParams) {\r\n        if (nodeAdmin === void 0) { nodeAdmin = false; }\r\n        if (persistenceKey === void 0) { persistenceKey = ''; }\r\n        if (includeNamespaceInQueryParams === void 0) { includeNamespaceInQueryParams = false; }\r\n        this.secure = secure;\r\n        this.namespace = namespace;\r\n        this.webSocketOnly = webSocketOnly;\r\n        this.nodeAdmin = nodeAdmin;\r\n        this.persistenceKey = persistenceKey;\r\n        this.includeNamespaceInQueryParams = includeNamespaceInQueryParams;\r\n        this.host = host.toLowerCase();\r\n        this.domain = this.host.substr(this.host.indexOf('.') + 1);\r\n        this.internalHost =\r\n            PersistentStorage.get('host:' + host) || this.host;\r\n    }\r\n    RepoInfo.prototype.needsQueryParam = function () {\r\n        return (this.host !== this.internalHost ||\r\n            this.isCustomHost() ||\r\n            this.includeNamespaceInQueryParams);\r\n    };\r\n    RepoInfo.prototype.isCacheableHost = function () {\r\n        return this.internalHost.substr(0, 2) === 's-';\r\n    };\r\n    RepoInfo.prototype.isDemoHost = function () {\r\n        return this.domain === 'firebaseio-demo.com';\r\n    };\r\n    RepoInfo.prototype.isCustomHost = function () {\r\n        return (this.domain !== 'firebaseio.com' && this.domain !== 'firebaseio-demo.com');\r\n    };\r\n    RepoInfo.prototype.updateHost = function (newHost) {\r\n        if (newHost !== this.internalHost) {\r\n            this.internalHost = newHost;\r\n            if (this.isCacheableHost()) {\r\n                PersistentStorage.set('host:' + this.host, this.internalHost);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Returns the websocket URL for this repo\r\n     * @param {string} type of connection\r\n     * @param {Object} params list\r\n     * @return {string} The URL for this repo\r\n     */\r\n    RepoInfo.prototype.connectionURL = function (type, params) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(typeof type === 'string', 'typeof type must == string');\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(typeof params === 'object', 'typeof params must == object');\r\n        var connURL;\r\n        if (type === WEBSOCKET) {\r\n            connURL =\r\n                (this.secure ? 'wss://' : 'ws://') + this.internalHost + '/.ws?';\r\n        }\r\n        else if (type === LONG_POLLING) {\r\n            connURL =\r\n                (this.secure ? 'https://' : 'http://') + this.internalHost + '/.lp?';\r\n        }\r\n        else {\r\n            throw new Error('Unknown connection type: ' + type);\r\n        }\r\n        if (this.needsQueryParam()) {\r\n            params['ns'] = this.namespace;\r\n        }\r\n        var pairs = [];\r\n        each(params, function (key, value) {\r\n            pairs.push(key + '=' + value);\r\n        });\r\n        return connURL + pairs.join('&');\r\n    };\r\n    /** @return {string} */\r\n    RepoInfo.prototype.toString = function () {\r\n        var str = this.toURLString();\r\n        if (this.persistenceKey) {\r\n            str += '<' + this.persistenceKey + '>';\r\n        }\r\n        return str;\r\n    };\r\n    /** @return {string} */\r\n    RepoInfo.prototype.toURLString = function () {\r\n        return (this.secure ? 'https://' : 'http://') + this.host;\r\n    };\r\n    return RepoInfo;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * @param {!string} pathString\r\n * @return {string}\r\n */\r\nfunction decodePath(pathString) {\r\n    var pathStringDecoded = '';\r\n    var pieces = pathString.split('/');\r\n    for (var i = 0; i < pieces.length; i++) {\r\n        if (pieces[i].length > 0) {\r\n            var piece = pieces[i];\r\n            try {\r\n                piece = decodeURIComponent(piece.replace(/\\+/g, ' '));\r\n            }\r\n            catch (e) { }\r\n            pathStringDecoded += '/' + piece;\r\n        }\r\n    }\r\n    return pathStringDecoded;\r\n}\r\n/**\r\n * @param {!string} queryString\r\n * @return {!{[key:string]:string}} key value hash\r\n */\r\nfunction decodeQuery(queryString) {\r\n    var e_1, _a;\r\n    var results = {};\r\n    if (queryString.charAt(0) === '?') {\r\n        queryString = queryString.substring(1);\r\n    }\r\n    try {\r\n        for (var _b = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__values)(queryString.split('&')), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n            var segment = _c.value;\r\n            if (segment.length === 0) {\r\n                continue;\r\n            }\r\n            var kv = segment.split('=');\r\n            if (kv.length === 2) {\r\n                results[decodeURIComponent(kv[0])] = decodeURIComponent(kv[1]);\r\n            }\r\n            else {\r\n                warn(\"Invalid query segment '\" + segment + \"' in query '\" + queryString + \"'\");\r\n            }\r\n        }\r\n    }\r\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n    finally {\r\n        try {\r\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n        }\r\n        finally { if (e_1) throw e_1.error; }\r\n    }\r\n    return results;\r\n}\r\nvar parseRepoInfo = function (dataURL, nodeAdmin) {\r\n    var parsedUrl = parseDatabaseURL(dataURL), namespace = parsedUrl.namespace;\r\n    if (parsedUrl.domain === 'firebase.com') {\r\n        fatal(parsedUrl.host +\r\n            ' is no longer supported. ' +\r\n            'Please use <YOUR FIREBASE>.firebaseio.com instead');\r\n    }\r\n    // Catch common error of uninitialized namespace value.\r\n    if ((!namespace || namespace === 'undefined') &&\r\n        parsedUrl.domain !== 'localhost') {\r\n        fatal('Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com');\r\n    }\r\n    if (!parsedUrl.secure) {\r\n        warnIfPageIsSecure();\r\n    }\r\n    var webSocketOnly = parsedUrl.scheme === 'ws' || parsedUrl.scheme === 'wss';\r\n    return {\r\n        repoInfo: new RepoInfo(parsedUrl.host, parsedUrl.secure, namespace, nodeAdmin, webSocketOnly, \r\n        /*persistenceKey=*/ '', \r\n        /*includeNamespaceInQueryParams=*/ namespace !== parsedUrl.subdomain),\r\n        path: new Path(parsedUrl.pathString)\r\n    };\r\n};\r\n/**\r\n *\r\n * @param {!string} dataURL\r\n * @return {{host: string, port: number, domain: string, subdomain: string, secure: boolean, scheme: string, pathString: string, namespace: string}}\r\n */\r\nvar parseDatabaseURL = function (dataURL) {\r\n    // Default to empty strings in the event of a malformed string.\r\n    var host = '', domain = '', subdomain = '', pathString = '', namespace = '';\r\n    // Always default to SSL, unless otherwise specified.\r\n    var secure = true, scheme = 'https', port = 443;\r\n    // Don't do any validation here. The caller is responsible for validating the result of parsing.\r\n    if (typeof dataURL === 'string') {\r\n        // Parse scheme.\r\n        var colonInd = dataURL.indexOf('//');\r\n        if (colonInd >= 0) {\r\n            scheme = dataURL.substring(0, colonInd - 1);\r\n            dataURL = dataURL.substring(colonInd + 2);\r\n        }\r\n        // Parse host, path, and query string.\r\n        var slashInd = dataURL.indexOf('/');\r\n        if (slashInd === -1) {\r\n            slashInd = dataURL.length;\r\n        }\r\n        var questionMarkInd = dataURL.indexOf('?');\r\n        if (questionMarkInd === -1) {\r\n            questionMarkInd = dataURL.length;\r\n        }\r\n        host = dataURL.substring(0, Math.min(slashInd, questionMarkInd));\r\n        if (slashInd < questionMarkInd) {\r\n            // For pathString, questionMarkInd will always come after slashInd\r\n            pathString = decodePath(dataURL.substring(slashInd, questionMarkInd));\r\n        }\r\n        var queryParams = decodeQuery(dataURL.substring(Math.min(dataURL.length, questionMarkInd)));\r\n        // If we have a port, use scheme for determining if it's secure.\r\n        colonInd = host.indexOf(':');\r\n        if (colonInd >= 0) {\r\n            secure = scheme === 'https' || scheme === 'wss';\r\n            port = parseInt(host.substring(colonInd + 1), 10);\r\n        }\r\n        else {\r\n            colonInd = host.length;\r\n        }\r\n        var hostWithoutPort = host.slice(0, colonInd);\r\n        if (hostWithoutPort.toLowerCase() === 'localhost') {\r\n            domain = 'localhost';\r\n        }\r\n        else if (hostWithoutPort.split('.').length <= 2) {\r\n            domain = hostWithoutPort;\r\n        }\r\n        else {\r\n            // Interpret the subdomain of a 3 or more component URL as the namespace name.\r\n            var dotInd = host.indexOf('.');\r\n            subdomain = host.substring(0, dotInd).toLowerCase();\r\n            domain = host.substring(dotInd + 1);\r\n            // Normalize namespaces to lowercase to share storage / connection.\r\n            namespace = subdomain;\r\n        }\r\n        // Always treat the value of the `ns` as the namespace name if it is present.\r\n        if ('ns' in queryParams) {\r\n            namespace = queryParams['ns'];\r\n        }\r\n    }\r\n    return {\r\n        host: host,\r\n        port: port,\r\n        domain: domain,\r\n        subdomain: subdomain,\r\n        secure: secure,\r\n        scheme: scheme,\r\n        pathString: pathString,\r\n        namespace: namespace\r\n    };\r\n};\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * True for invalid Firebase keys\r\n * @type {RegExp}\r\n * @private\r\n */\r\nvar INVALID_KEY_REGEX_ = /[\\[\\].#$\\/\\u0000-\\u001F\\u007F]/;\r\n/**\r\n * True for invalid Firebase paths.\r\n * Allows '/' in paths.\r\n * @type {RegExp}\r\n * @private\r\n */\r\nvar INVALID_PATH_REGEX_ = /[\\[\\].#$\\u0000-\\u001F\\u007F]/;\r\n/**\r\n * Maximum number of characters to allow in leaf value\r\n * @type {number}\r\n * @private\r\n */\r\nvar MAX_LEAF_SIZE_ = 10 * 1024 * 1024;\r\n/**\r\n * @param {*} key\r\n * @return {boolean}\r\n */\r\nvar isValidKey = function (key) {\r\n    return (typeof key === 'string' && key.length !== 0 && !INVALID_KEY_REGEX_.test(key));\r\n};\r\n/**\r\n * @param {string} pathString\r\n * @return {boolean}\r\n */\r\nvar isValidPathString = function (pathString) {\r\n    return (typeof pathString === 'string' &&\r\n        pathString.length !== 0 &&\r\n        !INVALID_PATH_REGEX_.test(pathString));\r\n};\r\n/**\r\n * @param {string} pathString\r\n * @return {boolean}\r\n */\r\nvar isValidRootPathString = function (pathString) {\r\n    if (pathString) {\r\n        // Allow '/.info/' at the beginning.\r\n        pathString = pathString.replace(/^\\/*\\.info(\\/|$)/, '/');\r\n    }\r\n    return isValidPathString(pathString);\r\n};\r\n/**\r\n * @param {*} priority\r\n * @return {boolean}\r\n */\r\nvar isValidPriority = function (priority) {\r\n    return (priority === null ||\r\n        typeof priority === 'string' ||\r\n        (typeof priority === 'number' && !isInvalidJSONNumber(priority)) ||\r\n        (priority &&\r\n            typeof priority === 'object' &&\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(priority, '.sv')));\r\n};\r\n/**\r\n * Pre-validate a datum passed as an argument to Firebase function.\r\n *\r\n * @param {string} fnName\r\n * @param {number} argumentNumber\r\n * @param {*} data\r\n * @param {!Path} path\r\n * @param {boolean} optional\r\n */\r\nvar validateFirebaseDataArg = function (fnName, argumentNumber, data, path, optional) {\r\n    if (optional && data === undefined) {\r\n        return;\r\n    }\r\n    validateFirebaseData((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.errorPrefix)(fnName, argumentNumber, optional), data, path);\r\n};\r\n/**\r\n * Validate a data object client-side before sending to server.\r\n *\r\n * @param {string} errorPrefix\r\n * @param {*} data\r\n * @param {!Path|!ValidationPath} path_\r\n */\r\nvar validateFirebaseData = function (errorPrefix, data, path_) {\r\n    var path = path_ instanceof Path ? new ValidationPath(path_, errorPrefix) : path_;\r\n    if (data === undefined) {\r\n        throw new Error(errorPrefix + 'contains undefined ' + path.toErrorString());\r\n    }\r\n    if (typeof data === 'function') {\r\n        throw new Error(errorPrefix +\r\n            'contains a function ' +\r\n            path.toErrorString() +\r\n            ' with contents = ' +\r\n            data.toString());\r\n    }\r\n    if (isInvalidJSONNumber(data)) {\r\n        throw new Error(errorPrefix + 'contains ' + data.toString() + ' ' + path.toErrorString());\r\n    }\r\n    // Check max leaf size, but try to avoid the utf8 conversion if we can.\r\n    if (typeof data === 'string' &&\r\n        data.length > MAX_LEAF_SIZE_ / 3 &&\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringLength)(data) > MAX_LEAF_SIZE_) {\r\n        throw new Error(errorPrefix +\r\n            'contains a string greater than ' +\r\n            MAX_LEAF_SIZE_ +\r\n            ' utf8 bytes ' +\r\n            path.toErrorString() +\r\n            \" ('\" +\r\n            data.substring(0, 50) +\r\n            \"...')\");\r\n    }\r\n    // TODO = Perf = Consider combining the recursive validation of keys into NodeFromJSON\r\n    // to save extra walking of large objects.\r\n    if (data && typeof data === 'object') {\r\n        var hasDotValue_1 = false;\r\n        var hasActualChild_1 = false;\r\n        each(data, function (key, value) {\r\n            if (key === '.value') {\r\n                hasDotValue_1 = true;\r\n            }\r\n            else if (key !== '.priority' && key !== '.sv') {\r\n                hasActualChild_1 = true;\r\n                if (!isValidKey(key)) {\r\n                    throw new Error(errorPrefix +\r\n                        ' contains an invalid key (' +\r\n                        key +\r\n                        ') ' +\r\n                        path.toErrorString() +\r\n                        '.  Keys must be non-empty strings ' +\r\n                        'and can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\"');\r\n                }\r\n            }\r\n            path.push(key);\r\n            validateFirebaseData(errorPrefix, value, path);\r\n            path.pop();\r\n        });\r\n        if (hasDotValue_1 && hasActualChild_1) {\r\n            throw new Error(errorPrefix +\r\n                ' contains \".value\" child ' +\r\n                path.toErrorString() +\r\n                ' in addition to actual children.');\r\n        }\r\n    }\r\n};\r\n/**\r\n * Pre-validate paths passed in the firebase function.\r\n *\r\n * @param {string} errorPrefix\r\n * @param {Array<!Path>} mergePaths\r\n */\r\nvar validateFirebaseMergePaths = function (errorPrefix, mergePaths) {\r\n    var i, curPath;\r\n    for (i = 0; i < mergePaths.length; i++) {\r\n        curPath = mergePaths[i];\r\n        var keys = curPath.slice();\r\n        for (var j = 0; j < keys.length; j++) {\r\n            if (keys[j] === '.priority' && j === keys.length - 1) ;\r\n            else if (!isValidKey(keys[j])) {\r\n                throw new Error(errorPrefix +\r\n                    'contains an invalid key (' +\r\n                    keys[j] +\r\n                    ') in path ' +\r\n                    curPath.toString() +\r\n                    '. Keys must be non-empty strings ' +\r\n                    'and can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\"');\r\n            }\r\n        }\r\n    }\r\n    // Check that update keys are not descendants of each other.\r\n    // We rely on the property that sorting guarantees that ancestors come\r\n    // right before descendants.\r\n    mergePaths.sort(Path.comparePaths);\r\n    var prevPath = null;\r\n    for (i = 0; i < mergePaths.length; i++) {\r\n        curPath = mergePaths[i];\r\n        if (prevPath !== null && prevPath.contains(curPath)) {\r\n            throw new Error(errorPrefix +\r\n                'contains a path ' +\r\n                prevPath.toString() +\r\n                ' that is ancestor of another path ' +\r\n                curPath.toString());\r\n        }\r\n        prevPath = curPath;\r\n    }\r\n};\r\n/**\r\n * pre-validate an object passed as an argument to firebase function (\r\n * must be an object - e.g. for firebase.update()).\r\n *\r\n * @param {string} fnName\r\n * @param {number} argumentNumber\r\n * @param {*} data\r\n * @param {!Path} path\r\n * @param {boolean} optional\r\n */\r\nvar validateFirebaseMergeDataArg = function (fnName, argumentNumber, data, path, optional) {\r\n    if (optional && data === undefined) {\r\n        return;\r\n    }\r\n    var errorPrefix$1 = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.errorPrefix)(fnName, argumentNumber, optional);\r\n    if (!(data && typeof data === 'object') || Array.isArray(data)) {\r\n        throw new Error(errorPrefix$1 + ' must be an object containing the children to replace.');\r\n    }\r\n    var mergePaths = [];\r\n    each(data, function (key, value) {\r\n        var curPath = new Path(key);\r\n        validateFirebaseData(errorPrefix$1, value, path.child(curPath));\r\n        if (curPath.getBack() === '.priority') {\r\n            if (!isValidPriority(value)) {\r\n                throw new Error(errorPrefix$1 +\r\n                    \"contains an invalid value for '\" +\r\n                    curPath.toString() +\r\n                    \"', which must be a valid \" +\r\n                    'Firebase priority (a string, finite number, server value, or null).');\r\n            }\r\n        }\r\n        mergePaths.push(curPath);\r\n    });\r\n    validateFirebaseMergePaths(errorPrefix$1, mergePaths);\r\n};\r\nvar validatePriority = function (fnName, argumentNumber, priority, optional) {\r\n    if (optional && priority === undefined) {\r\n        return;\r\n    }\r\n    if (isInvalidJSONNumber(priority)) {\r\n        throw new Error((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.errorPrefix)(fnName, argumentNumber, optional) +\r\n            'is ' +\r\n            priority.toString() +\r\n            ', but must be a valid Firebase priority (a string, finite number, ' +\r\n            'server value, or null).');\r\n    }\r\n    // Special case to allow importing data with a .sv.\r\n    if (!isValidPriority(priority)) {\r\n        throw new Error((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.errorPrefix)(fnName, argumentNumber, optional) +\r\n            'must be a valid Firebase priority ' +\r\n            '(a string, finite number, server value, or null).');\r\n    }\r\n};\r\nvar validateEventType = function (fnName, argumentNumber, eventType, optional) {\r\n    if (optional && eventType === undefined) {\r\n        return;\r\n    }\r\n    switch (eventType) {\r\n        case 'value':\r\n        case 'child_added':\r\n        case 'child_removed':\r\n        case 'child_changed':\r\n        case 'child_moved':\r\n            break;\r\n        default:\r\n            throw new Error((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.errorPrefix)(fnName, argumentNumber, optional) +\r\n                'must be a valid event type = \"value\", \"child_added\", \"child_removed\", ' +\r\n                '\"child_changed\", or \"child_moved\".');\r\n    }\r\n};\r\nvar validateKey = function (fnName, argumentNumber, key, optional) {\r\n    if (optional && key === undefined) {\r\n        return;\r\n    }\r\n    if (!isValidKey(key)) {\r\n        throw new Error((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.errorPrefix)(fnName, argumentNumber, optional) +\r\n            'was an invalid key = \"' +\r\n            key +\r\n            '\".  Firebase keys must be non-empty strings and ' +\r\n            'can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\").');\r\n    }\r\n};\r\nvar validatePathString = function (fnName, argumentNumber, pathString, optional) {\r\n    if (optional && pathString === undefined) {\r\n        return;\r\n    }\r\n    if (!isValidPathString(pathString)) {\r\n        throw new Error((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.errorPrefix)(fnName, argumentNumber, optional) +\r\n            'was an invalid path = \"' +\r\n            pathString +\r\n            '\". Paths must be non-empty strings and ' +\r\n            'can\\'t contain \".\", \"#\", \"$\", \"[\", or \"]\"');\r\n    }\r\n};\r\nvar validateRootPathString = function (fnName, argumentNumber, pathString, optional) {\r\n    if (pathString) {\r\n        // Allow '/.info/' at the beginning.\r\n        pathString = pathString.replace(/^\\/*\\.info(\\/|$)/, '/');\r\n    }\r\n    validatePathString(fnName, argumentNumber, pathString, optional);\r\n};\r\nvar validateWritablePath = function (fnName, path) {\r\n    if (path.getFront() === '.info') {\r\n        throw new Error(fnName + \" failed = Can't modify data under /.info/\");\r\n    }\r\n};\r\nvar validateUrl = function (fnName, argumentNumber, parsedUrl) {\r\n    // TODO = Validate server better.\r\n    var pathString = parsedUrl.path.toString();\r\n    if (!(typeof parsedUrl.repoInfo.host === 'string') ||\r\n        parsedUrl.repoInfo.host.length === 0 ||\r\n        (!isValidKey(parsedUrl.repoInfo.namespace) &&\r\n            parsedUrl.repoInfo.host.split(':')[0] !== 'localhost') ||\r\n        (pathString.length !== 0 && !isValidRootPathString(pathString))) {\r\n        throw new Error((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.errorPrefix)(fnName, argumentNumber, false) +\r\n            'must be a valid firebase URL and ' +\r\n            'the path can\\'t contain \".\", \"#\", \"$\", \"[\", or \"]\".');\r\n    }\r\n};\r\nvar validateBoolean = function (fnName, argumentNumber, bool, optional) {\r\n    if (optional && bool === undefined) {\r\n        return;\r\n    }\r\n    if (typeof bool !== 'boolean') {\r\n        throw new Error((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.errorPrefix)(fnName, argumentNumber, optional) + 'must be a boolean.');\r\n    }\r\n};\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * @constructor\r\n */\r\nvar OnDisconnect = /** @class */ (function () {\r\n    /**\r\n     * @param {!Repo} repo_\r\n     * @param {!Path} path_\r\n     */\r\n    function OnDisconnect(repo_, path_) {\r\n        this.repo_ = repo_;\r\n        this.path_ = path_;\r\n    }\r\n    /**\r\n     * @param {function(?Error)=} onComplete\r\n     * @return {!firebase.Promise}\r\n     */\r\n    OnDisconnect.prototype.cancel = function (onComplete) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('OnDisconnect.cancel', 0, 1, arguments.length);\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateCallback)('OnDisconnect.cancel', 1, onComplete, true);\r\n        var deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();\r\n        this.repo_.onDisconnectCancel(this.path_, deferred.wrapCallback(onComplete));\r\n        return deferred.promise;\r\n    };\r\n    /**\r\n     * @param {function(?Error)=} onComplete\r\n     * @return {!firebase.Promise}\r\n     */\r\n    OnDisconnect.prototype.remove = function (onComplete) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('OnDisconnect.remove', 0, 1, arguments.length);\r\n        validateWritablePath('OnDisconnect.remove', this.path_);\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateCallback)('OnDisconnect.remove', 1, onComplete, true);\r\n        var deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();\r\n        this.repo_.onDisconnectSet(this.path_, null, deferred.wrapCallback(onComplete));\r\n        return deferred.promise;\r\n    };\r\n    /**\r\n     * @param {*} value\r\n     * @param {function(?Error)=} onComplete\r\n     * @return {!firebase.Promise}\r\n     */\r\n    OnDisconnect.prototype.set = function (value, onComplete) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('OnDisconnect.set', 1, 2, arguments.length);\r\n        validateWritablePath('OnDisconnect.set', this.path_);\r\n        validateFirebaseDataArg('OnDisconnect.set', 1, value, this.path_, false);\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateCallback)('OnDisconnect.set', 2, onComplete, true);\r\n        var deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();\r\n        this.repo_.onDisconnectSet(this.path_, value, deferred.wrapCallback(onComplete));\r\n        return deferred.promise;\r\n    };\r\n    /**\r\n     * @param {*} value\r\n     * @param {number|string|null} priority\r\n     * @param {function(?Error)=} onComplete\r\n     * @return {!firebase.Promise}\r\n     */\r\n    OnDisconnect.prototype.setWithPriority = function (value, priority, onComplete) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('OnDisconnect.setWithPriority', 2, 3, arguments.length);\r\n        validateWritablePath('OnDisconnect.setWithPriority', this.path_);\r\n        validateFirebaseDataArg('OnDisconnect.setWithPriority', 1, value, this.path_, false);\r\n        validatePriority('OnDisconnect.setWithPriority', 2, priority, false);\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateCallback)('OnDisconnect.setWithPriority', 3, onComplete, true);\r\n        var deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();\r\n        this.repo_.onDisconnectSetWithPriority(this.path_, value, priority, deferred.wrapCallback(onComplete));\r\n        return deferred.promise;\r\n    };\r\n    /**\r\n     * @param {!Object} objectToMerge\r\n     * @param {function(?Error)=} onComplete\r\n     * @return {!firebase.Promise}\r\n     */\r\n    OnDisconnect.prototype.update = function (objectToMerge, onComplete) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('OnDisconnect.update', 1, 2, arguments.length);\r\n        validateWritablePath('OnDisconnect.update', this.path_);\r\n        if (Array.isArray(objectToMerge)) {\r\n            var newObjectToMerge = {};\r\n            for (var i = 0; i < objectToMerge.length; ++i) {\r\n                newObjectToMerge['' + i] = objectToMerge[i];\r\n            }\r\n            objectToMerge = newObjectToMerge;\r\n            warn('Passing an Array to firebase.database.onDisconnect().update() is deprecated. Use set() if you want to overwrite the ' +\r\n                'existing data, or an Object with integer keys if you really do want to only update some of the children.');\r\n        }\r\n        validateFirebaseMergeDataArg('OnDisconnect.update', 1, objectToMerge, this.path_, false);\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateCallback)('OnDisconnect.update', 2, onComplete, true);\r\n        var deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();\r\n        this.repo_.onDisconnectUpdate(this.path_, objectToMerge, deferred.wrapCallback(onComplete));\r\n        return deferred.promise;\r\n    };\r\n    return OnDisconnect;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar TransactionResult = /** @class */ (function () {\r\n    /**\r\n     * A type for the resolve value of Firebase.transaction.\r\n     * @constructor\r\n     * @dict\r\n     * @param {boolean} committed\r\n     * @param {DataSnapshot} snapshot\r\n     */\r\n    function TransactionResult(committed, snapshot) {\r\n        this.committed = committed;\r\n        this.snapshot = snapshot;\r\n    }\r\n    // Do not create public documentation. This is intended to make JSON serialization work but is otherwise unnecessary\r\n    // for end-users\r\n    TransactionResult.prototype.toJSON = function () {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('TransactionResult.toJSON', 0, 1, arguments.length);\r\n        return { committed: this.committed, snapshot: this.snapshot.toJSON() };\r\n    };\r\n    return TransactionResult;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Fancy ID generator that creates 20-character string identifiers with the\r\n * following properties:\r\n *\r\n * 1. They're based on timestamp so that they sort *after* any existing ids.\r\n * 2. They contain 72-bits of random data after the timestamp so that IDs won't\r\n *    collide with other clients' IDs.\r\n * 3. They sort *lexicographically* (so the timestamp is converted to characters\r\n *    that will sort properly).\r\n * 4. They're monotonically increasing. Even if you generate more than one in\r\n *    the same timestamp, the latter ones will sort after the former ones. We do\r\n *    this by using the previous random bits but \"incrementing\" them by 1 (only\r\n *    in the case of a timestamp collision).\r\n */\r\nvar nextPushId = (function () {\r\n    // Modeled after base64 web-safe chars, but ordered by ASCII.\r\n    var PUSH_CHARS = '-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz';\r\n    // Timestamp of last push, used to prevent local collisions if you push twice\r\n    // in one ms.\r\n    var lastPushTime = 0;\r\n    // We generate 72-bits of randomness which get turned into 12 characters and\r\n    // appended to the timestamp to prevent collisions with other clients. We\r\n    // store the last characters we generated because in the event of a collision,\r\n    // we'll use those same characters except \"incremented\" by one.\r\n    var lastRandChars = [];\r\n    return function (now) {\r\n        var duplicateTime = now === lastPushTime;\r\n        lastPushTime = now;\r\n        var i;\r\n        var timeStampChars = new Array(8);\r\n        for (i = 7; i >= 0; i--) {\r\n            timeStampChars[i] = PUSH_CHARS.charAt(now % 64);\r\n            // NOTE: Can't use << here because javascript will convert to int and lose\r\n            // the upper bits.\r\n            now = Math.floor(now / 64);\r\n        }\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(now === 0, 'Cannot push at time == 0');\r\n        var id = timeStampChars.join('');\r\n        if (!duplicateTime) {\r\n            for (i = 0; i < 12; i++) {\r\n                lastRandChars[i] = Math.floor(Math.random() * 64);\r\n            }\r\n        }\r\n        else {\r\n            // If the timestamp hasn't changed since last push, use the same random\r\n            // number, except incremented by 1.\r\n            for (i = 11; i >= 0 && lastRandChars[i] === 63; i--) {\r\n                lastRandChars[i] = 0;\r\n            }\r\n            lastRandChars[i]++;\r\n        }\r\n        for (i = 0; i < 12; i++) {\r\n            id += PUSH_CHARS.charAt(lastRandChars[i]);\r\n        }\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(id.length === 20, 'nextPushId: Length should be 20.');\r\n        return id;\r\n    };\r\n})();\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n *\r\n * @param {!string} name\r\n * @param {!Node} node\r\n * @constructor\r\n * @struct\r\n */\r\nvar NamedNode = /** @class */ (function () {\r\n    function NamedNode(name, node) {\r\n        this.name = name;\r\n        this.node = node;\r\n    }\r\n    /**\r\n     *\r\n     * @param {!string} name\r\n     * @param {!Node} node\r\n     * @return {NamedNode}\r\n     */\r\n    NamedNode.Wrap = function (name, node) {\r\n        return new NamedNode(name, node);\r\n    };\r\n    return NamedNode;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n *\r\n * @constructor\r\n */\r\nvar Index = /** @class */ (function () {\r\n    function Index() {\r\n    }\r\n    /**\r\n     * @return {function(!NamedNode, !NamedNode):number} A standalone comparison function for\r\n     * this index\r\n     */\r\n    Index.prototype.getCompare = function () {\r\n        return this.compare.bind(this);\r\n    };\r\n    /**\r\n     * Given a before and after value for a node, determine if the indexed value has changed. Even if they are different,\r\n     * it's possible that the changes are isolated to parts of the snapshot that are not indexed.\r\n     *\r\n     * @param {!Node} oldNode\r\n     * @param {!Node} newNode\r\n     * @return {boolean} True if the portion of the snapshot being indexed changed between oldNode and newNode\r\n     */\r\n    Index.prototype.indexedValueChanged = function (oldNode, newNode) {\r\n        var oldWrapped = new NamedNode(MIN_NAME, oldNode);\r\n        var newWrapped = new NamedNode(MIN_NAME, newNode);\r\n        return this.compare(oldWrapped, newWrapped) !== 0;\r\n    };\r\n    /**\r\n     * @return {!NamedNode} a node wrapper that will sort equal to or less than\r\n     * any other node wrapper, using this index\r\n     */\r\n    Index.prototype.minPost = function () {\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        return NamedNode.MIN;\r\n    };\r\n    return Index;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar __EMPTY_NODE;\r\nvar KeyIndex = /** @class */ (function (_super) {\r\n    (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(KeyIndex, _super);\r\n    function KeyIndex() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    Object.defineProperty(KeyIndex, \"__EMPTY_NODE\", {\r\n        get: function () {\r\n            return __EMPTY_NODE;\r\n        },\r\n        set: function (val) {\r\n            __EMPTY_NODE = val;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    KeyIndex.prototype.compare = function (a, b) {\r\n        return nameCompare(a.name, b.name);\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    KeyIndex.prototype.isDefinedOn = function (node) {\r\n        // We could probably return true here (since every node has a key), but it's never called\r\n        // so just leaving unimplemented for now.\r\n        throw (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assertionError)('KeyIndex.isDefinedOn not expected to be called.');\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    KeyIndex.prototype.indexedValueChanged = function (oldNode, newNode) {\r\n        return false; // The key for a node never changes.\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    KeyIndex.prototype.minPost = function () {\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        return NamedNode.MIN;\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    KeyIndex.prototype.maxPost = function () {\r\n        // TODO: This should really be created once and cached in a static property, but\r\n        // NamedNode isn't defined yet, so I can't use it in a static.  Bleh.\r\n        return new NamedNode(MAX_NAME, __EMPTY_NODE);\r\n    };\r\n    /**\r\n     * @param {*} indexValue\r\n     * @param {string} name\r\n     * @return {!NamedNode}\r\n     */\r\n    KeyIndex.prototype.makePost = function (indexValue, name) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(typeof indexValue === 'string', 'KeyIndex indexValue must always be a string.');\r\n        // We just use empty node, but it'll never be compared, since our comparator only looks at name.\r\n        return new NamedNode(indexValue, __EMPTY_NODE);\r\n    };\r\n    /**\r\n     * @return {!string} String representation for inclusion in a query spec\r\n     */\r\n    KeyIndex.prototype.toString = function () {\r\n        return '.key';\r\n    };\r\n    return KeyIndex;\r\n}(Index));\r\nvar KEY_INDEX = new KeyIndex();\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar MAX_NODE;\r\nfunction setMaxNode(val) {\r\n    MAX_NODE = val;\r\n}\r\n/**\r\n * @param {(!string|!number)} priority\r\n * @return {!string}\r\n */\r\nvar priorityHashText = function (priority) {\r\n    if (typeof priority === 'number') {\r\n        return 'number:' + doubleToIEEE754String(priority);\r\n    }\r\n    else {\r\n        return 'string:' + priority;\r\n    }\r\n};\r\n/**\r\n * Validates that a priority snapshot Node is valid.\r\n *\r\n * @param {!Node} priorityNode\r\n */\r\nvar validatePriorityNode = function (priorityNode) {\r\n    if (priorityNode.isLeafNode()) {\r\n        var val = priorityNode.val();\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(typeof val === 'string' ||\r\n            typeof val === 'number' ||\r\n            (typeof val === 'object' && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(val, '.sv')), 'Priority must be a string or number.');\r\n    }\r\n    else {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(priorityNode === MAX_NODE || priorityNode.isEmpty(), 'priority of unexpected type.');\r\n    }\r\n    // Don't call getPriority() on MAX_NODE to avoid hitting assertion.\r\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(priorityNode === MAX_NODE || priorityNode.getPriority().isEmpty(), \"Priority nodes can't have a priority of their own.\");\r\n};\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar __childrenNodeConstructor;\r\n/**\r\n * LeafNode is a class for storing leaf nodes in a DataSnapshot.  It\r\n * implements Node and stores the value of the node (a string,\r\n * number, or boolean) accessible via getValue().\r\n */\r\nvar LeafNode = /** @class */ (function () {\r\n    /**\r\n     * @implements {Node}\r\n     * @param {!(string|number|boolean|Object)} value_ The value to store in this leaf node.\r\n     *                                         The object type is possible in the event of a deferred value\r\n     * @param {!Node=} priorityNode_ The priority of this node.\r\n     */\r\n    function LeafNode(value_, priorityNode_) {\r\n        if (priorityNode_ === void 0) { priorityNode_ = LeafNode.__childrenNodeConstructor.EMPTY_NODE; }\r\n        this.value_ = value_;\r\n        this.priorityNode_ = priorityNode_;\r\n        this.lazyHash_ = null;\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.value_ !== undefined && this.value_ !== null, \"LeafNode shouldn't be created with null/undefined value.\");\r\n        validatePriorityNode(this.priorityNode_);\r\n    }\r\n    Object.defineProperty(LeafNode, \"__childrenNodeConstructor\", {\r\n        get: function () {\r\n            return __childrenNodeConstructor;\r\n        },\r\n        set: function (val) {\r\n            __childrenNodeConstructor = val;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /** @inheritDoc */\r\n    LeafNode.prototype.isLeafNode = function () {\r\n        return true;\r\n    };\r\n    /** @inheritDoc */\r\n    LeafNode.prototype.getPriority = function () {\r\n        return this.priorityNode_;\r\n    };\r\n    /** @inheritDoc */\r\n    LeafNode.prototype.updatePriority = function (newPriorityNode) {\r\n        return new LeafNode(this.value_, newPriorityNode);\r\n    };\r\n    /** @inheritDoc */\r\n    LeafNode.prototype.getImmediateChild = function (childName) {\r\n        // Hack to treat priority as a regular child\r\n        if (childName === '.priority') {\r\n            return this.priorityNode_;\r\n        }\r\n        else {\r\n            return LeafNode.__childrenNodeConstructor.EMPTY_NODE;\r\n        }\r\n    };\r\n    /** @inheritDoc */\r\n    LeafNode.prototype.getChild = function (path) {\r\n        if (path.isEmpty()) {\r\n            return this;\r\n        }\r\n        else if (path.getFront() === '.priority') {\r\n            return this.priorityNode_;\r\n        }\r\n        else {\r\n            return LeafNode.__childrenNodeConstructor.EMPTY_NODE;\r\n        }\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    LeafNode.prototype.hasChild = function () {\r\n        return false;\r\n    };\r\n    /** @inheritDoc */\r\n    LeafNode.prototype.getPredecessorChildName = function (childName, childNode) {\r\n        return null;\r\n    };\r\n    /** @inheritDoc */\r\n    LeafNode.prototype.updateImmediateChild = function (childName, newChildNode) {\r\n        if (childName === '.priority') {\r\n            return this.updatePriority(newChildNode);\r\n        }\r\n        else if (newChildNode.isEmpty() && childName !== '.priority') {\r\n            return this;\r\n        }\r\n        else {\r\n            return LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateImmediateChild(childName, newChildNode).updatePriority(this.priorityNode_);\r\n        }\r\n    };\r\n    /** @inheritDoc */\r\n    LeafNode.prototype.updateChild = function (path, newChildNode) {\r\n        var front = path.getFront();\r\n        if (front === null) {\r\n            return newChildNode;\r\n        }\r\n        else if (newChildNode.isEmpty() && front !== '.priority') {\r\n            return this;\r\n        }\r\n        else {\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(front !== '.priority' || path.getLength() === 1, '.priority must be the last token in a path');\r\n            return this.updateImmediateChild(front, LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateChild(path.popFront(), newChildNode));\r\n        }\r\n    };\r\n    /** @inheritDoc */\r\n    LeafNode.prototype.isEmpty = function () {\r\n        return false;\r\n    };\r\n    /** @inheritDoc */\r\n    LeafNode.prototype.numChildren = function () {\r\n        return 0;\r\n    };\r\n    /** @inheritDoc */\r\n    LeafNode.prototype.forEachChild = function (index, action) {\r\n        return false;\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    LeafNode.prototype.val = function (exportFormat) {\r\n        if (exportFormat && !this.getPriority().isEmpty()) {\r\n            return {\r\n                '.value': this.getValue(),\r\n                '.priority': this.getPriority().val()\r\n            };\r\n        }\r\n        else {\r\n            return this.getValue();\r\n        }\r\n    };\r\n    /** @inheritDoc */\r\n    LeafNode.prototype.hash = function () {\r\n        if (this.lazyHash_ === null) {\r\n            var toHash = '';\r\n            if (!this.priorityNode_.isEmpty()) {\r\n                toHash +=\r\n                    'priority:' +\r\n                        priorityHashText(this.priorityNode_.val()) +\r\n                        ':';\r\n            }\r\n            var type = typeof this.value_;\r\n            toHash += type + ':';\r\n            if (type === 'number') {\r\n                toHash += doubleToIEEE754String(this.value_);\r\n            }\r\n            else {\r\n                toHash += this.value_;\r\n            }\r\n            this.lazyHash_ = sha1(toHash);\r\n        }\r\n        return this.lazyHash_;\r\n    };\r\n    /**\r\n     * Returns the value of the leaf node.\r\n     * @return {Object|string|number|boolean} The value of the node.\r\n     */\r\n    LeafNode.prototype.getValue = function () {\r\n        return this.value_;\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    LeafNode.prototype.compareTo = function (other) {\r\n        if (other === LeafNode.__childrenNodeConstructor.EMPTY_NODE) {\r\n            return 1;\r\n        }\r\n        else if (other instanceof LeafNode.__childrenNodeConstructor) {\r\n            return -1;\r\n        }\r\n        else {\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(other.isLeafNode(), 'Unknown node type');\r\n            return this.compareToLeafNode_(other);\r\n        }\r\n    };\r\n    /**\r\n     * Comparison specifically for two leaf nodes\r\n     * @param {!LeafNode} otherLeaf\r\n     * @return {!number}\r\n     * @private\r\n     */\r\n    LeafNode.prototype.compareToLeafNode_ = function (otherLeaf) {\r\n        var otherLeafType = typeof otherLeaf.value_;\r\n        var thisLeafType = typeof this.value_;\r\n        var otherIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(otherLeafType);\r\n        var thisIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(thisLeafType);\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(otherIndex >= 0, 'Unknown leaf type: ' + otherLeafType);\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(thisIndex >= 0, 'Unknown leaf type: ' + thisLeafType);\r\n        if (otherIndex === thisIndex) {\r\n            // Same type, compare values\r\n            if (thisLeafType === 'object') {\r\n                // Deferred value nodes are all equal, but we should also never get to this point...\r\n                return 0;\r\n            }\r\n            else {\r\n                // Note that this works because true > false, all others are number or string comparisons\r\n                if (this.value_ < otherLeaf.value_) {\r\n                    return -1;\r\n                }\r\n                else if (this.value_ === otherLeaf.value_) {\r\n                    return 0;\r\n                }\r\n                else {\r\n                    return 1;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            return thisIndex - otherIndex;\r\n        }\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    LeafNode.prototype.withIndex = function () {\r\n        return this;\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    LeafNode.prototype.isIndexed = function () {\r\n        return true;\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    LeafNode.prototype.equals = function (other) {\r\n        /**\r\n         * @inheritDoc\r\n         */\r\n        if (other === this) {\r\n            return true;\r\n        }\r\n        else if (other.isLeafNode()) {\r\n            var otherLeaf = other;\r\n            return (this.value_ === otherLeaf.value_ &&\r\n                this.priorityNode_.equals(otherLeaf.priorityNode_));\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    };\r\n    /**\r\n     * The sort order for comparing leaf nodes of different types. If two leaf nodes have\r\n     * the same type, the comparison falls back to their value\r\n     * @type {Array.<!string>}\r\n     * @const\r\n     */\r\n    LeafNode.VALUE_TYPE_ORDER = ['object', 'boolean', 'number', 'string'];\r\n    return LeafNode;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar nodeFromJSON;\r\nvar MAX_NODE$1;\r\nfunction setNodeFromJSON(val) {\r\n    nodeFromJSON = val;\r\n}\r\nfunction setMaxNode$1(val) {\r\n    MAX_NODE$1 = val;\r\n}\r\n/**\r\n * @constructor\r\n * @extends {Index}\r\n * @private\r\n */\r\nvar PriorityIndex = /** @class */ (function (_super) {\r\n    (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(PriorityIndex, _super);\r\n    function PriorityIndex() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    PriorityIndex.prototype.compare = function (a, b) {\r\n        var aPriority = a.node.getPriority();\r\n        var bPriority = b.node.getPriority();\r\n        var indexCmp = aPriority.compareTo(bPriority);\r\n        if (indexCmp === 0) {\r\n            return nameCompare(a.name, b.name);\r\n        }\r\n        else {\r\n            return indexCmp;\r\n        }\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    PriorityIndex.prototype.isDefinedOn = function (node) {\r\n        return !node.getPriority().isEmpty();\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    PriorityIndex.prototype.indexedValueChanged = function (oldNode, newNode) {\r\n        return !oldNode.getPriority().equals(newNode.getPriority());\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    PriorityIndex.prototype.minPost = function () {\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        return NamedNode.MIN;\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    PriorityIndex.prototype.maxPost = function () {\r\n        return new NamedNode(MAX_NAME, new LeafNode('[PRIORITY-POST]', MAX_NODE$1));\r\n    };\r\n    /**\r\n     * @param {*} indexValue\r\n     * @param {string} name\r\n     * @return {!NamedNode}\r\n     */\r\n    PriorityIndex.prototype.makePost = function (indexValue, name) {\r\n        var priorityNode = nodeFromJSON(indexValue);\r\n        return new NamedNode(name, new LeafNode('[PRIORITY-POST]', priorityNode));\r\n    };\r\n    /**\r\n     * @return {!string} String representation for inclusion in a query spec\r\n     */\r\n    PriorityIndex.prototype.toString = function () {\r\n        return '.priority';\r\n    };\r\n    return PriorityIndex;\r\n}(Index));\r\nvar PRIORITY_INDEX = new PriorityIndex();\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An iterator over an LLRBNode.\r\n */\r\nvar SortedMapIterator = /** @class */ (function () {\r\n    /**\r\n     * @template K, V, T\r\n     * @param {LLRBNode|LLRBEmptyNode} node Node to iterate.\r\n     * @param {?K} startKey\r\n     * @param {function(K, K): number} comparator\r\n     * @param {boolean} isReverse_ Whether or not to iterate in reverse\r\n     * @param {(function(K, V):T)=} resultGenerator_\r\n     */\r\n    function SortedMapIterator(node, startKey, comparator, isReverse_, resultGenerator_) {\r\n        if (resultGenerator_ === void 0) { resultGenerator_ = null; }\r\n        this.isReverse_ = isReverse_;\r\n        this.resultGenerator_ = resultGenerator_;\r\n        /** @private\r\n         * @type {Array.<!LLRBNode>}\r\n         */\r\n        this.nodeStack_ = [];\r\n        var cmp = 1;\r\n        while (!node.isEmpty()) {\r\n            node = node;\r\n            cmp = startKey ? comparator(node.key, startKey) : 1;\r\n            // flip the comparison if we're going in reverse\r\n            if (isReverse_) {\r\n                cmp *= -1;\r\n            }\r\n            if (cmp < 0) {\r\n                // This node is less than our start key. ignore it\r\n                if (this.isReverse_) {\r\n                    node = node.left;\r\n                }\r\n                else {\r\n                    node = node.right;\r\n                }\r\n            }\r\n            else if (cmp === 0) {\r\n                // This node is exactly equal to our start key. Push it on the stack, but stop iterating;\r\n                this.nodeStack_.push(node);\r\n                break;\r\n            }\r\n            else {\r\n                // This node is greater than our start key, add it to the stack and move to the next one\r\n                this.nodeStack_.push(node);\r\n                if (this.isReverse_) {\r\n                    node = node.right;\r\n                }\r\n                else {\r\n                    node = node.left;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    SortedMapIterator.prototype.getNext = function () {\r\n        if (this.nodeStack_.length === 0) {\r\n            return null;\r\n        }\r\n        var node = this.nodeStack_.pop();\r\n        var result;\r\n        if (this.resultGenerator_) {\r\n            result = this.resultGenerator_(node.key, node.value);\r\n        }\r\n        else {\r\n            result = { key: node.key, value: node.value };\r\n        }\r\n        if (this.isReverse_) {\r\n            node = node.left;\r\n            while (!node.isEmpty()) {\r\n                this.nodeStack_.push(node);\r\n                node = node.right;\r\n            }\r\n        }\r\n        else {\r\n            node = node.right;\r\n            while (!node.isEmpty()) {\r\n                this.nodeStack_.push(node);\r\n                node = node.left;\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n    SortedMapIterator.prototype.hasNext = function () {\r\n        return this.nodeStack_.length > 0;\r\n    };\r\n    SortedMapIterator.prototype.peek = function () {\r\n        if (this.nodeStack_.length === 0) {\r\n            return null;\r\n        }\r\n        var node = this.nodeStack_[this.nodeStack_.length - 1];\r\n        if (this.resultGenerator_) {\r\n            return this.resultGenerator_(node.key, node.value);\r\n        }\r\n        else {\r\n            return { key: node.key, value: node.value };\r\n        }\r\n    };\r\n    return SortedMapIterator;\r\n}());\r\n/**\r\n * Represents a node in a Left-leaning Red-Black tree.\r\n */\r\nvar LLRBNode = /** @class */ (function () {\r\n    /**\r\n     * @template K, V\r\n     * @param {!K} key Key associated with this node.\r\n     * @param {!V} value Value associated with this node.\r\n     * @param {?boolean} color Whether this node is red.\r\n     * @param {?(LLRBNode|LLRBEmptyNode)=} left Left child.\r\n     * @param {?(LLRBNode|LLRBEmptyNode)=} right Right child.\r\n     */\r\n    function LLRBNode(key, value, color, left, right) {\r\n        this.key = key;\r\n        this.value = value;\r\n        this.color = color != null ? color : LLRBNode.RED;\r\n        this.left =\r\n            left != null ? left : SortedMap.EMPTY_NODE;\r\n        this.right =\r\n            right != null ? right : SortedMap.EMPTY_NODE;\r\n    }\r\n    /**\r\n     * Returns a copy of the current node, optionally replacing pieces of it.\r\n     *\r\n     * @param {?K} key New key for the node, or null.\r\n     * @param {?V} value New value for the node, or null.\r\n     * @param {?boolean} color New color for the node, or null.\r\n     * @param {?LLRBNode|LLRBEmptyNode} left New left child for the node, or null.\r\n     * @param {?LLRBNode|LLRBEmptyNode} right New right child for the node, or null.\r\n     * @return {!LLRBNode} The node copy.\r\n     */\r\n    LLRBNode.prototype.copy = function (key, value, color, left, right) {\r\n        return new LLRBNode(key != null ? key : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);\r\n    };\r\n    /**\r\n     * @return {number} The total number of nodes in the tree.\r\n     */\r\n    LLRBNode.prototype.count = function () {\r\n        return this.left.count() + 1 + this.right.count();\r\n    };\r\n    /**\r\n     * @return {boolean} True if the tree is empty.\r\n     */\r\n    LLRBNode.prototype.isEmpty = function () {\r\n        return false;\r\n    };\r\n    /**\r\n     * Traverses the tree in key order and calls the specified action function\r\n     * for each node.\r\n     *\r\n     * @param {function(!K, !V):*} action Callback function to be called for each\r\n     *   node.  If it returns true, traversal is aborted.\r\n     * @return {*} The first truthy value returned by action, or the last falsey\r\n     *   value returned by action\r\n     */\r\n    LLRBNode.prototype.inorderTraversal = function (action) {\r\n        return (this.left.inorderTraversal(action) ||\r\n            !!action(this.key, this.value) ||\r\n            this.right.inorderTraversal(action));\r\n    };\r\n    /**\r\n     * Traverses the tree in reverse key order and calls the specified action function\r\n     * for each node.\r\n     *\r\n     * @param {function(!Object, !Object)} action Callback function to be called for each\r\n     * node.  If it returns true, traversal is aborted.\r\n     * @return {*} True if traversal was aborted.\r\n     */\r\n    LLRBNode.prototype.reverseTraversal = function (action) {\r\n        return (this.right.reverseTraversal(action) ||\r\n            action(this.key, this.value) ||\r\n            this.left.reverseTraversal(action));\r\n    };\r\n    /**\r\n     * @return {!Object} The minimum node in the tree.\r\n     * @private\r\n     */\r\n    LLRBNode.prototype.min_ = function () {\r\n        if (this.left.isEmpty()) {\r\n            return this;\r\n        }\r\n        else {\r\n            return this.left.min_();\r\n        }\r\n    };\r\n    /**\r\n     * @return {!K} The maximum key in the tree.\r\n     */\r\n    LLRBNode.prototype.minKey = function () {\r\n        return this.min_().key;\r\n    };\r\n    /**\r\n     * @return {!K} The maximum key in the tree.\r\n     */\r\n    LLRBNode.prototype.maxKey = function () {\r\n        if (this.right.isEmpty()) {\r\n            return this.key;\r\n        }\r\n        else {\r\n            return this.right.maxKey();\r\n        }\r\n    };\r\n    /**\r\n     *\r\n     * @param {!Object} key Key to insert.\r\n     * @param {!Object} value Value to insert.\r\n     * @param {Comparator} comparator Comparator.\r\n     * @return {!LLRBNode} New tree, with the key/value added.\r\n     */\r\n    LLRBNode.prototype.insert = function (key, value, comparator) {\r\n        var n = this;\r\n        var cmp = comparator(key, n.key);\r\n        if (cmp < 0) {\r\n            n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);\r\n        }\r\n        else if (cmp === 0) {\r\n            n = n.copy(null, value, null, null, null);\r\n        }\r\n        else {\r\n            n = n.copy(null, null, null, null, n.right.insert(key, value, comparator));\r\n        }\r\n        return n.fixUp_();\r\n    };\r\n    /**\r\n     * @private\r\n     * @return {!LLRBNode|LLRBEmptyNode} New tree, with the minimum key removed.\r\n     */\r\n    LLRBNode.prototype.removeMin_ = function () {\r\n        if (this.left.isEmpty()) {\r\n            return SortedMap.EMPTY_NODE;\r\n        }\r\n        var n = this;\r\n        if (!n.left.isRed_() && !n.left.left.isRed_()) {\r\n            n = n.moveRedLeft_();\r\n        }\r\n        n = n.copy(null, null, null, n.left.removeMin_(), null);\r\n        return n.fixUp_();\r\n    };\r\n    /**\r\n     * @param {!Object} key The key of the item to remove.\r\n     * @param {Comparator} comparator Comparator.\r\n     * @return {!LLRBNode|LLRBEmptyNode} New tree, with the specified item removed.\r\n     */\r\n    LLRBNode.prototype.remove = function (key, comparator) {\r\n        var n, smallest;\r\n        n = this;\r\n        if (comparator(key, n.key) < 0) {\r\n            if (!n.left.isEmpty() && !n.left.isRed_() && !n.left.left.isRed_()) {\r\n                n = n.moveRedLeft_();\r\n            }\r\n            n = n.copy(null, null, null, n.left.remove(key, comparator), null);\r\n        }\r\n        else {\r\n            if (n.left.isRed_()) {\r\n                n = n.rotateRight_();\r\n            }\r\n            if (!n.right.isEmpty() && !n.right.isRed_() && !n.right.left.isRed_()) {\r\n                n = n.moveRedRight_();\r\n            }\r\n            if (comparator(key, n.key) === 0) {\r\n                if (n.right.isEmpty()) {\r\n                    return SortedMap.EMPTY_NODE;\r\n                }\r\n                else {\r\n                    smallest = n.right.min_();\r\n                    n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin_());\r\n                }\r\n            }\r\n            n = n.copy(null, null, null, null, n.right.remove(key, comparator));\r\n        }\r\n        return n.fixUp_();\r\n    };\r\n    /**\r\n     * @private\r\n     * @return {boolean} Whether this is a RED node.\r\n     */\r\n    LLRBNode.prototype.isRed_ = function () {\r\n        return this.color;\r\n    };\r\n    /**\r\n     * @private\r\n     * @return {!LLRBNode} New tree after performing any needed rotations.\r\n     */\r\n    LLRBNode.prototype.fixUp_ = function () {\r\n        var n = this;\r\n        if (n.right.isRed_() && !n.left.isRed_()) {\r\n            n = n.rotateLeft_();\r\n        }\r\n        if (n.left.isRed_() && n.left.left.isRed_()) {\r\n            n = n.rotateRight_();\r\n        }\r\n        if (n.left.isRed_() && n.right.isRed_()) {\r\n            n = n.colorFlip_();\r\n        }\r\n        return n;\r\n    };\r\n    /**\r\n     * @private\r\n     * @return {!LLRBNode} New tree, after moveRedLeft.\r\n     */\r\n    LLRBNode.prototype.moveRedLeft_ = function () {\r\n        var n = this.colorFlip_();\r\n        if (n.right.left.isRed_()) {\r\n            n = n.copy(null, null, null, null, n.right.rotateRight_());\r\n            n = n.rotateLeft_();\r\n            n = n.colorFlip_();\r\n        }\r\n        return n;\r\n    };\r\n    /**\r\n     * @private\r\n     * @return {!LLRBNode} New tree, after moveRedRight.\r\n     */\r\n    LLRBNode.prototype.moveRedRight_ = function () {\r\n        var n = this.colorFlip_();\r\n        if (n.left.left.isRed_()) {\r\n            n = n.rotateRight_();\r\n            n = n.colorFlip_();\r\n        }\r\n        return n;\r\n    };\r\n    /**\r\n     * @private\r\n     * @return {!LLRBNode} New tree, after rotateLeft.\r\n     */\r\n    LLRBNode.prototype.rotateLeft_ = function () {\r\n        var nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);\r\n        return this.right.copy(null, null, this.color, nl, null);\r\n    };\r\n    /**\r\n     * @private\r\n     * @return {!LLRBNode} New tree, after rotateRight.\r\n     */\r\n    LLRBNode.prototype.rotateRight_ = function () {\r\n        var nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);\r\n        return this.left.copy(null, null, this.color, null, nr);\r\n    };\r\n    /**\r\n     * @private\r\n     * @return {!LLRBNode} New tree, after colorFlip.\r\n     */\r\n    LLRBNode.prototype.colorFlip_ = function () {\r\n        var left = this.left.copy(null, null, !this.left.color, null, null);\r\n        var right = this.right.copy(null, null, !this.right.color, null, null);\r\n        return this.copy(null, null, !this.color, left, right);\r\n    };\r\n    /**\r\n     * For testing.\r\n     *\r\n     * @private\r\n     * @return {boolean} True if all is well.\r\n     */\r\n    LLRBNode.prototype.checkMaxDepth_ = function () {\r\n        var blackDepth = this.check_();\r\n        return Math.pow(2.0, blackDepth) <= this.count() + 1;\r\n    };\r\n    /**\r\n     * @private\r\n     * @return {number} Not sure what this returns exactly. :-).\r\n     */\r\n    LLRBNode.prototype.check_ = function () {\r\n        if (this.isRed_() && this.left.isRed_()) {\r\n            throw new Error('Red node has red child(' + this.key + ',' + this.value + ')');\r\n        }\r\n        if (this.right.isRed_()) {\r\n            throw new Error('Right child of (' + this.key + ',' + this.value + ') is red');\r\n        }\r\n        var blackDepth = this.left.check_();\r\n        if (blackDepth !== this.right.check_()) {\r\n            throw new Error('Black depths differ');\r\n        }\r\n        else {\r\n            return blackDepth + (this.isRed_() ? 0 : 1);\r\n        }\r\n    };\r\n    LLRBNode.RED = true;\r\n    LLRBNode.BLACK = false;\r\n    return LLRBNode;\r\n}());\r\n/**\r\n * Represents an empty node (a leaf node in the Red-Black Tree).\r\n */\r\nvar LLRBEmptyNode = /** @class */ (function () {\r\n    function LLRBEmptyNode() {\r\n    }\r\n    /**\r\n     * Returns a copy of the current node.\r\n     *\r\n     * @return {!LLRBEmptyNode} The node copy.\r\n     */\r\n    LLRBEmptyNode.prototype.copy = function (key, value, color, left, right) {\r\n        return this;\r\n    };\r\n    /**\r\n     * Returns a copy of the tree, with the specified key/value added.\r\n     *\r\n     * @param {!K} key Key to be added.\r\n     * @param {!V} value Value to be added.\r\n     * @param {Comparator} comparator Comparator.\r\n     * @return {!LLRBNode} New tree, with item added.\r\n     */\r\n    LLRBEmptyNode.prototype.insert = function (key, value, comparator) {\r\n        return new LLRBNode(key, value, null);\r\n    };\r\n    /**\r\n     * Returns a copy of the tree, with the specified key removed.\r\n     *\r\n     * @param {!K} key The key to remove.\r\n     * @param {Comparator} comparator Comparator.\r\n     * @return {!LLRBEmptyNode} New tree, with item removed.\r\n     */\r\n    LLRBEmptyNode.prototype.remove = function (key, comparator) {\r\n        return this;\r\n    };\r\n    /**\r\n     * @return {number} The total number of nodes in the tree.\r\n     */\r\n    LLRBEmptyNode.prototype.count = function () {\r\n        return 0;\r\n    };\r\n    /**\r\n     * @return {boolean} True if the tree is empty.\r\n     */\r\n    LLRBEmptyNode.prototype.isEmpty = function () {\r\n        return true;\r\n    };\r\n    /**\r\n     * Traverses the tree in key order and calls the specified action function\r\n     * for each node.\r\n     *\r\n     * @param {function(!K, !V):*} action Callback function to be called for each\r\n     * node.  If it returns true, traversal is aborted.\r\n     * @return {boolean} True if traversal was aborted.\r\n     */\r\n    LLRBEmptyNode.prototype.inorderTraversal = function (action) {\r\n        return false;\r\n    };\r\n    /**\r\n     * Traverses the tree in reverse key order and calls the specified action function\r\n     * for each node.\r\n     *\r\n     * @param {function(!K, !V)} action Callback function to be called for each\r\n     * node.  If it returns true, traversal is aborted.\r\n     * @return {boolean} True if traversal was aborted.\r\n     */\r\n    LLRBEmptyNode.prototype.reverseTraversal = function (action) {\r\n        return false;\r\n    };\r\n    /**\r\n     * @return {null}\r\n     */\r\n    LLRBEmptyNode.prototype.minKey = function () {\r\n        return null;\r\n    };\r\n    /**\r\n     * @return {null}\r\n     */\r\n    LLRBEmptyNode.prototype.maxKey = function () {\r\n        return null;\r\n    };\r\n    /**\r\n     * @private\r\n     * @return {number} Not sure what this returns exactly. :-).\r\n     */\r\n    LLRBEmptyNode.prototype.check_ = function () {\r\n        return 0;\r\n    };\r\n    /**\r\n     * @private\r\n     * @return {boolean} Whether this node is red.\r\n     */\r\n    LLRBEmptyNode.prototype.isRed_ = function () {\r\n        return false;\r\n    };\r\n    return LLRBEmptyNode;\r\n}());\r\n/**\r\n * An immutable sorted map implementation, based on a Left-leaning Red-Black\r\n * tree.\r\n */\r\nvar SortedMap = /** @class */ (function () {\r\n    /**\r\n     * @template K, V\r\n     * @param {function(K, K):number} comparator_ Key comparator.\r\n     * @param {LLRBNode=} root_ (Optional) Root node for the map.\r\n     */\r\n    function SortedMap(comparator_, root_) {\r\n        if (root_ === void 0) { root_ = SortedMap.EMPTY_NODE; }\r\n        this.comparator_ = comparator_;\r\n        this.root_ = root_;\r\n    }\r\n    /**\r\n     * Returns a copy of the map, with the specified key/value added or replaced.\r\n     * (TODO: We should perhaps rename this method to 'put')\r\n     *\r\n     * @param {!K} key Key to be added.\r\n     * @param {!V} value Value to be added.\r\n     * @return {!SortedMap.<K, V>} New map, with item added.\r\n     */\r\n    SortedMap.prototype.insert = function (key, value) {\r\n        return new SortedMap(this.comparator_, this.root_\r\n            .insert(key, value, this.comparator_)\r\n            .copy(null, null, LLRBNode.BLACK, null, null));\r\n    };\r\n    /**\r\n     * Returns a copy of the map, with the specified key removed.\r\n     *\r\n     * @param {!K} key The key to remove.\r\n     * @return {!SortedMap.<K, V>} New map, with item removed.\r\n     */\r\n    SortedMap.prototype.remove = function (key) {\r\n        return new SortedMap(this.comparator_, this.root_\r\n            .remove(key, this.comparator_)\r\n            .copy(null, null, LLRBNode.BLACK, null, null));\r\n    };\r\n    /**\r\n     * Returns the value of the node with the given key, or null.\r\n     *\r\n     * @param {!K} key The key to look up.\r\n     * @return {?V} The value of the node with the given key, or null if the\r\n     * key doesn't exist.\r\n     */\r\n    SortedMap.prototype.get = function (key) {\r\n        var cmp;\r\n        var node = this.root_;\r\n        while (!node.isEmpty()) {\r\n            cmp = this.comparator_(key, node.key);\r\n            if (cmp === 0) {\r\n                return node.value;\r\n            }\r\n            else if (cmp < 0) {\r\n                node = node.left;\r\n            }\r\n            else if (cmp > 0) {\r\n                node = node.right;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * Returns the key of the item *before* the specified key, or null if key is the first item.\r\n     * @param {K} key The key to find the predecessor of\r\n     * @return {?K} The predecessor key.\r\n     */\r\n    SortedMap.prototype.getPredecessorKey = function (key) {\r\n        var cmp, node = this.root_, rightParent = null;\r\n        while (!node.isEmpty()) {\r\n            cmp = this.comparator_(key, node.key);\r\n            if (cmp === 0) {\r\n                if (!node.left.isEmpty()) {\r\n                    node = node.left;\r\n                    while (!node.right.isEmpty()) {\r\n                        node = node.right;\r\n                    }\r\n                    return node.key;\r\n                }\r\n                else if (rightParent) {\r\n                    return rightParent.key;\r\n                }\r\n                else {\r\n                    return null; // first item.\r\n                }\r\n            }\r\n            else if (cmp < 0) {\r\n                node = node.left;\r\n            }\r\n            else if (cmp > 0) {\r\n                rightParent = node;\r\n                node = node.right;\r\n            }\r\n        }\r\n        throw new Error('Attempted to find predecessor key for a nonexistent key.  What gives?');\r\n    };\r\n    /**\r\n     * @return {boolean} True if the map is empty.\r\n     */\r\n    SortedMap.prototype.isEmpty = function () {\r\n        return this.root_.isEmpty();\r\n    };\r\n    /**\r\n     * @return {number} The total number of nodes in the map.\r\n     */\r\n    SortedMap.prototype.count = function () {\r\n        return this.root_.count();\r\n    };\r\n    /**\r\n     * @return {?K} The minimum key in the map.\r\n     */\r\n    SortedMap.prototype.minKey = function () {\r\n        return this.root_.minKey();\r\n    };\r\n    /**\r\n     * @return {?K} The maximum key in the map.\r\n     */\r\n    SortedMap.prototype.maxKey = function () {\r\n        return this.root_.maxKey();\r\n    };\r\n    /**\r\n     * Traverses the map in key order and calls the specified action function\r\n     * for each key/value pair.\r\n     *\r\n     * @param {function(!K, !V):*} action Callback function to be called\r\n     * for each key/value pair.  If action returns true, traversal is aborted.\r\n     * @return {*} The first truthy value returned by action, or the last falsey\r\n     *   value returned by action\r\n     */\r\n    SortedMap.prototype.inorderTraversal = function (action) {\r\n        return this.root_.inorderTraversal(action);\r\n    };\r\n    /**\r\n     * Traverses the map in reverse key order and calls the specified action function\r\n     * for each key/value pair.\r\n     *\r\n     * @param {function(!Object, !Object)} action Callback function to be called\r\n     * for each key/value pair.  If action returns true, traversal is aborted.\r\n     * @return {*} True if the traversal was aborted.\r\n     */\r\n    SortedMap.prototype.reverseTraversal = function (action) {\r\n        return this.root_.reverseTraversal(action);\r\n    };\r\n    /**\r\n     * Returns an iterator over the SortedMap.\r\n     * @template T\r\n     * @param {(function(K, V):T)=} resultGenerator\r\n     * @return {SortedMapIterator.<K, V, T>} The iterator.\r\n     */\r\n    SortedMap.prototype.getIterator = function (resultGenerator) {\r\n        return new SortedMapIterator(this.root_, null, this.comparator_, false, resultGenerator);\r\n    };\r\n    SortedMap.prototype.getIteratorFrom = function (key, resultGenerator) {\r\n        return new SortedMapIterator(this.root_, key, this.comparator_, false, resultGenerator);\r\n    };\r\n    SortedMap.prototype.getReverseIteratorFrom = function (key, resultGenerator) {\r\n        return new SortedMapIterator(this.root_, key, this.comparator_, true, resultGenerator);\r\n    };\r\n    SortedMap.prototype.getReverseIterator = function (resultGenerator) {\r\n        return new SortedMapIterator(this.root_, null, this.comparator_, true, resultGenerator);\r\n    };\r\n    /**\r\n     * Always use the same empty node, to reduce memory.\r\n     * @const\r\n     */\r\n    SortedMap.EMPTY_NODE = new LLRBEmptyNode();\r\n    return SortedMap;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar LOG_2 = Math.log(2);\r\n/**\r\n * @constructor\r\n */\r\nvar Base12Num = /** @class */ (function () {\r\n    /**\r\n     * @param {number} length\r\n     */\r\n    function Base12Num(length) {\r\n        var logBase2 = function (num) {\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            return parseInt((Math.log(num) / LOG_2), 10);\r\n        };\r\n        var bitMask = function (bits) { return parseInt(Array(bits + 1).join('1'), 2); };\r\n        this.count = logBase2(length + 1);\r\n        this.current_ = this.count - 1;\r\n        var mask = bitMask(this.count);\r\n        this.bits_ = (length + 1) & mask;\r\n    }\r\n    /**\r\n     * @return {boolean}\r\n     */\r\n    Base12Num.prototype.nextBitIsOne = function () {\r\n        //noinspection JSBitwiseOperatorUsage\r\n        var result = !(this.bits_ & (0x1 << this.current_));\r\n        this.current_--;\r\n        return result;\r\n    };\r\n    return Base12Num;\r\n}());\r\n/**\r\n * Takes a list of child nodes and constructs a SortedSet using the given comparison\r\n * function\r\n *\r\n * Uses the algorithm described in the paper linked here:\r\n * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.1458\r\n *\r\n * @template K, V\r\n * @param {Array.<!NamedNode>} childList Unsorted list of children\r\n * @param {function(!NamedNode, !NamedNode):number} cmp The comparison method to be used\r\n * @param {(function(NamedNode):K)=} keyFn An optional function to extract K from a node wrapper, if K's\r\n *                                                        type is not NamedNode\r\n * @param {(function(K, K):number)=} mapSortFn An optional override for comparator used by the generated sorted map\r\n * @return {SortedMap.<K, V>}\r\n */\r\nvar buildChildSet = function (childList, cmp, keyFn, mapSortFn) {\r\n    childList.sort(cmp);\r\n    var buildBalancedTree = function (low, high) {\r\n        var length = high - low;\r\n        var namedNode;\r\n        var key;\r\n        if (length === 0) {\r\n            return null;\r\n        }\r\n        else if (length === 1) {\r\n            namedNode = childList[low];\r\n            key = keyFn ? keyFn(namedNode) : namedNode;\r\n            return new LLRBNode(key, namedNode.node, LLRBNode.BLACK, null, null);\r\n        }\r\n        else {\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            var middle = parseInt((length / 2), 10) + low;\r\n            var left = buildBalancedTree(low, middle);\r\n            var right = buildBalancedTree(middle + 1, high);\r\n            namedNode = childList[middle];\r\n            key = keyFn ? keyFn(namedNode) : namedNode;\r\n            return new LLRBNode(key, namedNode.node, LLRBNode.BLACK, left, right);\r\n        }\r\n    };\r\n    var buildFrom12Array = function (base12) {\r\n        var node = null;\r\n        var root = null;\r\n        var index = childList.length;\r\n        var buildPennant = function (chunkSize, color) {\r\n            var low = index - chunkSize;\r\n            var high = index;\r\n            index -= chunkSize;\r\n            var childTree = buildBalancedTree(low + 1, high);\r\n            var namedNode = childList[low];\r\n            var key = keyFn ? keyFn(namedNode) : namedNode;\r\n            attachPennant(new LLRBNode(key, namedNode.node, color, null, childTree));\r\n        };\r\n        var attachPennant = function (pennant) {\r\n            if (node) {\r\n                node.left = pennant;\r\n                node = pennant;\r\n            }\r\n            else {\r\n                root = pennant;\r\n                node = pennant;\r\n            }\r\n        };\r\n        for (var i = 0; i < base12.count; ++i) {\r\n            var isOne = base12.nextBitIsOne();\r\n            // The number of nodes taken in each slice is 2^(arr.length - (i + 1))\r\n            var chunkSize = Math.pow(2, base12.count - (i + 1));\r\n            if (isOne) {\r\n                buildPennant(chunkSize, LLRBNode.BLACK);\r\n            }\r\n            else {\r\n                // current == 2\r\n                buildPennant(chunkSize, LLRBNode.BLACK);\r\n                buildPennant(chunkSize, LLRBNode.RED);\r\n            }\r\n        }\r\n        return root;\r\n    };\r\n    var base12 = new Base12Num(childList.length);\r\n    var root = buildFrom12Array(base12);\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    return new SortedMap(mapSortFn || cmp, root);\r\n};\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar _defaultIndexMap;\r\nvar fallbackObject = {};\r\nvar IndexMap = /** @class */ (function () {\r\n    function IndexMap(indexes_, indexSet_) {\r\n        this.indexes_ = indexes_;\r\n        this.indexSet_ = indexSet_;\r\n    }\r\n    Object.defineProperty(IndexMap, \"Default\", {\r\n        /**\r\n         * The default IndexMap for nodes without a priority\r\n         */\r\n        get: function () {\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(fallbackObject && PRIORITY_INDEX, 'ChildrenNode.ts has not been loaded');\r\n            _defaultIndexMap =\r\n                _defaultIndexMap ||\r\n                    new IndexMap({ '.priority': fallbackObject }, { '.priority': PRIORITY_INDEX });\r\n            return _defaultIndexMap;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    IndexMap.prototype.get = function (indexKey) {\r\n        var sortedMap = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.safeGet)(this.indexes_, indexKey);\r\n        if (!sortedMap) {\r\n            throw new Error('No index defined for ' + indexKey);\r\n        }\r\n        if (sortedMap instanceof SortedMap) {\r\n            return sortedMap;\r\n        }\r\n        else {\r\n            // The index exists, but it falls back to just name comparison. Return null so that the calling code uses the\r\n            // regular child map\r\n            return null;\r\n        }\r\n    };\r\n    IndexMap.prototype.hasIndex = function (indexDefinition) {\r\n        return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(this.indexSet_, indexDefinition.toString());\r\n    };\r\n    IndexMap.prototype.addIndex = function (indexDefinition, existingChildren) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(indexDefinition !== KEY_INDEX, \"KeyIndex always exists and isn't meant to be added to the IndexMap.\");\r\n        var childList = [];\r\n        var sawIndexedValue = false;\r\n        var iter = existingChildren.getIterator(NamedNode.Wrap);\r\n        var next = iter.getNext();\r\n        while (next) {\r\n            sawIndexedValue =\r\n                sawIndexedValue || indexDefinition.isDefinedOn(next.node);\r\n            childList.push(next);\r\n            next = iter.getNext();\r\n        }\r\n        var newIndex;\r\n        if (sawIndexedValue) {\r\n            newIndex = buildChildSet(childList, indexDefinition.getCompare());\r\n        }\r\n        else {\r\n            newIndex = fallbackObject;\r\n        }\r\n        var indexName = indexDefinition.toString();\r\n        var newIndexSet = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, this.indexSet_);\r\n        newIndexSet[indexName] = indexDefinition;\r\n        var newIndexes = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, this.indexes_);\r\n        newIndexes[indexName] = newIndex;\r\n        return new IndexMap(newIndexes, newIndexSet);\r\n    };\r\n    /**\r\n     * Ensure that this node is properly tracked in any indexes that we're maintaining\r\n     */\r\n    IndexMap.prototype.addToIndexes = function (namedNode, existingChildren) {\r\n        var _this = this;\r\n        var newIndexes = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.map)(this.indexes_, function (indexedChildren, indexName) {\r\n            var index = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.safeGet)(_this.indexSet_, indexName);\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(index, 'Missing index implementation for ' + indexName);\r\n            if (indexedChildren === fallbackObject) {\r\n                // Check to see if we need to index everything\r\n                if (index.isDefinedOn(namedNode.node)) {\r\n                    // We need to build this index\r\n                    var childList = [];\r\n                    var iter = existingChildren.getIterator(NamedNode.Wrap);\r\n                    var next = iter.getNext();\r\n                    while (next) {\r\n                        if (next.name !== namedNode.name) {\r\n                            childList.push(next);\r\n                        }\r\n                        next = iter.getNext();\r\n                    }\r\n                    childList.push(namedNode);\r\n                    return buildChildSet(childList, index.getCompare());\r\n                }\r\n                else {\r\n                    // No change, this remains a fallback\r\n                    return fallbackObject;\r\n                }\r\n            }\r\n            else {\r\n                var existingSnap = existingChildren.get(namedNode.name);\r\n                var newChildren = indexedChildren;\r\n                if (existingSnap) {\r\n                    newChildren = newChildren.remove(new NamedNode(namedNode.name, existingSnap));\r\n                }\r\n                return newChildren.insert(namedNode, namedNode.node);\r\n            }\r\n        });\r\n        return new IndexMap(newIndexes, this.indexSet_);\r\n    };\r\n    /**\r\n     * Create a new IndexMap instance with the given value removed\r\n     */\r\n    IndexMap.prototype.removeFromIndexes = function (namedNode, existingChildren) {\r\n        var newIndexes = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.map)(this.indexes_, function (indexedChildren) {\r\n            if (indexedChildren === fallbackObject) {\r\n                // This is the fallback. Just return it, nothing to do in this case\r\n                return indexedChildren;\r\n            }\r\n            else {\r\n                var existingSnap = existingChildren.get(namedNode.name);\r\n                if (existingSnap) {\r\n                    return indexedChildren.remove(new NamedNode(namedNode.name, existingSnap));\r\n                }\r\n                else {\r\n                    // No record of this child\r\n                    return indexedChildren;\r\n                }\r\n            }\r\n        });\r\n        return new IndexMap(newIndexes, this.indexSet_);\r\n    };\r\n    return IndexMap;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction NAME_ONLY_COMPARATOR(left, right) {\r\n    return nameCompare(left.name, right.name);\r\n}\r\nfunction NAME_COMPARATOR(left, right) {\r\n    return nameCompare(left, right);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// TODO: For memory savings, don't store priorityNode_ if it's empty.\r\nvar EMPTY_NODE;\r\n/**\r\n * ChildrenNode is a class for storing internal nodes in a DataSnapshot\r\n * (i.e. nodes with children).  It implements Node and stores the\r\n * list of children in the children property, sorted by child name.\r\n *\r\n * @constructor\r\n * @implements {Node}\r\n */\r\nvar ChildrenNode = /** @class */ (function () {\r\n    /**\r\n     *\r\n     * @param {!SortedMap.<string, !Node>} children_ List of children\r\n     * of this node..\r\n     * @param {?Node} priorityNode_ The priority of this node (as a snapshot node).\r\n     * @param {!IndexMap} indexMap_\r\n     */\r\n    function ChildrenNode(children_, priorityNode_, indexMap_) {\r\n        this.children_ = children_;\r\n        this.priorityNode_ = priorityNode_;\r\n        this.indexMap_ = indexMap_;\r\n        this.lazyHash_ = null;\r\n        /**\r\n         * Note: The only reason we allow null priority is for EMPTY_NODE, since we can't use\r\n         * EMPTY_NODE as the priority of EMPTY_NODE.  We might want to consider making EMPTY_NODE its own\r\n         * class instead of an empty ChildrenNode.\r\n         */\r\n        if (this.priorityNode_) {\r\n            validatePriorityNode(this.priorityNode_);\r\n        }\r\n        if (this.children_.isEmpty()) {\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.priorityNode_ || this.priorityNode_.isEmpty(), 'An empty node cannot have a priority');\r\n        }\r\n    }\r\n    Object.defineProperty(ChildrenNode, \"EMPTY_NODE\", {\r\n        get: function () {\r\n            return (EMPTY_NODE ||\r\n                (EMPTY_NODE = new ChildrenNode(new SortedMap(NAME_COMPARATOR), null, IndexMap.Default)));\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /** @inheritDoc */\r\n    ChildrenNode.prototype.isLeafNode = function () {\r\n        return false;\r\n    };\r\n    /** @inheritDoc */\r\n    ChildrenNode.prototype.getPriority = function () {\r\n        return this.priorityNode_ || EMPTY_NODE;\r\n    };\r\n    /** @inheritDoc */\r\n    ChildrenNode.prototype.updatePriority = function (newPriorityNode) {\r\n        if (this.children_.isEmpty()) {\r\n            // Don't allow priorities on empty nodes\r\n            return this;\r\n        }\r\n        else {\r\n            return new ChildrenNode(this.children_, newPriorityNode, this.indexMap_);\r\n        }\r\n    };\r\n    /** @inheritDoc */\r\n    ChildrenNode.prototype.getImmediateChild = function (childName) {\r\n        // Hack to treat priority as a regular child\r\n        if (childName === '.priority') {\r\n            return this.getPriority();\r\n        }\r\n        else {\r\n            var child = this.children_.get(childName);\r\n            return child === null ? EMPTY_NODE : child;\r\n        }\r\n    };\r\n    /** @inheritDoc */\r\n    ChildrenNode.prototype.getChild = function (path) {\r\n        var front = path.getFront();\r\n        if (front === null) {\r\n            return this;\r\n        }\r\n        return this.getImmediateChild(front).getChild(path.popFront());\r\n    };\r\n    /** @inheritDoc */\r\n    ChildrenNode.prototype.hasChild = function (childName) {\r\n        return this.children_.get(childName) !== null;\r\n    };\r\n    /** @inheritDoc */\r\n    ChildrenNode.prototype.updateImmediateChild = function (childName, newChildNode) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(newChildNode, 'We should always be passing snapshot nodes');\r\n        if (childName === '.priority') {\r\n            return this.updatePriority(newChildNode);\r\n        }\r\n        else {\r\n            var namedNode = new NamedNode(childName, newChildNode);\r\n            var newChildren = void 0, newIndexMap = void 0;\r\n            if (newChildNode.isEmpty()) {\r\n                newChildren = this.children_.remove(childName);\r\n                newIndexMap = this.indexMap_.removeFromIndexes(namedNode, this.children_);\r\n            }\r\n            else {\r\n                newChildren = this.children_.insert(childName, newChildNode);\r\n                newIndexMap = this.indexMap_.addToIndexes(namedNode, this.children_);\r\n            }\r\n            var newPriority = newChildren.isEmpty()\r\n                ? EMPTY_NODE\r\n                : this.priorityNode_;\r\n            return new ChildrenNode(newChildren, newPriority, newIndexMap);\r\n        }\r\n    };\r\n    /** @inheritDoc */\r\n    ChildrenNode.prototype.updateChild = function (path, newChildNode) {\r\n        var front = path.getFront();\r\n        if (front === null) {\r\n            return newChildNode;\r\n        }\r\n        else {\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(path.getFront() !== '.priority' || path.getLength() === 1, '.priority must be the last token in a path');\r\n            var newImmediateChild = this.getImmediateChild(front).updateChild(path.popFront(), newChildNode);\r\n            return this.updateImmediateChild(front, newImmediateChild);\r\n        }\r\n    };\r\n    /** @inheritDoc */\r\n    ChildrenNode.prototype.isEmpty = function () {\r\n        return this.children_.isEmpty();\r\n    };\r\n    /** @inheritDoc */\r\n    ChildrenNode.prototype.numChildren = function () {\r\n        return this.children_.count();\r\n    };\r\n    /** @inheritDoc */\r\n    ChildrenNode.prototype.val = function (exportFormat) {\r\n        if (this.isEmpty()) {\r\n            return null;\r\n        }\r\n        var obj = {};\r\n        var numKeys = 0, maxKey = 0, allIntegerKeys = true;\r\n        this.forEachChild(PRIORITY_INDEX, function (key, childNode) {\r\n            obj[key] = childNode.val(exportFormat);\r\n            numKeys++;\r\n            if (allIntegerKeys && ChildrenNode.INTEGER_REGEXP_.test(key)) {\r\n                maxKey = Math.max(maxKey, Number(key));\r\n            }\r\n            else {\r\n                allIntegerKeys = false;\r\n            }\r\n        });\r\n        if (!exportFormat && allIntegerKeys && maxKey < 2 * numKeys) {\r\n            // convert to array.\r\n            var array = [];\r\n            // eslint-disable-next-line guard-for-in\r\n            for (var key in obj) {\r\n                array[key] = obj[key];\r\n            }\r\n            return array;\r\n        }\r\n        else {\r\n            if (exportFormat && !this.getPriority().isEmpty()) {\r\n                obj['.priority'] = this.getPriority().val();\r\n            }\r\n            return obj;\r\n        }\r\n    };\r\n    /** @inheritDoc */\r\n    ChildrenNode.prototype.hash = function () {\r\n        if (this.lazyHash_ === null) {\r\n            var toHash_1 = '';\r\n            if (!this.getPriority().isEmpty()) {\r\n                toHash_1 +=\r\n                    'priority:' +\r\n                        priorityHashText(this.getPriority().val()) +\r\n                        ':';\r\n            }\r\n            this.forEachChild(PRIORITY_INDEX, function (key, childNode) {\r\n                var childHash = childNode.hash();\r\n                if (childHash !== '') {\r\n                    toHash_1 += ':' + key + ':' + childHash;\r\n                }\r\n            });\r\n            this.lazyHash_ = toHash_1 === '' ? '' : sha1(toHash_1);\r\n        }\r\n        return this.lazyHash_;\r\n    };\r\n    /** @inheritDoc */\r\n    ChildrenNode.prototype.getPredecessorChildName = function (childName, childNode, index) {\r\n        var idx = this.resolveIndex_(index);\r\n        if (idx) {\r\n            var predecessor = idx.getPredecessorKey(new NamedNode(childName, childNode));\r\n            return predecessor ? predecessor.name : null;\r\n        }\r\n        else {\r\n            return this.children_.getPredecessorKey(childName);\r\n        }\r\n    };\r\n    /**\r\n     * @param {!Index} indexDefinition\r\n     * @return {?string}\r\n     */\r\n    ChildrenNode.prototype.getFirstChildName = function (indexDefinition) {\r\n        var idx = this.resolveIndex_(indexDefinition);\r\n        if (idx) {\r\n            var minKey = idx.minKey();\r\n            return minKey && minKey.name;\r\n        }\r\n        else {\r\n            return this.children_.minKey();\r\n        }\r\n    };\r\n    /**\r\n     * @param {!Index} indexDefinition\r\n     * @return {?NamedNode}\r\n     */\r\n    ChildrenNode.prototype.getFirstChild = function (indexDefinition) {\r\n        var minKey = this.getFirstChildName(indexDefinition);\r\n        if (minKey) {\r\n            return new NamedNode(minKey, this.children_.get(minKey));\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    };\r\n    /**\r\n     * Given an index, return the key name of the largest value we have, according to that index\r\n     * @param {!Index} indexDefinition\r\n     * @return {?string}\r\n     */\r\n    ChildrenNode.prototype.getLastChildName = function (indexDefinition) {\r\n        var idx = this.resolveIndex_(indexDefinition);\r\n        if (idx) {\r\n            var maxKey = idx.maxKey();\r\n            return maxKey && maxKey.name;\r\n        }\r\n        else {\r\n            return this.children_.maxKey();\r\n        }\r\n    };\r\n    /**\r\n     * @param {!Index} indexDefinition\r\n     * @return {?NamedNode}\r\n     */\r\n    ChildrenNode.prototype.getLastChild = function (indexDefinition) {\r\n        var maxKey = this.getLastChildName(indexDefinition);\r\n        if (maxKey) {\r\n            return new NamedNode(maxKey, this.children_.get(maxKey));\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    ChildrenNode.prototype.forEachChild = function (index, action) {\r\n        var idx = this.resolveIndex_(index);\r\n        if (idx) {\r\n            return idx.inorderTraversal(function (wrappedNode) {\r\n                return action(wrappedNode.name, wrappedNode.node);\r\n            });\r\n        }\r\n        else {\r\n            return this.children_.inorderTraversal(action);\r\n        }\r\n    };\r\n    /**\r\n     * @param {!Index} indexDefinition\r\n     * @return {SortedMapIterator}\r\n     */\r\n    ChildrenNode.prototype.getIterator = function (indexDefinition) {\r\n        return this.getIteratorFrom(indexDefinition.minPost(), indexDefinition);\r\n    };\r\n    /**\r\n     *\r\n     * @param {!NamedNode} startPost\r\n     * @param {!Index} indexDefinition\r\n     * @return {!SortedMapIterator}\r\n     */\r\n    ChildrenNode.prototype.getIteratorFrom = function (startPost, indexDefinition) {\r\n        var idx = this.resolveIndex_(indexDefinition);\r\n        if (idx) {\r\n            return idx.getIteratorFrom(startPost, function (key) { return key; });\r\n        }\r\n        else {\r\n            var iterator = this.children_.getIteratorFrom(startPost.name, NamedNode.Wrap);\r\n            var next = iterator.peek();\r\n            while (next != null && indexDefinition.compare(next, startPost) < 0) {\r\n                iterator.getNext();\r\n                next = iterator.peek();\r\n            }\r\n            return iterator;\r\n        }\r\n    };\r\n    /**\r\n     * @param {!Index} indexDefinition\r\n     * @return {!SortedMapIterator}\r\n     */\r\n    ChildrenNode.prototype.getReverseIterator = function (indexDefinition) {\r\n        return this.getReverseIteratorFrom(indexDefinition.maxPost(), indexDefinition);\r\n    };\r\n    /**\r\n     * @param {!NamedNode} endPost\r\n     * @param {!Index} indexDefinition\r\n     * @return {!SortedMapIterator}\r\n     */\r\n    ChildrenNode.prototype.getReverseIteratorFrom = function (endPost, indexDefinition) {\r\n        var idx = this.resolveIndex_(indexDefinition);\r\n        if (idx) {\r\n            return idx.getReverseIteratorFrom(endPost, function (key) {\r\n                return key;\r\n            });\r\n        }\r\n        else {\r\n            var iterator = this.children_.getReverseIteratorFrom(endPost.name, NamedNode.Wrap);\r\n            var next = iterator.peek();\r\n            while (next != null && indexDefinition.compare(next, endPost) > 0) {\r\n                iterator.getNext();\r\n                next = iterator.peek();\r\n            }\r\n            return iterator;\r\n        }\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    ChildrenNode.prototype.compareTo = function (other) {\r\n        if (this.isEmpty()) {\r\n            if (other.isEmpty()) {\r\n                return 0;\r\n            }\r\n            else {\r\n                return -1;\r\n            }\r\n        }\r\n        else if (other.isLeafNode() || other.isEmpty()) {\r\n            return 1;\r\n        }\r\n        else if (other === MAX_NODE$2) {\r\n            return -1;\r\n        }\r\n        else {\r\n            // Must be another node with children.\r\n            return 0;\r\n        }\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    ChildrenNode.prototype.withIndex = function (indexDefinition) {\r\n        if (indexDefinition === KEY_INDEX ||\r\n            this.indexMap_.hasIndex(indexDefinition)) {\r\n            return this;\r\n        }\r\n        else {\r\n            var newIndexMap = this.indexMap_.addIndex(indexDefinition, this.children_);\r\n            return new ChildrenNode(this.children_, this.priorityNode_, newIndexMap);\r\n        }\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    ChildrenNode.prototype.isIndexed = function (index) {\r\n        return index === KEY_INDEX || this.indexMap_.hasIndex(index);\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    ChildrenNode.prototype.equals = function (other) {\r\n        if (other === this) {\r\n            return true;\r\n        }\r\n        else if (other.isLeafNode()) {\r\n            return false;\r\n        }\r\n        else {\r\n            var otherChildrenNode = other;\r\n            if (!this.getPriority().equals(otherChildrenNode.getPriority())) {\r\n                return false;\r\n            }\r\n            else if (this.children_.count() === otherChildrenNode.children_.count()) {\r\n                var thisIter = this.getIterator(PRIORITY_INDEX);\r\n                var otherIter = otherChildrenNode.getIterator(PRIORITY_INDEX);\r\n                var thisCurrent = thisIter.getNext();\r\n                var otherCurrent = otherIter.getNext();\r\n                while (thisCurrent && otherCurrent) {\r\n                    if (thisCurrent.name !== otherCurrent.name ||\r\n                        !thisCurrent.node.equals(otherCurrent.node)) {\r\n                        return false;\r\n                    }\r\n                    thisCurrent = thisIter.getNext();\r\n                    otherCurrent = otherIter.getNext();\r\n                }\r\n                return thisCurrent === null && otherCurrent === null;\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Returns a SortedMap ordered by index, or null if the default (by-key) ordering can be used\r\n     * instead.\r\n     *\r\n     * @private\r\n     * @param {!Index} indexDefinition\r\n     * @return {?SortedMap.<NamedNode, Node>}\r\n     */\r\n    ChildrenNode.prototype.resolveIndex_ = function (indexDefinition) {\r\n        if (indexDefinition === KEY_INDEX) {\r\n            return null;\r\n        }\r\n        else {\r\n            return this.indexMap_.get(indexDefinition.toString());\r\n        }\r\n    };\r\n    /**\r\n     * @private\r\n     * @type {RegExp}\r\n     */\r\n    ChildrenNode.INTEGER_REGEXP_ = /^(0|[1-9]\\d*)$/;\r\n    return ChildrenNode;\r\n}());\r\n/**\r\n * @constructor\r\n * @extends {ChildrenNode}\r\n * @private\r\n */\r\nvar MaxNode = /** @class */ (function (_super) {\r\n    (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(MaxNode, _super);\r\n    function MaxNode() {\r\n        return _super.call(this, new SortedMap(NAME_COMPARATOR), ChildrenNode.EMPTY_NODE, IndexMap.Default) || this;\r\n    }\r\n    MaxNode.prototype.compareTo = function (other) {\r\n        if (other === this) {\r\n            return 0;\r\n        }\r\n        else {\r\n            return 1;\r\n        }\r\n    };\r\n    MaxNode.prototype.equals = function (other) {\r\n        // Not that we every compare it, but MAX_NODE is only ever equal to itself\r\n        return other === this;\r\n    };\r\n    MaxNode.prototype.getPriority = function () {\r\n        return this;\r\n    };\r\n    MaxNode.prototype.getImmediateChild = function (childName) {\r\n        return ChildrenNode.EMPTY_NODE;\r\n    };\r\n    MaxNode.prototype.isEmpty = function () {\r\n        return false;\r\n    };\r\n    return MaxNode;\r\n}(ChildrenNode));\r\n/**\r\n * Marker that will sort higher than any other snapshot.\r\n * @type {!MAX_NODE}\r\n * @const\r\n */\r\nvar MAX_NODE$2 = new MaxNode();\r\nObject.defineProperties(NamedNode, {\r\n    MIN: {\r\n        value: new NamedNode(MIN_NAME, ChildrenNode.EMPTY_NODE)\r\n    },\r\n    MAX: {\r\n        value: new NamedNode(MAX_NAME, MAX_NODE$2)\r\n    }\r\n});\r\n/**\r\n * Reference Extensions\r\n */\r\nKeyIndex.__EMPTY_NODE = ChildrenNode.EMPTY_NODE;\r\nLeafNode.__childrenNodeConstructor = ChildrenNode;\r\nsetMaxNode(MAX_NODE$2);\r\nsetMaxNode$1(MAX_NODE$2);\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar USE_HINZE = true;\r\n/**\r\n * Constructs a snapshot node representing the passed JSON and returns it.\r\n * @param {*} json JSON to create a node for.\r\n * @param {?string|?number=} priority Optional priority to use.  This will be ignored if the\r\n * passed JSON contains a .priority property.\r\n * @return {!Node}\r\n */\r\nfunction nodeFromJSON$1(json, priority) {\r\n    if (priority === void 0) { priority = null; }\r\n    if (json === null) {\r\n        return ChildrenNode.EMPTY_NODE;\r\n    }\r\n    if (typeof json === 'object' && '.priority' in json) {\r\n        priority = json['.priority'];\r\n    }\r\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(priority === null ||\r\n        typeof priority === 'string' ||\r\n        typeof priority === 'number' ||\r\n        (typeof priority === 'object' && '.sv' in priority), 'Invalid priority type found: ' + typeof priority);\r\n    if (typeof json === 'object' && '.value' in json && json['.value'] !== null) {\r\n        json = json['.value'];\r\n    }\r\n    // Valid leaf nodes include non-objects or server-value wrapper objects\r\n    if (typeof json !== 'object' || '.sv' in json) {\r\n        var jsonLeaf = json;\r\n        return new LeafNode(jsonLeaf, nodeFromJSON$1(priority));\r\n    }\r\n    if (!(json instanceof Array) && USE_HINZE) {\r\n        var children_1 = [];\r\n        var childrenHavePriority_1 = false;\r\n        var hinzeJsonObj = json;\r\n        each(hinzeJsonObj, function (key, child) {\r\n            if (key.substring(0, 1) !== '.') {\r\n                // Ignore metadata nodes\r\n                var childNode = nodeFromJSON$1(child);\r\n                if (!childNode.isEmpty()) {\r\n                    childrenHavePriority_1 =\r\n                        childrenHavePriority_1 || !childNode.getPriority().isEmpty();\r\n                    children_1.push(new NamedNode(key, childNode));\r\n                }\r\n            }\r\n        });\r\n        if (children_1.length === 0) {\r\n            return ChildrenNode.EMPTY_NODE;\r\n        }\r\n        var childSet = buildChildSet(children_1, NAME_ONLY_COMPARATOR, function (namedNode) { return namedNode.name; }, NAME_COMPARATOR);\r\n        if (childrenHavePriority_1) {\r\n            var sortedChildSet = buildChildSet(children_1, PRIORITY_INDEX.getCompare());\r\n            return new ChildrenNode(childSet, nodeFromJSON$1(priority), new IndexMap({ '.priority': sortedChildSet }, { '.priority': PRIORITY_INDEX }));\r\n        }\r\n        else {\r\n            return new ChildrenNode(childSet, nodeFromJSON$1(priority), IndexMap.Default);\r\n        }\r\n    }\r\n    else {\r\n        var node_1 = ChildrenNode.EMPTY_NODE;\r\n        each(json, function (key, childData) {\r\n            if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(json, key)) {\r\n                if (key.substring(0, 1) !== '.') {\r\n                    // ignore metadata nodes.\r\n                    var childNode = nodeFromJSON$1(childData);\r\n                    if (childNode.isLeafNode() || !childNode.isEmpty()) {\r\n                        node_1 = node_1.updateImmediateChild(key, childNode);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        return node_1.updatePriority(nodeFromJSON$1(priority));\r\n    }\r\n}\r\nsetNodeFromJSON(nodeFromJSON$1);\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * @constructor\r\n * @extends {Index}\r\n * @private\r\n */\r\nvar ValueIndex = /** @class */ (function (_super) {\r\n    (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(ValueIndex, _super);\r\n    function ValueIndex() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    ValueIndex.prototype.compare = function (a, b) {\r\n        var indexCmp = a.node.compareTo(b.node);\r\n        if (indexCmp === 0) {\r\n            return nameCompare(a.name, b.name);\r\n        }\r\n        else {\r\n            return indexCmp;\r\n        }\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    ValueIndex.prototype.isDefinedOn = function (node) {\r\n        return true;\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    ValueIndex.prototype.indexedValueChanged = function (oldNode, newNode) {\r\n        return !oldNode.equals(newNode);\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    ValueIndex.prototype.minPost = function () {\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        return NamedNode.MIN;\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    ValueIndex.prototype.maxPost = function () {\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        return NamedNode.MAX;\r\n    };\r\n    /**\r\n     * @param {*} indexValue\r\n     * @param {string} name\r\n     * @return {!NamedNode}\r\n     */\r\n    ValueIndex.prototype.makePost = function (indexValue, name) {\r\n        var valueNode = nodeFromJSON$1(indexValue);\r\n        return new NamedNode(name, valueNode);\r\n    };\r\n    /**\r\n     * @return {!string} String representation for inclusion in a query spec\r\n     */\r\n    ValueIndex.prototype.toString = function () {\r\n        return '.value';\r\n    };\r\n    return ValueIndex;\r\n}(Index));\r\nvar VALUE_INDEX = new ValueIndex();\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * @param {!Path} indexPath\r\n * @constructor\r\n * @extends {Index}\r\n */\r\nvar PathIndex = /** @class */ (function (_super) {\r\n    (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(PathIndex, _super);\r\n    function PathIndex(indexPath_) {\r\n        var _this = _super.call(this) || this;\r\n        _this.indexPath_ = indexPath_;\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(!indexPath_.isEmpty() && indexPath_.getFront() !== '.priority', \"Can't create PathIndex with empty path or .priority key\");\r\n        return _this;\r\n    }\r\n    /**\r\n     * @param {!Node} snap\r\n     * @return {!Node}\r\n     * @protected\r\n     */\r\n    PathIndex.prototype.extractChild = function (snap) {\r\n        return snap.getChild(this.indexPath_);\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    PathIndex.prototype.isDefinedOn = function (node) {\r\n        return !node.getChild(this.indexPath_).isEmpty();\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    PathIndex.prototype.compare = function (a, b) {\r\n        var aChild = this.extractChild(a.node);\r\n        var bChild = this.extractChild(b.node);\r\n        var indexCmp = aChild.compareTo(bChild);\r\n        if (indexCmp === 0) {\r\n            return nameCompare(a.name, b.name);\r\n        }\r\n        else {\r\n            return indexCmp;\r\n        }\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    PathIndex.prototype.makePost = function (indexValue, name) {\r\n        var valueNode = nodeFromJSON$1(indexValue);\r\n        var node = ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_, valueNode);\r\n        return new NamedNode(name, node);\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    PathIndex.prototype.maxPost = function () {\r\n        var node = ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_, MAX_NODE$2);\r\n        return new NamedNode(MAX_NAME, node);\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    PathIndex.prototype.toString = function () {\r\n        return this.indexPath_.slice().join('/');\r\n    };\r\n    return PathIndex;\r\n}(Index));\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Class representing a firebase data snapshot.  It wraps a SnapshotNode and\r\n * surfaces the public methods (val, forEach, etc.) we want to expose.\r\n */\r\nvar DataSnapshot = /** @class */ (function () {\r\n    /**\r\n     * @param {!Node} node_ A SnapshotNode to wrap.\r\n     * @param {!Reference} ref_ The ref of the location this snapshot came from.\r\n     * @param {!Index} index_ The iteration order for this snapshot\r\n     */\r\n    function DataSnapshot(node_, ref_, index_) {\r\n        this.node_ = node_;\r\n        this.ref_ = ref_;\r\n        this.index_ = index_;\r\n    }\r\n    /**\r\n     * Retrieves the snapshot contents as JSON.  Returns null if the snapshot is\r\n     * empty.\r\n     *\r\n     * @return {*} JSON representation of the DataSnapshot contents, or null if empty.\r\n     */\r\n    DataSnapshot.prototype.val = function () {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('DataSnapshot.val', 0, 0, arguments.length);\r\n        return this.node_.val();\r\n    };\r\n    /**\r\n     * Returns the snapshot contents as JSON, including priorities of node.  Suitable for exporting\r\n     * the entire node contents.\r\n     * @return {*} JSON representation of the DataSnapshot contents, or null if empty.\r\n     */\r\n    DataSnapshot.prototype.exportVal = function () {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('DataSnapshot.exportVal', 0, 0, arguments.length);\r\n        return this.node_.val(true);\r\n    };\r\n    // Do not create public documentation. This is intended to make JSON serialization work but is otherwise unnecessary\r\n    // for end-users\r\n    DataSnapshot.prototype.toJSON = function () {\r\n        // Optional spacer argument is unnecessary because we're depending on recursion rather than stringifying the content\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('DataSnapshot.toJSON', 0, 1, arguments.length);\r\n        return this.exportVal();\r\n    };\r\n    /**\r\n     * Returns whether the snapshot contains a non-null value.\r\n     *\r\n     * @return {boolean} Whether the snapshot contains a non-null value, or is empty.\r\n     */\r\n    DataSnapshot.prototype.exists = function () {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('DataSnapshot.exists', 0, 0, arguments.length);\r\n        return !this.node_.isEmpty();\r\n    };\r\n    /**\r\n     * Returns a DataSnapshot of the specified child node's contents.\r\n     *\r\n     * @param {!string} childPathString Path to a child.\r\n     * @return {!DataSnapshot} DataSnapshot for child node.\r\n     */\r\n    DataSnapshot.prototype.child = function (childPathString) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('DataSnapshot.child', 0, 1, arguments.length);\r\n        // Ensure the childPath is a string (can be a number)\r\n        childPathString = String(childPathString);\r\n        validatePathString('DataSnapshot.child', 1, childPathString, false);\r\n        var childPath = new Path(childPathString);\r\n        var childRef = this.ref_.child(childPath);\r\n        return new DataSnapshot(this.node_.getChild(childPath), childRef, PRIORITY_INDEX);\r\n    };\r\n    /**\r\n     * Returns whether the snapshot contains a child at the specified path.\r\n     *\r\n     * @param {!string} childPathString Path to a child.\r\n     * @return {boolean} Whether the child exists.\r\n     */\r\n    DataSnapshot.prototype.hasChild = function (childPathString) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('DataSnapshot.hasChild', 1, 1, arguments.length);\r\n        validatePathString('DataSnapshot.hasChild', 1, childPathString, false);\r\n        var childPath = new Path(childPathString);\r\n        return !this.node_.getChild(childPath).isEmpty();\r\n    };\r\n    /**\r\n     * Returns the priority of the object, or null if no priority was set.\r\n     *\r\n     * @return {string|number|null} The priority.\r\n     */\r\n    DataSnapshot.prototype.getPriority = function () {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('DataSnapshot.getPriority', 0, 0, arguments.length);\r\n        // typecast here because we never return deferred values or internal priorities (MAX_PRIORITY)\r\n        return this.node_.getPriority().val();\r\n    };\r\n    /**\r\n     * Iterates through child nodes and calls the specified action for each one.\r\n     *\r\n     * @param {function(!DataSnapshot)} action Callback function to be called\r\n     * for each child.\r\n     * @return {boolean} True if forEach was canceled by action returning true for\r\n     * one of the child nodes.\r\n     */\r\n    DataSnapshot.prototype.forEach = function (action) {\r\n        var _this = this;\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('DataSnapshot.forEach', 1, 1, arguments.length);\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateCallback)('DataSnapshot.forEach', 1, action, false);\r\n        if (this.node_.isLeafNode()) {\r\n            return false;\r\n        }\r\n        var childrenNode = this.node_;\r\n        // Sanitize the return value to a boolean. ChildrenNode.forEachChild has a weird return type...\r\n        return !!childrenNode.forEachChild(this.index_, function (key, node) {\r\n            return action(new DataSnapshot(node, _this.ref_.child(key), PRIORITY_INDEX));\r\n        });\r\n    };\r\n    /**\r\n     * Returns whether this DataSnapshot has children.\r\n     * @return {boolean} True if the DataSnapshot contains 1 or more child nodes.\r\n     */\r\n    DataSnapshot.prototype.hasChildren = function () {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('DataSnapshot.hasChildren', 0, 0, arguments.length);\r\n        if (this.node_.isLeafNode()) {\r\n            return false;\r\n        }\r\n        else {\r\n            return !this.node_.isEmpty();\r\n        }\r\n    };\r\n    Object.defineProperty(DataSnapshot.prototype, \"key\", {\r\n        get: function () {\r\n            return this.ref_.getKey();\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Returns the number of children for this DataSnapshot.\r\n     * @return {number} The number of children that this DataSnapshot contains.\r\n     */\r\n    DataSnapshot.prototype.numChildren = function () {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('DataSnapshot.numChildren', 0, 0, arguments.length);\r\n        return this.node_.numChildren();\r\n    };\r\n    /**\r\n     * @return {Reference} The Firebase reference for the location this snapshot's data came from.\r\n     */\r\n    DataSnapshot.prototype.getRef = function () {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('DataSnapshot.ref', 0, 0, arguments.length);\r\n        return this.ref_;\r\n    };\r\n    Object.defineProperty(DataSnapshot.prototype, \"ref\", {\r\n        get: function () {\r\n            return this.getRef();\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    return DataSnapshot;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Encapsulates the data needed to raise an event\r\n * @implements {Event}\r\n */\r\nvar DataEvent = /** @class */ (function () {\r\n    /**\r\n     * @param {!string} eventType One of: value, child_added, child_changed, child_moved, child_removed\r\n     * @param {!EventRegistration} eventRegistration The function to call to with the event data. User provided\r\n     * @param {!DataSnapshot} snapshot The data backing the event\r\n     * @param {?string=} prevName Optional, the name of the previous child for child_* events.\r\n     */\r\n    function DataEvent(eventType, eventRegistration, snapshot, prevName) {\r\n        this.eventType = eventType;\r\n        this.eventRegistration = eventRegistration;\r\n        this.snapshot = snapshot;\r\n        this.prevName = prevName;\r\n    }\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    DataEvent.prototype.getPath = function () {\r\n        var ref = this.snapshot.getRef();\r\n        if (this.eventType === 'value') {\r\n            return ref.path;\r\n        }\r\n        else {\r\n            return ref.getParent().path;\r\n        }\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    DataEvent.prototype.getEventType = function () {\r\n        return this.eventType;\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    DataEvent.prototype.getEventRunner = function () {\r\n        return this.eventRegistration.getEventRunner(this);\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    DataEvent.prototype.toString = function () {\r\n        return (this.getPath().toString() +\r\n            ':' +\r\n            this.eventType +\r\n            ':' +\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(this.snapshot.exportVal()));\r\n    };\r\n    return DataEvent;\r\n}());\r\nvar CancelEvent = /** @class */ (function () {\r\n    /**\r\n     * @param {EventRegistration} eventRegistration\r\n     * @param {Error} error\r\n     * @param {!Path} path\r\n     */\r\n    function CancelEvent(eventRegistration, error, path) {\r\n        this.eventRegistration = eventRegistration;\r\n        this.error = error;\r\n        this.path = path;\r\n    }\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    CancelEvent.prototype.getPath = function () {\r\n        return this.path;\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    CancelEvent.prototype.getEventType = function () {\r\n        return 'cancel';\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    CancelEvent.prototype.getEventRunner = function () {\r\n        return this.eventRegistration.getEventRunner(this);\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    CancelEvent.prototype.toString = function () {\r\n        return this.path.toString() + ':cancel';\r\n    };\r\n    return CancelEvent;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Represents registration for 'value' events.\r\n */\r\nvar ValueEventRegistration = /** @class */ (function () {\r\n    /**\r\n     * @param {?function(!DataSnapshot)} callback_\r\n     * @param {?function(Error)} cancelCallback_\r\n     * @param {?Object} context_\r\n     */\r\n    function ValueEventRegistration(callback_, cancelCallback_, context_) {\r\n        this.callback_ = callback_;\r\n        this.cancelCallback_ = cancelCallback_;\r\n        this.context_ = context_;\r\n    }\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    ValueEventRegistration.prototype.respondsTo = function (eventType) {\r\n        return eventType === 'value';\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    ValueEventRegistration.prototype.createEvent = function (change, query) {\r\n        var index = query.getQueryParams().getIndex();\r\n        return new DataEvent('value', this, new DataSnapshot(change.snapshotNode, query.getRef(), index));\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    ValueEventRegistration.prototype.getEventRunner = function (eventData) {\r\n        var ctx = this.context_;\r\n        if (eventData.getEventType() === 'cancel') {\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.cancelCallback_, 'Raising a cancel event on a listener with no cancel callback');\r\n            var cancelCB_1 = this.cancelCallback_;\r\n            return function () {\r\n                // We know that error exists, we checked above that this is a cancel event\r\n                cancelCB_1.call(ctx, eventData.error);\r\n            };\r\n        }\r\n        else {\r\n            var cb_1 = this.callback_;\r\n            return function () {\r\n                cb_1.call(ctx, eventData.snapshot);\r\n            };\r\n        }\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    ValueEventRegistration.prototype.createCancelEvent = function (error, path) {\r\n        if (this.cancelCallback_) {\r\n            return new CancelEvent(this, error, path);\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    ValueEventRegistration.prototype.matches = function (other) {\r\n        if (!(other instanceof ValueEventRegistration)) {\r\n            return false;\r\n        }\r\n        else if (!other.callback_ || !this.callback_) {\r\n            // If no callback specified, we consider it to match any callback.\r\n            return true;\r\n        }\r\n        else {\r\n            return (other.callback_ === this.callback_ && other.context_ === this.context_);\r\n        }\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    ValueEventRegistration.prototype.hasAnyCallback = function () {\r\n        return this.callback_ !== null;\r\n    };\r\n    return ValueEventRegistration;\r\n}());\r\n/**\r\n * Represents the registration of 1 or more child_xxx events.\r\n *\r\n * Currently, it is always exactly 1 child_xxx event, but the idea is we might let you\r\n * register a group of callbacks together in the future.\r\n *\r\n * @constructor\r\n * @implements {EventRegistration}\r\n */\r\nvar ChildEventRegistration = /** @class */ (function () {\r\n    /**\r\n     * @param {?Object.<string, function(!DataSnapshot, ?string=)>} callbacks_\r\n     * @param {?function(Error)} cancelCallback_\r\n     * @param {Object=} context_\r\n     */\r\n    function ChildEventRegistration(callbacks_, cancelCallback_, context_) {\r\n        this.callbacks_ = callbacks_;\r\n        this.cancelCallback_ = cancelCallback_;\r\n        this.context_ = context_;\r\n    }\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    ChildEventRegistration.prototype.respondsTo = function (eventType) {\r\n        var eventToCheck = eventType === 'children_added' ? 'child_added' : eventType;\r\n        eventToCheck =\r\n            eventToCheck === 'children_removed' ? 'child_removed' : eventToCheck;\r\n        return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(this.callbacks_, eventToCheck);\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    ChildEventRegistration.prototype.createCancelEvent = function (error, path) {\r\n        if (this.cancelCallback_) {\r\n            return new CancelEvent(this, error, path);\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    ChildEventRegistration.prototype.createEvent = function (change, query) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(change.childName != null, 'Child events should have a childName.');\r\n        var ref = query.getRef().child(/** @type {!string} */ change.childName);\r\n        var index = query.getQueryParams().getIndex();\r\n        return new DataEvent(change.type, this, new DataSnapshot(change.snapshotNode, ref, index), change.prevName);\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    ChildEventRegistration.prototype.getEventRunner = function (eventData) {\r\n        var ctx = this.context_;\r\n        if (eventData.getEventType() === 'cancel') {\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.cancelCallback_, 'Raising a cancel event on a listener with no cancel callback');\r\n            var cancelCB_2 = this.cancelCallback_;\r\n            return function () {\r\n                // We know that error exists, we checked above that this is a cancel event\r\n                cancelCB_2.call(ctx, eventData.error);\r\n            };\r\n        }\r\n        else {\r\n            var cb_2 = this.callbacks_[eventData.eventType];\r\n            return function () {\r\n                cb_2.call(ctx, eventData.snapshot, eventData.prevName);\r\n            };\r\n        }\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    ChildEventRegistration.prototype.matches = function (other) {\r\n        var _this = this;\r\n        if (other instanceof ChildEventRegistration) {\r\n            if (!this.callbacks_ || !other.callbacks_) {\r\n                return true;\r\n            }\r\n            else if (this.context_ === other.context_) {\r\n                var otherKeys = Object.keys(other.callbacks_);\r\n                var thisKeys = Object.keys(this.callbacks_);\r\n                var otherCount = otherKeys.length;\r\n                var thisCount = thisKeys.length;\r\n                if (otherCount === thisCount) {\r\n                    // If count is 1, do an exact match on eventType, if either is defined but null, it's a match.\r\n                    // If event types don't match, not a match\r\n                    // If count is not 1, exact match across all\r\n                    if (otherCount === 1) {\r\n                        var otherKey = otherKeys[0];\r\n                        var thisKey = thisKeys[0];\r\n                        return (thisKey === otherKey &&\r\n                            (!other.callbacks_[otherKey] ||\r\n                                !this.callbacks_[thisKey] ||\r\n                                other.callbacks_[otherKey] === this.callbacks_[thisKey]));\r\n                    }\r\n                    else {\r\n                        // Exact match on each key.\r\n                        return thisKeys.every(function (eventType) {\r\n                            return other.callbacks_[eventType] === _this.callbacks_[eventType];\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    ChildEventRegistration.prototype.hasAnyCallback = function () {\r\n        return this.callbacks_ !== null;\r\n    };\r\n    return ChildEventRegistration;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar __referenceConstructor;\r\n/**\r\n * A Query represents a filter to be applied to a firebase location.  This object purely represents the\r\n * query expression (and exposes our public API to build the query).  The actual query logic is in ViewBase.js.\r\n *\r\n * Since every Firebase reference is a query, Firebase inherits from this object.\r\n */\r\nvar Query = /** @class */ (function () {\r\n    function Query(repo, path, queryParams_, orderByCalled_) {\r\n        this.repo = repo;\r\n        this.path = path;\r\n        this.queryParams_ = queryParams_;\r\n        this.orderByCalled_ = orderByCalled_;\r\n    }\r\n    Object.defineProperty(Query, \"__referenceConstructor\", {\r\n        get: function () {\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(__referenceConstructor, 'Reference.ts has not been loaded');\r\n            return __referenceConstructor;\r\n        },\r\n        set: function (val) {\r\n            __referenceConstructor = val;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Validates start/end values for queries.\r\n     * @param {!QueryParams} params\r\n     * @private\r\n     */\r\n    Query.validateQueryEndpoints_ = function (params) {\r\n        var startNode = null;\r\n        var endNode = null;\r\n        if (params.hasStart()) {\r\n            startNode = params.getIndexStartValue();\r\n        }\r\n        if (params.hasEnd()) {\r\n            endNode = params.getIndexEndValue();\r\n        }\r\n        if (params.getIndex() === KEY_INDEX) {\r\n            var tooManyArgsError = 'Query: When ordering by key, you may only pass one argument to ' +\r\n                'startAt(), endAt(), or equalTo().';\r\n            var wrongArgTypeError = 'Query: When ordering by key, the argument passed to startAt(), endAt(),' +\r\n                'or equalTo() must be a string.';\r\n            if (params.hasStart()) {\r\n                var startName = params.getIndexStartName();\r\n                if (startName !== MIN_NAME) {\r\n                    throw new Error(tooManyArgsError);\r\n                }\r\n                else if (typeof startNode !== 'string') {\r\n                    throw new Error(wrongArgTypeError);\r\n                }\r\n            }\r\n            if (params.hasEnd()) {\r\n                var endName = params.getIndexEndName();\r\n                if (endName !== MAX_NAME) {\r\n                    throw new Error(tooManyArgsError);\r\n                }\r\n                else if (typeof endNode !== 'string') {\r\n                    throw new Error(wrongArgTypeError);\r\n                }\r\n            }\r\n        }\r\n        else if (params.getIndex() === PRIORITY_INDEX) {\r\n            if ((startNode != null && !isValidPriority(startNode)) ||\r\n                (endNode != null && !isValidPriority(endNode))) {\r\n                throw new Error('Query: When ordering by priority, the first argument passed to startAt(), ' +\r\n                    'endAt(), or equalTo() must be a valid priority value (null, a number, or a string).');\r\n            }\r\n        }\r\n        else {\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(params.getIndex() instanceof PathIndex ||\r\n                params.getIndex() === VALUE_INDEX, 'unknown index type.');\r\n            if ((startNode != null && typeof startNode === 'object') ||\r\n                (endNode != null && typeof endNode === 'object')) {\r\n                throw new Error('Query: First argument passed to startAt(), endAt(), or equalTo() cannot be ' +\r\n                    'an object.');\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Validates that limit* has been called with the correct combination of parameters\r\n     * @param {!QueryParams} params\r\n     * @private\r\n     */\r\n    Query.validateLimit_ = function (params) {\r\n        if (params.hasStart() &&\r\n            params.hasEnd() &&\r\n            params.hasLimit() &&\r\n            !params.hasAnchoredLimit()) {\r\n            throw new Error(\"Query: Can't combine startAt(), endAt(), and limit(). Use limitToFirst() or limitToLast() instead.\");\r\n        }\r\n    };\r\n    /**\r\n     * Validates that no other order by call has been made\r\n     * @param {!string} fnName\r\n     * @private\r\n     */\r\n    Query.prototype.validateNoPreviousOrderByCall_ = function (fnName) {\r\n        if (this.orderByCalled_ === true) {\r\n            throw new Error(fnName + \": You can't combine multiple orderBy calls.\");\r\n        }\r\n    };\r\n    /**\r\n     * @return {!QueryParams}\r\n     */\r\n    Query.prototype.getQueryParams = function () {\r\n        return this.queryParams_;\r\n    };\r\n    /**\r\n     * @return {!Reference}\r\n     */\r\n    Query.prototype.getRef = function () {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('Query.ref', 0, 0, arguments.length);\r\n        // This is a slight hack. We cannot goog.require('fb.api.Firebase'), since Firebase requires fb.api.Query.\r\n        // However, we will always export 'Firebase' to the global namespace, so it's guaranteed to exist by the time this\r\n        // method gets called.\r\n        return new Query.__referenceConstructor(this.repo, this.path);\r\n    };\r\n    /**\r\n     * @param {!string} eventType\r\n     * @param {!function(DataSnapshot, string=)} callback\r\n     * @param {(function(Error)|Object)=} cancelCallbackOrContext\r\n     * @param {Object=} context\r\n     * @return {!function(DataSnapshot, string=)}\r\n     */\r\n    Query.prototype.on = function (eventType, callback, cancelCallbackOrContext, context) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('Query.on', 2, 4, arguments.length);\r\n        validateEventType('Query.on', 1, eventType, false);\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateCallback)('Query.on', 2, callback, false);\r\n        var ret = Query.getCancelAndContextArgs_('Query.on', cancelCallbackOrContext, context);\r\n        if (eventType === 'value') {\r\n            this.onValueEvent(callback, ret.cancel, ret.context);\r\n        }\r\n        else {\r\n            var callbacks = {};\r\n            callbacks[eventType] = callback;\r\n            this.onChildEvent(callbacks, ret.cancel, ret.context);\r\n        }\r\n        return callback;\r\n    };\r\n    /**\r\n     * @param {!function(!DataSnapshot)} callback\r\n     * @param {?function(Error)} cancelCallback\r\n     * @param {?Object} context\r\n     * @protected\r\n     */\r\n    Query.prototype.onValueEvent = function (callback, cancelCallback, context) {\r\n        var container = new ValueEventRegistration(callback, cancelCallback || null, context || null);\r\n        this.repo.addEventCallbackForQuery(this, container);\r\n    };\r\n    /**\r\n     * @param {!Object.<string, !function(!DataSnapshot, ?string)>} callbacks\r\n     * @param {?function(Error)} cancelCallback\r\n     * @param {?Object} context\r\n     * @protected\r\n     */\r\n    Query.prototype.onChildEvent = function (callbacks, cancelCallback, context) {\r\n        var container = new ChildEventRegistration(callbacks, cancelCallback, context);\r\n        this.repo.addEventCallbackForQuery(this, container);\r\n    };\r\n    /**\r\n     * @param {string=} eventType\r\n     * @param {(function(!DataSnapshot, ?string=))=} callback\r\n     * @param {Object=} context\r\n     */\r\n    Query.prototype.off = function (eventType, callback, context) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('Query.off', 0, 3, arguments.length);\r\n        validateEventType('Query.off', 1, eventType, true);\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateCallback)('Query.off', 2, callback, true);\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateContextObject)('Query.off', 3, context, true);\r\n        var container = null;\r\n        var callbacks = null;\r\n        if (eventType === 'value') {\r\n            var valueCallback = callback || null;\r\n            container = new ValueEventRegistration(valueCallback, null, context || null);\r\n        }\r\n        else if (eventType) {\r\n            if (callback) {\r\n                callbacks = {};\r\n                callbacks[eventType] = callback;\r\n            }\r\n            container = new ChildEventRegistration(callbacks, null, context || null);\r\n        }\r\n        this.repo.removeEventCallbackForQuery(this, container);\r\n    };\r\n    /**\r\n     * Attaches a listener, waits for the first event, and then removes the listener\r\n     * @param {!string} eventType\r\n     * @param {!function(!DataSnapshot, string=)} userCallback\r\n     * @param failureCallbackOrContext\r\n     * @param context\r\n     * @return {!firebase.Promise}\r\n     */\r\n    Query.prototype.once = function (eventType, userCallback, failureCallbackOrContext, context) {\r\n        var _this = this;\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('Query.once', 1, 4, arguments.length);\r\n        validateEventType('Query.once', 1, eventType, false);\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateCallback)('Query.once', 2, userCallback, true);\r\n        var ret = Query.getCancelAndContextArgs_('Query.once', failureCallbackOrContext, context);\r\n        // TODO: Implement this more efficiently (in particular, use 'get' wire protocol for 'value' event)\r\n        // TODO: consider actually wiring the callbacks into the promise. We cannot do this without a breaking change\r\n        // because the API currently expects callbacks will be called synchronously if the data is cached, but this is\r\n        // against the Promise specification.\r\n        var firstCall = true;\r\n        var deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();\r\n        // A dummy error handler in case a user wasn't expecting promises\r\n        deferred.promise.catch(function () { });\r\n        var onceCallback = function (snapshot) {\r\n            // NOTE: Even though we unsubscribe, we may get called multiple times if a single action (e.g. set() with JSON)\r\n            // triggers multiple events (e.g. child_added or child_changed).\r\n            if (firstCall) {\r\n                firstCall = false;\r\n                _this.off(eventType, onceCallback);\r\n                if (userCallback) {\r\n                    userCallback.bind(ret.context)(snapshot);\r\n                }\r\n                deferred.resolve(snapshot);\r\n            }\r\n        };\r\n        this.on(eventType, onceCallback, \r\n        /*cancel=*/ function (err) {\r\n            _this.off(eventType, onceCallback);\r\n            if (ret.cancel) {\r\n                ret.cancel.bind(ret.context)(err);\r\n            }\r\n            deferred.reject(err);\r\n        });\r\n        return deferred.promise;\r\n    };\r\n    /**\r\n     * Set a limit and anchor it to the start of the window.\r\n     * @param {!number} limit\r\n     * @return {!Query}\r\n     */\r\n    Query.prototype.limitToFirst = function (limit) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('Query.limitToFirst', 1, 1, arguments.length);\r\n        if (typeof limit !== 'number' ||\r\n            Math.floor(limit) !== limit ||\r\n            limit <= 0) {\r\n            throw new Error('Query.limitToFirst: First argument must be a positive integer.');\r\n        }\r\n        if (this.queryParams_.hasLimit()) {\r\n            throw new Error('Query.limitToFirst: Limit was already set (by another call to limit, ' +\r\n                'limitToFirst, or limitToLast).');\r\n        }\r\n        return new Query(this.repo, this.path, this.queryParams_.limitToFirst(limit), this.orderByCalled_);\r\n    };\r\n    /**\r\n     * Set a limit and anchor it to the end of the window.\r\n     * @param {!number} limit\r\n     * @return {!Query}\r\n     */\r\n    Query.prototype.limitToLast = function (limit) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('Query.limitToLast', 1, 1, arguments.length);\r\n        if (typeof limit !== 'number' ||\r\n            Math.floor(limit) !== limit ||\r\n            limit <= 0) {\r\n            throw new Error('Query.limitToLast: First argument must be a positive integer.');\r\n        }\r\n        if (this.queryParams_.hasLimit()) {\r\n            throw new Error('Query.limitToLast: Limit was already set (by another call to limit, ' +\r\n                'limitToFirst, or limitToLast).');\r\n        }\r\n        return new Query(this.repo, this.path, this.queryParams_.limitToLast(limit), this.orderByCalled_);\r\n    };\r\n    /**\r\n     * Given a child path, return a new query ordered by the specified grandchild path.\r\n     * @param {!string} path\r\n     * @return {!Query}\r\n     */\r\n    Query.prototype.orderByChild = function (path) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('Query.orderByChild', 1, 1, arguments.length);\r\n        if (path === '$key') {\r\n            throw new Error('Query.orderByChild: \"$key\" is invalid.  Use Query.orderByKey() instead.');\r\n        }\r\n        else if (path === '$priority') {\r\n            throw new Error('Query.orderByChild: \"$priority\" is invalid.  Use Query.orderByPriority() instead.');\r\n        }\r\n        else if (path === '$value') {\r\n            throw new Error('Query.orderByChild: \"$value\" is invalid.  Use Query.orderByValue() instead.');\r\n        }\r\n        validatePathString('Query.orderByChild', 1, path, false);\r\n        this.validateNoPreviousOrderByCall_('Query.orderByChild');\r\n        var parsedPath = new Path(path);\r\n        if (parsedPath.isEmpty()) {\r\n            throw new Error('Query.orderByChild: cannot pass in empty path.  Use Query.orderByValue() instead.');\r\n        }\r\n        var index = new PathIndex(parsedPath);\r\n        var newParams = this.queryParams_.orderBy(index);\r\n        Query.validateQueryEndpoints_(newParams);\r\n        return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);\r\n    };\r\n    /**\r\n     * Return a new query ordered by the KeyIndex\r\n     * @return {!Query}\r\n     */\r\n    Query.prototype.orderByKey = function () {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('Query.orderByKey', 0, 0, arguments.length);\r\n        this.validateNoPreviousOrderByCall_('Query.orderByKey');\r\n        var newParams = this.queryParams_.orderBy(KEY_INDEX);\r\n        Query.validateQueryEndpoints_(newParams);\r\n        return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);\r\n    };\r\n    /**\r\n     * Return a new query ordered by the PriorityIndex\r\n     * @return {!Query}\r\n     */\r\n    Query.prototype.orderByPriority = function () {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('Query.orderByPriority', 0, 0, arguments.length);\r\n        this.validateNoPreviousOrderByCall_('Query.orderByPriority');\r\n        var newParams = this.queryParams_.orderBy(PRIORITY_INDEX);\r\n        Query.validateQueryEndpoints_(newParams);\r\n        return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);\r\n    };\r\n    /**\r\n     * Return a new query ordered by the ValueIndex\r\n     * @return {!Query}\r\n     */\r\n    Query.prototype.orderByValue = function () {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('Query.orderByValue', 0, 0, arguments.length);\r\n        this.validateNoPreviousOrderByCall_('Query.orderByValue');\r\n        var newParams = this.queryParams_.orderBy(VALUE_INDEX);\r\n        Query.validateQueryEndpoints_(newParams);\r\n        return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);\r\n    };\r\n    /**\r\n     * @param {number|string|boolean|null} value\r\n     * @param {?string=} name\r\n     * @return {!Query}\r\n     */\r\n    Query.prototype.startAt = function (value, name) {\r\n        if (value === void 0) { value = null; }\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('Query.startAt', 0, 2, arguments.length);\r\n        validateFirebaseDataArg('Query.startAt', 1, value, this.path, true);\r\n        validateKey('Query.startAt', 2, name, true);\r\n        var newParams = this.queryParams_.startAt(value, name);\r\n        Query.validateLimit_(newParams);\r\n        Query.validateQueryEndpoints_(newParams);\r\n        if (this.queryParams_.hasStart()) {\r\n            throw new Error('Query.startAt: Starting point was already set (by another call to startAt ' +\r\n                'or equalTo).');\r\n        }\r\n        // Calling with no params tells us to start at the beginning.\r\n        if (value === undefined) {\r\n            value = null;\r\n            name = null;\r\n        }\r\n        return new Query(this.repo, this.path, newParams, this.orderByCalled_);\r\n    };\r\n    /**\r\n     * @param {number|string|boolean|null} value\r\n     * @param {?string=} name\r\n     * @return {!Query}\r\n     */\r\n    Query.prototype.endAt = function (value, name) {\r\n        if (value === void 0) { value = null; }\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('Query.endAt', 0, 2, arguments.length);\r\n        validateFirebaseDataArg('Query.endAt', 1, value, this.path, true);\r\n        validateKey('Query.endAt', 2, name, true);\r\n        var newParams = this.queryParams_.endAt(value, name);\r\n        Query.validateLimit_(newParams);\r\n        Query.validateQueryEndpoints_(newParams);\r\n        if (this.queryParams_.hasEnd()) {\r\n            throw new Error('Query.endAt: Ending point was already set (by another call to endAt or ' +\r\n                'equalTo).');\r\n        }\r\n        return new Query(this.repo, this.path, newParams, this.orderByCalled_);\r\n    };\r\n    /**\r\n     * Load the selection of children with exactly the specified value, and, optionally,\r\n     * the specified name.\r\n     * @param {number|string|boolean|null} value\r\n     * @param {string=} name\r\n     * @return {!Query}\r\n     */\r\n    Query.prototype.equalTo = function (value, name) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('Query.equalTo', 1, 2, arguments.length);\r\n        validateFirebaseDataArg('Query.equalTo', 1, value, this.path, false);\r\n        validateKey('Query.equalTo', 2, name, true);\r\n        if (this.queryParams_.hasStart()) {\r\n            throw new Error('Query.equalTo: Starting point was already set (by another call to startAt or ' +\r\n                'equalTo).');\r\n        }\r\n        if (this.queryParams_.hasEnd()) {\r\n            throw new Error('Query.equalTo: Ending point was already set (by another call to endAt or ' +\r\n                'equalTo).');\r\n        }\r\n        return this.startAt(value, name).endAt(value, name);\r\n    };\r\n    /**\r\n     * @return {!string} URL for this location.\r\n     */\r\n    Query.prototype.toString = function () {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('Query.toString', 0, 0, arguments.length);\r\n        return this.repo.toString() + this.path.toUrlEncodedString();\r\n    };\r\n    // Do not create public documentation. This is intended to make JSON serialization work but is otherwise unnecessary\r\n    // for end-users.\r\n    Query.prototype.toJSON = function () {\r\n        // An optional spacer argument is unnecessary for a string.\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('Query.toJSON', 0, 1, arguments.length);\r\n        return this.toString();\r\n    };\r\n    /**\r\n     * An object representation of the query parameters used by this Query.\r\n     * @return {!Object}\r\n     */\r\n    Query.prototype.queryObject = function () {\r\n        return this.queryParams_.getQueryObject();\r\n    };\r\n    /**\r\n     * @return {!string}\r\n     */\r\n    Query.prototype.queryIdentifier = function () {\r\n        var obj = this.queryObject();\r\n        var id = ObjectToUniqueKey(obj);\r\n        return id === '{}' ? 'default' : id;\r\n    };\r\n    /**\r\n     * Return true if this query and the provided query are equivalent; otherwise, return false.\r\n     * @param {Query} other\r\n     * @return {boolean}\r\n     */\r\n    Query.prototype.isEqual = function (other) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('Query.isEqual', 1, 1, arguments.length);\r\n        if (!(other instanceof Query)) {\r\n            var error = 'Query.isEqual failed: First argument must be an instance of firebase.database.Query.';\r\n            throw new Error(error);\r\n        }\r\n        var sameRepo = this.repo === other.repo;\r\n        var samePath = this.path.equals(other.path);\r\n        var sameQueryIdentifier = this.queryIdentifier() === other.queryIdentifier();\r\n        return sameRepo && samePath && sameQueryIdentifier;\r\n    };\r\n    /**\r\n     * Helper used by .on and .once to extract the context and or cancel arguments.\r\n     * @param {!string} fnName The function name (on or once)\r\n     * @param {(function(Error)|Object)=} cancelOrContext\r\n     * @param {Object=} context\r\n     * @return {{cancel: ?function(Error), context: ?Object}}\r\n     * @private\r\n     */\r\n    Query.getCancelAndContextArgs_ = function (fnName, cancelOrContext, context) {\r\n        var ret = { cancel: null, context: null };\r\n        if (cancelOrContext && context) {\r\n            ret.cancel = cancelOrContext;\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateCallback)(fnName, 3, ret.cancel, true);\r\n            ret.context = context;\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateContextObject)(fnName, 4, ret.context, true);\r\n        }\r\n        else if (cancelOrContext) {\r\n            // we have either a cancel callback or a context.\r\n            if (typeof cancelOrContext === 'object' && cancelOrContext !== null) {\r\n                // it's a context!\r\n                ret.context = cancelOrContext;\r\n            }\r\n            else if (typeof cancelOrContext === 'function') {\r\n                ret.cancel = cancelOrContext;\r\n            }\r\n            else {\r\n                throw new Error((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.errorPrefix)(fnName, 3, true) +\r\n                    ' must either be a cancel callback or a context object.');\r\n            }\r\n        }\r\n        return ret;\r\n    };\r\n    Object.defineProperty(Query.prototype, \"ref\", {\r\n        get: function () {\r\n            return this.getRef();\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    return Query;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar ExistingValueProvider = /** @class */ (function () {\r\n    function ExistingValueProvider(node_) {\r\n        this.node_ = node_;\r\n    }\r\n    ExistingValueProvider.prototype.getImmediateChild = function (childName) {\r\n        var child = this.node_.getImmediateChild(childName);\r\n        return new ExistingValueProvider(child);\r\n    };\r\n    ExistingValueProvider.prototype.node = function () {\r\n        return this.node_;\r\n    };\r\n    return ExistingValueProvider;\r\n}());\r\nvar DeferredValueProvider = /** @class */ (function () {\r\n    function DeferredValueProvider(syncTree, path) {\r\n        this.syncTree_ = syncTree;\r\n        this.path_ = path;\r\n    }\r\n    DeferredValueProvider.prototype.getImmediateChild = function (childName) {\r\n        var childPath = this.path_.child(childName);\r\n        return new DeferredValueProvider(this.syncTree_, childPath);\r\n    };\r\n    DeferredValueProvider.prototype.node = function () {\r\n        return this.syncTree_.calcCompleteEventCache(this.path_);\r\n    };\r\n    return DeferredValueProvider;\r\n}());\r\n/**\r\n * Generate placeholders for deferred values.\r\n * @param {?Object} values\r\n * @return {!Object}\r\n */\r\nvar generateWithValues = function (values) {\r\n    values = values || {};\r\n    values['timestamp'] = values['timestamp'] || new Date().getTime();\r\n    return values;\r\n};\r\n/**\r\n * Value to use when firing local events. When writing server values, fire\r\n * local events with an approximate value, otherwise return value as-is.\r\n * @param {(Object|string|number|boolean)} value\r\n * @param {!Object} serverValues\r\n * @return {!(string|number|boolean)}\r\n */\r\nvar resolveDeferredLeafValue = function (value, existingVal, serverValues) {\r\n    if (!value || typeof value !== 'object') {\r\n        return value;\r\n    }\r\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)('.sv' in value, 'Unexpected leaf node or priority contents');\r\n    if (typeof value['.sv'] === 'string') {\r\n        return resolveScalarDeferredValue(value['.sv'], existingVal, serverValues);\r\n    }\r\n    else if (typeof value['.sv'] === 'object') {\r\n        return resolveComplexDeferredValue(value['.sv'], existingVal);\r\n    }\r\n    else {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(false, 'Unexpected server value: ' + JSON.stringify(value, null, 2));\r\n    }\r\n};\r\nvar resolveScalarDeferredValue = function (op, existing, serverValues) {\r\n    switch (op) {\r\n        case 'timestamp':\r\n            return serverValues['timestamp'];\r\n        default:\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(false, 'Unexpected server value: ' + op);\r\n    }\r\n};\r\nvar resolveComplexDeferredValue = function (op, existing, unused) {\r\n    if (!op.hasOwnProperty('increment')) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(false, 'Unexpected server value: ' + JSON.stringify(op, null, 2));\r\n    }\r\n    var delta = op['increment'];\r\n    if (typeof delta !== 'number') {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(false, 'Unexpected increment value: ' + delta);\r\n    }\r\n    var existingNode = existing.node();\r\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(existingNode !== null && typeof existingNode !== 'undefined', 'Expected ChildrenNode.EMPTY_NODE for nulls');\r\n    // Incrementing a non-number sets the value to the incremented amount\r\n    if (!existingNode.isLeafNode()) {\r\n        return delta;\r\n    }\r\n    var leaf = existingNode;\r\n    var existingVal = leaf.getValue();\r\n    if (typeof existingVal !== 'number') {\r\n        return delta;\r\n    }\r\n    // No need to do over/underflow arithmetic here because JS only handles floats under the covers\r\n    return existingVal + delta;\r\n};\r\n/**\r\n * Recursively replace all deferred values and priorities in the tree with the\r\n * specified generated replacement values.\r\n * @param {!Path} path path to which write is relative\r\n * @param {!Node} node new data written at path\r\n * @param {!SyncTree} syncTree current data\r\n * @param {!Object} serverValues\r\n * @return {!SparseSnapshotTree}\r\n */\r\nvar resolveDeferredValueTree = function (path, node, syncTree, serverValues) {\r\n    return resolveDeferredValue(node, new DeferredValueProvider(syncTree, path), serverValues);\r\n};\r\n/**\r\n * Recursively replace all deferred values and priorities in the node with the\r\n * specified generated replacement values.  If there are no server values in the node,\r\n * it'll be returned as-is.\r\n * @param {!Node} node\r\n * @param {!Object} serverValues\r\n * @return {!Node}\r\n */\r\nvar resolveDeferredValueSnapshot = function (node, existing, serverValues) {\r\n    return resolveDeferredValue(node, new ExistingValueProvider(existing), serverValues);\r\n};\r\nfunction resolveDeferredValue(node, existingVal, serverValues) {\r\n    var rawPri = node.getPriority().val();\r\n    var priority = resolveDeferredLeafValue(rawPri, existingVal.getImmediateChild('.priority'), serverValues);\r\n    var newNode;\r\n    if (node.isLeafNode()) {\r\n        var leafNode = node;\r\n        var value = resolveDeferredLeafValue(leafNode.getValue(), existingVal, serverValues);\r\n        if (value !== leafNode.getValue() ||\r\n            priority !== leafNode.getPriority().val()) {\r\n            return new LeafNode(value, nodeFromJSON$1(priority));\r\n        }\r\n        else {\r\n            return node;\r\n        }\r\n    }\r\n    else {\r\n        var childrenNode = node;\r\n        newNode = childrenNode;\r\n        if (priority !== childrenNode.getPriority().val()) {\r\n            newNode = newNode.updatePriority(new LeafNode(priority));\r\n        }\r\n        childrenNode.forEachChild(PRIORITY_INDEX, function (childName, childNode) {\r\n            var newChildNode = resolveDeferredValue(childNode, existingVal.getImmediateChild(childName), serverValues);\r\n            if (newChildNode !== childNode) {\r\n                newNode = newNode.updateImmediateChild(childName, newChildNode);\r\n            }\r\n        });\r\n        return newNode;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Helper class to store a sparse set of snapshots.\r\n */\r\nvar SparseSnapshotTree = /** @class */ (function () {\r\n    function SparseSnapshotTree() {\r\n        this.value = null;\r\n        this.children = new Map();\r\n    }\r\n    /**\r\n     * Gets the node stored at the given path if one exists.\r\n     *\r\n     * @param path Path to look up snapshot for.\r\n     * @return The retrieved node, or null.\r\n     */\r\n    SparseSnapshotTree.prototype.find = function (path) {\r\n        if (this.value != null) {\r\n            return this.value.getChild(path);\r\n        }\r\n        else if (!path.isEmpty() && this.children.size > 0) {\r\n            var childKey = path.getFront();\r\n            path = path.popFront();\r\n            if (this.children.has(childKey)) {\r\n                var childTree = this.children.get(childKey);\r\n                return childTree.find(path);\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    };\r\n    /**\r\n     * Stores the given node at the specified path. If there is already a node\r\n     * at a shallower path, it merges the new data into that snapshot node.\r\n     *\r\n     * @param path Path to look up snapshot for.\r\n     * @param data The new data, or null.\r\n     */\r\n    SparseSnapshotTree.prototype.remember = function (path, data) {\r\n        if (path.isEmpty()) {\r\n            this.value = data;\r\n            this.children.clear();\r\n        }\r\n        else if (this.value !== null) {\r\n            this.value = this.value.updateChild(path, data);\r\n        }\r\n        else {\r\n            var childKey = path.getFront();\r\n            if (!this.children.has(childKey)) {\r\n                this.children.set(childKey, new SparseSnapshotTree());\r\n            }\r\n            var child = this.children.get(childKey);\r\n            path = path.popFront();\r\n            child.remember(path, data);\r\n        }\r\n    };\r\n    /**\r\n     * Purge the data at path from the cache.\r\n     *\r\n     * @param path Path to look up snapshot for.\r\n     * @return True if this node should now be removed.\r\n     */\r\n    SparseSnapshotTree.prototype.forget = function (path) {\r\n        if (path.isEmpty()) {\r\n            this.value = null;\r\n            this.children.clear();\r\n            return true;\r\n        }\r\n        else {\r\n            if (this.value !== null) {\r\n                if (this.value.isLeafNode()) {\r\n                    // We're trying to forget a node that doesn't exist\r\n                    return false;\r\n                }\r\n                else {\r\n                    var value = this.value;\r\n                    this.value = null;\r\n                    var self_1 = this;\r\n                    value.forEachChild(PRIORITY_INDEX, function (key, tree) {\r\n                        self_1.remember(new Path(key), tree);\r\n                    });\r\n                    return this.forget(path);\r\n                }\r\n            }\r\n            else if (this.children.size > 0) {\r\n                var childKey = path.getFront();\r\n                path = path.popFront();\r\n                if (this.children.has(childKey)) {\r\n                    var safeToRemove = this.children.get(childKey).forget(path);\r\n                    if (safeToRemove) {\r\n                        this.children.delete(childKey);\r\n                    }\r\n                }\r\n                return this.children.size === 0;\r\n            }\r\n            else {\r\n                return true;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Recursively iterates through all of the stored tree and calls the\r\n     * callback on each one.\r\n     *\r\n     * @param prefixPath Path to look up node for.\r\n     * @param func The function to invoke for each tree.\r\n     */\r\n    SparseSnapshotTree.prototype.forEachTree = function (prefixPath, func) {\r\n        if (this.value !== null) {\r\n            func(prefixPath, this.value);\r\n        }\r\n        else {\r\n            this.forEachChild(function (key, tree) {\r\n                var path = new Path(prefixPath.toString() + '/' + key);\r\n                tree.forEachTree(path, func);\r\n            });\r\n        }\r\n    };\r\n    /**\r\n     * Iterates through each immediate child and triggers the callback.\r\n     *\r\n     * @param func The function to invoke for each child.\r\n     */\r\n    SparseSnapshotTree.prototype.forEachChild = function (func) {\r\n        this.children.forEach(function (tree, key) {\r\n            func(key, tree);\r\n        });\r\n    };\r\n    return SparseSnapshotTree;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n *\r\n * @enum\r\n */\r\nvar OperationType;\r\n(function (OperationType) {\r\n    OperationType[OperationType[\"OVERWRITE\"] = 0] = \"OVERWRITE\";\r\n    OperationType[OperationType[\"MERGE\"] = 1] = \"MERGE\";\r\n    OperationType[OperationType[\"ACK_USER_WRITE\"] = 2] = \"ACK_USER_WRITE\";\r\n    OperationType[OperationType[\"LISTEN_COMPLETE\"] = 3] = \"LISTEN_COMPLETE\";\r\n})(OperationType || (OperationType = {}));\r\n/**\r\n * @param {boolean} fromUser\r\n * @param {boolean} fromServer\r\n * @param {?string} queryId\r\n * @param {boolean} tagged\r\n * @constructor\r\n */\r\nvar OperationSource = /** @class */ (function () {\r\n    function OperationSource(fromUser, fromServer, queryId, tagged) {\r\n        this.fromUser = fromUser;\r\n        this.fromServer = fromServer;\r\n        this.queryId = queryId;\r\n        this.tagged = tagged;\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(!tagged || fromServer, 'Tagged queries must be from server.');\r\n    }\r\n    /**\r\n     * @const\r\n     * @type {!OperationSource}\r\n     */\r\n    OperationSource.User = new OperationSource(\r\n    /*fromUser=*/ true, false, null, \r\n    /*tagged=*/ false);\r\n    /**\r\n     * @const\r\n     * @type {!OperationSource}\r\n     */\r\n    OperationSource.Server = new OperationSource(false, \r\n    /*fromServer=*/ true, null, \r\n    /*tagged=*/ false);\r\n    /**\r\n     * @param {string} queryId\r\n     * @return {!OperationSource}\r\n     */\r\n    OperationSource.forServerTaggedQuery = function (queryId) {\r\n        return new OperationSource(false, \r\n        /*fromServer=*/ true, queryId, \r\n        /*tagged=*/ true);\r\n    };\r\n    return OperationSource;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar AckUserWrite = /** @class */ (function () {\r\n    /**\r\n     *\r\n     * @param {!Path} path\r\n     * @param {!ImmutableTree<!boolean>} affectedTree A tree containing true for each affected path. Affected paths can't overlap.\r\n     * @param {!boolean} revert\r\n     */\r\n    function AckUserWrite(\r\n    /** @inheritDoc */ path, \r\n    /** @inheritDoc */ affectedTree, \r\n    /** @inheritDoc */ revert) {\r\n        this.path = path;\r\n        this.affectedTree = affectedTree;\r\n        this.revert = revert;\r\n        /** @inheritDoc */\r\n        this.type = OperationType.ACK_USER_WRITE;\r\n        /** @inheritDoc */\r\n        this.source = OperationSource.User;\r\n    }\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    AckUserWrite.prototype.operationForChild = function (childName) {\r\n        if (!this.path.isEmpty()) {\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.path.getFront() === childName, 'operationForChild called for unrelated child.');\r\n            return new AckUserWrite(this.path.popFront(), this.affectedTree, this.revert);\r\n        }\r\n        else if (this.affectedTree.value != null) {\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.affectedTree.children.isEmpty(), 'affectedTree should not have overlapping affected paths.');\r\n            // All child locations are affected as well; just return same operation.\r\n            return this;\r\n        }\r\n        else {\r\n            var childTree = this.affectedTree.subtree(new Path(childName));\r\n            return new AckUserWrite(Path.Empty, childTree, this.revert);\r\n        }\r\n    };\r\n    return AckUserWrite;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar emptyChildrenSingleton;\r\n/**\r\n * Singleton empty children collection.\r\n *\r\n * @const\r\n * @type {!SortedMap.<string, !ImmutableTree.<?>>}\r\n */\r\nvar EmptyChildren = function () {\r\n    if (!emptyChildrenSingleton) {\r\n        emptyChildrenSingleton = new SortedMap(stringCompare);\r\n    }\r\n    return emptyChildrenSingleton;\r\n};\r\n/**\r\n * A tree with immutable elements.\r\n */\r\nvar ImmutableTree = /** @class */ (function () {\r\n    /**\r\n     * @template T\r\n     * @param {?T} value\r\n     * @param {SortedMap.<string, !ImmutableTree.<T>>=} children\r\n     */\r\n    function ImmutableTree(value, children) {\r\n        if (children === void 0) { children = EmptyChildren(); }\r\n        this.value = value;\r\n        this.children = children;\r\n    }\r\n    /**\r\n     * @template T\r\n     * @param {!Object.<string, !T>} obj\r\n     * @return {!ImmutableTree.<!T>}\r\n     */\r\n    ImmutableTree.fromObject = function (obj) {\r\n        var tree = ImmutableTree.Empty;\r\n        each(obj, function (childPath, childSnap) {\r\n            tree = tree.set(new Path(childPath), childSnap);\r\n        });\r\n        return tree;\r\n    };\r\n    /**\r\n     * True if the value is empty and there are no children\r\n     * @return {boolean}\r\n     */\r\n    ImmutableTree.prototype.isEmpty = function () {\r\n        return this.value === null && this.children.isEmpty();\r\n    };\r\n    /**\r\n     * Given a path and predicate, return the first node and the path to that node\r\n     * where the predicate returns true.\r\n     *\r\n     * TODO Do a perf test -- If we're creating a bunch of {path: value:} objects\r\n     * on the way back out, it may be better to pass down a pathSoFar obj.\r\n     *\r\n     * @param {!Path} relativePath The remainder of the path\r\n     * @param {function(T):boolean} predicate The predicate to satisfy to return a\r\n     *   node\r\n     * @return {?{path:!Path, value:!T}}\r\n     */\r\n    ImmutableTree.prototype.findRootMostMatchingPathAndValue = function (relativePath, predicate) {\r\n        if (this.value != null && predicate(this.value)) {\r\n            return { path: Path.Empty, value: this.value };\r\n        }\r\n        else {\r\n            if (relativePath.isEmpty()) {\r\n                return null;\r\n            }\r\n            else {\r\n                var front = relativePath.getFront();\r\n                var child = this.children.get(front);\r\n                if (child !== null) {\r\n                    var childExistingPathAndValue = child.findRootMostMatchingPathAndValue(relativePath.popFront(), predicate);\r\n                    if (childExistingPathAndValue != null) {\r\n                        var fullPath = new Path(front).child(childExistingPathAndValue.path);\r\n                        return { path: fullPath, value: childExistingPathAndValue.value };\r\n                    }\r\n                    else {\r\n                        return null;\r\n                    }\r\n                }\r\n                else {\r\n                    return null;\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Find, if it exists, the shortest subpath of the given path that points a defined\r\n     * value in the tree\r\n     * @param {!Path} relativePath\r\n     * @return {?{path: !Path, value: !T}}\r\n     */\r\n    ImmutableTree.prototype.findRootMostValueAndPath = function (relativePath) {\r\n        return this.findRootMostMatchingPathAndValue(relativePath, function () { return true; });\r\n    };\r\n    /**\r\n     * @param {!Path} relativePath\r\n     * @return {!ImmutableTree.<T>} The subtree at the given path\r\n     */\r\n    ImmutableTree.prototype.subtree = function (relativePath) {\r\n        if (relativePath.isEmpty()) {\r\n            return this;\r\n        }\r\n        else {\r\n            var front = relativePath.getFront();\r\n            var childTree = this.children.get(front);\r\n            if (childTree !== null) {\r\n                return childTree.subtree(relativePath.popFront());\r\n            }\r\n            else {\r\n                return ImmutableTree.Empty;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Sets a value at the specified path.\r\n     *\r\n     * @param {!Path} relativePath Path to set value at.\r\n     * @param {?T} toSet Value to set.\r\n     * @return {!ImmutableTree.<T>} Resulting tree.\r\n     */\r\n    ImmutableTree.prototype.set = function (relativePath, toSet) {\r\n        if (relativePath.isEmpty()) {\r\n            return new ImmutableTree(toSet, this.children);\r\n        }\r\n        else {\r\n            var front = relativePath.getFront();\r\n            var child = this.children.get(front) || ImmutableTree.Empty;\r\n            var newChild = child.set(relativePath.popFront(), toSet);\r\n            var newChildren = this.children.insert(front, newChild);\r\n            return new ImmutableTree(this.value, newChildren);\r\n        }\r\n    };\r\n    /**\r\n     * Removes the value at the specified path.\r\n     *\r\n     * @param {!Path} relativePath Path to value to remove.\r\n     * @return {!ImmutableTree.<T>} Resulting tree.\r\n     */\r\n    ImmutableTree.prototype.remove = function (relativePath) {\r\n        if (relativePath.isEmpty()) {\r\n            if (this.children.isEmpty()) {\r\n                return ImmutableTree.Empty;\r\n            }\r\n            else {\r\n                return new ImmutableTree(null, this.children);\r\n            }\r\n        }\r\n        else {\r\n            var front = relativePath.getFront();\r\n            var child = this.children.get(front);\r\n            if (child) {\r\n                var newChild = child.remove(relativePath.popFront());\r\n                var newChildren = void 0;\r\n                if (newChild.isEmpty()) {\r\n                    newChildren = this.children.remove(front);\r\n                }\r\n                else {\r\n                    newChildren = this.children.insert(front, newChild);\r\n                }\r\n                if (this.value === null && newChildren.isEmpty()) {\r\n                    return ImmutableTree.Empty;\r\n                }\r\n                else {\r\n                    return new ImmutableTree(this.value, newChildren);\r\n                }\r\n            }\r\n            else {\r\n                return this;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Gets a value from the tree.\r\n     *\r\n     * @param {!Path} relativePath Path to get value for.\r\n     * @return {?T} Value at path, or null.\r\n     */\r\n    ImmutableTree.prototype.get = function (relativePath) {\r\n        if (relativePath.isEmpty()) {\r\n            return this.value;\r\n        }\r\n        else {\r\n            var front = relativePath.getFront();\r\n            var child = this.children.get(front);\r\n            if (child) {\r\n                return child.get(relativePath.popFront());\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Replace the subtree at the specified path with the given new tree.\r\n     *\r\n     * @param {!Path} relativePath Path to replace subtree for.\r\n     * @param {!ImmutableTree} newTree New tree.\r\n     * @return {!ImmutableTree} Resulting tree.\r\n     */\r\n    ImmutableTree.prototype.setTree = function (relativePath, newTree) {\r\n        if (relativePath.isEmpty()) {\r\n            return newTree;\r\n        }\r\n        else {\r\n            var front = relativePath.getFront();\r\n            var child = this.children.get(front) || ImmutableTree.Empty;\r\n            var newChild = child.setTree(relativePath.popFront(), newTree);\r\n            var newChildren = void 0;\r\n            if (newChild.isEmpty()) {\r\n                newChildren = this.children.remove(front);\r\n            }\r\n            else {\r\n                newChildren = this.children.insert(front, newChild);\r\n            }\r\n            return new ImmutableTree(this.value, newChildren);\r\n        }\r\n    };\r\n    /**\r\n     * Performs a depth first fold on this tree. Transforms a tree into a single\r\n     * value, given a function that operates on the path to a node, an optional\r\n     * current value, and a map of child names to folded subtrees\r\n     * @template V\r\n     * @param {function(Path, ?T, Object.<string, V>):V} fn\r\n     * @return {V}\r\n     */\r\n    ImmutableTree.prototype.fold = function (fn) {\r\n        return this.fold_(Path.Empty, fn);\r\n    };\r\n    /**\r\n     * Recursive helper for public-facing fold() method\r\n     * @template V\r\n     * @param {!Path} pathSoFar\r\n     * @param {function(Path, ?T, Object.<string, V>):V} fn\r\n     * @return {V}\r\n     * @private\r\n     */\r\n    ImmutableTree.prototype.fold_ = function (pathSoFar, fn) {\r\n        var accum = {};\r\n        this.children.inorderTraversal(function (childKey, childTree) {\r\n            accum[childKey] = childTree.fold_(pathSoFar.child(childKey), fn);\r\n        });\r\n        return fn(pathSoFar, this.value, accum);\r\n    };\r\n    /**\r\n     * Find the first matching value on the given path. Return the result of applying f to it.\r\n     * @template V\r\n     * @param {!Path} path\r\n     * @param {!function(!Path, !T):?V} f\r\n     * @return {?V}\r\n     */\r\n    ImmutableTree.prototype.findOnPath = function (path, f) {\r\n        return this.findOnPath_(path, Path.Empty, f);\r\n    };\r\n    ImmutableTree.prototype.findOnPath_ = function (pathToFollow, pathSoFar, f) {\r\n        var result = this.value ? f(pathSoFar, this.value) : false;\r\n        if (result) {\r\n            return result;\r\n        }\r\n        else {\r\n            if (pathToFollow.isEmpty()) {\r\n                return null;\r\n            }\r\n            else {\r\n                var front = pathToFollow.getFront();\r\n                var nextChild = this.children.get(front);\r\n                if (nextChild) {\r\n                    return nextChild.findOnPath_(pathToFollow.popFront(), pathSoFar.child(front), f);\r\n                }\r\n                else {\r\n                    return null;\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     *\r\n     * @param {!Path} path\r\n     * @param {!function(!Path, !T)} f\r\n     * @returns {!ImmutableTree.<T>}\r\n     */\r\n    ImmutableTree.prototype.foreachOnPath = function (path, f) {\r\n        return this.foreachOnPath_(path, Path.Empty, f);\r\n    };\r\n    ImmutableTree.prototype.foreachOnPath_ = function (pathToFollow, currentRelativePath, f) {\r\n        if (pathToFollow.isEmpty()) {\r\n            return this;\r\n        }\r\n        else {\r\n            if (this.value) {\r\n                f(currentRelativePath, this.value);\r\n            }\r\n            var front = pathToFollow.getFront();\r\n            var nextChild = this.children.get(front);\r\n            if (nextChild) {\r\n                return nextChild.foreachOnPath_(pathToFollow.popFront(), currentRelativePath.child(front), f);\r\n            }\r\n            else {\r\n                return ImmutableTree.Empty;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Calls the given function for each node in the tree that has a value.\r\n     *\r\n     * @param {function(!Path, !T)} f A function to be called with\r\n     *   the path from the root of the tree to a node, and the value at that node.\r\n     *   Called in depth-first order.\r\n     */\r\n    ImmutableTree.prototype.foreach = function (f) {\r\n        this.foreach_(Path.Empty, f);\r\n    };\r\n    ImmutableTree.prototype.foreach_ = function (currentRelativePath, f) {\r\n        this.children.inorderTraversal(function (childName, childTree) {\r\n            childTree.foreach_(currentRelativePath.child(childName), f);\r\n        });\r\n        if (this.value) {\r\n            f(currentRelativePath, this.value);\r\n        }\r\n    };\r\n    /**\r\n     *\r\n     * @param {function(string, !T)} f\r\n     */\r\n    ImmutableTree.prototype.foreachChild = function (f) {\r\n        this.children.inorderTraversal(function (childName, childTree) {\r\n            if (childTree.value) {\r\n                f(childName, childTree.value);\r\n            }\r\n        });\r\n    };\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    ImmutableTree.Empty = new ImmutableTree(null);\r\n    return ImmutableTree;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * @param {!OperationSource} source\r\n * @param {!Path} path\r\n * @constructor\r\n * @implements {Operation}\r\n */\r\nvar ListenComplete = /** @class */ (function () {\r\n    function ListenComplete(source, path) {\r\n        this.source = source;\r\n        this.path = path;\r\n        /** @inheritDoc */\r\n        this.type = OperationType.LISTEN_COMPLETE;\r\n    }\r\n    ListenComplete.prototype.operationForChild = function (childName) {\r\n        if (this.path.isEmpty()) {\r\n            return new ListenComplete(this.source, Path.Empty);\r\n        }\r\n        else {\r\n            return new ListenComplete(this.source, this.path.popFront());\r\n        }\r\n    };\r\n    return ListenComplete;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * @param {!OperationSource} source\r\n * @param {!Path} path\r\n * @param {!Node} snap\r\n * @constructor\r\n * @implements {Operation}\r\n */\r\nvar Overwrite = /** @class */ (function () {\r\n    function Overwrite(source, path, snap) {\r\n        this.source = source;\r\n        this.path = path;\r\n        this.snap = snap;\r\n        /** @inheritDoc */\r\n        this.type = OperationType.OVERWRITE;\r\n    }\r\n    Overwrite.prototype.operationForChild = function (childName) {\r\n        if (this.path.isEmpty()) {\r\n            return new Overwrite(this.source, Path.Empty, this.snap.getImmediateChild(childName));\r\n        }\r\n        else {\r\n            return new Overwrite(this.source, this.path.popFront(), this.snap);\r\n        }\r\n    };\r\n    return Overwrite;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * @param {!OperationSource} source\r\n * @param {!Path} path\r\n * @param {!ImmutableTree.<!Node>} children\r\n * @constructor\r\n * @implements {Operation}\r\n */\r\nvar Merge = /** @class */ (function () {\r\n    function Merge(\r\n    /** @inheritDoc */ source, \r\n    /** @inheritDoc */ path, \r\n    /** @inheritDoc */ children) {\r\n        this.source = source;\r\n        this.path = path;\r\n        this.children = children;\r\n        /** @inheritDoc */\r\n        this.type = OperationType.MERGE;\r\n    }\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    Merge.prototype.operationForChild = function (childName) {\r\n        if (this.path.isEmpty()) {\r\n            var childTree = this.children.subtree(new Path(childName));\r\n            if (childTree.isEmpty()) {\r\n                // This child is unaffected\r\n                return null;\r\n            }\r\n            else if (childTree.value) {\r\n                // We have a snapshot for the child in question.  This becomes an overwrite of the child.\r\n                return new Overwrite(this.source, Path.Empty, childTree.value);\r\n            }\r\n            else {\r\n                // This is a merge at a deeper level\r\n                return new Merge(this.source, Path.Empty, childTree);\r\n            }\r\n        }\r\n        else {\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.path.getFront() === childName, \"Can't get a merge for a child not on the path of the operation\");\r\n            return new Merge(this.source, this.path.popFront(), this.children);\r\n        }\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    Merge.prototype.toString = function () {\r\n        return ('Operation(' +\r\n            this.path +\r\n            ': ' +\r\n            this.source.toString() +\r\n            ' merge: ' +\r\n            this.children.toString() +\r\n            ')');\r\n    };\r\n    return Merge;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A cache node only stores complete children. Additionally it holds a flag whether the node can be considered fully\r\n * initialized in the sense that we know at one point in time this represented a valid state of the world, e.g.\r\n * initialized with data from the server, or a complete overwrite by the client. The filtered flag also tracks\r\n * whether a node potentially had children removed due to a filter.\r\n */\r\nvar CacheNode = /** @class */ (function () {\r\n    /**\r\n     * @param {!Node} node_\r\n     * @param {boolean} fullyInitialized_\r\n     * @param {boolean} filtered_\r\n     */\r\n    function CacheNode(node_, fullyInitialized_, filtered_) {\r\n        this.node_ = node_;\r\n        this.fullyInitialized_ = fullyInitialized_;\r\n        this.filtered_ = filtered_;\r\n    }\r\n    /**\r\n     * Returns whether this node was fully initialized with either server data or a complete overwrite by the client\r\n     * @return {boolean}\r\n     */\r\n    CacheNode.prototype.isFullyInitialized = function () {\r\n        return this.fullyInitialized_;\r\n    };\r\n    /**\r\n     * Returns whether this node is potentially missing children due to a filter applied to the node\r\n     * @return {boolean}\r\n     */\r\n    CacheNode.prototype.isFiltered = function () {\r\n        return this.filtered_;\r\n    };\r\n    /**\r\n     * @param {!Path} path\r\n     * @return {boolean}\r\n     */\r\n    CacheNode.prototype.isCompleteForPath = function (path) {\r\n        if (path.isEmpty()) {\r\n            return this.isFullyInitialized() && !this.filtered_;\r\n        }\r\n        var childKey = path.getFront();\r\n        return this.isCompleteForChild(childKey);\r\n    };\r\n    /**\r\n     * @param {!string} key\r\n     * @return {boolean}\r\n     */\r\n    CacheNode.prototype.isCompleteForChild = function (key) {\r\n        return ((this.isFullyInitialized() && !this.filtered_) || this.node_.hasChild(key));\r\n    };\r\n    /**\r\n     * @return {!Node}\r\n     */\r\n    CacheNode.prototype.getNode = function () {\r\n        return this.node_;\r\n    };\r\n    return CacheNode;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Stores the data we have cached for a view.\r\n *\r\n * serverSnap is the cached server data, eventSnap is the cached event data (server data plus any local writes).\r\n *\r\n * @constructor\r\n */\r\nvar ViewCache = /** @class */ (function () {\r\n    /**\r\n     *\r\n     * @param {!CacheNode} eventCache_\r\n     * @param {!CacheNode} serverCache_\r\n     */\r\n    function ViewCache(eventCache_, serverCache_) {\r\n        this.eventCache_ = eventCache_;\r\n        this.serverCache_ = serverCache_;\r\n    }\r\n    /**\r\n     * @param {!Node} eventSnap\r\n     * @param {boolean} complete\r\n     * @param {boolean} filtered\r\n     * @return {!ViewCache}\r\n     */\r\n    ViewCache.prototype.updateEventSnap = function (eventSnap, complete, filtered) {\r\n        return new ViewCache(new CacheNode(eventSnap, complete, filtered), this.serverCache_);\r\n    };\r\n    /**\r\n     * @param {!Node} serverSnap\r\n     * @param {boolean} complete\r\n     * @param {boolean} filtered\r\n     * @return {!ViewCache}\r\n     */\r\n    ViewCache.prototype.updateServerSnap = function (serverSnap, complete, filtered) {\r\n        return new ViewCache(this.eventCache_, new CacheNode(serverSnap, complete, filtered));\r\n    };\r\n    /**\r\n     * @return {!CacheNode}\r\n     */\r\n    ViewCache.prototype.getEventCache = function () {\r\n        return this.eventCache_;\r\n    };\r\n    /**\r\n     * @return {?Node}\r\n     */\r\n    ViewCache.prototype.getCompleteEventSnap = function () {\r\n        return this.eventCache_.isFullyInitialized()\r\n            ? this.eventCache_.getNode()\r\n            : null;\r\n    };\r\n    /**\r\n     * @return {!CacheNode}\r\n     */\r\n    ViewCache.prototype.getServerCache = function () {\r\n        return this.serverCache_;\r\n    };\r\n    /**\r\n     * @return {?Node}\r\n     */\r\n    ViewCache.prototype.getCompleteServerSnap = function () {\r\n        return this.serverCache_.isFullyInitialized()\r\n            ? this.serverCache_.getNode()\r\n            : null;\r\n    };\r\n    /**\r\n     * @const\r\n     * @type {ViewCache}\r\n     */\r\n    ViewCache.Empty = new ViewCache(new CacheNode(ChildrenNode.EMPTY_NODE, \r\n    /*fullyInitialized=*/ false, \r\n    /*filtered=*/ false), new CacheNode(ChildrenNode.EMPTY_NODE, \r\n    /*fullyInitialized=*/ false, \r\n    /*filtered=*/ false));\r\n    return ViewCache;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * @constructor\r\n * @struct\r\n * @param {!string} type The event type\r\n * @param {!Node} snapshotNode The data\r\n * @param {string=} childName The name for this child, if it's a child event\r\n * @param {Node=} oldSnap Used for intermediate processing of child changed events\r\n * @param {string=} prevName The name for the previous child, if applicable\r\n */\r\nvar Change = /** @class */ (function () {\r\n    function Change(type, snapshotNode, childName, oldSnap, prevName) {\r\n        this.type = type;\r\n        this.snapshotNode = snapshotNode;\r\n        this.childName = childName;\r\n        this.oldSnap = oldSnap;\r\n        this.prevName = prevName;\r\n    }\r\n    /**\r\n     * @param {!Node} snapshot\r\n     * @return {!Change}\r\n     */\r\n    Change.valueChange = function (snapshot) {\r\n        return new Change(Change.VALUE, snapshot);\r\n    };\r\n    /**\r\n     * @param {string} childKey\r\n     * @param {!Node} snapshot\r\n     * @return {!Change}\r\n     */\r\n    Change.childAddedChange = function (childKey, snapshot) {\r\n        return new Change(Change.CHILD_ADDED, snapshot, childKey);\r\n    };\r\n    /**\r\n     * @param {string} childKey\r\n     * @param {!Node} snapshot\r\n     * @return {!Change}\r\n     */\r\n    Change.childRemovedChange = function (childKey, snapshot) {\r\n        return new Change(Change.CHILD_REMOVED, snapshot, childKey);\r\n    };\r\n    /**\r\n     * @param {string} childKey\r\n     * @param {!Node} newSnapshot\r\n     * @param {!Node} oldSnapshot\r\n     * @return {!Change}\r\n     */\r\n    Change.childChangedChange = function (childKey, newSnapshot, oldSnapshot) {\r\n        return new Change(Change.CHILD_CHANGED, newSnapshot, childKey, oldSnapshot);\r\n    };\r\n    /**\r\n     * @param {string} childKey\r\n     * @param {!Node} snapshot\r\n     * @return {!Change}\r\n     */\r\n    Change.childMovedChange = function (childKey, snapshot) {\r\n        return new Change(Change.CHILD_MOVED, snapshot, childKey);\r\n    };\r\n    //event types\r\n    /** Event type for a child added */\r\n    Change.CHILD_ADDED = 'child_added';\r\n    /** Event type for a child removed */\r\n    Change.CHILD_REMOVED = 'child_removed';\r\n    /** Event type for a child changed */\r\n    Change.CHILD_CHANGED = 'child_changed';\r\n    /** Event type for a child moved */\r\n    Change.CHILD_MOVED = 'child_moved';\r\n    /** Event type for a value change */\r\n    Change.VALUE = 'value';\r\n    return Change;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Doesn't really filter nodes but applies an index to the node and keeps track of any changes\r\n *\r\n * @constructor\r\n * @implements {NodeFilter}\r\n * @param {!Index} index\r\n */\r\nvar IndexedFilter = /** @class */ (function () {\r\n    function IndexedFilter(index_) {\r\n        this.index_ = index_;\r\n    }\r\n    IndexedFilter.prototype.updateChild = function (snap, key, newChild, affectedPath, source, optChangeAccumulator) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(snap.isIndexed(this.index_), 'A node must be indexed if only a child is updated');\r\n        var oldChild = snap.getImmediateChild(key);\r\n        // Check if anything actually changed.\r\n        if (oldChild.getChild(affectedPath).equals(newChild.getChild(affectedPath))) {\r\n            // There's an edge case where a child can enter or leave the view because affectedPath was set to null.\r\n            // In this case, affectedPath will appear null in both the old and new snapshots.  So we need\r\n            // to avoid treating these cases as \"nothing changed.\"\r\n            if (oldChild.isEmpty() === newChild.isEmpty()) {\r\n                // Nothing changed.\r\n                // This assert should be valid, but it's expensive (can dominate perf testing) so don't actually do it.\r\n                //assert(oldChild.equals(newChild), 'Old and new snapshots should be equal.');\r\n                return snap;\r\n            }\r\n        }\r\n        if (optChangeAccumulator != null) {\r\n            if (newChild.isEmpty()) {\r\n                if (snap.hasChild(key)) {\r\n                    optChangeAccumulator.trackChildChange(Change.childRemovedChange(key, oldChild));\r\n                }\r\n                else {\r\n                    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(snap.isLeafNode(), 'A child remove without an old child only makes sense on a leaf node');\r\n                }\r\n            }\r\n            else if (oldChild.isEmpty()) {\r\n                optChangeAccumulator.trackChildChange(Change.childAddedChange(key, newChild));\r\n            }\r\n            else {\r\n                optChangeAccumulator.trackChildChange(Change.childChangedChange(key, newChild, oldChild));\r\n            }\r\n        }\r\n        if (snap.isLeafNode() && newChild.isEmpty()) {\r\n            return snap;\r\n        }\r\n        else {\r\n            // Make sure the node is indexed\r\n            return snap.updateImmediateChild(key, newChild).withIndex(this.index_);\r\n        }\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    IndexedFilter.prototype.updateFullNode = function (oldSnap, newSnap, optChangeAccumulator) {\r\n        if (optChangeAccumulator != null) {\r\n            if (!oldSnap.isLeafNode()) {\r\n                oldSnap.forEachChild(PRIORITY_INDEX, function (key, childNode) {\r\n                    if (!newSnap.hasChild(key)) {\r\n                        optChangeAccumulator.trackChildChange(Change.childRemovedChange(key, childNode));\r\n                    }\r\n                });\r\n            }\r\n            if (!newSnap.isLeafNode()) {\r\n                newSnap.forEachChild(PRIORITY_INDEX, function (key, childNode) {\r\n                    if (oldSnap.hasChild(key)) {\r\n                        var oldChild = oldSnap.getImmediateChild(key);\r\n                        if (!oldChild.equals(childNode)) {\r\n                            optChangeAccumulator.trackChildChange(Change.childChangedChange(key, childNode, oldChild));\r\n                        }\r\n                    }\r\n                    else {\r\n                        optChangeAccumulator.trackChildChange(Change.childAddedChange(key, childNode));\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        return newSnap.withIndex(this.index_);\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    IndexedFilter.prototype.updatePriority = function (oldSnap, newPriority) {\r\n        if (oldSnap.isEmpty()) {\r\n            return ChildrenNode.EMPTY_NODE;\r\n        }\r\n        else {\r\n            return oldSnap.updatePriority(newPriority);\r\n        }\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    IndexedFilter.prototype.filtersNodes = function () {\r\n        return false;\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    IndexedFilter.prototype.getIndexedFilter = function () {\r\n        return this;\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    IndexedFilter.prototype.getIndex = function () {\r\n        return this.index_;\r\n    };\r\n    return IndexedFilter;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar ChildChangeAccumulator = /** @class */ (function () {\r\n    function ChildChangeAccumulator() {\r\n        this.changeMap = new Map();\r\n    }\r\n    ChildChangeAccumulator.prototype.trackChildChange = function (change) {\r\n        var type = change.type;\r\n        var childKey = change.childName;\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(type === Change.CHILD_ADDED ||\r\n            type === Change.CHILD_CHANGED ||\r\n            type === Change.CHILD_REMOVED, 'Only child changes supported for tracking');\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(childKey !== '.priority', 'Only non-priority child changes can be tracked.');\r\n        var oldChange = this.changeMap.get(childKey);\r\n        if (oldChange) {\r\n            var oldType = oldChange.type;\r\n            if (type === Change.CHILD_ADDED && oldType === Change.CHILD_REMOVED) {\r\n                this.changeMap.set(childKey, Change.childChangedChange(childKey, change.snapshotNode, oldChange.snapshotNode));\r\n            }\r\n            else if (type === Change.CHILD_REMOVED &&\r\n                oldType === Change.CHILD_ADDED) {\r\n                this.changeMap.delete(childKey);\r\n            }\r\n            else if (type === Change.CHILD_REMOVED &&\r\n                oldType === Change.CHILD_CHANGED) {\r\n                this.changeMap.set(childKey, Change.childRemovedChange(childKey, oldChange.oldSnap));\r\n            }\r\n            else if (type === Change.CHILD_CHANGED &&\r\n                oldType === Change.CHILD_ADDED) {\r\n                this.changeMap.set(childKey, Change.childAddedChange(childKey, change.snapshotNode));\r\n            }\r\n            else if (type === Change.CHILD_CHANGED &&\r\n                oldType === Change.CHILD_CHANGED) {\r\n                this.changeMap.set(childKey, Change.childChangedChange(childKey, change.snapshotNode, oldChange.oldSnap));\r\n            }\r\n            else {\r\n                throw (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assertionError)('Illegal combination of changes: ' +\r\n                    change +\r\n                    ' occurred after ' +\r\n                    oldChange);\r\n            }\r\n        }\r\n        else {\r\n            this.changeMap.set(childKey, change);\r\n        }\r\n    };\r\n    ChildChangeAccumulator.prototype.getChanges = function () {\r\n        return Array.from(this.changeMap.values());\r\n    };\r\n    return ChildChangeAccumulator;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An implementation of CompleteChildSource that never returns any additional children\r\n *\r\n * @private\r\n * @constructor\r\n * @implements CompleteChildSource\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nvar NoCompleteChildSource_ = /** @class */ (function () {\r\n    function NoCompleteChildSource_() {\r\n    }\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    NoCompleteChildSource_.prototype.getCompleteChild = function (childKey) {\r\n        return null;\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    NoCompleteChildSource_.prototype.getChildAfterChild = function (index, child, reverse) {\r\n        return null;\r\n    };\r\n    return NoCompleteChildSource_;\r\n}());\r\n/**\r\n * Singleton instance.\r\n * @const\r\n * @type {!CompleteChildSource}\r\n */\r\nvar NO_COMPLETE_CHILD_SOURCE = new NoCompleteChildSource_();\r\n/**\r\n * An implementation of CompleteChildSource that uses a WriteTree in addition to any other server data or\r\n * old event caches available to calculate complete children.\r\n *\r\n *\r\n * @implements CompleteChildSource\r\n */\r\nvar WriteTreeCompleteChildSource = /** @class */ (function () {\r\n    /**\r\n     * @param {!WriteTreeRef} writes_\r\n     * @param {!ViewCache} viewCache_\r\n     * @param {?Node} optCompleteServerCache_\r\n     */\r\n    function WriteTreeCompleteChildSource(writes_, viewCache_, optCompleteServerCache_) {\r\n        if (optCompleteServerCache_ === void 0) { optCompleteServerCache_ = null; }\r\n        this.writes_ = writes_;\r\n        this.viewCache_ = viewCache_;\r\n        this.optCompleteServerCache_ = optCompleteServerCache_;\r\n    }\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    WriteTreeCompleteChildSource.prototype.getCompleteChild = function (childKey) {\r\n        var node = this.viewCache_.getEventCache();\r\n        if (node.isCompleteForChild(childKey)) {\r\n            return node.getNode().getImmediateChild(childKey);\r\n        }\r\n        else {\r\n            var serverNode = this.optCompleteServerCache_ != null\r\n                ? new CacheNode(this.optCompleteServerCache_, true, false)\r\n                : this.viewCache_.getServerCache();\r\n            return this.writes_.calcCompleteChild(childKey, serverNode);\r\n        }\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    WriteTreeCompleteChildSource.prototype.getChildAfterChild = function (index, child, reverse) {\r\n        var completeServerData = this.optCompleteServerCache_ != null\r\n            ? this.optCompleteServerCache_\r\n            : this.viewCache_.getCompleteServerSnap();\r\n        var nodes = this.writes_.calcIndexedSlice(completeServerData, child, 1, reverse, index);\r\n        if (nodes.length === 0) {\r\n            return null;\r\n        }\r\n        else {\r\n            return nodes[0];\r\n        }\r\n    };\r\n    return WriteTreeCompleteChildSource;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * @constructor\r\n * @struct\r\n */\r\nvar ProcessorResult = /** @class */ (function () {\r\n    /**\r\n     * @param {!ViewCache} viewCache\r\n     * @param {!Array.<!Change>} changes\r\n     */\r\n    function ProcessorResult(viewCache, changes) {\r\n        this.viewCache = viewCache;\r\n        this.changes = changes;\r\n    }\r\n    return ProcessorResult;\r\n}());\r\n/**\r\n * @constructor\r\n */\r\nvar ViewProcessor = /** @class */ (function () {\r\n    /**\r\n     * @param {!NodeFilter} filter_\r\n     */\r\n    function ViewProcessor(filter_) {\r\n        this.filter_ = filter_;\r\n    }\r\n    /**\r\n     * @param {!ViewCache} viewCache\r\n     */\r\n    ViewProcessor.prototype.assertIndexed = function (viewCache) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(viewCache.getEventCache().getNode().isIndexed(this.filter_.getIndex()), 'Event snap not indexed');\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(viewCache.getServerCache().getNode().isIndexed(this.filter_.getIndex()), 'Server snap not indexed');\r\n    };\r\n    /**\r\n     * @param {!ViewCache} oldViewCache\r\n     * @param {!Operation} operation\r\n     * @param {!WriteTreeRef} writesCache\r\n     * @param {?Node} completeCache\r\n     * @return {!ProcessorResult}\r\n     */\r\n    ViewProcessor.prototype.applyOperation = function (oldViewCache, operation, writesCache, completeCache) {\r\n        var accumulator = new ChildChangeAccumulator();\r\n        var newViewCache, filterServerNode;\r\n        if (operation.type === OperationType.OVERWRITE) {\r\n            var overwrite = operation;\r\n            if (overwrite.source.fromUser) {\r\n                newViewCache = this.applyUserOverwrite_(oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, accumulator);\r\n            }\r\n            else {\r\n                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(overwrite.source.fromServer, 'Unknown source.');\r\n                // We filter the node if it's a tagged update or the node has been previously filtered  and the\r\n                // update is not at the root in which case it is ok (and necessary) to mark the node unfiltered\r\n                // again\r\n                filterServerNode =\r\n                    overwrite.source.tagged ||\r\n                        (oldViewCache.getServerCache().isFiltered() &&\r\n                            !overwrite.path.isEmpty());\r\n                newViewCache = this.applyServerOverwrite_(oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, filterServerNode, accumulator);\r\n            }\r\n        }\r\n        else if (operation.type === OperationType.MERGE) {\r\n            var merge = operation;\r\n            if (merge.source.fromUser) {\r\n                newViewCache = this.applyUserMerge_(oldViewCache, merge.path, merge.children, writesCache, completeCache, accumulator);\r\n            }\r\n            else {\r\n                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(merge.source.fromServer, 'Unknown source.');\r\n                // We filter the node if it's a tagged update or the node has been previously filtered\r\n                filterServerNode =\r\n                    merge.source.tagged || oldViewCache.getServerCache().isFiltered();\r\n                newViewCache = this.applyServerMerge_(oldViewCache, merge.path, merge.children, writesCache, completeCache, filterServerNode, accumulator);\r\n            }\r\n        }\r\n        else if (operation.type === OperationType.ACK_USER_WRITE) {\r\n            var ackUserWrite = operation;\r\n            if (!ackUserWrite.revert) {\r\n                newViewCache = this.ackUserWrite_(oldViewCache, ackUserWrite.path, ackUserWrite.affectedTree, writesCache, completeCache, accumulator);\r\n            }\r\n            else {\r\n                newViewCache = this.revertUserWrite_(oldViewCache, ackUserWrite.path, writesCache, completeCache, accumulator);\r\n            }\r\n        }\r\n        else if (operation.type === OperationType.LISTEN_COMPLETE) {\r\n            newViewCache = this.listenComplete_(oldViewCache, operation.path, writesCache, accumulator);\r\n        }\r\n        else {\r\n            throw (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assertionError)('Unknown operation type: ' + operation.type);\r\n        }\r\n        var changes = accumulator.getChanges();\r\n        ViewProcessor.maybeAddValueEvent_(oldViewCache, newViewCache, changes);\r\n        return new ProcessorResult(newViewCache, changes);\r\n    };\r\n    /**\r\n     * @param {!ViewCache} oldViewCache\r\n     * @param {!ViewCache} newViewCache\r\n     * @param {!Array.<!Change>} accumulator\r\n     * @private\r\n     */\r\n    ViewProcessor.maybeAddValueEvent_ = function (oldViewCache, newViewCache, accumulator) {\r\n        var eventSnap = newViewCache.getEventCache();\r\n        if (eventSnap.isFullyInitialized()) {\r\n            var isLeafOrEmpty = eventSnap.getNode().isLeafNode() || eventSnap.getNode().isEmpty();\r\n            var oldCompleteSnap = oldViewCache.getCompleteEventSnap();\r\n            if (accumulator.length > 0 ||\r\n                !oldViewCache.getEventCache().isFullyInitialized() ||\r\n                (isLeafOrEmpty &&\r\n                    !eventSnap.getNode().equals(/** @type {!Node} */ oldCompleteSnap)) ||\r\n                !eventSnap.getNode().getPriority().equals(oldCompleteSnap.getPriority())) {\r\n                accumulator.push(Change.valueChange(\r\n                /** @type {!Node} */ newViewCache.getCompleteEventSnap()));\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * @param {!ViewCache} viewCache\r\n     * @param {!Path} changePath\r\n     * @param {!WriteTreeRef} writesCache\r\n     * @param {!CompleteChildSource} source\r\n     * @param {!ChildChangeAccumulator} accumulator\r\n     * @return {!ViewCache}\r\n     * @private\r\n     */\r\n    ViewProcessor.prototype.generateEventCacheAfterServerEvent_ = function (viewCache, changePath, writesCache, source, accumulator) {\r\n        var oldEventSnap = viewCache.getEventCache();\r\n        if (writesCache.shadowingWrite(changePath) != null) {\r\n            // we have a shadowing write, ignore changes\r\n            return viewCache;\r\n        }\r\n        else {\r\n            var newEventCache = void 0, serverNode = void 0;\r\n            if (changePath.isEmpty()) {\r\n                // TODO: figure out how this plays with \"sliding ack windows\"\r\n                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(viewCache.getServerCache().isFullyInitialized(), 'If change path is empty, we must have complete server data');\r\n                if (viewCache.getServerCache().isFiltered()) {\r\n                    // We need to special case this, because we need to only apply writes to complete children, or\r\n                    // we might end up raising events for incomplete children. If the server data is filtered deep\r\n                    // writes cannot be guaranteed to be complete\r\n                    var serverCache = viewCache.getCompleteServerSnap();\r\n                    var completeChildren = serverCache instanceof ChildrenNode\r\n                        ? serverCache\r\n                        : ChildrenNode.EMPTY_NODE;\r\n                    var completeEventChildren = writesCache.calcCompleteEventChildren(completeChildren);\r\n                    newEventCache = this.filter_.updateFullNode(viewCache.getEventCache().getNode(), completeEventChildren, accumulator);\r\n                }\r\n                else {\r\n                    var completeNode = writesCache.calcCompleteEventCache(viewCache.getCompleteServerSnap());\r\n                    newEventCache = this.filter_.updateFullNode(viewCache.getEventCache().getNode(), completeNode, accumulator);\r\n                }\r\n            }\r\n            else {\r\n                var childKey = changePath.getFront();\r\n                if (childKey === '.priority') {\r\n                    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(changePath.getLength() === 1, \"Can't have a priority with additional path components\");\r\n                    var oldEventNode = oldEventSnap.getNode();\r\n                    serverNode = viewCache.getServerCache().getNode();\r\n                    // we might have overwrites for this priority\r\n                    var updatedPriority = writesCache.calcEventCacheAfterServerOverwrite(changePath, oldEventNode, serverNode);\r\n                    if (updatedPriority != null) {\r\n                        newEventCache = this.filter_.updatePriority(oldEventNode, updatedPriority);\r\n                    }\r\n                    else {\r\n                        // priority didn't change, keep old node\r\n                        newEventCache = oldEventSnap.getNode();\r\n                    }\r\n                }\r\n                else {\r\n                    var childChangePath = changePath.popFront();\r\n                    // update child\r\n                    var newEventChild = void 0;\r\n                    if (oldEventSnap.isCompleteForChild(childKey)) {\r\n                        serverNode = viewCache.getServerCache().getNode();\r\n                        var eventChildUpdate = writesCache.calcEventCacheAfterServerOverwrite(changePath, oldEventSnap.getNode(), serverNode);\r\n                        if (eventChildUpdate != null) {\r\n                            newEventChild = oldEventSnap\r\n                                .getNode()\r\n                                .getImmediateChild(childKey)\r\n                                .updateChild(childChangePath, eventChildUpdate);\r\n                        }\r\n                        else {\r\n                            // Nothing changed, just keep the old child\r\n                            newEventChild = oldEventSnap\r\n                                .getNode()\r\n                                .getImmediateChild(childKey);\r\n                        }\r\n                    }\r\n                    else {\r\n                        newEventChild = writesCache.calcCompleteChild(childKey, viewCache.getServerCache());\r\n                    }\r\n                    if (newEventChild != null) {\r\n                        newEventCache = this.filter_.updateChild(oldEventSnap.getNode(), childKey, newEventChild, childChangePath, source, accumulator);\r\n                    }\r\n                    else {\r\n                        // no complete child available or no change\r\n                        newEventCache = oldEventSnap.getNode();\r\n                    }\r\n                }\r\n            }\r\n            return viewCache.updateEventSnap(newEventCache, oldEventSnap.isFullyInitialized() || changePath.isEmpty(), this.filter_.filtersNodes());\r\n        }\r\n    };\r\n    /**\r\n     * @param {!ViewCache} oldViewCache\r\n     * @param {!Path} changePath\r\n     * @param {!Node} changedSnap\r\n     * @param {!WriteTreeRef} writesCache\r\n     * @param {?Node} completeCache\r\n     * @param {boolean} filterServerNode\r\n     * @param {!ChildChangeAccumulator} accumulator\r\n     * @return {!ViewCache}\r\n     * @private\r\n     */\r\n    ViewProcessor.prototype.applyServerOverwrite_ = function (oldViewCache, changePath, changedSnap, writesCache, completeCache, filterServerNode, accumulator) {\r\n        var oldServerSnap = oldViewCache.getServerCache();\r\n        var newServerCache;\r\n        var serverFilter = filterServerNode\r\n            ? this.filter_\r\n            : this.filter_.getIndexedFilter();\r\n        if (changePath.isEmpty()) {\r\n            newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), changedSnap, null);\r\n        }\r\n        else if (serverFilter.filtersNodes() && !oldServerSnap.isFiltered()) {\r\n            // we want to filter the server node, but we didn't filter the server node yet, so simulate a full update\r\n            var newServerNode = oldServerSnap\r\n                .getNode()\r\n                .updateChild(changePath, changedSnap);\r\n            newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), newServerNode, null);\r\n        }\r\n        else {\r\n            var childKey = changePath.getFront();\r\n            if (!oldServerSnap.isCompleteForPath(changePath) &&\r\n                changePath.getLength() > 1) {\r\n                // We don't update incomplete nodes with updates intended for other listeners\r\n                return oldViewCache;\r\n            }\r\n            var childChangePath = changePath.popFront();\r\n            var childNode = oldServerSnap.getNode().getImmediateChild(childKey);\r\n            var newChildNode = childNode.updateChild(childChangePath, changedSnap);\r\n            if (childKey === '.priority') {\r\n                newServerCache = serverFilter.updatePriority(oldServerSnap.getNode(), newChildNode);\r\n            }\r\n            else {\r\n                newServerCache = serverFilter.updateChild(oldServerSnap.getNode(), childKey, newChildNode, childChangePath, NO_COMPLETE_CHILD_SOURCE, null);\r\n            }\r\n        }\r\n        var newViewCache = oldViewCache.updateServerSnap(newServerCache, oldServerSnap.isFullyInitialized() || changePath.isEmpty(), serverFilter.filtersNodes());\r\n        var source = new WriteTreeCompleteChildSource(writesCache, newViewCache, completeCache);\r\n        return this.generateEventCacheAfterServerEvent_(newViewCache, changePath, writesCache, source, accumulator);\r\n    };\r\n    /**\r\n     * @param {!ViewCache} oldViewCache\r\n     * @param {!Path} changePath\r\n     * @param {!Node} changedSnap\r\n     * @param {!WriteTreeRef} writesCache\r\n     * @param {?Node} completeCache\r\n     * @param {!ChildChangeAccumulator} accumulator\r\n     * @return {!ViewCache}\r\n     * @private\r\n     */\r\n    ViewProcessor.prototype.applyUserOverwrite_ = function (oldViewCache, changePath, changedSnap, writesCache, completeCache, accumulator) {\r\n        var oldEventSnap = oldViewCache.getEventCache();\r\n        var newViewCache, newEventCache;\r\n        var source = new WriteTreeCompleteChildSource(writesCache, oldViewCache, completeCache);\r\n        if (changePath.isEmpty()) {\r\n            newEventCache = this.filter_.updateFullNode(oldViewCache.getEventCache().getNode(), changedSnap, accumulator);\r\n            newViewCache = oldViewCache.updateEventSnap(newEventCache, true, this.filter_.filtersNodes());\r\n        }\r\n        else {\r\n            var childKey = changePath.getFront();\r\n            if (childKey === '.priority') {\r\n                newEventCache = this.filter_.updatePriority(oldViewCache.getEventCache().getNode(), changedSnap);\r\n                newViewCache = oldViewCache.updateEventSnap(newEventCache, oldEventSnap.isFullyInitialized(), oldEventSnap.isFiltered());\r\n            }\r\n            else {\r\n                var childChangePath = changePath.popFront();\r\n                var oldChild = oldEventSnap.getNode().getImmediateChild(childKey);\r\n                var newChild = void 0;\r\n                if (childChangePath.isEmpty()) {\r\n                    // Child overwrite, we can replace the child\r\n                    newChild = changedSnap;\r\n                }\r\n                else {\r\n                    var childNode = source.getCompleteChild(childKey);\r\n                    if (childNode != null) {\r\n                        if (childChangePath.getBack() === '.priority' &&\r\n                            childNode.getChild(childChangePath.parent()).isEmpty()) {\r\n                            // This is a priority update on an empty node. If this node exists on the server, the\r\n                            // server will send down the priority in the update, so ignore for now\r\n                            newChild = childNode;\r\n                        }\r\n                        else {\r\n                            newChild = childNode.updateChild(childChangePath, changedSnap);\r\n                        }\r\n                    }\r\n                    else {\r\n                        // There is no complete child node available\r\n                        newChild = ChildrenNode.EMPTY_NODE;\r\n                    }\r\n                }\r\n                if (!oldChild.equals(newChild)) {\r\n                    var newEventSnap = this.filter_.updateChild(oldEventSnap.getNode(), childKey, newChild, childChangePath, source, accumulator);\r\n                    newViewCache = oldViewCache.updateEventSnap(newEventSnap, oldEventSnap.isFullyInitialized(), this.filter_.filtersNodes());\r\n                }\r\n                else {\r\n                    newViewCache = oldViewCache;\r\n                }\r\n            }\r\n        }\r\n        return newViewCache;\r\n    };\r\n    /**\r\n     * @param {!ViewCache} viewCache\r\n     * @param {string} childKey\r\n     * @return {boolean}\r\n     * @private\r\n     */\r\n    ViewProcessor.cacheHasChild_ = function (viewCache, childKey) {\r\n        return viewCache.getEventCache().isCompleteForChild(childKey);\r\n    };\r\n    /**\r\n     * @param {!ViewCache} viewCache\r\n     * @param {!Path} path\r\n     * @param {ImmutableTree.<!Node>} changedChildren\r\n     * @param {!WriteTreeRef} writesCache\r\n     * @param {?Node} serverCache\r\n     * @param {!ChildChangeAccumulator} accumulator\r\n     * @return {!ViewCache}\r\n     * @private\r\n     */\r\n    ViewProcessor.prototype.applyUserMerge_ = function (viewCache, path, changedChildren, writesCache, serverCache, accumulator) {\r\n        var _this = this;\r\n        // HACK: In the case of a limit query, there may be some changes that bump things out of the\r\n        // window leaving room for new items.  It's important we process these changes first, so we\r\n        // iterate the changes twice, first processing any that affect items currently in view.\r\n        // TODO: I consider an item \"in view\" if cacheHasChild is true, which checks both the server\r\n        // and event snap.  I'm not sure if this will result in edge cases when a child is in one but\r\n        // not the other.\r\n        var curViewCache = viewCache;\r\n        changedChildren.foreach(function (relativePath, childNode) {\r\n            var writePath = path.child(relativePath);\r\n            if (ViewProcessor.cacheHasChild_(viewCache, writePath.getFront())) {\r\n                curViewCache = _this.applyUserOverwrite_(curViewCache, writePath, childNode, writesCache, serverCache, accumulator);\r\n            }\r\n        });\r\n        changedChildren.foreach(function (relativePath, childNode) {\r\n            var writePath = path.child(relativePath);\r\n            if (!ViewProcessor.cacheHasChild_(viewCache, writePath.getFront())) {\r\n                curViewCache = _this.applyUserOverwrite_(curViewCache, writePath, childNode, writesCache, serverCache, accumulator);\r\n            }\r\n        });\r\n        return curViewCache;\r\n    };\r\n    /**\r\n     * @param {!Node} node\r\n     * @param {ImmutableTree.<!Node>} merge\r\n     * @return {!Node}\r\n     * @private\r\n     */\r\n    ViewProcessor.prototype.applyMerge_ = function (node, merge) {\r\n        merge.foreach(function (relativePath, childNode) {\r\n            node = node.updateChild(relativePath, childNode);\r\n        });\r\n        return node;\r\n    };\r\n    /**\r\n     * @param {!ViewCache} viewCache\r\n     * @param {!Path} path\r\n     * @param {!ImmutableTree.<!Node>} changedChildren\r\n     * @param {!WriteTreeRef} writesCache\r\n     * @param {?Node} serverCache\r\n     * @param {boolean} filterServerNode\r\n     * @param {!ChildChangeAccumulator} accumulator\r\n     * @return {!ViewCache}\r\n     * @private\r\n     */\r\n    ViewProcessor.prototype.applyServerMerge_ = function (viewCache, path, changedChildren, writesCache, serverCache, filterServerNode, accumulator) {\r\n        var _this = this;\r\n        // If we don't have a cache yet, this merge was intended for a previously listen in the same location. Ignore it and\r\n        // wait for the complete data update coming soon.\r\n        if (viewCache.getServerCache().getNode().isEmpty() &&\r\n            !viewCache.getServerCache().isFullyInitialized()) {\r\n            return viewCache;\r\n        }\r\n        // HACK: In the case of a limit query, there may be some changes that bump things out of the\r\n        // window leaving room for new items.  It's important we process these changes first, so we\r\n        // iterate the changes twice, first processing any that affect items currently in view.\r\n        // TODO: I consider an item \"in view\" if cacheHasChild is true, which checks both the server\r\n        // and event snap.  I'm not sure if this will result in edge cases when a child is in one but\r\n        // not the other.\r\n        var curViewCache = viewCache;\r\n        var viewMergeTree;\r\n        if (path.isEmpty()) {\r\n            viewMergeTree = changedChildren;\r\n        }\r\n        else {\r\n            viewMergeTree = ImmutableTree.Empty.setTree(path, changedChildren);\r\n        }\r\n        var serverNode = viewCache.getServerCache().getNode();\r\n        viewMergeTree.children.inorderTraversal(function (childKey, childTree) {\r\n            if (serverNode.hasChild(childKey)) {\r\n                var serverChild = viewCache\r\n                    .getServerCache()\r\n                    .getNode()\r\n                    .getImmediateChild(childKey);\r\n                var newChild = _this.applyMerge_(serverChild, childTree);\r\n                curViewCache = _this.applyServerOverwrite_(curViewCache, new Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);\r\n            }\r\n        });\r\n        viewMergeTree.children.inorderTraversal(function (childKey, childMergeTree) {\r\n            var isUnknownDeepMerge = !viewCache.getServerCache().isCompleteForChild(childKey) &&\r\n                childMergeTree.value == null;\r\n            if (!serverNode.hasChild(childKey) && !isUnknownDeepMerge) {\r\n                var serverChild = viewCache\r\n                    .getServerCache()\r\n                    .getNode()\r\n                    .getImmediateChild(childKey);\r\n                var newChild = _this.applyMerge_(serverChild, childMergeTree);\r\n                curViewCache = _this.applyServerOverwrite_(curViewCache, new Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);\r\n            }\r\n        });\r\n        return curViewCache;\r\n    };\r\n    /**\r\n     * @param {!ViewCache} viewCache\r\n     * @param {!Path} ackPath\r\n     * @param {!ImmutableTree<!boolean>} affectedTree\r\n     * @param {!WriteTreeRef} writesCache\r\n     * @param {?Node} completeCache\r\n     * @param {!ChildChangeAccumulator} accumulator\r\n     * @return {!ViewCache}\r\n     * @private\r\n     */\r\n    ViewProcessor.prototype.ackUserWrite_ = function (viewCache, ackPath, affectedTree, writesCache, completeCache, accumulator) {\r\n        if (writesCache.shadowingWrite(ackPath) != null) {\r\n            return viewCache;\r\n        }\r\n        // Only filter server node if it is currently filtered\r\n        var filterServerNode = viewCache.getServerCache().isFiltered();\r\n        // Essentially we'll just get our existing server cache for the affected paths and re-apply it as a server update\r\n        // now that it won't be shadowed.\r\n        var serverCache = viewCache.getServerCache();\r\n        if (affectedTree.value != null) {\r\n            // This is an overwrite.\r\n            if ((ackPath.isEmpty() && serverCache.isFullyInitialized()) ||\r\n                serverCache.isCompleteForPath(ackPath)) {\r\n                return this.applyServerOverwrite_(viewCache, ackPath, serverCache.getNode().getChild(ackPath), writesCache, completeCache, filterServerNode, accumulator);\r\n            }\r\n            else if (ackPath.isEmpty()) {\r\n                // This is a goofy edge case where we are acking data at this location but don't have full data.  We\r\n                // should just re-apply whatever we have in our cache as a merge.\r\n                var changedChildren_1 = ImmutableTree.Empty;\r\n                serverCache.getNode().forEachChild(KEY_INDEX, function (name, node) {\r\n                    changedChildren_1 = changedChildren_1.set(new Path(name), node);\r\n                });\r\n                return this.applyServerMerge_(viewCache, ackPath, changedChildren_1, writesCache, completeCache, filterServerNode, accumulator);\r\n            }\r\n            else {\r\n                return viewCache;\r\n            }\r\n        }\r\n        else {\r\n            // This is a merge.\r\n            var changedChildren_2 = ImmutableTree.Empty;\r\n            affectedTree.foreach(function (mergePath, value) {\r\n                var serverCachePath = ackPath.child(mergePath);\r\n                if (serverCache.isCompleteForPath(serverCachePath)) {\r\n                    changedChildren_2 = changedChildren_2.set(mergePath, serverCache.getNode().getChild(serverCachePath));\r\n                }\r\n            });\r\n            return this.applyServerMerge_(viewCache, ackPath, changedChildren_2, writesCache, completeCache, filterServerNode, accumulator);\r\n        }\r\n    };\r\n    /**\r\n     * @param {!ViewCache} viewCache\r\n     * @param {!Path} path\r\n     * @param {!WriteTreeRef} writesCache\r\n     * @param {!ChildChangeAccumulator} accumulator\r\n     * @return {!ViewCache}\r\n     * @private\r\n     */\r\n    ViewProcessor.prototype.listenComplete_ = function (viewCache, path, writesCache, accumulator) {\r\n        var oldServerNode = viewCache.getServerCache();\r\n        var newViewCache = viewCache.updateServerSnap(oldServerNode.getNode(), oldServerNode.isFullyInitialized() || path.isEmpty(), oldServerNode.isFiltered());\r\n        return this.generateEventCacheAfterServerEvent_(newViewCache, path, writesCache, NO_COMPLETE_CHILD_SOURCE, accumulator);\r\n    };\r\n    /**\r\n     * @param {!ViewCache} viewCache\r\n     * @param {!Path} path\r\n     * @param {!WriteTreeRef} writesCache\r\n     * @param {?Node} completeServerCache\r\n     * @param {!ChildChangeAccumulator} accumulator\r\n     * @return {!ViewCache}\r\n     * @private\r\n     */\r\n    ViewProcessor.prototype.revertUserWrite_ = function (viewCache, path, writesCache, completeServerCache, accumulator) {\r\n        var complete;\r\n        if (writesCache.shadowingWrite(path) != null) {\r\n            return viewCache;\r\n        }\r\n        else {\r\n            var source = new WriteTreeCompleteChildSource(writesCache, viewCache, completeServerCache);\r\n            var oldEventCache = viewCache.getEventCache().getNode();\r\n            var newEventCache = void 0;\r\n            if (path.isEmpty() || path.getFront() === '.priority') {\r\n                var newNode = void 0;\r\n                if (viewCache.getServerCache().isFullyInitialized()) {\r\n                    newNode = writesCache.calcCompleteEventCache(viewCache.getCompleteServerSnap());\r\n                }\r\n                else {\r\n                    var serverChildren = viewCache.getServerCache().getNode();\r\n                    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(serverChildren instanceof ChildrenNode, 'serverChildren would be complete if leaf node');\r\n                    newNode = writesCache.calcCompleteEventChildren(serverChildren);\r\n                }\r\n                newNode = newNode;\r\n                newEventCache = this.filter_.updateFullNode(oldEventCache, newNode, accumulator);\r\n            }\r\n            else {\r\n                var childKey = path.getFront();\r\n                var newChild = writesCache.calcCompleteChild(childKey, viewCache.getServerCache());\r\n                if (newChild == null &&\r\n                    viewCache.getServerCache().isCompleteForChild(childKey)) {\r\n                    newChild = oldEventCache.getImmediateChild(childKey);\r\n                }\r\n                if (newChild != null) {\r\n                    newEventCache = this.filter_.updateChild(oldEventCache, childKey, newChild, path.popFront(), source, accumulator);\r\n                }\r\n                else if (viewCache.getEventCache().getNode().hasChild(childKey)) {\r\n                    // No complete child available, delete the existing one, if any\r\n                    newEventCache = this.filter_.updateChild(oldEventCache, childKey, ChildrenNode.EMPTY_NODE, path.popFront(), source, accumulator);\r\n                }\r\n                else {\r\n                    newEventCache = oldEventCache;\r\n                }\r\n                if (newEventCache.isEmpty() &&\r\n                    viewCache.getServerCache().isFullyInitialized()) {\r\n                    // We might have reverted all child writes. Maybe the old event was a leaf node\r\n                    complete = writesCache.calcCompleteEventCache(viewCache.getCompleteServerSnap());\r\n                    if (complete.isLeafNode()) {\r\n                        newEventCache = this.filter_.updateFullNode(newEventCache, complete, accumulator);\r\n                    }\r\n                }\r\n            }\r\n            complete =\r\n                viewCache.getServerCache().isFullyInitialized() ||\r\n                    writesCache.shadowingWrite(Path.Empty) != null;\r\n            return viewCache.updateEventSnap(newEventCache, complete, this.filter_.filtersNodes());\r\n        }\r\n    };\r\n    return ViewProcessor;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An EventGenerator is used to convert \"raw\" changes (Change) as computed by the\r\n * CacheDiffer into actual events (Event) that can be raised.  See generateEventsForChanges()\r\n * for details.\r\n *\r\n * @constructor\r\n */\r\nvar EventGenerator = /** @class */ (function () {\r\n    /**\r\n     *\r\n     * @param {!Query} query_\r\n     */\r\n    function EventGenerator(query_) {\r\n        this.query_ = query_;\r\n        /**\r\n         * @private\r\n         * @type {!Index}\r\n         */\r\n        this.index_ = this.query_.getQueryParams().getIndex();\r\n    }\r\n    /**\r\n     * Given a set of raw changes (no moved events and prevName not specified yet), and a set of\r\n     * EventRegistrations that should be notified of these changes, generate the actual events to be raised.\r\n     *\r\n     * Notes:\r\n     *  - child_moved events will be synthesized at this time for any child_changed events that affect\r\n     *    our index.\r\n     *  - prevName will be calculated based on the index ordering.\r\n     *\r\n     * @param {!Array.<!Change>} changes\r\n     * @param {!Node} eventCache\r\n     * @param {!Array.<!EventRegistration>} eventRegistrations\r\n     * @return {!Array.<!Event>}\r\n     */\r\n    EventGenerator.prototype.generateEventsForChanges = function (changes, eventCache, eventRegistrations) {\r\n        var _this = this;\r\n        var events = [];\r\n        var moves = [];\r\n        changes.forEach(function (change) {\r\n            if (change.type === Change.CHILD_CHANGED &&\r\n                _this.index_.indexedValueChanged(change.oldSnap, change.snapshotNode)) {\r\n                moves.push(Change.childMovedChange(change.childName, change.snapshotNode));\r\n            }\r\n        });\r\n        this.generateEventsForType_(events, Change.CHILD_REMOVED, changes, eventRegistrations, eventCache);\r\n        this.generateEventsForType_(events, Change.CHILD_ADDED, changes, eventRegistrations, eventCache);\r\n        this.generateEventsForType_(events, Change.CHILD_MOVED, moves, eventRegistrations, eventCache);\r\n        this.generateEventsForType_(events, Change.CHILD_CHANGED, changes, eventRegistrations, eventCache);\r\n        this.generateEventsForType_(events, Change.VALUE, changes, eventRegistrations, eventCache);\r\n        return events;\r\n    };\r\n    /**\r\n     * Given changes of a single change type, generate the corresponding events.\r\n     *\r\n     * @param {!Array.<!Event>} events\r\n     * @param {!string} eventType\r\n     * @param {!Array.<!Change>} changes\r\n     * @param {!Array.<!EventRegistration>} registrations\r\n     * @param {!Node} eventCache\r\n     * @private\r\n     */\r\n    EventGenerator.prototype.generateEventsForType_ = function (events, eventType, changes, registrations, eventCache) {\r\n        var _this = this;\r\n        var filteredChanges = changes.filter(function (change) { return change.type === eventType; });\r\n        filteredChanges.sort(this.compareChanges_.bind(this));\r\n        filteredChanges.forEach(function (change) {\r\n            var materializedChange = _this.materializeSingleChange_(change, eventCache);\r\n            registrations.forEach(function (registration) {\r\n                if (registration.respondsTo(change.type)) {\r\n                    events.push(registration.createEvent(materializedChange, _this.query_));\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * @param {!Change} change\r\n     * @param {!Node} eventCache\r\n     * @return {!Change}\r\n     * @private\r\n     */\r\n    EventGenerator.prototype.materializeSingleChange_ = function (change, eventCache) {\r\n        if (change.type === 'value' || change.type === 'child_removed') {\r\n            return change;\r\n        }\r\n        else {\r\n            change.prevName = eventCache.getPredecessorChildName(\r\n            /** @type {!string} */\r\n            change.childName, change.snapshotNode, this.index_);\r\n            return change;\r\n        }\r\n    };\r\n    /**\r\n     * @param {!Change} a\r\n     * @param {!Change} b\r\n     * @return {number}\r\n     * @private\r\n     */\r\n    EventGenerator.prototype.compareChanges_ = function (a, b) {\r\n        if (a.childName == null || b.childName == null) {\r\n            throw (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assertionError)('Should only compare child_ events.');\r\n        }\r\n        var aWrapped = new NamedNode(a.childName, a.snapshotNode);\r\n        var bWrapped = new NamedNode(b.childName, b.snapshotNode);\r\n        return this.index_.compare(aWrapped, bWrapped);\r\n    };\r\n    return EventGenerator;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A view represents a specific location and query that has 1 or more event registrations.\r\n *\r\n * It does several things:\r\n *  - Maintains the list of event registrations for this location/query.\r\n *  - Maintains a cache of the data visible for this location/query.\r\n *  - Applies new operations (via applyOperation), updates the cache, and based on the event\r\n *    registrations returns the set of events to be raised.\r\n * @constructor\r\n */\r\nvar View = /** @class */ (function () {\r\n    /**\r\n     *\r\n     * @param {!Query} query_\r\n     * @param {!ViewCache} initialViewCache\r\n     */\r\n    function View(query_, initialViewCache) {\r\n        this.query_ = query_;\r\n        this.eventRegistrations_ = [];\r\n        var params = this.query_.getQueryParams();\r\n        var indexFilter = new IndexedFilter(params.getIndex());\r\n        var filter = params.getNodeFilter();\r\n        /**\r\n         * @type {ViewProcessor}\r\n         * @private\r\n         */\r\n        this.processor_ = new ViewProcessor(filter);\r\n        var initialServerCache = initialViewCache.getServerCache();\r\n        var initialEventCache = initialViewCache.getEventCache();\r\n        // Don't filter server node with other filter than index, wait for tagged listen\r\n        var serverSnap = indexFilter.updateFullNode(ChildrenNode.EMPTY_NODE, initialServerCache.getNode(), null);\r\n        var eventSnap = filter.updateFullNode(ChildrenNode.EMPTY_NODE, initialEventCache.getNode(), null);\r\n        var newServerCache = new CacheNode(serverSnap, initialServerCache.isFullyInitialized(), indexFilter.filtersNodes());\r\n        var newEventCache = new CacheNode(eventSnap, initialEventCache.isFullyInitialized(), filter.filtersNodes());\r\n        /**\r\n         * @type {!ViewCache}\r\n         * @private\r\n         */\r\n        this.viewCache_ = new ViewCache(newEventCache, newServerCache);\r\n        /**\r\n         * @type {!EventGenerator}\r\n         * @private\r\n         */\r\n        this.eventGenerator_ = new EventGenerator(this.query_);\r\n    }\r\n    /**\r\n     * @return {!Query}\r\n     */\r\n    View.prototype.getQuery = function () {\r\n        return this.query_;\r\n    };\r\n    /**\r\n     * @return {?Node}\r\n     */\r\n    View.prototype.getServerCache = function () {\r\n        return this.viewCache_.getServerCache().getNode();\r\n    };\r\n    /**\r\n     * @param {!Path} path\r\n     * @return {?Node}\r\n     */\r\n    View.prototype.getCompleteServerCache = function (path) {\r\n        var cache = this.viewCache_.getCompleteServerSnap();\r\n        if (cache) {\r\n            // If this isn't a \"loadsAllData\" view, then cache isn't actually a complete cache and\r\n            // we need to see if it contains the child we're interested in.\r\n            if (this.query_.getQueryParams().loadsAllData() ||\r\n                (!path.isEmpty() && !cache.getImmediateChild(path.getFront()).isEmpty())) {\r\n                return cache.getChild(path);\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * @return {boolean}\r\n     */\r\n    View.prototype.isEmpty = function () {\r\n        return this.eventRegistrations_.length === 0;\r\n    };\r\n    /**\r\n     * @param {!EventRegistration} eventRegistration\r\n     */\r\n    View.prototype.addEventRegistration = function (eventRegistration) {\r\n        this.eventRegistrations_.push(eventRegistration);\r\n    };\r\n    /**\r\n     * @param {?EventRegistration} eventRegistration If null, remove all callbacks.\r\n     * @param {Error=} cancelError If a cancelError is provided, appropriate cancel events will be returned.\r\n     * @return {!Array.<!Event>} Cancel events, if cancelError was provided.\r\n     */\r\n    View.prototype.removeEventRegistration = function (eventRegistration, cancelError) {\r\n        var cancelEvents = [];\r\n        if (cancelError) {\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(eventRegistration == null, 'A cancel should cancel all event registrations.');\r\n            var path_1 = this.query_.path;\r\n            this.eventRegistrations_.forEach(function (registration) {\r\n                cancelError /** @type {!Error} */ = cancelError;\r\n                var maybeEvent = registration.createCancelEvent(cancelError, path_1);\r\n                if (maybeEvent) {\r\n                    cancelEvents.push(maybeEvent);\r\n                }\r\n            });\r\n        }\r\n        if (eventRegistration) {\r\n            var remaining = [];\r\n            for (var i = 0; i < this.eventRegistrations_.length; ++i) {\r\n                var existing = this.eventRegistrations_[i];\r\n                if (!existing.matches(eventRegistration)) {\r\n                    remaining.push(existing);\r\n                }\r\n                else if (eventRegistration.hasAnyCallback()) {\r\n                    // We're removing just this one\r\n                    remaining = remaining.concat(this.eventRegistrations_.slice(i + 1));\r\n                    break;\r\n                }\r\n            }\r\n            this.eventRegistrations_ = remaining;\r\n        }\r\n        else {\r\n            this.eventRegistrations_ = [];\r\n        }\r\n        return cancelEvents;\r\n    };\r\n    /**\r\n     * Applies the given Operation, updates our cache, and returns the appropriate events.\r\n     *\r\n     * @param {!Operation} operation\r\n     * @param {!WriteTreeRef} writesCache\r\n     * @param {?Node} completeServerCache\r\n     * @return {!Array.<!Event>}\r\n     */\r\n    View.prototype.applyOperation = function (operation, writesCache, completeServerCache) {\r\n        if (operation.type === OperationType.MERGE &&\r\n            operation.source.queryId !== null) {\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.viewCache_.getCompleteServerSnap(), 'We should always have a full cache before handling merges');\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.viewCache_.getCompleteEventSnap(), 'Missing event cache, even though we have a server cache');\r\n        }\r\n        var oldViewCache = this.viewCache_;\r\n        var result = this.processor_.applyOperation(oldViewCache, operation, writesCache, completeServerCache);\r\n        this.processor_.assertIndexed(result.viewCache);\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(result.viewCache.getServerCache().isFullyInitialized() ||\r\n            !oldViewCache.getServerCache().isFullyInitialized(), 'Once a server snap is complete, it should never go back');\r\n        this.viewCache_ = result.viewCache;\r\n        return this.generateEventsForChanges_(result.changes, result.viewCache.getEventCache().getNode(), null);\r\n    };\r\n    /**\r\n     * @param {!EventRegistration} registration\r\n     * @return {!Array.<!Event>}\r\n     */\r\n    View.prototype.getInitialEvents = function (registration) {\r\n        var eventSnap = this.viewCache_.getEventCache();\r\n        var initialChanges = [];\r\n        if (!eventSnap.getNode().isLeafNode()) {\r\n            var eventNode = eventSnap.getNode();\r\n            eventNode.forEachChild(PRIORITY_INDEX, function (key, childNode) {\r\n                initialChanges.push(Change.childAddedChange(key, childNode));\r\n            });\r\n        }\r\n        if (eventSnap.isFullyInitialized()) {\r\n            initialChanges.push(Change.valueChange(eventSnap.getNode()));\r\n        }\r\n        return this.generateEventsForChanges_(initialChanges, eventSnap.getNode(), registration);\r\n    };\r\n    /**\r\n     * @private\r\n     * @param {!Array.<!Change>} changes\r\n     * @param {!Node} eventCache\r\n     * @param {EventRegistration=} eventRegistration\r\n     * @return {!Array.<!Event>}\r\n     */\r\n    View.prototype.generateEventsForChanges_ = function (changes, eventCache, eventRegistration) {\r\n        var registrations = eventRegistration\r\n            ? [eventRegistration]\r\n            : this.eventRegistrations_;\r\n        return this.eventGenerator_.generateEventsForChanges(changes, eventCache, registrations);\r\n    };\r\n    return View;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar __referenceConstructor$1;\r\n/**\r\n * SyncPoint represents a single location in a SyncTree with 1 or more event registrations, meaning we need to\r\n * maintain 1 or more Views at this location to cache server data and raise appropriate events for server changes\r\n * and user writes (set, transaction, update).\r\n *\r\n * It's responsible for:\r\n *  - Maintaining the set of 1 or more views necessary at this location (a SyncPoint with 0 views should be removed).\r\n *  - Proxying user / server operations to the views as appropriate (i.e. applyServerOverwrite,\r\n *    applyUserOverwrite, etc.)\r\n */\r\nvar SyncPoint = /** @class */ (function () {\r\n    function SyncPoint() {\r\n        /**\r\n         * The Views being tracked at this location in the tree, stored as a map where the key is a\r\n         * queryId and the value is the View for that query.\r\n         *\r\n         * NOTE: This list will be quite small (usually 1, but perhaps 2 or 3; any more is an odd use case).\r\n         */\r\n        this.views = new Map();\r\n    }\r\n    Object.defineProperty(SyncPoint, \"__referenceConstructor\", {\r\n        get: function () {\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(__referenceConstructor$1, 'Reference.ts has not been loaded');\r\n            return __referenceConstructor$1;\r\n        },\r\n        set: function (val) {\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(!__referenceConstructor$1, '__referenceConstructor has already been defined');\r\n            __referenceConstructor$1 = val;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    SyncPoint.prototype.isEmpty = function () {\r\n        return this.views.size === 0;\r\n    };\r\n    SyncPoint.prototype.applyOperation = function (operation, writesCache, optCompleteServerCache) {\r\n        var e_1, _a;\r\n        var queryId = operation.source.queryId;\r\n        if (queryId !== null) {\r\n            var view = this.views.get(queryId);\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(view != null, 'SyncTree gave us an op for an invalid query.');\r\n            return view.applyOperation(operation, writesCache, optCompleteServerCache);\r\n        }\r\n        else {\r\n            var events = [];\r\n            try {\r\n                for (var _b = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__values)(this.views.values()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                    var view = _c.value;\r\n                    events = events.concat(view.applyOperation(operation, writesCache, optCompleteServerCache));\r\n                }\r\n            }\r\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n            finally {\r\n                try {\r\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                }\r\n                finally { if (e_1) throw e_1.error; }\r\n            }\r\n            return events;\r\n        }\r\n    };\r\n    /**\r\n     * Add an event callback for the specified query.\r\n     *\r\n     * @param {!Query} query\r\n     * @param {!EventRegistration} eventRegistration\r\n     * @param {!WriteTreeRef} writesCache\r\n     * @param {?Node} serverCache Complete server cache, if we have it.\r\n     * @param {boolean} serverCacheComplete\r\n     * @return {!Array.<!Event>} Events to raise.\r\n     */\r\n    SyncPoint.prototype.addEventRegistration = function (query, eventRegistration, writesCache, serverCache, serverCacheComplete) {\r\n        var queryId = query.queryIdentifier();\r\n        var view = this.views.get(queryId);\r\n        if (!view) {\r\n            // TODO: make writesCache take flag for complete server node\r\n            var eventCache = writesCache.calcCompleteEventCache(serverCacheComplete ? serverCache : null);\r\n            var eventCacheComplete = false;\r\n            if (eventCache) {\r\n                eventCacheComplete = true;\r\n            }\r\n            else if (serverCache instanceof ChildrenNode) {\r\n                eventCache = writesCache.calcCompleteEventChildren(serverCache);\r\n                eventCacheComplete = false;\r\n            }\r\n            else {\r\n                eventCache = ChildrenNode.EMPTY_NODE;\r\n                eventCacheComplete = false;\r\n            }\r\n            var viewCache = new ViewCache(new CacheNode(\r\n            /** @type {!Node} */ eventCache, eventCacheComplete, false), new CacheNode(\r\n            /** @type {!Node} */ serverCache, serverCacheComplete, false));\r\n            view = new View(query, viewCache);\r\n            this.views.set(queryId, view);\r\n        }\r\n        // This is guaranteed to exist now, we just created anything that was missing\r\n        view.addEventRegistration(eventRegistration);\r\n        return view.getInitialEvents(eventRegistration);\r\n    };\r\n    /**\r\n     * Remove event callback(s).  Return cancelEvents if a cancelError is specified.\r\n     *\r\n     * If query is the default query, we'll check all views for the specified eventRegistration.\r\n     * If eventRegistration is null, we'll remove all callbacks for the specified view(s).\r\n     *\r\n     * @param {!Query} query\r\n     * @param {?EventRegistration} eventRegistration If null, remove all callbacks.\r\n     * @param {Error=} cancelError If a cancelError is provided, appropriate cancel events will be returned.\r\n     * @return {{removed:!Array.<!Query>, events:!Array.<!Event>}} removed queries and any cancel events\r\n     */\r\n    SyncPoint.prototype.removeEventRegistration = function (query, eventRegistration, cancelError) {\r\n        var e_2, _a;\r\n        var queryId = query.queryIdentifier();\r\n        var removed = [];\r\n        var cancelEvents = [];\r\n        var hadCompleteView = this.hasCompleteView();\r\n        if (queryId === 'default') {\r\n            try {\r\n                // When you do ref.off(...), we search all views for the registration to remove.\r\n                for (var _b = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__values)(this.views.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                    var _d = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__read)(_c.value, 2), viewQueryId = _d[0], view = _d[1];\r\n                    cancelEvents = cancelEvents.concat(view.removeEventRegistration(eventRegistration, cancelError));\r\n                    if (view.isEmpty()) {\r\n                        this.views.delete(viewQueryId);\r\n                        // We'll deal with complete views later.\r\n                        if (!view.getQuery().getQueryParams().loadsAllData()) {\r\n                            removed.push(view.getQuery());\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n            finally {\r\n                try {\r\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                }\r\n                finally { if (e_2) throw e_2.error; }\r\n            }\r\n        }\r\n        else {\r\n            // remove the callback from the specific view.\r\n            var view = this.views.get(queryId);\r\n            if (view) {\r\n                cancelEvents = cancelEvents.concat(view.removeEventRegistration(eventRegistration, cancelError));\r\n                if (view.isEmpty()) {\r\n                    this.views.delete(queryId);\r\n                    // We'll deal with complete views later.\r\n                    if (!view.getQuery().getQueryParams().loadsAllData()) {\r\n                        removed.push(view.getQuery());\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (hadCompleteView && !this.hasCompleteView()) {\r\n            // We removed our last complete view.\r\n            removed.push(new SyncPoint.__referenceConstructor(query.repo, query.path));\r\n        }\r\n        return { removed: removed, events: cancelEvents };\r\n    };\r\n    SyncPoint.prototype.getQueryViews = function () {\r\n        var e_3, _a;\r\n        var result = [];\r\n        try {\r\n            for (var _b = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__values)(this.views.values()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var view = _c.value;\r\n                if (!view.getQuery().getQueryParams().loadsAllData()) {\r\n                    result.push(view);\r\n                }\r\n            }\r\n        }\r\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_3) throw e_3.error; }\r\n        }\r\n        return result;\r\n    };\r\n    /**\r\n     * @param path The path to the desired complete snapshot\r\n     * @return A complete cache, if it exists\r\n     */\r\n    SyncPoint.prototype.getCompleteServerCache = function (path) {\r\n        var e_4, _a;\r\n        var serverCache = null;\r\n        try {\r\n            for (var _b = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__values)(this.views.values()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var view = _c.value;\r\n                serverCache = serverCache || view.getCompleteServerCache(path);\r\n            }\r\n        }\r\n        catch (e_4_1) { e_4 = { error: e_4_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_4) throw e_4.error; }\r\n        }\r\n        return serverCache;\r\n    };\r\n    SyncPoint.prototype.viewForQuery = function (query) {\r\n        var params = query.getQueryParams();\r\n        if (params.loadsAllData()) {\r\n            return this.getCompleteView();\r\n        }\r\n        else {\r\n            var queryId = query.queryIdentifier();\r\n            return this.views.get(queryId);\r\n        }\r\n    };\r\n    SyncPoint.prototype.viewExistsForQuery = function (query) {\r\n        return this.viewForQuery(query) != null;\r\n    };\r\n    SyncPoint.prototype.hasCompleteView = function () {\r\n        return this.getCompleteView() != null;\r\n    };\r\n    SyncPoint.prototype.getCompleteView = function () {\r\n        var e_5, _a;\r\n        try {\r\n            for (var _b = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__values)(this.views.values()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var view = _c.value;\r\n                if (view.getQuery().getQueryParams().loadsAllData()) {\r\n                    return view;\r\n                }\r\n            }\r\n        }\r\n        catch (e_5_1) { e_5 = { error: e_5_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_5) throw e_5.error; }\r\n        }\r\n        return null;\r\n    };\r\n    return SyncPoint;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * This class holds a collection of writes that can be applied to nodes in unison. It abstracts away the logic with\r\n * dealing with priority writes and multiple nested writes. At any given path there is only allowed to be one write\r\n * modifying that path. Any write to an existing path or shadowing an existing path will modify that existing write\r\n * to reflect the write added.\r\n */\r\nvar CompoundWrite = /** @class */ (function () {\r\n    function CompoundWrite(writeTree_) {\r\n        this.writeTree_ = writeTree_;\r\n    }\r\n    CompoundWrite.prototype.addWrite = function (path, node) {\r\n        if (path.isEmpty()) {\r\n            return new CompoundWrite(new ImmutableTree(node));\r\n        }\r\n        else {\r\n            var rootmost = this.writeTree_.findRootMostValueAndPath(path);\r\n            if (rootmost != null) {\r\n                var rootMostPath = rootmost.path;\r\n                var value = rootmost.value;\r\n                var relativePath = Path.relativePath(rootMostPath, path);\r\n                value = value.updateChild(relativePath, node);\r\n                return new CompoundWrite(this.writeTree_.set(rootMostPath, value));\r\n            }\r\n            else {\r\n                var subtree = new ImmutableTree(node);\r\n                var newWriteTree = this.writeTree_.setTree(path, subtree);\r\n                return new CompoundWrite(newWriteTree);\r\n            }\r\n        }\r\n    };\r\n    CompoundWrite.prototype.addWrites = function (path, updates) {\r\n        var newWrite = this;\r\n        each(updates, function (childKey, node) {\r\n            newWrite = newWrite.addWrite(path.child(childKey), node);\r\n        });\r\n        return newWrite;\r\n    };\r\n    /**\r\n     * Will remove a write at the given path and deeper paths. This will <em>not</em> modify a write at a higher\r\n     * location, which must be removed by calling this method with that path.\r\n     *\r\n     * @param path The path at which a write and all deeper writes should be removed\r\n     * @return {!CompoundWrite} The new CompoundWrite with the removed path\r\n     */\r\n    CompoundWrite.prototype.removeWrite = function (path) {\r\n        if (path.isEmpty()) {\r\n            return CompoundWrite.Empty;\r\n        }\r\n        else {\r\n            var newWriteTree = this.writeTree_.setTree(path, ImmutableTree.Empty);\r\n            return new CompoundWrite(newWriteTree);\r\n        }\r\n    };\r\n    /**\r\n     * Returns whether this CompoundWrite will fully overwrite a node at a given location and can therefore be\r\n     * considered \"complete\".\r\n     *\r\n     * @param path The path to check for\r\n     * @return Whether there is a complete write at that path\r\n     */\r\n    CompoundWrite.prototype.hasCompleteWrite = function (path) {\r\n        return this.getCompleteNode(path) != null;\r\n    };\r\n    /**\r\n     * Returns a node for a path if and only if the node is a \"complete\" overwrite at that path. This will not aggregate\r\n     * writes from deeper paths, but will return child nodes from a more shallow path.\r\n     *\r\n     * @param path The path to get a complete write\r\n     * @return The node if complete at that path, or null otherwise.\r\n     */\r\n    CompoundWrite.prototype.getCompleteNode = function (path) {\r\n        var rootmost = this.writeTree_.findRootMostValueAndPath(path);\r\n        if (rootmost != null) {\r\n            return this.writeTree_\r\n                .get(rootmost.path)\r\n                .getChild(Path.relativePath(rootmost.path, path));\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    };\r\n    /**\r\n     * Returns all children that are guaranteed to be a complete overwrite.\r\n     *\r\n     * @return A list of all complete children.\r\n     */\r\n    CompoundWrite.prototype.getCompleteChildren = function () {\r\n        var children = [];\r\n        var node = this.writeTree_.value;\r\n        if (node != null) {\r\n            // If it's a leaf node, it has no children; so nothing to do.\r\n            if (!node.isLeafNode()) {\r\n                node.forEachChild(PRIORITY_INDEX, function (childName, childNode) {\r\n                    children.push(new NamedNode(childName, childNode));\r\n                });\r\n            }\r\n        }\r\n        else {\r\n            this.writeTree_.children.inorderTraversal(function (childName, childTree) {\r\n                if (childTree.value != null) {\r\n                    children.push(new NamedNode(childName, childTree.value));\r\n                }\r\n            });\r\n        }\r\n        return children;\r\n    };\r\n    CompoundWrite.prototype.childCompoundWrite = function (path) {\r\n        if (path.isEmpty()) {\r\n            return this;\r\n        }\r\n        else {\r\n            var shadowingNode = this.getCompleteNode(path);\r\n            if (shadowingNode != null) {\r\n                return new CompoundWrite(new ImmutableTree(shadowingNode));\r\n            }\r\n            else {\r\n                return new CompoundWrite(this.writeTree_.subtree(path));\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Returns true if this CompoundWrite is empty and therefore does not modify any nodes.\r\n     * @return Whether this CompoundWrite is empty\r\n     */\r\n    CompoundWrite.prototype.isEmpty = function () {\r\n        return this.writeTree_.isEmpty();\r\n    };\r\n    /**\r\n     * Applies this CompoundWrite to a node. The node is returned with all writes from this CompoundWrite applied to the\r\n     * node\r\n     * @param node The node to apply this CompoundWrite to\r\n     * @return The node with all writes applied\r\n     */\r\n    CompoundWrite.prototype.apply = function (node) {\r\n        return applySubtreeWrite(Path.Empty, this.writeTree_, node);\r\n    };\r\n    CompoundWrite.Empty = new CompoundWrite(new ImmutableTree(null));\r\n    return CompoundWrite;\r\n}());\r\nfunction applySubtreeWrite(relativePath, writeTree, node) {\r\n    if (writeTree.value != null) {\r\n        // Since there a write is always a leaf, we're done here\r\n        return node.updateChild(relativePath, writeTree.value);\r\n    }\r\n    else {\r\n        var priorityWrite_1 = null;\r\n        writeTree.children.inorderTraversal(function (childKey, childTree) {\r\n            if (childKey === '.priority') {\r\n                // Apply priorities at the end so we don't update priorities for either empty nodes or forget\r\n                // to apply priorities to empty nodes that are later filled\r\n                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(childTree.value !== null, 'Priority writes must always be leaf nodes');\r\n                priorityWrite_1 = childTree.value;\r\n            }\r\n            else {\r\n                node = applySubtreeWrite(relativePath.child(childKey), childTree, node);\r\n            }\r\n        });\r\n        // If there was a priority write, we only apply it if the node is not empty\r\n        if (!node.getChild(relativePath).isEmpty() && priorityWrite_1 !== null) {\r\n            node = node.updateChild(relativePath.child('.priority'), priorityWrite_1);\r\n        }\r\n        return node;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * WriteTree tracks all pending user-initiated writes and has methods to calculate the result of merging them\r\n * with underlying server data (to create \"event cache\" data).  Pending writes are added with addOverwrite()\r\n * and addMerge(), and removed with removeWrite().\r\n *\r\n * @constructor\r\n */\r\nvar WriteTree = /** @class */ (function () {\r\n    function WriteTree() {\r\n        /**\r\n         * A tree tracking the result of applying all visible writes.  This does not include transactions with\r\n         * applyLocally=false or writes that are completely shadowed by other writes.\r\n         *\r\n         * @type {!CompoundWrite}\r\n         * @private\r\n         */\r\n        this.visibleWrites_ = CompoundWrite.Empty;\r\n        /**\r\n         * A list of all pending writes, regardless of visibility and shadowed-ness.  Used to calculate arbitrary\r\n         * sets of the changed data, such as hidden writes (from transactions) or changes with certain writes excluded (also\r\n         * used by transactions).\r\n         *\r\n         * @type {!Array.<!WriteRecord>}\r\n         * @private\r\n         */\r\n        this.allWrites_ = [];\r\n        this.lastWriteId_ = -1;\r\n    }\r\n    /**\r\n     * Create a new WriteTreeRef for the given path. For use with a new sync point at the given path.\r\n     *\r\n     * @param {!Path} path\r\n     * @return {!WriteTreeRef}\r\n     */\r\n    WriteTree.prototype.childWrites = function (path) {\r\n        return new WriteTreeRef(path, this);\r\n    };\r\n    /**\r\n     * Record a new overwrite from user code.\r\n     *\r\n     * @param {!Path} path\r\n     * @param {!Node} snap\r\n     * @param {!number} writeId\r\n     * @param {boolean=} visible This is set to false by some transactions. It should be excluded from event caches\r\n     */\r\n    WriteTree.prototype.addOverwrite = function (path, snap, writeId, visible) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(writeId > this.lastWriteId_, 'Stacking an older write on top of newer ones');\r\n        if (visible === undefined) {\r\n            visible = true;\r\n        }\r\n        this.allWrites_.push({\r\n            path: path,\r\n            snap: snap,\r\n            writeId: writeId,\r\n            visible: visible\r\n        });\r\n        if (visible) {\r\n            this.visibleWrites_ = this.visibleWrites_.addWrite(path, snap);\r\n        }\r\n        this.lastWriteId_ = writeId;\r\n    };\r\n    /**\r\n     * Record a new merge from user code.\r\n     *\r\n     * @param {!Path} path\r\n     * @param {!Object.<string, !Node>} changedChildren\r\n     * @param {!number} writeId\r\n     */\r\n    WriteTree.prototype.addMerge = function (path, changedChildren, writeId) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(writeId > this.lastWriteId_, 'Stacking an older merge on top of newer ones');\r\n        this.allWrites_.push({\r\n            path: path,\r\n            children: changedChildren,\r\n            writeId: writeId,\r\n            visible: true\r\n        });\r\n        this.visibleWrites_ = this.visibleWrites_.addWrites(path, changedChildren);\r\n        this.lastWriteId_ = writeId;\r\n    };\r\n    /**\r\n     * @param {!number} writeId\r\n     * @return {?WriteRecord}\r\n     */\r\n    WriteTree.prototype.getWrite = function (writeId) {\r\n        for (var i = 0; i < this.allWrites_.length; i++) {\r\n            var record = this.allWrites_[i];\r\n            if (record.writeId === writeId) {\r\n                return record;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * Remove a write (either an overwrite or merge) that has been successfully acknowledge by the server. Recalculates\r\n     * the tree if necessary.  We return true if it may have been visible, meaning views need to reevaluate.\r\n     *\r\n     * @param {!number} writeId\r\n     * @return {boolean} true if the write may have been visible (meaning we'll need to reevaluate / raise\r\n     * events as a result).\r\n     */\r\n    WriteTree.prototype.removeWrite = function (writeId) {\r\n        // Note: disabling this check. It could be a transaction that preempted another transaction, and thus was applied\r\n        // out of order.\r\n        //const validClear = revert || this.allWrites_.length === 0 || writeId <= this.allWrites_[0].writeId;\r\n        //assert(validClear, \"Either we don't have this write, or it's the first one in the queue\");\r\n        var _this = this;\r\n        var idx = this.allWrites_.findIndex(function (s) {\r\n            return s.writeId === writeId;\r\n        });\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(idx >= 0, 'removeWrite called with nonexistent writeId.');\r\n        var writeToRemove = this.allWrites_[idx];\r\n        this.allWrites_.splice(idx, 1);\r\n        var removedWriteWasVisible = writeToRemove.visible;\r\n        var removedWriteOverlapsWithOtherWrites = false;\r\n        var i = this.allWrites_.length - 1;\r\n        while (removedWriteWasVisible && i >= 0) {\r\n            var currentWrite = this.allWrites_[i];\r\n            if (currentWrite.visible) {\r\n                if (i >= idx &&\r\n                    this.recordContainsPath_(currentWrite, writeToRemove.path)) {\r\n                    // The removed write was completely shadowed by a subsequent write.\r\n                    removedWriteWasVisible = false;\r\n                }\r\n                else if (writeToRemove.path.contains(currentWrite.path)) {\r\n                    // Either we're covering some writes or they're covering part of us (depending on which came first).\r\n                    removedWriteOverlapsWithOtherWrites = true;\r\n                }\r\n            }\r\n            i--;\r\n        }\r\n        if (!removedWriteWasVisible) {\r\n            return false;\r\n        }\r\n        else if (removedWriteOverlapsWithOtherWrites) {\r\n            // There's some shadowing going on. Just rebuild the visible writes from scratch.\r\n            this.resetTree_();\r\n            return true;\r\n        }\r\n        else {\r\n            // There's no shadowing.  We can safely just remove the write(s) from visibleWrites.\r\n            if (writeToRemove.snap) {\r\n                this.visibleWrites_ = this.visibleWrites_.removeWrite(writeToRemove.path);\r\n            }\r\n            else {\r\n                var children = writeToRemove.children;\r\n                each(children, function (childName) {\r\n                    _this.visibleWrites_ = _this.visibleWrites_.removeWrite(writeToRemove.path.child(childName));\r\n                });\r\n            }\r\n            return true;\r\n        }\r\n    };\r\n    /**\r\n     * Return a complete snapshot for the given path if there's visible write data at that path, else null.\r\n     * No server data is considered.\r\n     *\r\n     * @param {!Path} path\r\n     * @return {?Node}\r\n     */\r\n    WriteTree.prototype.getCompleteWriteData = function (path) {\r\n        return this.visibleWrites_.getCompleteNode(path);\r\n    };\r\n    /**\r\n     * Given optional, underlying server data, and an optional set of constraints (exclude some sets, include hidden\r\n     * writes), attempt to calculate a complete snapshot for the given path\r\n     *\r\n     * @param {!Path} treePath\r\n     * @param {?Node} completeServerCache\r\n     * @param {Array.<number>=} writeIdsToExclude An optional set to be excluded\r\n     * @param {boolean=} includeHiddenWrites Defaults to false, whether or not to layer on writes with visible set to false\r\n     * @return {?Node}\r\n     */\r\n    WriteTree.prototype.calcCompleteEventCache = function (treePath, completeServerCache, writeIdsToExclude, includeHiddenWrites) {\r\n        if (!writeIdsToExclude && !includeHiddenWrites) {\r\n            var shadowingNode = this.visibleWrites_.getCompleteNode(treePath);\r\n            if (shadowingNode != null) {\r\n                return shadowingNode;\r\n            }\r\n            else {\r\n                var subMerge = this.visibleWrites_.childCompoundWrite(treePath);\r\n                if (subMerge.isEmpty()) {\r\n                    return completeServerCache;\r\n                }\r\n                else if (completeServerCache == null &&\r\n                    !subMerge.hasCompleteWrite(Path.Empty)) {\r\n                    // We wouldn't have a complete snapshot, since there's no underlying data and no complete shadow\r\n                    return null;\r\n                }\r\n                else {\r\n                    var layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;\r\n                    return subMerge.apply(layeredCache);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            var merge = this.visibleWrites_.childCompoundWrite(treePath);\r\n            if (!includeHiddenWrites && merge.isEmpty()) {\r\n                return completeServerCache;\r\n            }\r\n            else {\r\n                // If the server cache is null, and we don't have a complete cache, we need to return null\r\n                if (!includeHiddenWrites &&\r\n                    completeServerCache == null &&\r\n                    !merge.hasCompleteWrite(Path.Empty)) {\r\n                    return null;\r\n                }\r\n                else {\r\n                    var filter = function (write) {\r\n                        return ((write.visible || includeHiddenWrites) &&\r\n                            (!writeIdsToExclude ||\r\n                                !~writeIdsToExclude.indexOf(write.writeId)) &&\r\n                            (write.path.contains(treePath) || treePath.contains(write.path)));\r\n                    };\r\n                    var mergeAtPath = WriteTree.layerTree_(this.allWrites_, filter, treePath);\r\n                    var layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;\r\n                    return mergeAtPath.apply(layeredCache);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * With optional, underlying server data, attempt to return a children node of children that we have complete data for.\r\n     * Used when creating new views, to pre-fill their complete event children snapshot.\r\n     *\r\n     * @param {!Path} treePath\r\n     * @param {?ChildrenNode} completeServerChildren\r\n     * @return {!ChildrenNode}\r\n     */\r\n    WriteTree.prototype.calcCompleteEventChildren = function (treePath, completeServerChildren) {\r\n        var completeChildren = ChildrenNode.EMPTY_NODE;\r\n        var topLevelSet = this.visibleWrites_.getCompleteNode(treePath);\r\n        if (topLevelSet) {\r\n            if (!topLevelSet.isLeafNode()) {\r\n                // we're shadowing everything. Return the children.\r\n                topLevelSet.forEachChild(PRIORITY_INDEX, function (childName, childSnap) {\r\n                    completeChildren = completeChildren.updateImmediateChild(childName, childSnap);\r\n                });\r\n            }\r\n            return completeChildren;\r\n        }\r\n        else if (completeServerChildren) {\r\n            // Layer any children we have on top of this\r\n            // We know we don't have a top-level set, so just enumerate existing children\r\n            var merge_1 = this.visibleWrites_.childCompoundWrite(treePath);\r\n            completeServerChildren.forEachChild(PRIORITY_INDEX, function (childName, childNode) {\r\n                var node = merge_1\r\n                    .childCompoundWrite(new Path(childName))\r\n                    .apply(childNode);\r\n                completeChildren = completeChildren.updateImmediateChild(childName, node);\r\n            });\r\n            // Add any complete children we have from the set\r\n            merge_1.getCompleteChildren().forEach(function (namedNode) {\r\n                completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);\r\n            });\r\n            return completeChildren;\r\n        }\r\n        else {\r\n            // We don't have anything to layer on top of. Layer on any children we have\r\n            // Note that we can return an empty snap if we have a defined delete\r\n            var merge = this.visibleWrites_.childCompoundWrite(treePath);\r\n            merge.getCompleteChildren().forEach(function (namedNode) {\r\n                completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);\r\n            });\r\n            return completeChildren;\r\n        }\r\n    };\r\n    /**\r\n     * Given that the underlying server data has updated, determine what, if anything, needs to be\r\n     * applied to the event cache.\r\n     *\r\n     * Possibilities:\r\n     *\r\n     * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data\r\n     *\r\n     * 2. Some write is completely shadowing. No events to be raised\r\n     *\r\n     * 3. Is partially shadowed. Events\r\n     *\r\n     * Either existingEventSnap or existingServerSnap must exist\r\n     *\r\n     * @param {!Path} treePath\r\n     * @param {!Path} childPath\r\n     * @param {?Node} existingEventSnap\r\n     * @param {?Node} existingServerSnap\r\n     * @return {?Node}\r\n     */\r\n    WriteTree.prototype.calcEventCacheAfterServerOverwrite = function (treePath, childPath, existingEventSnap, existingServerSnap) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(existingEventSnap || existingServerSnap, 'Either existingEventSnap or existingServerSnap must exist');\r\n        var path = treePath.child(childPath);\r\n        if (this.visibleWrites_.hasCompleteWrite(path)) {\r\n            // At this point we can probably guarantee that we're in case 2, meaning no events\r\n            // May need to check visibility while doing the findRootMostValueAndPath call\r\n            return null;\r\n        }\r\n        else {\r\n            // No complete shadowing. We're either partially shadowing or not shadowing at all.\r\n            var childMerge = this.visibleWrites_.childCompoundWrite(path);\r\n            if (childMerge.isEmpty()) {\r\n                // We're not shadowing at all. Case 1\r\n                return existingServerSnap.getChild(childPath);\r\n            }\r\n            else {\r\n                // This could be more efficient if the serverNode + updates doesn't change the eventSnap\r\n                // However this is tricky to find out, since user updates don't necessary change the server\r\n                // snap, e.g. priority updates on empty nodes, or deep deletes. Another special case is if the server\r\n                // adds nodes, but doesn't change any existing writes. It is therefore not enough to\r\n                // only check if the updates change the serverNode.\r\n                // Maybe check if the merge tree contains these special cases and only do a full overwrite in that case?\r\n                return childMerge.apply(existingServerSnap.getChild(childPath));\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Returns a complete child for a given server snap after applying all user writes or null if there is no\r\n     * complete child for this ChildKey.\r\n     *\r\n     * @param {!Path} treePath\r\n     * @param {!string} childKey\r\n     * @param {!CacheNode} existingServerSnap\r\n     * @return {?Node}\r\n     */\r\n    WriteTree.prototype.calcCompleteChild = function (treePath, childKey, existingServerSnap) {\r\n        var path = treePath.child(childKey);\r\n        var shadowingNode = this.visibleWrites_.getCompleteNode(path);\r\n        if (shadowingNode != null) {\r\n            return shadowingNode;\r\n        }\r\n        else {\r\n            if (existingServerSnap.isCompleteForChild(childKey)) {\r\n                var childMerge = this.visibleWrites_.childCompoundWrite(path);\r\n                return childMerge.apply(existingServerSnap.getNode().getImmediateChild(childKey));\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at\r\n     * a higher path, this will return the child of that write relative to the write and this path.\r\n     * Returns null if there is no write at this path.\r\n     */\r\n    WriteTree.prototype.shadowingWrite = function (path) {\r\n        return this.visibleWrites_.getCompleteNode(path);\r\n    };\r\n    /**\r\n     * This method is used when processing child remove events on a query. If we can, we pull in children that were outside\r\n     * the window, but may now be in the window.\r\n     */\r\n    WriteTree.prototype.calcIndexedSlice = function (treePath, completeServerData, startPost, count, reverse, index) {\r\n        var toIterate;\r\n        var merge = this.visibleWrites_.childCompoundWrite(treePath);\r\n        var shadowingNode = merge.getCompleteNode(Path.Empty);\r\n        if (shadowingNode != null) {\r\n            toIterate = shadowingNode;\r\n        }\r\n        else if (completeServerData != null) {\r\n            toIterate = merge.apply(completeServerData);\r\n        }\r\n        else {\r\n            // no children to iterate on\r\n            return [];\r\n        }\r\n        toIterate = toIterate.withIndex(index);\r\n        if (!toIterate.isEmpty() && !toIterate.isLeafNode()) {\r\n            var nodes = [];\r\n            var cmp = index.getCompare();\r\n            var iter = reverse\r\n                ? toIterate.getReverseIteratorFrom(startPost, index)\r\n                : toIterate.getIteratorFrom(startPost, index);\r\n            var next = iter.getNext();\r\n            while (next && nodes.length < count) {\r\n                if (cmp(next, startPost) !== 0) {\r\n                    nodes.push(next);\r\n                }\r\n                next = iter.getNext();\r\n            }\r\n            return nodes;\r\n        }\r\n        else {\r\n            return [];\r\n        }\r\n    };\r\n    WriteTree.prototype.recordContainsPath_ = function (writeRecord, path) {\r\n        if (writeRecord.snap) {\r\n            return writeRecord.path.contains(path);\r\n        }\r\n        else {\r\n            for (var childName in writeRecord.children) {\r\n                if (writeRecord.children.hasOwnProperty(childName) &&\r\n                    writeRecord.path.child(childName).contains(path)) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n    };\r\n    /**\r\n     * Re-layer the writes and merges into a tree so we can efficiently calculate event snapshots\r\n     */\r\n    WriteTree.prototype.resetTree_ = function () {\r\n        this.visibleWrites_ = WriteTree.layerTree_(this.allWrites_, WriteTree.DefaultFilter_, Path.Empty);\r\n        if (this.allWrites_.length > 0) {\r\n            this.lastWriteId_ = this.allWrites_[this.allWrites_.length - 1].writeId;\r\n        }\r\n        else {\r\n            this.lastWriteId_ = -1;\r\n        }\r\n    };\r\n    /**\r\n     * The default filter used when constructing the tree. Keep everything that's visible.\r\n     */\r\n    WriteTree.DefaultFilter_ = function (write) {\r\n        return write.visible;\r\n    };\r\n    /**\r\n     * Static method. Given an array of WriteRecords, a filter for which ones to include, and a path, construct the tree of\r\n     * event data at that path.\r\n     */\r\n    WriteTree.layerTree_ = function (writes, filter, treeRoot) {\r\n        var compoundWrite = CompoundWrite.Empty;\r\n        for (var i = 0; i < writes.length; ++i) {\r\n            var write = writes[i];\r\n            // Theory, a later set will either:\r\n            // a) abort a relevant transaction, so no need to worry about excluding it from calculating that transaction\r\n            // b) not be relevant to a transaction (separate branch), so again will not affect the data for that transaction\r\n            if (filter(write)) {\r\n                var writePath = write.path;\r\n                var relativePath = void 0;\r\n                if (write.snap) {\r\n                    if (treeRoot.contains(writePath)) {\r\n                        relativePath = Path.relativePath(treeRoot, writePath);\r\n                        compoundWrite = compoundWrite.addWrite(relativePath, write.snap);\r\n                    }\r\n                    else if (writePath.contains(treeRoot)) {\r\n                        relativePath = Path.relativePath(writePath, treeRoot);\r\n                        compoundWrite = compoundWrite.addWrite(Path.Empty, write.snap.getChild(relativePath));\r\n                    }\r\n                    else ;\r\n                }\r\n                else if (write.children) {\r\n                    if (treeRoot.contains(writePath)) {\r\n                        relativePath = Path.relativePath(treeRoot, writePath);\r\n                        compoundWrite = compoundWrite.addWrites(relativePath, write.children);\r\n                    }\r\n                    else if (writePath.contains(treeRoot)) {\r\n                        relativePath = Path.relativePath(writePath, treeRoot);\r\n                        if (relativePath.isEmpty()) {\r\n                            compoundWrite = compoundWrite.addWrites(Path.Empty, write.children);\r\n                        }\r\n                        else {\r\n                            var child = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.safeGet)(write.children, relativePath.getFront());\r\n                            if (child) {\r\n                                // There exists a child in this node that matches the root path\r\n                                var deepNode = child.getChild(relativePath.popFront());\r\n                                compoundWrite = compoundWrite.addWrite(Path.Empty, deepNode);\r\n                            }\r\n                        }\r\n                    }\r\n                    else ;\r\n                }\r\n                else {\r\n                    throw (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assertionError)('WriteRecord should have .snap or .children');\r\n                }\r\n            }\r\n        }\r\n        return compoundWrite;\r\n    };\r\n    return WriteTree;\r\n}());\r\n/**\r\n * A WriteTreeRef wraps a WriteTree and a path, for convenient access to a particular subtree.  All of the methods\r\n * just proxy to the underlying WriteTree.\r\n *\r\n * @constructor\r\n */\r\nvar WriteTreeRef = /** @class */ (function () {\r\n    /**\r\n     * @param {!Path} path\r\n     * @param {!WriteTree} writeTree\r\n     */\r\n    function WriteTreeRef(path, writeTree) {\r\n        this.treePath_ = path;\r\n        this.writeTree_ = writeTree;\r\n    }\r\n    /**\r\n     * If possible, returns a complete event cache, using the underlying server data if possible. In addition, can be used\r\n     * to get a cache that includes hidden writes, and excludes arbitrary writes. Note that customizing the returned node\r\n     * can lead to a more expensive calculation.\r\n     *\r\n     * @param {?Node} completeServerCache\r\n     * @param {Array.<number>=} writeIdsToExclude Optional writes to exclude.\r\n     * @param {boolean=} includeHiddenWrites Defaults to false, whether or not to layer on writes with visible set to false\r\n     * @return {?Node}\r\n     */\r\n    WriteTreeRef.prototype.calcCompleteEventCache = function (completeServerCache, writeIdsToExclude, includeHiddenWrites) {\r\n        return this.writeTree_.calcCompleteEventCache(this.treePath_, completeServerCache, writeIdsToExclude, includeHiddenWrites);\r\n    };\r\n    /**\r\n     * If possible, returns a children node containing all of the complete children we have data for. The returned data is a\r\n     * mix of the given server data and write data.\r\n     *\r\n     * @param {?ChildrenNode} completeServerChildren\r\n     * @return {!ChildrenNode}\r\n     */\r\n    WriteTreeRef.prototype.calcCompleteEventChildren = function (completeServerChildren) {\r\n        return this.writeTree_.calcCompleteEventChildren(this.treePath_, completeServerChildren);\r\n    };\r\n    /**\r\n     * Given that either the underlying server data has updated or the outstanding writes have updated, determine what,\r\n     * if anything, needs to be applied to the event cache.\r\n     *\r\n     * Possibilities:\r\n     *\r\n     * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data\r\n     *\r\n     * 2. Some write is completely shadowing. No events to be raised\r\n     *\r\n     * 3. Is partially shadowed. Events should be raised\r\n     *\r\n     * Either existingEventSnap or existingServerSnap must exist, this is validated via an assert\r\n     *\r\n     * @param {!Path} path\r\n     * @param {?Node} existingEventSnap\r\n     * @param {?Node} existingServerSnap\r\n     * @return {?Node}\r\n     */\r\n    WriteTreeRef.prototype.calcEventCacheAfterServerOverwrite = function (path, existingEventSnap, existingServerSnap) {\r\n        return this.writeTree_.calcEventCacheAfterServerOverwrite(this.treePath_, path, existingEventSnap, existingServerSnap);\r\n    };\r\n    /**\r\n     * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at\r\n     * a higher path, this will return the child of that write relative to the write and this path.\r\n     * Returns null if there is no write at this path.\r\n     *\r\n     * @param {!Path} path\r\n     * @return {?Node}\r\n     */\r\n    WriteTreeRef.prototype.shadowingWrite = function (path) {\r\n        return this.writeTree_.shadowingWrite(this.treePath_.child(path));\r\n    };\r\n    /**\r\n     * This method is used when processing child remove events on a query. If we can, we pull in children that were outside\r\n     * the window, but may now be in the window\r\n     *\r\n     * @param {?Node} completeServerData\r\n     * @param {!NamedNode} startPost\r\n     * @param {!number} count\r\n     * @param {boolean} reverse\r\n     * @param {!Index} index\r\n     * @return {!Array.<!NamedNode>}\r\n     */\r\n    WriteTreeRef.prototype.calcIndexedSlice = function (completeServerData, startPost, count, reverse, index) {\r\n        return this.writeTree_.calcIndexedSlice(this.treePath_, completeServerData, startPost, count, reverse, index);\r\n    };\r\n    /**\r\n     * Returns a complete child for a given server snap after applying all user writes or null if there is no\r\n     * complete child for this ChildKey.\r\n     *\r\n     * @param {!string} childKey\r\n     * @param {!CacheNode} existingServerCache\r\n     * @return {?Node}\r\n     */\r\n    WriteTreeRef.prototype.calcCompleteChild = function (childKey, existingServerCache) {\r\n        return this.writeTree_.calcCompleteChild(this.treePath_, childKey, existingServerCache);\r\n    };\r\n    /**\r\n     * Return a WriteTreeRef for a child.\r\n     *\r\n     * @param {string} childName\r\n     * @return {!WriteTreeRef}\r\n     */\r\n    WriteTreeRef.prototype.child = function (childName) {\r\n        return new WriteTreeRef(this.treePath_.child(childName), this.writeTree_);\r\n    };\r\n    return WriteTreeRef;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * SyncTree is the central class for managing event callback registration, data caching, views\r\n * (query processing), and event generation.  There are typically two SyncTree instances for\r\n * each Repo, one for the normal Firebase data, and one for the .info data.\r\n *\r\n * It has a number of responsibilities, including:\r\n *  - Tracking all user event callbacks (registered via addEventRegistration() and removeEventRegistration()).\r\n *  - Applying and caching data changes for user set(), transaction(), and update() calls\r\n *    (applyUserOverwrite(), applyUserMerge()).\r\n *  - Applying and caching data changes for server data changes (applyServerOverwrite(),\r\n *    applyServerMerge()).\r\n *  - Generating user-facing events for server and user changes (all of the apply* methods\r\n *    return the set of events that need to be raised as a result).\r\n *  - Maintaining the appropriate set of server listens to ensure we are always subscribed\r\n *    to the correct set of paths and queries to satisfy the current set of user event\r\n *    callbacks (listens are started/stopped using the provided listenProvider).\r\n *\r\n * NOTE: Although SyncTree tracks event callbacks and calculates events to raise, the actual\r\n * events are returned to the caller rather than raised synchronously.\r\n *\r\n * @constructor\r\n */\r\nvar SyncTree = /** @class */ (function () {\r\n    /**\r\n     * @param {!ListenProvider} listenProvider_ Used by SyncTree to start / stop listening\r\n     *   to server data.\r\n     */\r\n    function SyncTree(listenProvider_) {\r\n        this.listenProvider_ = listenProvider_;\r\n        /**\r\n         * Tree of SyncPoints.  There's a SyncPoint at any location that has 1 or more views.\r\n         */\r\n        this.syncPointTree_ = ImmutableTree.Empty;\r\n        /**\r\n         * A tree of all pending user writes (user-initiated set()'s, transaction()'s, update()'s, etc.).\r\n         */\r\n        this.pendingWriteTree_ = new WriteTree();\r\n        this.tagToQueryMap = new Map();\r\n        this.queryToTagMap = new Map();\r\n    }\r\n    /**\r\n     * Apply the data changes for a user-generated set() or transaction() call.\r\n     *\r\n     * @return Events to raise.\r\n     */\r\n    SyncTree.prototype.applyUserOverwrite = function (path, newData, writeId, visible) {\r\n        // Record pending write.\r\n        this.pendingWriteTree_.addOverwrite(path, newData, writeId, visible);\r\n        if (!visible) {\r\n            return [];\r\n        }\r\n        else {\r\n            return this.applyOperationToSyncPoints_(new Overwrite(OperationSource.User, path, newData));\r\n        }\r\n    };\r\n    /**\r\n     * Apply the data from a user-generated update() call\r\n     *\r\n     * @return Events to raise.\r\n     */\r\n    SyncTree.prototype.applyUserMerge = function (path, changedChildren, writeId) {\r\n        // Record pending merge.\r\n        this.pendingWriteTree_.addMerge(path, changedChildren, writeId);\r\n        var changeTree = ImmutableTree.fromObject(changedChildren);\r\n        return this.applyOperationToSyncPoints_(new Merge(OperationSource.User, path, changeTree));\r\n    };\r\n    /**\r\n     * Acknowledge a pending user write that was previously registered with applyUserOverwrite() or applyUserMerge().\r\n     *\r\n     * @param revert True if the given write failed and needs to be reverted\r\n     * @return Events to raise.\r\n     */\r\n    SyncTree.prototype.ackUserWrite = function (writeId, revert) {\r\n        if (revert === void 0) { revert = false; }\r\n        var write = this.pendingWriteTree_.getWrite(writeId);\r\n        var needToReevaluate = this.pendingWriteTree_.removeWrite(writeId);\r\n        if (!needToReevaluate) {\r\n            return [];\r\n        }\r\n        else {\r\n            var affectedTree_1 = ImmutableTree.Empty;\r\n            if (write.snap != null) {\r\n                // overwrite\r\n                affectedTree_1 = affectedTree_1.set(Path.Empty, true);\r\n            }\r\n            else {\r\n                each(write.children, function (pathString, node) {\r\n                    affectedTree_1 = affectedTree_1.set(new Path(pathString), node);\r\n                });\r\n            }\r\n            return this.applyOperationToSyncPoints_(new AckUserWrite(write.path, affectedTree_1, revert));\r\n        }\r\n    };\r\n    /**\r\n     * Apply new server data for the specified path..\r\n     *\r\n     * @return Events to raise.\r\n     */\r\n    SyncTree.prototype.applyServerOverwrite = function (path, newData) {\r\n        return this.applyOperationToSyncPoints_(new Overwrite(OperationSource.Server, path, newData));\r\n    };\r\n    /**\r\n     * Apply new server data to be merged in at the specified path.\r\n     *\r\n     * @return Events to raise.\r\n     */\r\n    SyncTree.prototype.applyServerMerge = function (path, changedChildren) {\r\n        var changeTree = ImmutableTree.fromObject(changedChildren);\r\n        return this.applyOperationToSyncPoints_(new Merge(OperationSource.Server, path, changeTree));\r\n    };\r\n    /**\r\n     * Apply a listen complete for a query\r\n     *\r\n     * @return Events to raise.\r\n     */\r\n    SyncTree.prototype.applyListenComplete = function (path) {\r\n        return this.applyOperationToSyncPoints_(new ListenComplete(OperationSource.Server, path));\r\n    };\r\n    /**\r\n     * Apply new server data for the specified tagged query.\r\n     *\r\n     * @return Events to raise.\r\n     */\r\n    SyncTree.prototype.applyTaggedQueryOverwrite = function (path, snap, tag) {\r\n        var queryKey = this.queryKeyForTag_(tag);\r\n        if (queryKey != null) {\r\n            var r = SyncTree.parseQueryKey_(queryKey);\r\n            var queryPath = r.path, queryId = r.queryId;\r\n            var relativePath = Path.relativePath(queryPath, path);\r\n            var op = new Overwrite(OperationSource.forServerTaggedQuery(queryId), relativePath, snap);\r\n            return this.applyTaggedOperation_(queryPath, op);\r\n        }\r\n        else {\r\n            // Query must have been removed already\r\n            return [];\r\n        }\r\n    };\r\n    /**\r\n     * Apply server data to be merged in for the specified tagged query.\r\n     *\r\n     * @return Events to raise.\r\n     */\r\n    SyncTree.prototype.applyTaggedQueryMerge = function (path, changedChildren, tag) {\r\n        var queryKey = this.queryKeyForTag_(tag);\r\n        if (queryKey) {\r\n            var r = SyncTree.parseQueryKey_(queryKey);\r\n            var queryPath = r.path, queryId = r.queryId;\r\n            var relativePath = Path.relativePath(queryPath, path);\r\n            var changeTree = ImmutableTree.fromObject(changedChildren);\r\n            var op = new Merge(OperationSource.forServerTaggedQuery(queryId), relativePath, changeTree);\r\n            return this.applyTaggedOperation_(queryPath, op);\r\n        }\r\n        else {\r\n            // We've already removed the query. No big deal, ignore the update\r\n            return [];\r\n        }\r\n    };\r\n    /**\r\n     * Apply a listen complete for a tagged query\r\n     *\r\n     * @return Events to raise.\r\n     */\r\n    SyncTree.prototype.applyTaggedListenComplete = function (path, tag) {\r\n        var queryKey = this.queryKeyForTag_(tag);\r\n        if (queryKey) {\r\n            var r = SyncTree.parseQueryKey_(queryKey);\r\n            var queryPath = r.path, queryId = r.queryId;\r\n            var relativePath = Path.relativePath(queryPath, path);\r\n            var op = new ListenComplete(OperationSource.forServerTaggedQuery(queryId), relativePath);\r\n            return this.applyTaggedOperation_(queryPath, op);\r\n        }\r\n        else {\r\n            // We've already removed the query. No big deal, ignore the update\r\n            return [];\r\n        }\r\n    };\r\n    /**\r\n     * Add an event callback for the specified query.\r\n     *\r\n     * @return Events to raise.\r\n     */\r\n    SyncTree.prototype.addEventRegistration = function (query, eventRegistration) {\r\n        var path = query.path;\r\n        var serverCache = null;\r\n        var foundAncestorDefaultView = false;\r\n        // Any covering writes will necessarily be at the root, so really all we need to find is the server cache.\r\n        // Consider optimizing this once there's a better understanding of what actual behavior will be.\r\n        this.syncPointTree_.foreachOnPath(path, function (pathToSyncPoint, sp) {\r\n            var relativePath = Path.relativePath(pathToSyncPoint, path);\r\n            serverCache = serverCache || sp.getCompleteServerCache(relativePath);\r\n            foundAncestorDefaultView =\r\n                foundAncestorDefaultView || sp.hasCompleteView();\r\n        });\r\n        var syncPoint = this.syncPointTree_.get(path);\r\n        if (!syncPoint) {\r\n            syncPoint = new SyncPoint();\r\n            this.syncPointTree_ = this.syncPointTree_.set(path, syncPoint);\r\n        }\r\n        else {\r\n            foundAncestorDefaultView =\r\n                foundAncestorDefaultView || syncPoint.hasCompleteView();\r\n            serverCache = serverCache || syncPoint.getCompleteServerCache(Path.Empty);\r\n        }\r\n        var serverCacheComplete;\r\n        if (serverCache != null) {\r\n            serverCacheComplete = true;\r\n        }\r\n        else {\r\n            serverCacheComplete = false;\r\n            serverCache = ChildrenNode.EMPTY_NODE;\r\n            var subtree = this.syncPointTree_.subtree(path);\r\n            subtree.foreachChild(function (childName, childSyncPoint) {\r\n                var completeCache = childSyncPoint.getCompleteServerCache(Path.Empty);\r\n                if (completeCache) {\r\n                    serverCache = serverCache.updateImmediateChild(childName, completeCache);\r\n                }\r\n            });\r\n        }\r\n        var viewAlreadyExists = syncPoint.viewExistsForQuery(query);\r\n        if (!viewAlreadyExists && !query.getQueryParams().loadsAllData()) {\r\n            // We need to track a tag for this query\r\n            var queryKey = SyncTree.makeQueryKey_(query);\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.queryToTagMap.has(queryKey), 'View does not exist, but we have a tag');\r\n            var tag = SyncTree.getNextQueryTag_();\r\n            this.queryToTagMap.set(queryKey, tag);\r\n            this.tagToQueryMap.set(tag, queryKey);\r\n        }\r\n        var writesCache = this.pendingWriteTree_.childWrites(path);\r\n        var events = syncPoint.addEventRegistration(query, eventRegistration, writesCache, serverCache, serverCacheComplete);\r\n        if (!viewAlreadyExists && !foundAncestorDefaultView) {\r\n            var view /** @type !View */ = syncPoint.viewForQuery(query);\r\n            events = events.concat(this.setupListener_(query, view));\r\n        }\r\n        return events;\r\n    };\r\n    /**\r\n     * Remove event callback(s).\r\n     *\r\n     * If query is the default query, we'll check all queries for the specified eventRegistration.\r\n     * If eventRegistration is null, we'll remove all callbacks for the specified query/queries.\r\n     *\r\n     * @param eventRegistration If null, all callbacks are removed.\r\n     * @param cancelError If a cancelError is provided, appropriate cancel events will be returned.\r\n     * @return Cancel events, if cancelError was provided.\r\n     */\r\n    SyncTree.prototype.removeEventRegistration = function (query, eventRegistration, cancelError) {\r\n        var _this = this;\r\n        // Find the syncPoint first. Then deal with whether or not it has matching listeners\r\n        var path = query.path;\r\n        var maybeSyncPoint = this.syncPointTree_.get(path);\r\n        var cancelEvents = [];\r\n        // A removal on a default query affects all queries at that location. A removal on an indexed query, even one without\r\n        // other query constraints, does *not* affect all queries at that location. So this check must be for 'default', and\r\n        // not loadsAllData().\r\n        if (maybeSyncPoint &&\r\n            (query.queryIdentifier() === 'default' ||\r\n                maybeSyncPoint.viewExistsForQuery(query))) {\r\n            /**\r\n             * @type {{removed: !Array.<!Query>, events: !Array.<!Event>}}\r\n             */\r\n            var removedAndEvents = maybeSyncPoint.removeEventRegistration(query, eventRegistration, cancelError);\r\n            if (maybeSyncPoint.isEmpty()) {\r\n                this.syncPointTree_ = this.syncPointTree_.remove(path);\r\n            }\r\n            var removed = removedAndEvents.removed;\r\n            cancelEvents = removedAndEvents.events;\r\n            // We may have just removed one of many listeners and can short-circuit this whole process\r\n            // We may also not have removed a default listener, in which case all of the descendant listeners should already be\r\n            // properly set up.\r\n            //\r\n            // Since indexed queries can shadow if they don't have other query constraints, check for loadsAllData(), instead of\r\n            // queryId === 'default'\r\n            var removingDefault = -1 !==\r\n                removed.findIndex(function (query) {\r\n                    return query.getQueryParams().loadsAllData();\r\n                });\r\n            var covered = this.syncPointTree_.findOnPath(path, function (relativePath, parentSyncPoint) {\r\n                return parentSyncPoint.hasCompleteView();\r\n            });\r\n            if (removingDefault && !covered) {\r\n                var subtree = this.syncPointTree_.subtree(path);\r\n                // There are potentially child listeners. Determine what if any listens we need to send before executing the\r\n                // removal\r\n                if (!subtree.isEmpty()) {\r\n                    // We need to fold over our subtree and collect the listeners to send\r\n                    var newViews = this.collectDistinctViewsForSubTree_(subtree);\r\n                    // Ok, we've collected all the listens we need. Set them up.\r\n                    for (var i = 0; i < newViews.length; ++i) {\r\n                        var view = newViews[i], newQuery = view.getQuery();\r\n                        var listener = this.createListenerForView_(view);\r\n                        this.listenProvider_.startListening(SyncTree.queryForListening_(newQuery), this.tagForQuery_(newQuery), listener.hashFn, listener.onComplete);\r\n                    }\r\n                }\r\n            }\r\n            // If we removed anything and we're not covered by a higher up listen, we need to stop listening on this query\r\n            // The above block has us covered in terms of making sure we're set up on listens lower in the tree.\r\n            // Also, note that if we have a cancelError, it's already been removed at the provider level.\r\n            if (!covered && removed.length > 0 && !cancelError) {\r\n                // If we removed a default, then we weren't listening on any of the other queries here. Just cancel the one\r\n                // default. Otherwise, we need to iterate through and cancel each individual query\r\n                if (removingDefault) {\r\n                    // We don't tag default listeners\r\n                    var defaultTag = null;\r\n                    this.listenProvider_.stopListening(SyncTree.queryForListening_(query), defaultTag);\r\n                }\r\n                else {\r\n                    removed.forEach(function (queryToRemove) {\r\n                        var tagToRemove = _this.queryToTagMap.get(SyncTree.makeQueryKey_(queryToRemove));\r\n                        _this.listenProvider_.stopListening(SyncTree.queryForListening_(queryToRemove), tagToRemove);\r\n                    });\r\n                }\r\n            }\r\n            // Now, clear all of the tags we're tracking for the removed listens\r\n            this.removeTags_(removed);\r\n        }\r\n        return cancelEvents;\r\n    };\r\n    /**\r\n     * Returns a complete cache, if we have one, of the data at a particular path. If the location does not have a\r\n     * listener above it, we will get a false \"null\". This shouldn't be a problem because transactions will always\r\n     * have a listener above, and atomic operations would correctly show a jitter of <increment value> ->\r\n     *     <incremented total> as the write is applied locally and then acknowledged at the server.\r\n     *\r\n     * Note: this method will *include* hidden writes from transaction with applyLocally set to false.\r\n     *\r\n     * @param path The path to the data we want\r\n     * @param writeIdsToExclude A specific set to be excluded\r\n     */\r\n    SyncTree.prototype.calcCompleteEventCache = function (path, writeIdsToExclude) {\r\n        var includeHiddenSets = true;\r\n        var writeTree = this.pendingWriteTree_;\r\n        var serverCache = this.syncPointTree_.findOnPath(path, function (pathSoFar, syncPoint) {\r\n            var relativePath = Path.relativePath(pathSoFar, path);\r\n            var serverCache = syncPoint.getCompleteServerCache(relativePath);\r\n            if (serverCache) {\r\n                return serverCache;\r\n            }\r\n        });\r\n        return writeTree.calcCompleteEventCache(path, serverCache, writeIdsToExclude, includeHiddenSets);\r\n    };\r\n    /**\r\n     * This collapses multiple unfiltered views into a single view, since we only need a single\r\n     * listener for them.\r\n     */\r\n    SyncTree.prototype.collectDistinctViewsForSubTree_ = function (subtree) {\r\n        return subtree.fold(function (relativePath, maybeChildSyncPoint, childMap) {\r\n            if (maybeChildSyncPoint && maybeChildSyncPoint.hasCompleteView()) {\r\n                var completeView = maybeChildSyncPoint.getCompleteView();\r\n                return [completeView];\r\n            }\r\n            else {\r\n                // No complete view here, flatten any deeper listens into an array\r\n                var views_1 = [];\r\n                if (maybeChildSyncPoint) {\r\n                    views_1 = maybeChildSyncPoint.getQueryViews();\r\n                }\r\n                each(childMap, function (_key, childViews) {\r\n                    views_1 = views_1.concat(childViews);\r\n                });\r\n                return views_1;\r\n            }\r\n        });\r\n    };\r\n    SyncTree.prototype.removeTags_ = function (queries) {\r\n        for (var j = 0; j < queries.length; ++j) {\r\n            var removedQuery = queries[j];\r\n            if (!removedQuery.getQueryParams().loadsAllData()) {\r\n                // We should have a tag for this\r\n                var removedQueryKey = SyncTree.makeQueryKey_(removedQuery);\r\n                var removedQueryTag = this.queryToTagMap.get(removedQueryKey);\r\n                this.queryToTagMap.delete(removedQueryKey);\r\n                this.tagToQueryMap.delete(removedQueryTag);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Normalizes a query to a query we send the server for listening\r\n     *\r\n     * @return The normalized query\r\n     */\r\n    SyncTree.queryForListening_ = function (query) {\r\n        if (query.getQueryParams().loadsAllData() &&\r\n            !query.getQueryParams().isDefault()) {\r\n            // We treat queries that load all data as default queries\r\n            // Cast is necessary because ref() technically returns Firebase which is actually fb.api.Firebase which inherits\r\n            // from Query\r\n            return query.getRef();\r\n        }\r\n        else {\r\n            return query;\r\n        }\r\n    };\r\n    /**\r\n     * For a given new listen, manage the de-duplication of outstanding subscriptions.\r\n     *\r\n     * @return This method can return events to support synchronous data sources\r\n     */\r\n    SyncTree.prototype.setupListener_ = function (query, view) {\r\n        var path = query.path;\r\n        var tag = this.tagForQuery_(query);\r\n        var listener = this.createListenerForView_(view);\r\n        var events = this.listenProvider_.startListening(SyncTree.queryForListening_(query), tag, listener.hashFn, listener.onComplete);\r\n        var subtree = this.syncPointTree_.subtree(path);\r\n        // The root of this subtree has our query. We're here because we definitely need to send a listen for that, but we\r\n        // may need to shadow other listens as well.\r\n        if (tag) {\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(!subtree.value.hasCompleteView(), \"If we're adding a query, it shouldn't be shadowed\");\r\n        }\r\n        else {\r\n            // Shadow everything at or below this location, this is a default listener.\r\n            var queriesToStop = subtree.fold(function (relativePath, maybeChildSyncPoint, childMap) {\r\n                if (!relativePath.isEmpty() &&\r\n                    maybeChildSyncPoint &&\r\n                    maybeChildSyncPoint.hasCompleteView()) {\r\n                    return [maybeChildSyncPoint.getCompleteView().getQuery()];\r\n                }\r\n                else {\r\n                    // No default listener here, flatten any deeper queries into an array\r\n                    var queries_1 = [];\r\n                    if (maybeChildSyncPoint) {\r\n                        queries_1 = queries_1.concat(maybeChildSyncPoint.getQueryViews().map(function (view) { return view.getQuery(); }));\r\n                    }\r\n                    each(childMap, function (_key, childQueries) {\r\n                        queries_1 = queries_1.concat(childQueries);\r\n                    });\r\n                    return queries_1;\r\n                }\r\n            });\r\n            for (var i = 0; i < queriesToStop.length; ++i) {\r\n                var queryToStop = queriesToStop[i];\r\n                this.listenProvider_.stopListening(SyncTree.queryForListening_(queryToStop), this.tagForQuery_(queryToStop));\r\n            }\r\n        }\r\n        return events;\r\n    };\r\n    SyncTree.prototype.createListenerForView_ = function (view) {\r\n        var _this = this;\r\n        var query = view.getQuery();\r\n        var tag = this.tagForQuery_(query);\r\n        return {\r\n            hashFn: function () {\r\n                var cache = view.getServerCache() || ChildrenNode.EMPTY_NODE;\r\n                return cache.hash();\r\n            },\r\n            onComplete: function (status) {\r\n                if (status === 'ok') {\r\n                    if (tag) {\r\n                        return _this.applyTaggedListenComplete(query.path, tag);\r\n                    }\r\n                    else {\r\n                        return _this.applyListenComplete(query.path);\r\n                    }\r\n                }\r\n                else {\r\n                    // If a listen failed, kill all of the listeners here, not just the one that triggered the error.\r\n                    // Note that this may need to be scoped to just this listener if we change permissions on filtered children\r\n                    var error = errorForServerCode(status, query);\r\n                    return _this.removeEventRegistration(query, \r\n                    /*eventRegistration*/ null, error);\r\n                }\r\n            }\r\n        };\r\n    };\r\n    /**\r\n     * Given a query, computes a \"queryKey\" suitable for use in our queryToTagMap_.\r\n     */\r\n    SyncTree.makeQueryKey_ = function (query) {\r\n        return query.path.toString() + '$' + query.queryIdentifier();\r\n    };\r\n    /**\r\n     * Given a queryKey (created by makeQueryKey), parse it back into a path and queryId.\r\n     */\r\n    SyncTree.parseQueryKey_ = function (queryKey) {\r\n        var splitIndex = queryKey.indexOf('$');\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(splitIndex !== -1 && splitIndex < queryKey.length - 1, 'Bad queryKey.');\r\n        return {\r\n            queryId: queryKey.substr(splitIndex + 1),\r\n            path: new Path(queryKey.substr(0, splitIndex))\r\n        };\r\n    };\r\n    /**\r\n     * Return the query associated with the given tag, if we have one\r\n     */\r\n    SyncTree.prototype.queryKeyForTag_ = function (tag) {\r\n        return this.tagToQueryMap.get(tag);\r\n    };\r\n    /**\r\n     * Return the tag associated with the given query.\r\n     */\r\n    SyncTree.prototype.tagForQuery_ = function (query) {\r\n        var queryKey = SyncTree.makeQueryKey_(query);\r\n        return this.queryToTagMap.get(queryKey);\r\n    };\r\n    /**\r\n     * Static accessor for query tags.\r\n     */\r\n    SyncTree.getNextQueryTag_ = function () {\r\n        return SyncTree.nextQueryTag_++;\r\n    };\r\n    /**\r\n     * A helper method to apply tagged operations\r\n     */\r\n    SyncTree.prototype.applyTaggedOperation_ = function (queryPath, operation) {\r\n        var syncPoint = this.syncPointTree_.get(queryPath);\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(syncPoint, \"Missing sync point for query tag that we're tracking\");\r\n        var writesCache = this.pendingWriteTree_.childWrites(queryPath);\r\n        return syncPoint.applyOperation(operation, writesCache, \r\n        /*serverCache=*/ null);\r\n    };\r\n    /**\r\n     * A helper method that visits all descendant and ancestor SyncPoints, applying the operation.\r\n     *\r\n     * NOTES:\r\n     * - Descendant SyncPoints will be visited first (since we raise events depth-first).\r\n     *\r\n     * - We call applyOperation() on each SyncPoint passing three things:\r\n     *   1. A version of the Operation that has been made relative to the SyncPoint location.\r\n     *   2. A WriteTreeRef of any writes we have cached at the SyncPoint location.\r\n     *   3. A snapshot Node with cached server data, if we have it.\r\n     *\r\n     * - We concatenate all of the events returned by each SyncPoint and return the result.\r\n     */\r\n    SyncTree.prototype.applyOperationToSyncPoints_ = function (operation) {\r\n        return this.applyOperationHelper_(operation, this.syncPointTree_, \r\n        /*serverCache=*/ null, this.pendingWriteTree_.childWrites(Path.Empty));\r\n    };\r\n    /**\r\n     * Recursive helper for applyOperationToSyncPoints_\r\n     */\r\n    SyncTree.prototype.applyOperationHelper_ = function (operation, syncPointTree, serverCache, writesCache) {\r\n        if (operation.path.isEmpty()) {\r\n            return this.applyOperationDescendantsHelper_(operation, syncPointTree, serverCache, writesCache);\r\n        }\r\n        else {\r\n            var syncPoint = syncPointTree.get(Path.Empty);\r\n            // If we don't have cached server data, see if we can get it from this SyncPoint.\r\n            if (serverCache == null && syncPoint != null) {\r\n                serverCache = syncPoint.getCompleteServerCache(Path.Empty);\r\n            }\r\n            var events = [];\r\n            var childName = operation.path.getFront();\r\n            var childOperation = operation.operationForChild(childName);\r\n            var childTree = syncPointTree.children.get(childName);\r\n            if (childTree && childOperation) {\r\n                var childServerCache = serverCache\r\n                    ? serverCache.getImmediateChild(childName)\r\n                    : null;\r\n                var childWritesCache = writesCache.child(childName);\r\n                events = events.concat(this.applyOperationHelper_(childOperation, childTree, childServerCache, childWritesCache));\r\n            }\r\n            if (syncPoint) {\r\n                events = events.concat(syncPoint.applyOperation(operation, writesCache, serverCache));\r\n            }\r\n            return events;\r\n        }\r\n    };\r\n    /**\r\n     * Recursive helper for applyOperationToSyncPoints_\r\n     */\r\n    SyncTree.prototype.applyOperationDescendantsHelper_ = function (operation, syncPointTree, serverCache, writesCache) {\r\n        var _this = this;\r\n        var syncPoint = syncPointTree.get(Path.Empty);\r\n        // If we don't have cached server data, see if we can get it from this SyncPoint.\r\n        if (serverCache == null && syncPoint != null) {\r\n            serverCache = syncPoint.getCompleteServerCache(Path.Empty);\r\n        }\r\n        var events = [];\r\n        syncPointTree.children.inorderTraversal(function (childName, childTree) {\r\n            var childServerCache = serverCache\r\n                ? serverCache.getImmediateChild(childName)\r\n                : null;\r\n            var childWritesCache = writesCache.child(childName);\r\n            var childOperation = operation.operationForChild(childName);\r\n            if (childOperation) {\r\n                events = events.concat(_this.applyOperationDescendantsHelper_(childOperation, childTree, childServerCache, childWritesCache));\r\n            }\r\n        });\r\n        if (syncPoint) {\r\n            events = events.concat(syncPoint.applyOperation(operation, writesCache, serverCache));\r\n        }\r\n        return events;\r\n    };\r\n    /**\r\n     * Static tracker for next query tag.\r\n     */\r\n    SyncTree.nextQueryTag_ = 1;\r\n    return SyncTree;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Mutable object which basically just stores a reference to the \"latest\" immutable snapshot.\r\n *\r\n * @constructor\r\n */\r\nvar SnapshotHolder = /** @class */ (function () {\r\n    function SnapshotHolder() {\r\n        this.rootNode_ = ChildrenNode.EMPTY_NODE;\r\n    }\r\n    SnapshotHolder.prototype.getNode = function (path) {\r\n        return this.rootNode_.getChild(path);\r\n    };\r\n    SnapshotHolder.prototype.updateSnapshot = function (path, newSnapshotNode) {\r\n        this.rootNode_ = this.rootNode_.updateChild(path, newSnapshotNode);\r\n    };\r\n    return SnapshotHolder;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Tracks a collection of stats.\r\n *\r\n * @constructor\r\n */\r\nvar StatsCollection = /** @class */ (function () {\r\n    function StatsCollection() {\r\n        this.counters_ = {};\r\n    }\r\n    StatsCollection.prototype.incrementCounter = function (name, amount) {\r\n        if (amount === void 0) { amount = 1; }\r\n        if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(this.counters_, name)) {\r\n            this.counters_[name] = 0;\r\n        }\r\n        this.counters_[name] += amount;\r\n    };\r\n    StatsCollection.prototype.get = function () {\r\n        return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.deepCopy)(this.counters_);\r\n    };\r\n    return StatsCollection;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar StatsManager = /** @class */ (function () {\r\n    function StatsManager() {\r\n    }\r\n    StatsManager.getCollection = function (repoInfo) {\r\n        var hashString = repoInfo.toString();\r\n        if (!this.collections_[hashString]) {\r\n            this.collections_[hashString] = new StatsCollection();\r\n        }\r\n        return this.collections_[hashString];\r\n    };\r\n    StatsManager.getOrCreateReporter = function (repoInfo, creatorFunction) {\r\n        var hashString = repoInfo.toString();\r\n        if (!this.reporters_[hashString]) {\r\n            this.reporters_[hashString] = creatorFunction();\r\n        }\r\n        return this.reporters_[hashString];\r\n    };\r\n    StatsManager.collections_ = {};\r\n    StatsManager.reporters_ = {};\r\n    return StatsManager;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Returns the delta from the previous call to get stats.\r\n *\r\n * @param collection_ The collection to \"listen\" to.\r\n * @constructor\r\n */\r\nvar StatsListener = /** @class */ (function () {\r\n    function StatsListener(collection_) {\r\n        this.collection_ = collection_;\r\n        this.last_ = null;\r\n    }\r\n    StatsListener.prototype.get = function () {\r\n        var newStats = this.collection_.get();\r\n        var delta = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, newStats);\r\n        if (this.last_) {\r\n            each(this.last_, function (stat, value) {\r\n                delta[stat] = delta[stat] - value;\r\n            });\r\n        }\r\n        this.last_ = newStats;\r\n        return delta;\r\n    };\r\n    return StatsListener;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// Assuming some apps may have a short amount of time on page, and a bulk of firebase operations probably\r\n// happen on page load, we try to report our first set of stats pretty quickly, but we wait at least 10\r\n// seconds to try to ensure the Firebase connection is established / settled.\r\nvar FIRST_STATS_MIN_TIME = 10 * 1000;\r\nvar FIRST_STATS_MAX_TIME = 30 * 1000;\r\n// We'll continue to report stats on average every 5 minutes.\r\nvar REPORT_STATS_INTERVAL = 5 * 60 * 1000;\r\n/**\r\n * @constructor\r\n */\r\nvar StatsReporter = /** @class */ (function () {\r\n    /**\r\n     * @param collection\r\n     * @param server_\r\n     */\r\n    function StatsReporter(collection, server_) {\r\n        this.server_ = server_;\r\n        this.statsToReport_ = {};\r\n        this.statsListener_ = new StatsListener(collection);\r\n        var timeout = FIRST_STATS_MIN_TIME +\r\n            (FIRST_STATS_MAX_TIME - FIRST_STATS_MIN_TIME) * Math.random();\r\n        setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(timeout));\r\n    }\r\n    StatsReporter.prototype.includeStat = function (stat) {\r\n        this.statsToReport_[stat] = true;\r\n    };\r\n    StatsReporter.prototype.reportStats_ = function () {\r\n        var _this = this;\r\n        var stats = this.statsListener_.get();\r\n        var reportedStats = {};\r\n        var haveStatsToReport = false;\r\n        each(stats, function (stat, value) {\r\n            if (value > 0 && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(_this.statsToReport_, stat)) {\r\n                reportedStats[stat] = value;\r\n                haveStatsToReport = true;\r\n            }\r\n        });\r\n        if (haveStatsToReport) {\r\n            this.server_.reportStats(reportedStats);\r\n        }\r\n        // queue our next run.\r\n        setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(Math.random() * 2 * REPORT_STATS_INTERVAL));\r\n    };\r\n    return StatsReporter;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * The event queue serves a few purposes:\r\n * 1. It ensures we maintain event order in the face of event callbacks doing operations that result in more\r\n *    events being queued.\r\n * 2. raiseQueuedEvents() handles being called reentrantly nicely.  That is, if in the course of raising events,\r\n *    raiseQueuedEvents() is called again, the \"inner\" call will pick up raising events where the \"outer\" call\r\n *    left off, ensuring that the events are still raised synchronously and in order.\r\n * 3. You can use raiseEventsAtPath and raiseEventsForChangedPath to ensure only relevant previously-queued\r\n *    events are raised synchronously.\r\n *\r\n * NOTE: This can all go away if/when we move to async events.\r\n *\r\n * @constructor\r\n */\r\nvar EventQueue = /** @class */ (function () {\r\n    function EventQueue() {\r\n        /**\r\n         * @private\r\n         * @type {!Array.<EventList>}\r\n         */\r\n        this.eventLists_ = [];\r\n        /**\r\n         * Tracks recursion depth of raiseQueuedEvents_, for debugging purposes.\r\n         * @private\r\n         * @type {!number}\r\n         */\r\n        this.recursionDepth_ = 0;\r\n    }\r\n    /**\r\n     * @param {!Array.<Event>} eventDataList The new events to queue.\r\n     */\r\n    EventQueue.prototype.queueEvents = function (eventDataList) {\r\n        // We group events by path, storing them in a single EventList, to make it easier to skip over them quickly.\r\n        var currList = null;\r\n        for (var i = 0; i < eventDataList.length; i++) {\r\n            var eventData = eventDataList[i];\r\n            var eventPath = eventData.getPath();\r\n            if (currList !== null && !eventPath.equals(currList.getPath())) {\r\n                this.eventLists_.push(currList);\r\n                currList = null;\r\n            }\r\n            if (currList === null) {\r\n                currList = new EventList(eventPath);\r\n            }\r\n            currList.add(eventData);\r\n        }\r\n        if (currList) {\r\n            this.eventLists_.push(currList);\r\n        }\r\n    };\r\n    /**\r\n     * Queues the specified events and synchronously raises all events (including previously queued ones)\r\n     * for the specified path.\r\n     *\r\n     * It is assumed that the new events are all for the specified path.\r\n     *\r\n     * @param {!Path} path The path to raise events for.\r\n     * @param {!Array.<Event>} eventDataList The new events to raise.\r\n     */\r\n    EventQueue.prototype.raiseEventsAtPath = function (path, eventDataList) {\r\n        this.queueEvents(eventDataList);\r\n        this.raiseQueuedEventsMatchingPredicate_(function (eventPath) {\r\n            return eventPath.equals(path);\r\n        });\r\n    };\r\n    /**\r\n     * Queues the specified events and synchronously raises all events (including previously queued ones) for\r\n     * locations related to the specified change path (i.e. all ancestors and descendants).\r\n     *\r\n     * It is assumed that the new events are all related (ancestor or descendant) to the specified path.\r\n     *\r\n     * @param {!Path} changedPath The path to raise events for.\r\n     * @param {!Array.<!Event>} eventDataList The events to raise\r\n     */\r\n    EventQueue.prototype.raiseEventsForChangedPath = function (changedPath, eventDataList) {\r\n        this.queueEvents(eventDataList);\r\n        this.raiseQueuedEventsMatchingPredicate_(function (eventPath) {\r\n            return eventPath.contains(changedPath) || changedPath.contains(eventPath);\r\n        });\r\n    };\r\n    /**\r\n     * @param {!function(!Path):boolean} predicate\r\n     * @private\r\n     */\r\n    EventQueue.prototype.raiseQueuedEventsMatchingPredicate_ = function (predicate) {\r\n        this.recursionDepth_++;\r\n        var sentAll = true;\r\n        for (var i = 0; i < this.eventLists_.length; i++) {\r\n            var eventList = this.eventLists_[i];\r\n            if (eventList) {\r\n                var eventPath = eventList.getPath();\r\n                if (predicate(eventPath)) {\r\n                    this.eventLists_[i].raise();\r\n                    this.eventLists_[i] = null;\r\n                }\r\n                else {\r\n                    sentAll = false;\r\n                }\r\n            }\r\n        }\r\n        if (sentAll) {\r\n            this.eventLists_ = [];\r\n        }\r\n        this.recursionDepth_--;\r\n    };\r\n    return EventQueue;\r\n}());\r\n/**\r\n * @param {!Path} path\r\n * @constructor\r\n */\r\nvar EventList = /** @class */ (function () {\r\n    function EventList(path_) {\r\n        this.path_ = path_;\r\n        /**\r\n         * @type {!Array.<Event>}\r\n         * @private\r\n         */\r\n        this.events_ = [];\r\n    }\r\n    /**\r\n     * @param {!Event} eventData\r\n     */\r\n    EventList.prototype.add = function (eventData) {\r\n        this.events_.push(eventData);\r\n    };\r\n    /**\r\n     * Iterates through the list and raises each event\r\n     */\r\n    EventList.prototype.raise = function () {\r\n        for (var i = 0; i < this.events_.length; i++) {\r\n            var eventData = this.events_[i];\r\n            if (eventData !== null) {\r\n                this.events_[i] = null;\r\n                var eventFn = eventData.getEventRunner();\r\n                if (logger) {\r\n                    log('event: ' + eventData.toString());\r\n                }\r\n                exceptionGuard(eventFn);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * @return {!Path}\r\n     */\r\n    EventList.prototype.getPath = function () {\r\n        return this.path_;\r\n    };\r\n    return EventList;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Base class to be used if you want to emit events. Call the constructor with\r\n * the set of allowed event names.\r\n */\r\nvar EventEmitter = /** @class */ (function () {\r\n    /**\r\n     * @param {!Array.<string>} allowedEvents_\r\n     */\r\n    function EventEmitter(allowedEvents_) {\r\n        this.allowedEvents_ = allowedEvents_;\r\n        this.listeners_ = {};\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(Array.isArray(allowedEvents_) && allowedEvents_.length > 0, 'Requires a non-empty array');\r\n    }\r\n    /**\r\n     * To be called by derived classes to trigger events.\r\n     * @param {!string} eventType\r\n     * @param {...*} varArgs\r\n     */\r\n    EventEmitter.prototype.trigger = function (eventType) {\r\n        var varArgs = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            varArgs[_i - 1] = arguments[_i];\r\n        }\r\n        if (Array.isArray(this.listeners_[eventType])) {\r\n            // Clone the list, since callbacks could add/remove listeners.\r\n            var listeners = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spread)(this.listeners_[eventType]);\r\n            for (var i = 0; i < listeners.length; i++) {\r\n                listeners[i].callback.apply(listeners[i].context, varArgs);\r\n            }\r\n        }\r\n    };\r\n    EventEmitter.prototype.on = function (eventType, callback, context) {\r\n        this.validateEventType_(eventType);\r\n        this.listeners_[eventType] = this.listeners_[eventType] || [];\r\n        this.listeners_[eventType].push({ callback: callback, context: context });\r\n        var eventData = this.getInitialEvent(eventType);\r\n        if (eventData) {\r\n            callback.apply(context, eventData);\r\n        }\r\n    };\r\n    EventEmitter.prototype.off = function (eventType, callback, context) {\r\n        this.validateEventType_(eventType);\r\n        var listeners = this.listeners_[eventType] || [];\r\n        for (var i = 0; i < listeners.length; i++) {\r\n            if (listeners[i].callback === callback &&\r\n                (!context || context === listeners[i].context)) {\r\n                listeners.splice(i, 1);\r\n                return;\r\n            }\r\n        }\r\n    };\r\n    EventEmitter.prototype.validateEventType_ = function (eventType) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.allowedEvents_.find(function (et) {\r\n            return et === eventType;\r\n        }), 'Unknown event: ' + eventType);\r\n    };\r\n    return EventEmitter;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * @extends {EventEmitter}\r\n */\r\nvar VisibilityMonitor = /** @class */ (function (_super) {\r\n    (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(VisibilityMonitor, _super);\r\n    function VisibilityMonitor() {\r\n        var _this = _super.call(this, ['visible']) || this;\r\n        var hidden;\r\n        var visibilityChange;\r\n        if (typeof document !== 'undefined' &&\r\n            typeof document.addEventListener !== 'undefined') {\r\n            if (typeof document['hidden'] !== 'undefined') {\r\n                // Opera 12.10 and Firefox 18 and later support\r\n                visibilityChange = 'visibilitychange';\r\n                hidden = 'hidden';\r\n            }\r\n            else if (typeof document['mozHidden'] !== 'undefined') {\r\n                visibilityChange = 'mozvisibilitychange';\r\n                hidden = 'mozHidden';\r\n            }\r\n            else if (typeof document['msHidden'] !== 'undefined') {\r\n                visibilityChange = 'msvisibilitychange';\r\n                hidden = 'msHidden';\r\n            }\r\n            else if (typeof document['webkitHidden'] !== 'undefined') {\r\n                visibilityChange = 'webkitvisibilitychange';\r\n                hidden = 'webkitHidden';\r\n            }\r\n        }\r\n        // Initially, we always assume we are visible. This ensures that in browsers\r\n        // without page visibility support or in cases where we are never visible\r\n        // (e.g. chrome extension), we act as if we are visible, i.e. don't delay\r\n        // reconnects\r\n        _this.visible_ = true;\r\n        if (visibilityChange) {\r\n            document.addEventListener(visibilityChange, function () {\r\n                var visible = !document[hidden];\r\n                if (visible !== _this.visible_) {\r\n                    _this.visible_ = visible;\r\n                    _this.trigger('visible', visible);\r\n                }\r\n            }, false);\r\n        }\r\n        return _this;\r\n    }\r\n    VisibilityMonitor.getInstance = function () {\r\n        return new VisibilityMonitor();\r\n    };\r\n    /**\r\n     * @param {!string} eventType\r\n     * @return {Array.<boolean>}\r\n     */\r\n    VisibilityMonitor.prototype.getInitialEvent = function (eventType) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(eventType === 'visible', 'Unknown event type: ' + eventType);\r\n        return [this.visible_];\r\n    };\r\n    return VisibilityMonitor;\r\n}(EventEmitter));\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Monitors online state (as reported by window.online/offline events).\r\n *\r\n * The expectation is that this could have many false positives (thinks we are online\r\n * when we're not), but no false negatives.  So we can safely use it to determine when\r\n * we definitely cannot reach the internet.\r\n *\r\n * @extends {EventEmitter}\r\n */\r\nvar OnlineMonitor = /** @class */ (function (_super) {\r\n    (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(OnlineMonitor, _super);\r\n    function OnlineMonitor() {\r\n        var _this = _super.call(this, ['online']) || this;\r\n        _this.online_ = true;\r\n        // We've had repeated complaints that Cordova apps can get stuck \"offline\", e.g.\r\n        // https://forum.ionicframework.com/t/firebase-connection-is-lost-and-never-come-back/43810\r\n        // It would seem that the 'online' event does not always fire consistently. So we disable it\r\n        // for Cordova.\r\n        if (typeof window !== 'undefined' &&\r\n            typeof window.addEventListener !== 'undefined' &&\r\n            !(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isMobileCordova)()) {\r\n            window.addEventListener('online', function () {\r\n                if (!_this.online_) {\r\n                    _this.online_ = true;\r\n                    _this.trigger('online', true);\r\n                }\r\n            }, false);\r\n            window.addEventListener('offline', function () {\r\n                if (_this.online_) {\r\n                    _this.online_ = false;\r\n                    _this.trigger('online', false);\r\n                }\r\n            }, false);\r\n        }\r\n        return _this;\r\n    }\r\n    OnlineMonitor.getInstance = function () {\r\n        return new OnlineMonitor();\r\n    };\r\n    /**\r\n     * @param {!string} eventType\r\n     * @return {Array.<boolean>}\r\n     */\r\n    OnlineMonitor.prototype.getInitialEvent = function (eventType) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(eventType === 'online', 'Unknown event type: ' + eventType);\r\n        return [this.online_];\r\n    };\r\n    /**\r\n     * @return {boolean}\r\n     */\r\n    OnlineMonitor.prototype.currentlyOnline = function () {\r\n        return this.online_;\r\n    };\r\n    return OnlineMonitor;\r\n}(EventEmitter));\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * This class ensures the packets from the server arrive in order\r\n * This class takes data from the server and ensures it gets passed into the callbacks in order.\r\n * @constructor\r\n */\r\nvar PacketReceiver = /** @class */ (function () {\r\n    /**\r\n     * @param onMessage_\r\n     */\r\n    function PacketReceiver(onMessage_) {\r\n        this.onMessage_ = onMessage_;\r\n        this.pendingResponses = [];\r\n        this.currentResponseNum = 0;\r\n        this.closeAfterResponse = -1;\r\n        this.onClose = null;\r\n    }\r\n    PacketReceiver.prototype.closeAfter = function (responseNum, callback) {\r\n        this.closeAfterResponse = responseNum;\r\n        this.onClose = callback;\r\n        if (this.closeAfterResponse < this.currentResponseNum) {\r\n            this.onClose();\r\n            this.onClose = null;\r\n        }\r\n    };\r\n    /**\r\n     * Each message from the server comes with a response number, and an array of data. The responseNumber\r\n     * allows us to ensure that we process them in the right order, since we can't be guaranteed that all\r\n     * browsers will respond in the same order as the requests we sent\r\n     * @param {number} requestNum\r\n     * @param {Array} data\r\n     */\r\n    PacketReceiver.prototype.handleResponse = function (requestNum, data) {\r\n        var _this = this;\r\n        this.pendingResponses[requestNum] = data;\r\n        var _loop_1 = function () {\r\n            var toProcess = this_1.pendingResponses[this_1.currentResponseNum];\r\n            delete this_1.pendingResponses[this_1.currentResponseNum];\r\n            var _loop_2 = function (i) {\r\n                if (toProcess[i]) {\r\n                    exceptionGuard(function () {\r\n                        _this.onMessage_(toProcess[i]);\r\n                    });\r\n                }\r\n            };\r\n            for (var i = 0; i < toProcess.length; ++i) {\r\n                _loop_2(i);\r\n            }\r\n            if (this_1.currentResponseNum === this_1.closeAfterResponse) {\r\n                if (this_1.onClose) {\r\n                    this_1.onClose();\r\n                    this_1.onClose = null;\r\n                }\r\n                return \"break\";\r\n            }\r\n            this_1.currentResponseNum++;\r\n        };\r\n        var this_1 = this;\r\n        while (this.pendingResponses[this.currentResponseNum]) {\r\n            var state_1 = _loop_1();\r\n            if (state_1 === \"break\")\r\n                break;\r\n        }\r\n    };\r\n    return PacketReceiver;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// URL query parameters associated with longpolling\r\nvar FIREBASE_LONGPOLL_START_PARAM = 'start';\r\nvar FIREBASE_LONGPOLL_CLOSE_COMMAND = 'close';\r\nvar FIREBASE_LONGPOLL_COMMAND_CB_NAME = 'pLPCommand';\r\nvar FIREBASE_LONGPOLL_DATA_CB_NAME = 'pRTLPCB';\r\nvar FIREBASE_LONGPOLL_ID_PARAM = 'id';\r\nvar FIREBASE_LONGPOLL_PW_PARAM = 'pw';\r\nvar FIREBASE_LONGPOLL_SERIAL_PARAM = 'ser';\r\nvar FIREBASE_LONGPOLL_CALLBACK_ID_PARAM = 'cb';\r\nvar FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM = 'seg';\r\nvar FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET = 'ts';\r\nvar FIREBASE_LONGPOLL_DATA_PARAM = 'd';\r\nvar FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM = 'dframe';\r\n//Data size constants.\r\n//TODO: Perf: the maximum length actually differs from browser to browser.\r\n// We should check what browser we're on and set accordingly.\r\nvar MAX_URL_DATA_SIZE = 1870;\r\nvar SEG_HEADER_SIZE = 30; //ie: &seg=8299234&ts=982389123&d=\r\nvar MAX_PAYLOAD_SIZE = MAX_URL_DATA_SIZE - SEG_HEADER_SIZE;\r\n/**\r\n * Keepalive period\r\n * send a fresh request at minimum every 25 seconds. Opera has a maximum request\r\n * length of 30 seconds that we can't exceed.\r\n * @const\r\n * @type {number}\r\n */\r\nvar KEEPALIVE_REQUEST_INTERVAL = 25000;\r\n/**\r\n * How long to wait before aborting a long-polling connection attempt.\r\n * @const\r\n * @type {number}\r\n */\r\nvar LP_CONNECT_TIMEOUT = 30000;\r\n/**\r\n * This class manages a single long-polling connection.\r\n *\r\n * @constructor\r\n * @implements {Transport}\r\n */\r\nvar BrowserPollConnection = /** @class */ (function () {\r\n    /**\r\n     * @param connId An identifier for this connection, used for logging\r\n     * @param repoInfo The info for the endpoint to send data to.\r\n     * @param applicationId The Firebase App ID for this project.\r\n     * @param transportSessionId Optional transportSessionid if we are reconnecting for an existing\r\n     *                                         transport session\r\n     * @param lastSessionId Optional lastSessionId if the PersistentConnection has already created a\r\n     *                                     connection previously\r\n     */\r\n    function BrowserPollConnection(connId, repoInfo, applicationId, transportSessionId, lastSessionId) {\r\n        this.connId = connId;\r\n        this.repoInfo = repoInfo;\r\n        this.applicationId = applicationId;\r\n        this.transportSessionId = transportSessionId;\r\n        this.lastSessionId = lastSessionId;\r\n        this.bytesSent = 0;\r\n        this.bytesReceived = 0;\r\n        this.everConnected_ = false;\r\n        this.log_ = logWrapper(connId);\r\n        this.stats_ = StatsManager.getCollection(repoInfo);\r\n        this.urlFn = function (params) {\r\n            return repoInfo.connectionURL(LONG_POLLING, params);\r\n        };\r\n    }\r\n    /**\r\n     *\r\n     * @param {function(Object)} onMessage Callback when messages arrive\r\n     * @param {function()} onDisconnect Callback with connection lost.\r\n     */\r\n    BrowserPollConnection.prototype.open = function (onMessage, onDisconnect) {\r\n        var _this = this;\r\n        this.curSegmentNum = 0;\r\n        this.onDisconnect_ = onDisconnect;\r\n        this.myPacketOrderer = new PacketReceiver(onMessage);\r\n        this.isClosed_ = false;\r\n        this.connectTimeoutTimer_ = setTimeout(function () {\r\n            _this.log_('Timed out trying to connect.');\r\n            // Make sure we clear the host cache\r\n            _this.onClosed_();\r\n            _this.connectTimeoutTimer_ = null;\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        }, Math.floor(LP_CONNECT_TIMEOUT));\r\n        // Ensure we delay the creation of the iframe until the DOM is loaded.\r\n        executeWhenDOMReady(function () {\r\n            if (_this.isClosed_) {\r\n                return;\r\n            }\r\n            //Set up a callback that gets triggered once a connection is set up.\r\n            _this.scriptTagHolder = new FirebaseIFrameScriptHolder(function () {\r\n                var args = [];\r\n                for (var _i = 0; _i < arguments.length; _i++) {\r\n                    args[_i] = arguments[_i];\r\n                }\r\n                var _a = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__read)(args, 5), command = _a[0], arg1 = _a[1], arg2 = _a[2], arg3 = _a[3], arg4 = _a[4];\r\n                _this.incrementIncomingBytes_(args);\r\n                if (!_this.scriptTagHolder) {\r\n                    return; // we closed the connection.\r\n                }\r\n                if (_this.connectTimeoutTimer_) {\r\n                    clearTimeout(_this.connectTimeoutTimer_);\r\n                    _this.connectTimeoutTimer_ = null;\r\n                }\r\n                _this.everConnected_ = true;\r\n                if (command === FIREBASE_LONGPOLL_START_PARAM) {\r\n                    _this.id = arg1;\r\n                    _this.password = arg2;\r\n                }\r\n                else if (command === FIREBASE_LONGPOLL_CLOSE_COMMAND) {\r\n                    // Don't clear the host cache. We got a response from the server, so we know it's reachable\r\n                    if (arg1) {\r\n                        // We aren't expecting any more data (other than what the server's already in the process of sending us\r\n                        // through our already open polls), so don't send any more.\r\n                        _this.scriptTagHolder.sendNewPolls = false;\r\n                        // arg1 in this case is the last response number sent by the server. We should try to receive\r\n                        // all of the responses up to this one before closing\r\n                        _this.myPacketOrderer.closeAfter(arg1, function () {\r\n                            _this.onClosed_();\r\n                        });\r\n                    }\r\n                    else {\r\n                        _this.onClosed_();\r\n                    }\r\n                }\r\n                else {\r\n                    throw new Error('Unrecognized command received: ' + command);\r\n                }\r\n            }, function () {\r\n                var args = [];\r\n                for (var _i = 0; _i < arguments.length; _i++) {\r\n                    args[_i] = arguments[_i];\r\n                }\r\n                var _a = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__read)(args, 2), pN = _a[0], data = _a[1];\r\n                _this.incrementIncomingBytes_(args);\r\n                _this.myPacketOrderer.handleResponse(pN, data);\r\n            }, function () {\r\n                _this.onClosed_();\r\n            }, _this.urlFn);\r\n            //Send the initial request to connect. The serial number is simply to keep the browser from pulling previous results\r\n            //from cache.\r\n            var urlParams = {};\r\n            urlParams[FIREBASE_LONGPOLL_START_PARAM] = 't';\r\n            urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = Math.floor(Math.random() * 100000000);\r\n            if (_this.scriptTagHolder.uniqueCallbackIdentifier) {\r\n                urlParams[FIREBASE_LONGPOLL_CALLBACK_ID_PARAM] = _this.scriptTagHolder.uniqueCallbackIdentifier;\r\n            }\r\n            urlParams[VERSION_PARAM] = PROTOCOL_VERSION;\r\n            if (_this.transportSessionId) {\r\n                urlParams[TRANSPORT_SESSION_PARAM] = _this.transportSessionId;\r\n            }\r\n            if (_this.lastSessionId) {\r\n                urlParams[LAST_SESSION_PARAM] = _this.lastSessionId;\r\n            }\r\n            if (_this.applicationId) {\r\n                urlParams[APPLICATION_ID_PARAM] = _this.applicationId;\r\n            }\r\n            if (typeof location !== 'undefined' &&\r\n                location.href &&\r\n                location.href.indexOf(FORGE_DOMAIN) !== -1) {\r\n                urlParams[REFERER_PARAM] = FORGE_REF;\r\n            }\r\n            var connectURL = _this.urlFn(urlParams);\r\n            _this.log_('Connecting via long-poll to ' + connectURL);\r\n            _this.scriptTagHolder.addTag(connectURL, function () {\r\n                /* do nothing */\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Call this when a handshake has completed successfully and we want to consider the connection established\r\n     */\r\n    BrowserPollConnection.prototype.start = function () {\r\n        this.scriptTagHolder.startLongPoll(this.id, this.password);\r\n        this.addDisconnectPingFrame(this.id, this.password);\r\n    };\r\n    /**\r\n     * Forces long polling to be considered as a potential transport\r\n     */\r\n    BrowserPollConnection.forceAllow = function () {\r\n        BrowserPollConnection.forceAllow_ = true;\r\n    };\r\n    /**\r\n     * Forces longpolling to not be considered as a potential transport\r\n     */\r\n    BrowserPollConnection.forceDisallow = function () {\r\n        BrowserPollConnection.forceDisallow_ = true;\r\n    };\r\n    // Static method, use string literal so it can be accessed in a generic way\r\n    BrowserPollConnection.isAvailable = function () {\r\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isNodeSdk)()) {\r\n            return false;\r\n        }\r\n        else if (BrowserPollConnection.forceAllow_) {\r\n            return true;\r\n        }\r\n        else {\r\n            // NOTE: In React-Native there's normally no 'document', but if you debug a React-Native app in\r\n            // the Chrome debugger, 'document' is defined, but document.createElement is null (2015/06/08).\r\n            return (!BrowserPollConnection.forceDisallow_ &&\r\n                typeof document !== 'undefined' &&\r\n                document.createElement != null &&\r\n                !isChromeExtensionContentScript() &&\r\n                !isWindowsStoreApp());\r\n        }\r\n    };\r\n    /**\r\n     * No-op for polling\r\n     */\r\n    BrowserPollConnection.prototype.markConnectionHealthy = function () { };\r\n    /**\r\n     * Stops polling and cleans up the iframe\r\n     * @private\r\n     */\r\n    BrowserPollConnection.prototype.shutdown_ = function () {\r\n        this.isClosed_ = true;\r\n        if (this.scriptTagHolder) {\r\n            this.scriptTagHolder.close();\r\n            this.scriptTagHolder = null;\r\n        }\r\n        //remove the disconnect frame, which will trigger an XHR call to the server to tell it we're leaving.\r\n        if (this.myDisconnFrame) {\r\n            document.body.removeChild(this.myDisconnFrame);\r\n            this.myDisconnFrame = null;\r\n        }\r\n        if (this.connectTimeoutTimer_) {\r\n            clearTimeout(this.connectTimeoutTimer_);\r\n            this.connectTimeoutTimer_ = null;\r\n        }\r\n    };\r\n    /**\r\n     * Triggered when this transport is closed\r\n     * @private\r\n     */\r\n    BrowserPollConnection.prototype.onClosed_ = function () {\r\n        if (!this.isClosed_) {\r\n            this.log_('Longpoll is closing itself');\r\n            this.shutdown_();\r\n            if (this.onDisconnect_) {\r\n                this.onDisconnect_(this.everConnected_);\r\n                this.onDisconnect_ = null;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * External-facing close handler. RealTime has requested we shut down. Kill our connection and tell the server\r\n     * that we've left.\r\n     */\r\n    BrowserPollConnection.prototype.close = function () {\r\n        if (!this.isClosed_) {\r\n            this.log_('Longpoll is being closed.');\r\n            this.shutdown_();\r\n        }\r\n    };\r\n    /**\r\n     * Send the JSON object down to the server. It will need to be stringified, base64 encoded, and then\r\n     * broken into chunks (since URLs have a small maximum length).\r\n     * @param {!Object} data The JSON data to transmit.\r\n     */\r\n    BrowserPollConnection.prototype.send = function (data) {\r\n        var dataStr = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(data);\r\n        this.bytesSent += dataStr.length;\r\n        this.stats_.incrementCounter('bytes_sent', dataStr.length);\r\n        //first, lets get the base64-encoded data\r\n        var base64data = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.base64Encode)(dataStr);\r\n        //We can only fit a certain amount in each URL, so we need to split this request\r\n        //up into multiple pieces if it doesn't fit in one request.\r\n        var dataSegs = splitStringBySize(base64data, MAX_PAYLOAD_SIZE);\r\n        //Enqueue each segment for transmission. We assign each chunk a sequential ID and a total number\r\n        //of segments so that we can reassemble the packet on the server.\r\n        for (var i = 0; i < dataSegs.length; i++) {\r\n            this.scriptTagHolder.enqueueSegment(this.curSegmentNum, dataSegs.length, dataSegs[i]);\r\n            this.curSegmentNum++;\r\n        }\r\n    };\r\n    /**\r\n     * This is how we notify the server that we're leaving.\r\n     * We aren't able to send requests with DHTML on a window close event, but we can\r\n     * trigger XHR requests in some browsers (everything but Opera basically).\r\n     * @param {!string} id\r\n     * @param {!string} pw\r\n     */\r\n    BrowserPollConnection.prototype.addDisconnectPingFrame = function (id, pw) {\r\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isNodeSdk)()) {\r\n            return;\r\n        }\r\n        this.myDisconnFrame = document.createElement('iframe');\r\n        var urlParams = {};\r\n        urlParams[FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM] = 't';\r\n        urlParams[FIREBASE_LONGPOLL_ID_PARAM] = id;\r\n        urlParams[FIREBASE_LONGPOLL_PW_PARAM] = pw;\r\n        this.myDisconnFrame.src = this.urlFn(urlParams);\r\n        this.myDisconnFrame.style.display = 'none';\r\n        document.body.appendChild(this.myDisconnFrame);\r\n    };\r\n    /**\r\n     * Used to track the bytes received by this client\r\n     * @param {*} args\r\n     * @private\r\n     */\r\n    BrowserPollConnection.prototype.incrementIncomingBytes_ = function (args) {\r\n        // TODO: This is an annoying perf hit just to track the number of incoming bytes.  Maybe it should be opt-in.\r\n        var bytesReceived = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(args).length;\r\n        this.bytesReceived += bytesReceived;\r\n        this.stats_.incrementCounter('bytes_received', bytesReceived);\r\n    };\r\n    return BrowserPollConnection;\r\n}());\r\n/*********************************************************************************************\r\n * A wrapper around an iframe that is used as a long-polling script holder.\r\n * @constructor\r\n *********************************************************************************************/\r\nvar FirebaseIFrameScriptHolder = /** @class */ (function () {\r\n    /**\r\n     * @param commandCB - The callback to be called when control commands are recevied from the server.\r\n     * @param onMessageCB - The callback to be triggered when responses arrive from the server.\r\n     * @param onDisconnect - The callback to be triggered when this tag holder is closed\r\n     * @param urlFn - A function that provides the URL of the endpoint to send data to.\r\n     */\r\n    function FirebaseIFrameScriptHolder(commandCB, onMessageCB, onDisconnect, urlFn) {\r\n        this.onDisconnect = onDisconnect;\r\n        this.urlFn = urlFn;\r\n        //We maintain a count of all of the outstanding requests, because if we have too many active at once it can cause\r\n        //problems in some browsers.\r\n        this.outstandingRequests = new Set();\r\n        //A queue of the pending segments waiting for transmission to the server.\r\n        this.pendingSegs = [];\r\n        //A serial number. We use this for two things:\r\n        // 1) A way to ensure the browser doesn't cache responses to polls\r\n        // 2) A way to make the server aware when long-polls arrive in a different order than we started them. The\r\n        //    server needs to release both polls in this case or it will cause problems in Opera since Opera can only execute\r\n        //    JSONP code in the order it was added to the iframe.\r\n        this.currentSerial = Math.floor(Math.random() * 100000000);\r\n        // This gets set to false when we're \"closing down\" the connection (e.g. we're switching transports but there's still\r\n        // incoming data from the server that we're waiting for).\r\n        this.sendNewPolls = true;\r\n        if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isNodeSdk)()) {\r\n            //Each script holder registers a couple of uniquely named callbacks with the window. These are called from the\r\n            //iframes where we put the long-polling script tags. We have two callbacks:\r\n            //   1) Command Callback - Triggered for control issues, like starting a connection.\r\n            //   2) Message Callback - Triggered when new data arrives.\r\n            this.uniqueCallbackIdentifier = LUIDGenerator();\r\n            window[FIREBASE_LONGPOLL_COMMAND_CB_NAME + this.uniqueCallbackIdentifier] = commandCB;\r\n            window[FIREBASE_LONGPOLL_DATA_CB_NAME + this.uniqueCallbackIdentifier] = onMessageCB;\r\n            //Create an iframe for us to add script tags to.\r\n            this.myIFrame = FirebaseIFrameScriptHolder.createIFrame_();\r\n            // Set the iframe's contents.\r\n            var script = '';\r\n            // if we set a javascript url, it's IE and we need to set the document domain. The javascript url is sufficient\r\n            // for ie9, but ie8 needs to do it again in the document itself.\r\n            if (this.myIFrame.src &&\r\n                this.myIFrame.src.substr(0, 'javascript:'.length) === 'javascript:') {\r\n                var currentDomain = document.domain;\r\n                script = '<script>document.domain=\"' + currentDomain + '\";</script>';\r\n            }\r\n            var iframeContents = '<html><body>' + script + '</body></html>';\r\n            try {\r\n                this.myIFrame.doc.open();\r\n                this.myIFrame.doc.write(iframeContents);\r\n                this.myIFrame.doc.close();\r\n            }\r\n            catch (e) {\r\n                log('frame writing exception');\r\n                if (e.stack) {\r\n                    log(e.stack);\r\n                }\r\n                log(e);\r\n            }\r\n        }\r\n        else {\r\n            this.commandCB = commandCB;\r\n            this.onMessageCB = onMessageCB;\r\n        }\r\n    }\r\n    /**\r\n     * Each browser has its own funny way to handle iframes. Here we mush them all together into one object that I can\r\n     * actually use.\r\n     * @private\r\n     * @return {Element}\r\n     */\r\n    FirebaseIFrameScriptHolder.createIFrame_ = function () {\r\n        var iframe = document.createElement('iframe');\r\n        iframe.style.display = 'none';\r\n        // This is necessary in order to initialize the document inside the iframe\r\n        if (document.body) {\r\n            document.body.appendChild(iframe);\r\n            try {\r\n                // If document.domain has been modified in IE, this will throw an error, and we need to set the\r\n                // domain of the iframe's document manually. We can do this via a javascript: url as the src attribute\r\n                // Also note that we must do this *after* the iframe has been appended to the page. Otherwise it doesn't work.\r\n                var a = iframe.contentWindow.document;\r\n                if (!a) {\r\n                    // Apologies for the log-spam, I need to do something to keep closure from optimizing out the assignment above.\r\n                    log('No IE domain setting required');\r\n                }\r\n            }\r\n            catch (e) {\r\n                var domain = document.domain;\r\n                iframe.src =\r\n                    \"javascript:void((function(){document.open();document.domain='\" +\r\n                        domain +\r\n                        \"';document.close();})())\";\r\n            }\r\n        }\r\n        else {\r\n            // LongPollConnection attempts to delay initialization until the document is ready, so hopefully this\r\n            // never gets hit.\r\n            throw 'Document body has not initialized. Wait to initialize Firebase until after the document is ready.';\r\n        }\r\n        // Get the document of the iframe in a browser-specific way.\r\n        if (iframe.contentDocument) {\r\n            iframe.doc = iframe.contentDocument; // Firefox, Opera, Safari\r\n        }\r\n        else if (iframe.contentWindow) {\r\n            iframe.doc = iframe.contentWindow.document; // Internet Explorer\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        }\r\n        else if (iframe.document) {\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            iframe.doc = iframe.document; //others?\r\n        }\r\n        return iframe;\r\n    };\r\n    /**\r\n     * Cancel all outstanding queries and remove the frame.\r\n     */\r\n    FirebaseIFrameScriptHolder.prototype.close = function () {\r\n        var _this = this;\r\n        //Mark this iframe as dead, so no new requests are sent.\r\n        this.alive = false;\r\n        if (this.myIFrame) {\r\n            //We have to actually remove all of the html inside this iframe before removing it from the\r\n            //window, or IE will continue loading and executing the script tags we've already added, which\r\n            //can lead to some errors being thrown. Setting innerHTML seems to be the easiest way to do this.\r\n            this.myIFrame.doc.body.innerHTML = '';\r\n            setTimeout(function () {\r\n                if (_this.myIFrame !== null) {\r\n                    document.body.removeChild(_this.myIFrame);\r\n                    _this.myIFrame = null;\r\n                }\r\n            }, Math.floor(0));\r\n        }\r\n        // Protect from being called recursively.\r\n        var onDisconnect = this.onDisconnect;\r\n        if (onDisconnect) {\r\n            this.onDisconnect = null;\r\n            onDisconnect();\r\n        }\r\n    };\r\n    /**\r\n     * Actually start the long-polling session by adding the first script tag(s) to the iframe.\r\n     * @param {!string} id - The ID of this connection\r\n     * @param {!string} pw - The password for this connection\r\n     */\r\n    FirebaseIFrameScriptHolder.prototype.startLongPoll = function (id, pw) {\r\n        this.myID = id;\r\n        this.myPW = pw;\r\n        this.alive = true;\r\n        //send the initial request. If there are requests queued, make sure that we transmit as many as we are currently able to.\r\n        while (this.newRequest_()) { }\r\n    };\r\n    /**\r\n     * This is called any time someone might want a script tag to be added. It adds a script tag when there aren't\r\n     * too many outstanding requests and we are still alive.\r\n     *\r\n     * If there are outstanding packet segments to send, it sends one. If there aren't, it sends a long-poll anyways if\r\n     * needed.\r\n     */\r\n    FirebaseIFrameScriptHolder.prototype.newRequest_ = function () {\r\n        // We keep one outstanding request open all the time to receive data, but if we need to send data\r\n        // (pendingSegs.length > 0) then we create a new request to send the data.  The server will automatically\r\n        // close the old request.\r\n        if (this.alive &&\r\n            this.sendNewPolls &&\r\n            this.outstandingRequests.size < (this.pendingSegs.length > 0 ? 2 : 1)) {\r\n            //construct our url\r\n            this.currentSerial++;\r\n            var urlParams = {};\r\n            urlParams[FIREBASE_LONGPOLL_ID_PARAM] = this.myID;\r\n            urlParams[FIREBASE_LONGPOLL_PW_PARAM] = this.myPW;\r\n            urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = this.currentSerial;\r\n            var theURL = this.urlFn(urlParams);\r\n            //Now add as much data as we can.\r\n            var curDataString = '';\r\n            var i = 0;\r\n            while (this.pendingSegs.length > 0) {\r\n                //first, lets see if the next segment will fit.\r\n                var nextSeg = this.pendingSegs[0];\r\n                if (nextSeg.d.length +\r\n                    SEG_HEADER_SIZE +\r\n                    curDataString.length <=\r\n                    MAX_URL_DATA_SIZE) {\r\n                    //great, the segment will fit. Lets append it.\r\n                    var theSeg = this.pendingSegs.shift();\r\n                    curDataString =\r\n                        curDataString +\r\n                            '&' +\r\n                            FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM +\r\n                            i +\r\n                            '=' +\r\n                            theSeg.seg +\r\n                            '&' +\r\n                            FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET +\r\n                            i +\r\n                            '=' +\r\n                            theSeg.ts +\r\n                            '&' +\r\n                            FIREBASE_LONGPOLL_DATA_PARAM +\r\n                            i +\r\n                            '=' +\r\n                            theSeg.d;\r\n                    i++;\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n            theURL = theURL + curDataString;\r\n            this.addLongPollTag_(theURL, this.currentSerial);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    };\r\n    /**\r\n     * Queue a packet for transmission to the server.\r\n     * @param segnum - A sequential id for this packet segment used for reassembly\r\n     * @param totalsegs - The total number of segments in this packet\r\n     * @param data - The data for this segment.\r\n     */\r\n    FirebaseIFrameScriptHolder.prototype.enqueueSegment = function (segnum, totalsegs, data) {\r\n        //add this to the queue of segments to send.\r\n        this.pendingSegs.push({ seg: segnum, ts: totalsegs, d: data });\r\n        //send the data immediately if there isn't already data being transmitted, unless\r\n        //startLongPoll hasn't been called yet.\r\n        if (this.alive) {\r\n            this.newRequest_();\r\n        }\r\n    };\r\n    /**\r\n     * Add a script tag for a regular long-poll request.\r\n     * @param {!string} url - The URL of the script tag.\r\n     * @param {!number} serial - The serial number of the request.\r\n     * @private\r\n     */\r\n    FirebaseIFrameScriptHolder.prototype.addLongPollTag_ = function (url, serial) {\r\n        var _this = this;\r\n        //remember that we sent this request.\r\n        this.outstandingRequests.add(serial);\r\n        var doNewRequest = function () {\r\n            _this.outstandingRequests.delete(serial);\r\n            _this.newRequest_();\r\n        };\r\n        // If this request doesn't return on its own accord (by the server sending us some data), we'll\r\n        // create a new one after the KEEPALIVE interval to make sure we always keep a fresh request open.\r\n        var keepaliveTimeout = setTimeout(doNewRequest, Math.floor(KEEPALIVE_REQUEST_INTERVAL));\r\n        var readyStateCB = function () {\r\n            // Request completed.  Cancel the keepalive.\r\n            clearTimeout(keepaliveTimeout);\r\n            // Trigger a new request so we can continue receiving data.\r\n            doNewRequest();\r\n        };\r\n        this.addTag(url, readyStateCB);\r\n    };\r\n    /**\r\n     * Add an arbitrary script tag to the iframe.\r\n     * @param {!string} url - The URL for the script tag source.\r\n     * @param {!function()} loadCB - A callback to be triggered once the script has loaded.\r\n     */\r\n    FirebaseIFrameScriptHolder.prototype.addTag = function (url, loadCB) {\r\n        var _this = this;\r\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isNodeSdk)()) {\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            this.doNodeLongPoll(url, loadCB);\r\n        }\r\n        else {\r\n            setTimeout(function () {\r\n                try {\r\n                    // if we're already closed, don't add this poll\r\n                    if (!_this.sendNewPolls) {\r\n                        return;\r\n                    }\r\n                    var newScript_1 = _this.myIFrame.doc.createElement('script');\r\n                    newScript_1.type = 'text/javascript';\r\n                    newScript_1.async = true;\r\n                    newScript_1.src = url;\r\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                    newScript_1.onload = newScript_1.onreadystatechange = function () {\r\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                        var rstate = newScript_1.readyState;\r\n                        if (!rstate || rstate === 'loaded' || rstate === 'complete') {\r\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                            newScript_1.onload = newScript_1.onreadystatechange = null;\r\n                            if (newScript_1.parentNode) {\r\n                                newScript_1.parentNode.removeChild(newScript_1);\r\n                            }\r\n                            loadCB();\r\n                        }\r\n                    };\r\n                    newScript_1.onerror = function () {\r\n                        log('Long-poll script failed to load: ' + url);\r\n                        _this.sendNewPolls = false;\r\n                        _this.close();\r\n                    };\r\n                    _this.myIFrame.doc.body.appendChild(newScript_1);\r\n                }\r\n                catch (e) {\r\n                    // TODO: we should make this error visible somehow\r\n                }\r\n            }, Math.floor(1));\r\n        }\r\n    };\r\n    return FirebaseIFrameScriptHolder;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** The semver (www.semver.org) version of the SDK. */\r\nvar SDK_VERSION = '';\r\n// SDK_VERSION should be set before any database instance is created\r\nfunction setSDKVersion(version) {\r\n    SDK_VERSION = version;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar WEBSOCKET_MAX_FRAME_SIZE = 16384;\r\nvar WEBSOCKET_KEEPALIVE_INTERVAL = 45000;\r\nvar WebSocketImpl = null;\r\nif (typeof MozWebSocket !== 'undefined') {\r\n    WebSocketImpl = MozWebSocket;\r\n}\r\nelse if (typeof WebSocket !== 'undefined') {\r\n    WebSocketImpl = WebSocket;\r\n}\r\n/**\r\n * Create a new websocket connection with the given callbacks.\r\n * @constructor\r\n * @implements {Transport}\r\n */\r\nvar WebSocketConnection = /** @class */ (function () {\r\n    /**\r\n     * @param connId identifier for this transport\r\n     * @param repoInfo The info for the websocket endpoint.\r\n     * @param applicationId The Firebase App ID for this project.\r\n     * @param transportSessionId Optional transportSessionId if this is connecting to an existing transport\r\n     *                                         session\r\n     * @param lastSessionId Optional lastSessionId if there was a previous connection\r\n     */\r\n    function WebSocketConnection(connId, repoInfo, applicationId, transportSessionId, lastSessionId) {\r\n        this.connId = connId;\r\n        this.applicationId = applicationId;\r\n        this.keepaliveTimer = null;\r\n        this.frames = null;\r\n        this.totalFrames = 0;\r\n        this.bytesSent = 0;\r\n        this.bytesReceived = 0;\r\n        this.log_ = logWrapper(this.connId);\r\n        this.stats_ = StatsManager.getCollection(repoInfo);\r\n        this.connURL = WebSocketConnection.connectionURL_(repoInfo, transportSessionId, lastSessionId);\r\n        this.nodeAdmin = repoInfo.nodeAdmin;\r\n    }\r\n    /**\r\n     * @param {RepoInfo} repoInfo The info for the websocket endpoint.\r\n     * @param {string=} transportSessionId Optional transportSessionId if this is connecting to an existing transport\r\n     *                                         session\r\n     * @param {string=} lastSessionId Optional lastSessionId if there was a previous connection\r\n     * @return {string} connection url\r\n     * @private\r\n     */\r\n    WebSocketConnection.connectionURL_ = function (repoInfo, transportSessionId, lastSessionId) {\r\n        var urlParams = {};\r\n        urlParams[VERSION_PARAM] = PROTOCOL_VERSION;\r\n        if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isNodeSdk)() &&\r\n            typeof location !== 'undefined' &&\r\n            location.href &&\r\n            location.href.indexOf(FORGE_DOMAIN) !== -1) {\r\n            urlParams[REFERER_PARAM] = FORGE_REF;\r\n        }\r\n        if (transportSessionId) {\r\n            urlParams[TRANSPORT_SESSION_PARAM] = transportSessionId;\r\n        }\r\n        if (lastSessionId) {\r\n            urlParams[LAST_SESSION_PARAM] = lastSessionId;\r\n        }\r\n        return repoInfo.connectionURL(WEBSOCKET, urlParams);\r\n    };\r\n    /**\r\n     *\r\n     * @param onMessage Callback when messages arrive\r\n     * @param onDisconnect Callback with connection lost.\r\n     */\r\n    WebSocketConnection.prototype.open = function (onMessage, onDisconnect) {\r\n        var _this = this;\r\n        this.onDisconnect = onDisconnect;\r\n        this.onMessage = onMessage;\r\n        this.log_('Websocket connecting to ' + this.connURL);\r\n        this.everConnected_ = false;\r\n        // Assume failure until proven otherwise.\r\n        PersistentStorage.set('previous_websocket_failure', true);\r\n        try {\r\n            if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isNodeSdk)()) {\r\n                var device = this.nodeAdmin ? 'AdminNode' : 'Node';\r\n                // UA Format: Firebase/<wire_protocol>/<sdk_version>/<platform>/<device>\r\n                var options = {\r\n                    headers: {\r\n                        'User-Agent': \"Firebase/\" + PROTOCOL_VERSION + \"/\" + SDK_VERSION + \"/\" + process.platform + \"/\" + device,\r\n                        'X-Firebase-GMPID': this.applicationId || ''\r\n                    }\r\n                };\r\n                // Plumb appropriate http_proxy environment variable into faye-websocket if it exists.\r\n                var env = process['env'];\r\n                var proxy = this.connURL.indexOf('wss://') === 0\r\n                    ? env['HTTPS_PROXY'] || env['https_proxy']\r\n                    : env['HTTP_PROXY'] || env['http_proxy'];\r\n                if (proxy) {\r\n                    options['proxy'] = { origin: proxy };\r\n                }\r\n                this.mySock = new WebSocketImpl(this.connURL, [], options);\r\n            }\r\n            else {\r\n                var options = {\r\n                    headers: {\r\n                        'X-Firebase-GMPID': this.applicationId || ''\r\n                    }\r\n                };\r\n                this.mySock = new WebSocketImpl(this.connURL, [], options);\r\n            }\r\n        }\r\n        catch (e) {\r\n            this.log_('Error instantiating WebSocket.');\r\n            var error = e.message || e.data;\r\n            if (error) {\r\n                this.log_(error);\r\n            }\r\n            this.onClosed_();\r\n            return;\r\n        }\r\n        this.mySock.onopen = function () {\r\n            _this.log_('Websocket connected.');\r\n            _this.everConnected_ = true;\r\n        };\r\n        this.mySock.onclose = function () {\r\n            _this.log_('Websocket connection was disconnected.');\r\n            _this.mySock = null;\r\n            _this.onClosed_();\r\n        };\r\n        this.mySock.onmessage = function (m) {\r\n            _this.handleIncomingFrame(m);\r\n        };\r\n        this.mySock.onerror = function (e) {\r\n            _this.log_('WebSocket error.  Closing connection.');\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            var error = e.message || e.data;\r\n            if (error) {\r\n                _this.log_(error);\r\n            }\r\n            _this.onClosed_();\r\n        };\r\n    };\r\n    /**\r\n     * No-op for websockets, we don't need to do anything once the connection is confirmed as open\r\n     */\r\n    WebSocketConnection.prototype.start = function () { };\r\n    WebSocketConnection.forceDisallow = function () {\r\n        WebSocketConnection.forceDisallow_ = true;\r\n    };\r\n    WebSocketConnection.isAvailable = function () {\r\n        var isOldAndroid = false;\r\n        if (typeof navigator !== 'undefined' && navigator.userAgent) {\r\n            var oldAndroidRegex = /Android ([0-9]{0,}\\.[0-9]{0,})/;\r\n            var oldAndroidMatch = navigator.userAgent.match(oldAndroidRegex);\r\n            if (oldAndroidMatch && oldAndroidMatch.length > 1) {\r\n                if (parseFloat(oldAndroidMatch[1]) < 4.4) {\r\n                    isOldAndroid = true;\r\n                }\r\n            }\r\n        }\r\n        return (!isOldAndroid &&\r\n            WebSocketImpl !== null &&\r\n            !WebSocketConnection.forceDisallow_);\r\n    };\r\n    /**\r\n     * Returns true if we previously failed to connect with this transport.\r\n     * @return {boolean}\r\n     */\r\n    WebSocketConnection.previouslyFailed = function () {\r\n        // If our persistent storage is actually only in-memory storage,\r\n        // we default to assuming that it previously failed to be safe.\r\n        return (PersistentStorage.isInMemoryStorage ||\r\n            PersistentStorage.get('previous_websocket_failure') === true);\r\n    };\r\n    WebSocketConnection.prototype.markConnectionHealthy = function () {\r\n        PersistentStorage.remove('previous_websocket_failure');\r\n    };\r\n    WebSocketConnection.prototype.appendFrame_ = function (data) {\r\n        this.frames.push(data);\r\n        if (this.frames.length === this.totalFrames) {\r\n            var fullMess = this.frames.join('');\r\n            this.frames = null;\r\n            var jsonMess = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.jsonEval)(fullMess);\r\n            //handle the message\r\n            this.onMessage(jsonMess);\r\n        }\r\n    };\r\n    /**\r\n     * @param {number} frameCount The number of frames we are expecting from the server\r\n     * @private\r\n     */\r\n    WebSocketConnection.prototype.handleNewFrameCount_ = function (frameCount) {\r\n        this.totalFrames = frameCount;\r\n        this.frames = [];\r\n    };\r\n    /**\r\n     * Attempts to parse a frame count out of some text. If it can't, assumes a value of 1\r\n     * @param {!String} data\r\n     * @return {?String} Any remaining data to be process, or null if there is none\r\n     * @private\r\n     */\r\n    WebSocketConnection.prototype.extractFrameCount_ = function (data) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.frames === null, 'We already have a frame buffer');\r\n        // TODO: The server is only supposed to send up to 9999 frames (i.e. length <= 4), but that isn't being enforced\r\n        // currently.  So allowing larger frame counts (length <= 6).  See https://app.asana.com/0/search/8688598998380/8237608042508\r\n        if (data.length <= 6) {\r\n            var frameCount = Number(data);\r\n            if (!isNaN(frameCount)) {\r\n                this.handleNewFrameCount_(frameCount);\r\n                return null;\r\n            }\r\n        }\r\n        this.handleNewFrameCount_(1);\r\n        return data;\r\n    };\r\n    /**\r\n     * Process a websocket frame that has arrived from the server.\r\n     * @param mess The frame data\r\n     */\r\n    WebSocketConnection.prototype.handleIncomingFrame = function (mess) {\r\n        if (this.mySock === null) {\r\n            return; // Chrome apparently delivers incoming packets even after we .close() the connection sometimes.\r\n        }\r\n        var data = mess['data'];\r\n        this.bytesReceived += data.length;\r\n        this.stats_.incrementCounter('bytes_received', data.length);\r\n        this.resetKeepAlive();\r\n        if (this.frames !== null) {\r\n            // we're buffering\r\n            this.appendFrame_(data);\r\n        }\r\n        else {\r\n            // try to parse out a frame count, otherwise, assume 1 and process it\r\n            var remainingData = this.extractFrameCount_(data);\r\n            if (remainingData !== null) {\r\n                this.appendFrame_(remainingData);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Send a message to the server\r\n     * @param {Object} data The JSON object to transmit\r\n     */\r\n    WebSocketConnection.prototype.send = function (data) {\r\n        this.resetKeepAlive();\r\n        var dataStr = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(data);\r\n        this.bytesSent += dataStr.length;\r\n        this.stats_.incrementCounter('bytes_sent', dataStr.length);\r\n        //We can only fit a certain amount in each websocket frame, so we need to split this request\r\n        //up into multiple pieces if it doesn't fit in one request.\r\n        var dataSegs = splitStringBySize(dataStr, WEBSOCKET_MAX_FRAME_SIZE);\r\n        //Send the length header\r\n        if (dataSegs.length > 1) {\r\n            this.sendString_(String(dataSegs.length));\r\n        }\r\n        //Send the actual data in segments.\r\n        for (var i = 0; i < dataSegs.length; i++) {\r\n            this.sendString_(dataSegs[i]);\r\n        }\r\n    };\r\n    WebSocketConnection.prototype.shutdown_ = function () {\r\n        this.isClosed_ = true;\r\n        if (this.keepaliveTimer) {\r\n            clearInterval(this.keepaliveTimer);\r\n            this.keepaliveTimer = null;\r\n        }\r\n        if (this.mySock) {\r\n            this.mySock.close();\r\n            this.mySock = null;\r\n        }\r\n    };\r\n    WebSocketConnection.prototype.onClosed_ = function () {\r\n        if (!this.isClosed_) {\r\n            this.log_('WebSocket is closing itself');\r\n            this.shutdown_();\r\n            // since this is an internal close, trigger the close listener\r\n            if (this.onDisconnect) {\r\n                this.onDisconnect(this.everConnected_);\r\n                this.onDisconnect = null;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * External-facing close handler.\r\n     * Close the websocket and kill the connection.\r\n     */\r\n    WebSocketConnection.prototype.close = function () {\r\n        if (!this.isClosed_) {\r\n            this.log_('WebSocket is being closed');\r\n            this.shutdown_();\r\n        }\r\n    };\r\n    /**\r\n     * Kill the current keepalive timer and start a new one, to ensure that it always fires N seconds after\r\n     * the last activity.\r\n     */\r\n    WebSocketConnection.prototype.resetKeepAlive = function () {\r\n        var _this = this;\r\n        clearInterval(this.keepaliveTimer);\r\n        this.keepaliveTimer = setInterval(function () {\r\n            //If there has been no websocket activity for a while, send a no-op\r\n            if (_this.mySock) {\r\n                _this.sendString_('0');\r\n            }\r\n            _this.resetKeepAlive();\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        }, Math.floor(WEBSOCKET_KEEPALIVE_INTERVAL));\r\n    };\r\n    /**\r\n     * Send a string over the websocket.\r\n     *\r\n     * @param {string} str String to send.\r\n     * @private\r\n     */\r\n    WebSocketConnection.prototype.sendString_ = function (str) {\r\n        // Firefox seems to sometimes throw exceptions (NS_ERROR_UNEXPECTED) from websocket .send()\r\n        // calls for some unknown reason.  We treat these as an error and disconnect.\r\n        // See https://app.asana.com/0/58926111402292/68021340250410\r\n        try {\r\n            this.mySock.send(str);\r\n        }\r\n        catch (e) {\r\n            this.log_('Exception thrown from WebSocket.send():', e.message || e.data, 'Closing connection.');\r\n            setTimeout(this.onClosed_.bind(this), 0);\r\n        }\r\n    };\r\n    /**\r\n     * Number of response before we consider the connection \"healthy.\"\r\n     * @type {number}\r\n     */\r\n    WebSocketConnection.responsesRequiredToBeHealthy = 2;\r\n    /**\r\n     * Time to wait for the connection te become healthy before giving up.\r\n     * @type {number}\r\n     */\r\n    WebSocketConnection.healthyTimeout = 30000;\r\n    return WebSocketConnection;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Currently simplistic, this class manages what transport a Connection should use at various stages of its\r\n * lifecycle.\r\n *\r\n * It starts with longpolling in a browser, and httppolling on node. It then upgrades to websockets if\r\n * they are available.\r\n * @constructor\r\n */\r\nvar TransportManager = /** @class */ (function () {\r\n    /**\r\n     * @param {!RepoInfo} repoInfo Metadata around the namespace we're connecting to\r\n     */\r\n    function TransportManager(repoInfo) {\r\n        this.initTransports_(repoInfo);\r\n    }\r\n    Object.defineProperty(TransportManager, \"ALL_TRANSPORTS\", {\r\n        /**\r\n         * @const\r\n         * @type {!Array.<function(new:Transport, string, RepoInfo, string=)>}\r\n         */\r\n        get: function () {\r\n            return [BrowserPollConnection, WebSocketConnection];\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * @param {!RepoInfo} repoInfo\r\n     * @private\r\n     */\r\n    TransportManager.prototype.initTransports_ = function (repoInfo) {\r\n        var e_1, _a;\r\n        var isWebSocketsAvailable = WebSocketConnection && WebSocketConnection['isAvailable']();\r\n        var isSkipPollConnection = isWebSocketsAvailable && !WebSocketConnection.previouslyFailed();\r\n        if (repoInfo.webSocketOnly) {\r\n            if (!isWebSocketsAvailable) {\r\n                warn(\"wss:// URL used, but browser isn't known to support websockets.  Trying anyway.\");\r\n            }\r\n            isSkipPollConnection = true;\r\n        }\r\n        if (isSkipPollConnection) {\r\n            this.transports_ = [WebSocketConnection];\r\n        }\r\n        else {\r\n            var transports = (this.transports_ = []);\r\n            try {\r\n                for (var _b = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__values)(TransportManager.ALL_TRANSPORTS), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                    var transport = _c.value;\r\n                    if (transport && transport['isAvailable']()) {\r\n                        transports.push(transport);\r\n                    }\r\n                }\r\n            }\r\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n            finally {\r\n                try {\r\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                }\r\n                finally { if (e_1) throw e_1.error; }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * @return {function(new:Transport, !string, !RepoInfo, string=, string=)} The constructor for the\r\n     * initial transport to use\r\n     */\r\n    TransportManager.prototype.initialTransport = function () {\r\n        if (this.transports_.length > 0) {\r\n            return this.transports_[0];\r\n        }\r\n        else {\r\n            throw new Error('No transports available');\r\n        }\r\n    };\r\n    /**\r\n     * @return {?function(new:Transport, function(),function(), string=)} The constructor for the next\r\n     * transport, or null\r\n     */\r\n    TransportManager.prototype.upgradeTransport = function () {\r\n        if (this.transports_.length > 1) {\r\n            return this.transports_[1];\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    };\r\n    return TransportManager;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// Abort upgrade attempt if it takes longer than 60s.\r\nvar UPGRADE_TIMEOUT = 60000;\r\n// For some transports (WebSockets), we need to \"validate\" the transport by exchanging a few requests and responses.\r\n// If we haven't sent enough requests within 5s, we'll start sending noop ping requests.\r\nvar DELAY_BEFORE_SENDING_EXTRA_REQUESTS = 5000;\r\n// If the initial data sent triggers a lot of bandwidth (i.e. it's a large put or a listen for a large amount of data)\r\n// then we may not be able to exchange our ping/pong requests within the healthy timeout.  So if we reach the timeout\r\n// but we've sent/received enough bytes, we don't cancel the connection.\r\nvar BYTES_SENT_HEALTHY_OVERRIDE = 10 * 1024;\r\nvar BYTES_RECEIVED_HEALTHY_OVERRIDE = 100 * 1024;\r\nvar MESSAGE_TYPE = 't';\r\nvar MESSAGE_DATA = 'd';\r\nvar CONTROL_SHUTDOWN = 's';\r\nvar CONTROL_RESET = 'r';\r\nvar CONTROL_ERROR = 'e';\r\nvar CONTROL_PONG = 'o';\r\nvar SWITCH_ACK = 'a';\r\nvar END_TRANSMISSION = 'n';\r\nvar PING = 'p';\r\nvar SERVER_HELLO = 'h';\r\n/**\r\n * Creates a new real-time connection to the server using whichever method works\r\n * best in the current browser.\r\n *\r\n * @constructor\r\n */\r\nvar Connection = /** @class */ (function () {\r\n    /**\r\n     * @param id - an id for this connection\r\n     * @param repoInfo_ - the info for the endpoint to connect to\r\n     * @param applicationId_ - the Firebase App ID for this project\r\n     * @param onMessage_ - the callback to be triggered when a server-push message arrives\r\n     * @param onReady_ - the callback to be triggered when this connection is ready to send messages.\r\n     * @param onDisconnect_ - the callback to be triggered when a connection was lost\r\n     * @param onKill_ - the callback to be triggered when this connection has permanently shut down.\r\n     * @param lastSessionId - last session id in persistent connection. is used to clean up old session in real-time server\r\n     */\r\n    function Connection(id, repoInfo_, applicationId_, onMessage_, onReady_, onDisconnect_, onKill_, lastSessionId) {\r\n        this.id = id;\r\n        this.repoInfo_ = repoInfo_;\r\n        this.applicationId_ = applicationId_;\r\n        this.onMessage_ = onMessage_;\r\n        this.onReady_ = onReady_;\r\n        this.onDisconnect_ = onDisconnect_;\r\n        this.onKill_ = onKill_;\r\n        this.lastSessionId = lastSessionId;\r\n        this.connectionCount = 0;\r\n        this.pendingDataMessages = [];\r\n        this.state_ = 0 /* CONNECTING */;\r\n        this.log_ = logWrapper('c:' + this.id + ':');\r\n        this.transportManager_ = new TransportManager(repoInfo_);\r\n        this.log_('Connection created');\r\n        this.start_();\r\n    }\r\n    /**\r\n     * Starts a connection attempt\r\n     * @private\r\n     */\r\n    Connection.prototype.start_ = function () {\r\n        var _this = this;\r\n        var conn = this.transportManager_.initialTransport();\r\n        this.conn_ = new conn(this.nextTransportId_(), this.repoInfo_, this.applicationId_, undefined, this.lastSessionId);\r\n        // For certain transports (WebSockets), we need to send and receive several messages back and forth before we\r\n        // can consider the transport healthy.\r\n        this.primaryResponsesRequired_ = conn['responsesRequiredToBeHealthy'] || 0;\r\n        var onMessageReceived = this.connReceiver_(this.conn_);\r\n        var onConnectionLost = this.disconnReceiver_(this.conn_);\r\n        this.tx_ = this.conn_;\r\n        this.rx_ = this.conn_;\r\n        this.secondaryConn_ = null;\r\n        this.isHealthy_ = false;\r\n        /*\r\n         * Firefox doesn't like when code from one iframe tries to create another iframe by way of the parent frame.\r\n         * This can occur in the case of a redirect, i.e. we guessed wrong on what server to connect to and received a reset.\r\n         * Somehow, setTimeout seems to make this ok. That doesn't make sense from a security perspective, since you should\r\n         * still have the context of your originating frame.\r\n         */\r\n        setTimeout(function () {\r\n            // this.conn_ gets set to null in some of the tests. Check to make sure it still exists before using it\r\n            _this.conn_ && _this.conn_.open(onMessageReceived, onConnectionLost);\r\n        }, Math.floor(0));\r\n        var healthyTimeoutMS = conn['healthyTimeout'] || 0;\r\n        if (healthyTimeoutMS > 0) {\r\n            this.healthyTimeout_ = setTimeoutNonBlocking(function () {\r\n                _this.healthyTimeout_ = null;\r\n                if (!_this.isHealthy_) {\r\n                    if (_this.conn_ &&\r\n                        _this.conn_.bytesReceived > BYTES_RECEIVED_HEALTHY_OVERRIDE) {\r\n                        _this.log_('Connection exceeded healthy timeout but has received ' +\r\n                            _this.conn_.bytesReceived +\r\n                            ' bytes.  Marking connection healthy.');\r\n                        _this.isHealthy_ = true;\r\n                        _this.conn_.markConnectionHealthy();\r\n                    }\r\n                    else if (_this.conn_ &&\r\n                        _this.conn_.bytesSent > BYTES_SENT_HEALTHY_OVERRIDE) {\r\n                        _this.log_('Connection exceeded healthy timeout but has sent ' +\r\n                            _this.conn_.bytesSent +\r\n                            ' bytes.  Leaving connection alive.');\r\n                        // NOTE: We don't want to mark it healthy, since we have no guarantee that the bytes have made it to\r\n                        // the server.\r\n                    }\r\n                    else {\r\n                        _this.log_('Closing unhealthy connection after timeout.');\r\n                        _this.close();\r\n                    }\r\n                }\r\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            }, Math.floor(healthyTimeoutMS));\r\n        }\r\n    };\r\n    /**\r\n     * @return {!string}\r\n     * @private\r\n     */\r\n    Connection.prototype.nextTransportId_ = function () {\r\n        return 'c:' + this.id + ':' + this.connectionCount++;\r\n    };\r\n    Connection.prototype.disconnReceiver_ = function (conn) {\r\n        var _this = this;\r\n        return function (everConnected) {\r\n            if (conn === _this.conn_) {\r\n                _this.onConnectionLost_(everConnected);\r\n            }\r\n            else if (conn === _this.secondaryConn_) {\r\n                _this.log_('Secondary connection lost.');\r\n                _this.onSecondaryConnectionLost_();\r\n            }\r\n            else {\r\n                _this.log_('closing an old connection');\r\n            }\r\n        };\r\n    };\r\n    Connection.prototype.connReceiver_ = function (conn) {\r\n        var _this = this;\r\n        return function (message) {\r\n            if (_this.state_ !== 2 /* DISCONNECTED */) {\r\n                if (conn === _this.rx_) {\r\n                    _this.onPrimaryMessageReceived_(message);\r\n                }\r\n                else if (conn === _this.secondaryConn_) {\r\n                    _this.onSecondaryMessageReceived_(message);\r\n                }\r\n                else {\r\n                    _this.log_('message on old connection');\r\n                }\r\n            }\r\n        };\r\n    };\r\n    /**\r\n     *\r\n     * @param {Object} dataMsg An arbitrary data message to be sent to the server\r\n     */\r\n    Connection.prototype.sendRequest = function (dataMsg) {\r\n        // wrap in a data message envelope and send it on\r\n        var msg = { t: 'd', d: dataMsg };\r\n        this.sendData_(msg);\r\n    };\r\n    Connection.prototype.tryCleanupConnection = function () {\r\n        if (this.tx_ === this.secondaryConn_ && this.rx_ === this.secondaryConn_) {\r\n            this.log_('cleaning up and promoting a connection: ' + this.secondaryConn_.connId);\r\n            this.conn_ = this.secondaryConn_;\r\n            this.secondaryConn_ = null;\r\n            // the server will shutdown the old connection\r\n        }\r\n    };\r\n    Connection.prototype.onSecondaryControl_ = function (controlData) {\r\n        if (MESSAGE_TYPE in controlData) {\r\n            var cmd = controlData[MESSAGE_TYPE];\r\n            if (cmd === SWITCH_ACK) {\r\n                this.upgradeIfSecondaryHealthy_();\r\n            }\r\n            else if (cmd === CONTROL_RESET) {\r\n                // Most likely the session wasn't valid. Abandon the switch attempt\r\n                this.log_('Got a reset on secondary, closing it');\r\n                this.secondaryConn_.close();\r\n                // If we were already using this connection for something, than we need to fully close\r\n                if (this.tx_ === this.secondaryConn_ ||\r\n                    this.rx_ === this.secondaryConn_) {\r\n                    this.close();\r\n                }\r\n            }\r\n            else if (cmd === CONTROL_PONG) {\r\n                this.log_('got pong on secondary.');\r\n                this.secondaryResponsesRequired_--;\r\n                this.upgradeIfSecondaryHealthy_();\r\n            }\r\n        }\r\n    };\r\n    Connection.prototype.onSecondaryMessageReceived_ = function (parsedData) {\r\n        var layer = requireKey('t', parsedData);\r\n        var data = requireKey('d', parsedData);\r\n        if (layer === 'c') {\r\n            this.onSecondaryControl_(data);\r\n        }\r\n        else if (layer === 'd') {\r\n            // got a data message, but we're still second connection. Need to buffer it up\r\n            this.pendingDataMessages.push(data);\r\n        }\r\n        else {\r\n            throw new Error('Unknown protocol layer: ' + layer);\r\n        }\r\n    };\r\n    Connection.prototype.upgradeIfSecondaryHealthy_ = function () {\r\n        if (this.secondaryResponsesRequired_ <= 0) {\r\n            this.log_('Secondary connection is healthy.');\r\n            this.isHealthy_ = true;\r\n            this.secondaryConn_.markConnectionHealthy();\r\n            this.proceedWithUpgrade_();\r\n        }\r\n        else {\r\n            // Send a ping to make sure the connection is healthy.\r\n            this.log_('sending ping on secondary.');\r\n            this.secondaryConn_.send({ t: 'c', d: { t: PING, d: {} } });\r\n        }\r\n    };\r\n    Connection.prototype.proceedWithUpgrade_ = function () {\r\n        // tell this connection to consider itself open\r\n        this.secondaryConn_.start();\r\n        // send ack\r\n        this.log_('sending client ack on secondary');\r\n        this.secondaryConn_.send({ t: 'c', d: { t: SWITCH_ACK, d: {} } });\r\n        // send end packet on primary transport, switch to sending on this one\r\n        // can receive on this one, buffer responses until end received on primary transport\r\n        this.log_('Ending transmission on primary');\r\n        this.conn_.send({ t: 'c', d: { t: END_TRANSMISSION, d: {} } });\r\n        this.tx_ = this.secondaryConn_;\r\n        this.tryCleanupConnection();\r\n    };\r\n    Connection.prototype.onPrimaryMessageReceived_ = function (parsedData) {\r\n        // Must refer to parsedData properties in quotes, so closure doesn't touch them.\r\n        var layer = requireKey('t', parsedData);\r\n        var data = requireKey('d', parsedData);\r\n        if (layer === 'c') {\r\n            this.onControl_(data);\r\n        }\r\n        else if (layer === 'd') {\r\n            this.onDataMessage_(data);\r\n        }\r\n    };\r\n    Connection.prototype.onDataMessage_ = function (message) {\r\n        this.onPrimaryResponse_();\r\n        // We don't do anything with data messages, just kick them up a level\r\n        this.onMessage_(message);\r\n    };\r\n    Connection.prototype.onPrimaryResponse_ = function () {\r\n        if (!this.isHealthy_) {\r\n            this.primaryResponsesRequired_--;\r\n            if (this.primaryResponsesRequired_ <= 0) {\r\n                this.log_('Primary connection is healthy.');\r\n                this.isHealthy_ = true;\r\n                this.conn_.markConnectionHealthy();\r\n            }\r\n        }\r\n    };\r\n    Connection.prototype.onControl_ = function (controlData) {\r\n        var cmd = requireKey(MESSAGE_TYPE, controlData);\r\n        if (MESSAGE_DATA in controlData) {\r\n            var payload = controlData[MESSAGE_DATA];\r\n            if (cmd === SERVER_HELLO) {\r\n                this.onHandshake_(payload);\r\n            }\r\n            else if (cmd === END_TRANSMISSION) {\r\n                this.log_('recvd end transmission on primary');\r\n                this.rx_ = this.secondaryConn_;\r\n                for (var i = 0; i < this.pendingDataMessages.length; ++i) {\r\n                    this.onDataMessage_(this.pendingDataMessages[i]);\r\n                }\r\n                this.pendingDataMessages = [];\r\n                this.tryCleanupConnection();\r\n            }\r\n            else if (cmd === CONTROL_SHUTDOWN) {\r\n                // This was previously the 'onKill' callback passed to the lower-level connection\r\n                // payload in this case is the reason for the shutdown. Generally a human-readable error\r\n                this.onConnectionShutdown_(payload);\r\n            }\r\n            else if (cmd === CONTROL_RESET) {\r\n                // payload in this case is the host we should contact\r\n                this.onReset_(payload);\r\n            }\r\n            else if (cmd === CONTROL_ERROR) {\r\n                error('Server Error: ' + payload);\r\n            }\r\n            else if (cmd === CONTROL_PONG) {\r\n                this.log_('got pong on primary.');\r\n                this.onPrimaryResponse_();\r\n                this.sendPingOnPrimaryIfNecessary_();\r\n            }\r\n            else {\r\n                error('Unknown control packet command: ' + cmd);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     *\r\n     * @param {Object} handshake The handshake data returned from the server\r\n     * @private\r\n     */\r\n    Connection.prototype.onHandshake_ = function (handshake) {\r\n        var timestamp = handshake.ts;\r\n        var version = handshake.v;\r\n        var host = handshake.h;\r\n        this.sessionId = handshake.s;\r\n        this.repoInfo_.updateHost(host);\r\n        // if we've already closed the connection, then don't bother trying to progress further\r\n        if (this.state_ === 0 /* CONNECTING */) {\r\n            this.conn_.start();\r\n            this.onConnectionEstablished_(this.conn_, timestamp);\r\n            if (PROTOCOL_VERSION !== version) {\r\n                warn('Protocol version mismatch detected');\r\n            }\r\n            // TODO: do we want to upgrade? when? maybe a delay?\r\n            this.tryStartUpgrade_();\r\n        }\r\n    };\r\n    Connection.prototype.tryStartUpgrade_ = function () {\r\n        var conn = this.transportManager_.upgradeTransport();\r\n        if (conn) {\r\n            this.startUpgrade_(conn);\r\n        }\r\n    };\r\n    Connection.prototype.startUpgrade_ = function (conn) {\r\n        var _this = this;\r\n        this.secondaryConn_ = new conn(this.nextTransportId_(), this.repoInfo_, this.applicationId_, this.sessionId);\r\n        // For certain transports (WebSockets), we need to send and receive several messages back and forth before we\r\n        // can consider the transport healthy.\r\n        this.secondaryResponsesRequired_ =\r\n            conn['responsesRequiredToBeHealthy'] || 0;\r\n        var onMessage = this.connReceiver_(this.secondaryConn_);\r\n        var onDisconnect = this.disconnReceiver_(this.secondaryConn_);\r\n        this.secondaryConn_.open(onMessage, onDisconnect);\r\n        // If we haven't successfully upgraded after UPGRADE_TIMEOUT, give up and kill the secondary.\r\n        setTimeoutNonBlocking(function () {\r\n            if (_this.secondaryConn_) {\r\n                _this.log_('Timed out trying to upgrade.');\r\n                _this.secondaryConn_.close();\r\n            }\r\n        }, Math.floor(UPGRADE_TIMEOUT));\r\n    };\r\n    Connection.prototype.onReset_ = function (host) {\r\n        this.log_('Reset packet received.  New host: ' + host);\r\n        this.repoInfo_.updateHost(host);\r\n        // TODO: if we're already \"connected\", we need to trigger a disconnect at the next layer up.\r\n        // We don't currently support resets after the connection has already been established\r\n        if (this.state_ === 1 /* CONNECTED */) {\r\n            this.close();\r\n        }\r\n        else {\r\n            // Close whatever connections we have open and start again.\r\n            this.closeConnections_();\r\n            this.start_();\r\n        }\r\n    };\r\n    Connection.prototype.onConnectionEstablished_ = function (conn, timestamp) {\r\n        var _this = this;\r\n        this.log_('Realtime connection established.');\r\n        this.conn_ = conn;\r\n        this.state_ = 1 /* CONNECTED */;\r\n        if (this.onReady_) {\r\n            this.onReady_(timestamp, this.sessionId);\r\n            this.onReady_ = null;\r\n        }\r\n        // If after 5 seconds we haven't sent enough requests to the server to get the connection healthy,\r\n        // send some pings.\r\n        if (this.primaryResponsesRequired_ === 0) {\r\n            this.log_('Primary connection is healthy.');\r\n            this.isHealthy_ = true;\r\n        }\r\n        else {\r\n            setTimeoutNonBlocking(function () {\r\n                _this.sendPingOnPrimaryIfNecessary_();\r\n            }, Math.floor(DELAY_BEFORE_SENDING_EXTRA_REQUESTS));\r\n        }\r\n    };\r\n    Connection.prototype.sendPingOnPrimaryIfNecessary_ = function () {\r\n        // If the connection isn't considered healthy yet, we'll send a noop ping packet request.\r\n        if (!this.isHealthy_ && this.state_ === 1 /* CONNECTED */) {\r\n            this.log_('sending ping on primary.');\r\n            this.sendData_({ t: 'c', d: { t: PING, d: {} } });\r\n        }\r\n    };\r\n    Connection.prototype.onSecondaryConnectionLost_ = function () {\r\n        var conn = this.secondaryConn_;\r\n        this.secondaryConn_ = null;\r\n        if (this.tx_ === conn || this.rx_ === conn) {\r\n            // we are relying on this connection already in some capacity. Therefore, a failure is real\r\n            this.close();\r\n        }\r\n    };\r\n    /**\r\n     *\r\n     * @param {boolean} everConnected Whether or not the connection ever reached a server. Used to determine if\r\n     * we should flush the host cache\r\n     * @private\r\n     */\r\n    Connection.prototype.onConnectionLost_ = function (everConnected) {\r\n        this.conn_ = null;\r\n        // NOTE: IF you're seeing a Firefox error for this line, I think it might be because it's getting\r\n        // called on window close and RealtimeState.CONNECTING is no longer defined.  Just a guess.\r\n        if (!everConnected && this.state_ === 0 /* CONNECTING */) {\r\n            this.log_('Realtime connection failed.');\r\n            // Since we failed to connect at all, clear any cached entry for this namespace in case the machine went away\r\n            if (this.repoInfo_.isCacheableHost()) {\r\n                PersistentStorage.remove('host:' + this.repoInfo_.host);\r\n                // reset the internal host to what we would show the user, i.e. <ns>.firebaseio.com\r\n                this.repoInfo_.internalHost = this.repoInfo_.host;\r\n            }\r\n        }\r\n        else if (this.state_ === 1 /* CONNECTED */) {\r\n            this.log_('Realtime connection lost.');\r\n        }\r\n        this.close();\r\n    };\r\n    /**\r\n     *\r\n     * @param {string} reason\r\n     * @private\r\n     */\r\n    Connection.prototype.onConnectionShutdown_ = function (reason) {\r\n        this.log_('Connection shutdown command received. Shutting down...');\r\n        if (this.onKill_) {\r\n            this.onKill_(reason);\r\n            this.onKill_ = null;\r\n        }\r\n        // We intentionally don't want to fire onDisconnect (kill is a different case),\r\n        // so clear the callback.\r\n        this.onDisconnect_ = null;\r\n        this.close();\r\n    };\r\n    Connection.prototype.sendData_ = function (data) {\r\n        if (this.state_ !== 1 /* CONNECTED */) {\r\n            throw 'Connection is not connected';\r\n        }\r\n        else {\r\n            this.tx_.send(data);\r\n        }\r\n    };\r\n    /**\r\n     * Cleans up this connection, calling the appropriate callbacks\r\n     */\r\n    Connection.prototype.close = function () {\r\n        if (this.state_ !== 2 /* DISCONNECTED */) {\r\n            this.log_('Closing realtime connection.');\r\n            this.state_ = 2 /* DISCONNECTED */;\r\n            this.closeConnections_();\r\n            if (this.onDisconnect_) {\r\n                this.onDisconnect_();\r\n                this.onDisconnect_ = null;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     *\r\n     * @private\r\n     */\r\n    Connection.prototype.closeConnections_ = function () {\r\n        this.log_('Shutting down all connections');\r\n        if (this.conn_) {\r\n            this.conn_.close();\r\n            this.conn_ = null;\r\n        }\r\n        if (this.secondaryConn_) {\r\n            this.secondaryConn_.close();\r\n            this.secondaryConn_ = null;\r\n        }\r\n        if (this.healthyTimeout_) {\r\n            clearTimeout(this.healthyTimeout_);\r\n            this.healthyTimeout_ = null;\r\n        }\r\n    };\r\n    return Connection;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Interface defining the set of actions that can be performed against the Firebase server\r\n * (basically corresponds to our wire protocol).\r\n *\r\n * @interface\r\n */\r\nvar ServerActions = /** @class */ (function () {\r\n    function ServerActions() {\r\n    }\r\n    /**\r\n     * @param {string} pathString\r\n     * @param {*} data\r\n     * @param {function(string, string)=} onComplete\r\n     * @param {string=} hash\r\n     */\r\n    ServerActions.prototype.put = function (pathString, data, onComplete, hash) { };\r\n    /**\r\n     * @param {string} pathString\r\n     * @param {*} data\r\n     * @param {function(string, ?string)} onComplete\r\n     * @param {string=} hash\r\n     */\r\n    ServerActions.prototype.merge = function (pathString, data, onComplete, hash) { };\r\n    /**\r\n     * Refreshes the auth token for the current connection.\r\n     * @param {string} token The authentication token\r\n     */\r\n    ServerActions.prototype.refreshAuthToken = function (token) { };\r\n    /**\r\n     * @param {string} pathString\r\n     * @param {*} data\r\n     * @param {function(string, string)=} onComplete\r\n     */\r\n    ServerActions.prototype.onDisconnectPut = function (pathString, data, onComplete) { };\r\n    /**\r\n     * @param {string} pathString\r\n     * @param {*} data\r\n     * @param {function(string, string)=} onComplete\r\n     */\r\n    ServerActions.prototype.onDisconnectMerge = function (pathString, data, onComplete) { };\r\n    /**\r\n     * @param {string} pathString\r\n     * @param {function(string, string)=} onComplete\r\n     */\r\n    ServerActions.prototype.onDisconnectCancel = function (pathString, onComplete) { };\r\n    /**\r\n     * @param {Object.<string, *>} stats\r\n     */\r\n    ServerActions.prototype.reportStats = function (stats) { };\r\n    return ServerActions;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar RECONNECT_MIN_DELAY = 1000;\r\nvar RECONNECT_MAX_DELAY_DEFAULT = 60 * 5 * 1000; // 5 minutes in milliseconds (Case: 1858)\r\nvar RECONNECT_MAX_DELAY_FOR_ADMINS = 30 * 1000; // 30 seconds for admin clients (likely to be a backend server)\r\nvar RECONNECT_DELAY_MULTIPLIER = 1.3;\r\nvar RECONNECT_DELAY_RESET_TIMEOUT = 30000; // Reset delay back to MIN_DELAY after being connected for 30sec.\r\nvar SERVER_KILL_INTERRUPT_REASON = 'server_kill';\r\n// If auth fails repeatedly, we'll assume something is wrong and log a warning / back off.\r\nvar INVALID_AUTH_TOKEN_THRESHOLD = 3;\r\n/**\r\n * Firebase connection.  Abstracts wire protocol and handles reconnecting.\r\n *\r\n * NOTE: All JSON objects sent to the realtime connection must have property names enclosed\r\n * in quotes to make sure the closure compiler does not minify them.\r\n */\r\nvar PersistentConnection = /** @class */ (function (_super) {\r\n    (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(PersistentConnection, _super);\r\n    /**\r\n     * @implements {ServerActions}\r\n     * @param repoInfo_ Data about the namespace we are connecting to\r\n     * @param applicationId_ The Firebase App ID for this project\r\n     * @param onDataUpdate_ A callback for new data from the server\r\n     */\r\n    function PersistentConnection(repoInfo_, applicationId_, onDataUpdate_, onConnectStatus_, onServerInfoUpdate_, authTokenProvider_, authOverride_) {\r\n        var _this = _super.call(this) || this;\r\n        _this.repoInfo_ = repoInfo_;\r\n        _this.applicationId_ = applicationId_;\r\n        _this.onDataUpdate_ = onDataUpdate_;\r\n        _this.onConnectStatus_ = onConnectStatus_;\r\n        _this.onServerInfoUpdate_ = onServerInfoUpdate_;\r\n        _this.authTokenProvider_ = authTokenProvider_;\r\n        _this.authOverride_ = authOverride_;\r\n        // Used for diagnostic logging.\r\n        _this.id = PersistentConnection.nextPersistentConnectionId_++;\r\n        _this.log_ = logWrapper('p:' + _this.id + ':');\r\n        _this.interruptReasons_ = {};\r\n        /** Map<path, Map<queryId, ListenSpec>> */\r\n        _this.listens = new Map();\r\n        _this.outstandingPuts_ = [];\r\n        _this.outstandingPutCount_ = 0;\r\n        _this.onDisconnectRequestQueue_ = [];\r\n        _this.connected_ = false;\r\n        _this.reconnectDelay_ = RECONNECT_MIN_DELAY;\r\n        _this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_DEFAULT;\r\n        _this.securityDebugCallback_ = null;\r\n        _this.lastSessionId = null;\r\n        _this.establishConnectionTimer_ = null;\r\n        _this.visible_ = false;\r\n        // Before we get connected, we keep a queue of pending messages to send.\r\n        _this.requestCBHash_ = {};\r\n        _this.requestNumber_ = 0;\r\n        _this.realtime_ = null;\r\n        _this.authToken_ = null;\r\n        _this.forceTokenRefresh_ = false;\r\n        _this.invalidAuthTokenCount_ = 0;\r\n        _this.firstConnection_ = true;\r\n        _this.lastConnectionAttemptTime_ = null;\r\n        _this.lastConnectionEstablishedTime_ = null;\r\n        if (authOverride_ && !(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isNodeSdk)()) {\r\n            throw new Error('Auth override specified in options, but not supported on non Node.js platforms');\r\n        }\r\n        _this.scheduleConnect_(0);\r\n        VisibilityMonitor.getInstance().on('visible', _this.onVisible_, _this);\r\n        if (repoInfo_.host.indexOf('fblocal') === -1) {\r\n            OnlineMonitor.getInstance().on('online', _this.onOnline_, _this);\r\n        }\r\n        return _this;\r\n    }\r\n    PersistentConnection.prototype.sendRequest = function (action, body, onResponse) {\r\n        var curReqNum = ++this.requestNumber_;\r\n        var msg = { r: curReqNum, a: action, b: body };\r\n        this.log_((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(msg));\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.connected_, \"sendRequest call when we're not connected not allowed.\");\r\n        this.realtime_.sendRequest(msg);\r\n        if (onResponse) {\r\n            this.requestCBHash_[curReqNum] = onResponse;\r\n        }\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    PersistentConnection.prototype.listen = function (query, currentHashFn, tag, onComplete) {\r\n        var queryId = query.queryIdentifier();\r\n        var pathString = query.path.toString();\r\n        this.log_('Listen called for ' + pathString + ' ' + queryId);\r\n        if (!this.listens.has(pathString)) {\r\n            this.listens.set(pathString, new Map());\r\n        }\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(query.getQueryParams().isDefault() ||\r\n            !query.getQueryParams().loadsAllData(), 'listen() called for non-default but complete query');\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.listens.get(pathString).has(queryId), 'listen() called twice for same path/queryId.');\r\n        var listenSpec = {\r\n            onComplete: onComplete,\r\n            hashFn: currentHashFn,\r\n            query: query,\r\n            tag: tag\r\n        };\r\n        this.listens.get(pathString).set(queryId, listenSpec);\r\n        if (this.connected_) {\r\n            this.sendListen_(listenSpec);\r\n        }\r\n    };\r\n    PersistentConnection.prototype.sendListen_ = function (listenSpec) {\r\n        var _this = this;\r\n        var query = listenSpec.query;\r\n        var pathString = query.path.toString();\r\n        var queryId = query.queryIdentifier();\r\n        this.log_('Listen on ' + pathString + ' for ' + queryId);\r\n        var req = { /*path*/ p: pathString };\r\n        var action = 'q';\r\n        // Only bother to send query if it's non-default.\r\n        if (listenSpec.tag) {\r\n            req['q'] = query.queryObject();\r\n            req['t'] = listenSpec.tag;\r\n        }\r\n        req[ /*hash*/'h'] = listenSpec.hashFn();\r\n        this.sendRequest(action, req, function (message) {\r\n            var payload = message[ /*data*/'d'];\r\n            var status = message[ /*status*/'s'];\r\n            // print warnings in any case...\r\n            PersistentConnection.warnOnListenWarnings_(payload, query);\r\n            var currentListenSpec = _this.listens.get(pathString) &&\r\n                _this.listens.get(pathString).get(queryId);\r\n            // only trigger actions if the listen hasn't been removed and readded\r\n            if (currentListenSpec === listenSpec) {\r\n                _this.log_('listen response', message);\r\n                if (status !== 'ok') {\r\n                    _this.removeListen_(pathString, queryId);\r\n                }\r\n                if (listenSpec.onComplete) {\r\n                    listenSpec.onComplete(status, payload);\r\n                }\r\n            }\r\n        });\r\n    };\r\n    PersistentConnection.warnOnListenWarnings_ = function (payload, query) {\r\n        if (payload && typeof payload === 'object' && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(payload, 'w')) {\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            var warnings = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.safeGet)(payload, 'w');\r\n            if (Array.isArray(warnings) && ~warnings.indexOf('no_index')) {\r\n                var indexSpec = '\".indexOn\": \"' + query.getQueryParams().getIndex().toString() + '\"';\r\n                var indexPath = query.path.toString();\r\n                warn(\"Using an unspecified index. Your data will be downloaded and \" +\r\n                    (\"filtered on the client. Consider adding \" + indexSpec + \" at \") +\r\n                    (indexPath + \" to your security rules for better performance.\"));\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    PersistentConnection.prototype.refreshAuthToken = function (token) {\r\n        this.authToken_ = token;\r\n        this.log_('Auth token refreshed');\r\n        if (this.authToken_) {\r\n            this.tryAuth();\r\n        }\r\n        else {\r\n            //If we're connected we want to let the server know to unauthenticate us. If we're not connected, simply delete\r\n            //the credential so we dont become authenticated next time we connect.\r\n            if (this.connected_) {\r\n                this.sendRequest('unauth', {}, function () { });\r\n            }\r\n        }\r\n        this.reduceReconnectDelayIfAdminCredential_(token);\r\n    };\r\n    PersistentConnection.prototype.reduceReconnectDelayIfAdminCredential_ = function (credential) {\r\n        // NOTE: This isn't intended to be bulletproof (a malicious developer can always just modify the client).\r\n        // Additionally, we don't bother resetting the max delay back to the default if auth fails / expires.\r\n        var isFirebaseSecret = credential && credential.length === 40;\r\n        if (isFirebaseSecret || (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isAdmin)(credential)) {\r\n            this.log_('Admin auth credential detected.  Reducing max reconnect time.');\r\n            this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;\r\n        }\r\n    };\r\n    /**\r\n     * Attempts to authenticate with the given credentials. If the authentication attempt fails, it's triggered like\r\n     * a auth revoked (the connection is closed).\r\n     */\r\n    PersistentConnection.prototype.tryAuth = function () {\r\n        var _this = this;\r\n        if (this.connected_ && this.authToken_) {\r\n            var token_1 = this.authToken_;\r\n            var authMethod = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isValidFormat)(token_1) ? 'auth' : 'gauth';\r\n            var requestData = { cred: token_1 };\r\n            if (this.authOverride_ === null) {\r\n                requestData['noauth'] = true;\r\n            }\r\n            else if (typeof this.authOverride_ === 'object') {\r\n                requestData['authvar'] = this.authOverride_;\r\n            }\r\n            this.sendRequest(authMethod, requestData, function (res) {\r\n                var status = res[ /*status*/'s'];\r\n                var data = res[ /*data*/'d'] || 'error';\r\n                if (_this.authToken_ === token_1) {\r\n                    if (status === 'ok') {\r\n                        _this.invalidAuthTokenCount_ = 0;\r\n                    }\r\n                    else {\r\n                        // Triggers reconnect and force refresh for auth token\r\n                        _this.onAuthRevoked_(status, data);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    PersistentConnection.prototype.unlisten = function (query, tag) {\r\n        var pathString = query.path.toString();\r\n        var queryId = query.queryIdentifier();\r\n        this.log_('Unlisten called for ' + pathString + ' ' + queryId);\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(query.getQueryParams().isDefault() ||\r\n            !query.getQueryParams().loadsAllData(), 'unlisten() called for non-default but complete query');\r\n        var listen = this.removeListen_(pathString, queryId);\r\n        if (listen && this.connected_) {\r\n            this.sendUnlisten_(pathString, queryId, query.queryObject(), tag);\r\n        }\r\n    };\r\n    PersistentConnection.prototype.sendUnlisten_ = function (pathString, queryId, queryObj, tag) {\r\n        this.log_('Unlisten on ' + pathString + ' for ' + queryId);\r\n        var req = { /*path*/ p: pathString };\r\n        var action = 'n';\r\n        // Only bother sending queryId if it's non-default.\r\n        if (tag) {\r\n            req['q'] = queryObj;\r\n            req['t'] = tag;\r\n        }\r\n        this.sendRequest(action, req);\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    PersistentConnection.prototype.onDisconnectPut = function (pathString, data, onComplete) {\r\n        if (this.connected_) {\r\n            this.sendOnDisconnect_('o', pathString, data, onComplete);\r\n        }\r\n        else {\r\n            this.onDisconnectRequestQueue_.push({\r\n                pathString: pathString,\r\n                action: 'o',\r\n                data: data,\r\n                onComplete: onComplete\r\n            });\r\n        }\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    PersistentConnection.prototype.onDisconnectMerge = function (pathString, data, onComplete) {\r\n        if (this.connected_) {\r\n            this.sendOnDisconnect_('om', pathString, data, onComplete);\r\n        }\r\n        else {\r\n            this.onDisconnectRequestQueue_.push({\r\n                pathString: pathString,\r\n                action: 'om',\r\n                data: data,\r\n                onComplete: onComplete\r\n            });\r\n        }\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    PersistentConnection.prototype.onDisconnectCancel = function (pathString, onComplete) {\r\n        if (this.connected_) {\r\n            this.sendOnDisconnect_('oc', pathString, null, onComplete);\r\n        }\r\n        else {\r\n            this.onDisconnectRequestQueue_.push({\r\n                pathString: pathString,\r\n                action: 'oc',\r\n                data: null,\r\n                onComplete: onComplete\r\n            });\r\n        }\r\n    };\r\n    PersistentConnection.prototype.sendOnDisconnect_ = function (action, pathString, data, onComplete) {\r\n        var request = { /*path*/ p: pathString, /*data*/ d: data };\r\n        this.log_('onDisconnect ' + action, request);\r\n        this.sendRequest(action, request, function (response) {\r\n            if (onComplete) {\r\n                setTimeout(function () {\r\n                    onComplete(response[ /*status*/'s'], response[ /* data */'d']);\r\n                }, Math.floor(0));\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    PersistentConnection.prototype.put = function (pathString, data, onComplete, hash) {\r\n        this.putInternal('p', pathString, data, onComplete, hash);\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    PersistentConnection.prototype.merge = function (pathString, data, onComplete, hash) {\r\n        this.putInternal('m', pathString, data, onComplete, hash);\r\n    };\r\n    PersistentConnection.prototype.putInternal = function (action, pathString, data, onComplete, hash) {\r\n        var request = {\r\n            /*path*/ p: pathString,\r\n            /*data*/ d: data\r\n        };\r\n        if (hash !== undefined) {\r\n            request[ /*hash*/'h'] = hash;\r\n        }\r\n        // TODO: Only keep track of the most recent put for a given path?\r\n        this.outstandingPuts_.push({\r\n            action: action,\r\n            request: request,\r\n            onComplete: onComplete\r\n        });\r\n        this.outstandingPutCount_++;\r\n        var index = this.outstandingPuts_.length - 1;\r\n        if (this.connected_) {\r\n            this.sendPut_(index);\r\n        }\r\n        else {\r\n            this.log_('Buffering put: ' + pathString);\r\n        }\r\n    };\r\n    PersistentConnection.prototype.sendPut_ = function (index) {\r\n        var _this = this;\r\n        var action = this.outstandingPuts_[index].action;\r\n        var request = this.outstandingPuts_[index].request;\r\n        var onComplete = this.outstandingPuts_[index].onComplete;\r\n        this.outstandingPuts_[index].queued = this.connected_;\r\n        this.sendRequest(action, request, function (message) {\r\n            _this.log_(action + ' response', message);\r\n            delete _this.outstandingPuts_[index];\r\n            _this.outstandingPutCount_--;\r\n            // Clean up array occasionally.\r\n            if (_this.outstandingPutCount_ === 0) {\r\n                _this.outstandingPuts_ = [];\r\n            }\r\n            if (onComplete) {\r\n                onComplete(message[ /*status*/'s'], message[ /* data */'d']);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    PersistentConnection.prototype.reportStats = function (stats) {\r\n        var _this = this;\r\n        // If we're not connected, we just drop the stats.\r\n        if (this.connected_) {\r\n            var request = { /*counters*/ c: stats };\r\n            this.log_('reportStats', request);\r\n            this.sendRequest(/*stats*/ 's', request, function (result) {\r\n                var status = result[ /*status*/'s'];\r\n                if (status !== 'ok') {\r\n                    var errorReason = result[ /* data */'d'];\r\n                    _this.log_('reportStats', 'Error sending stats: ' + errorReason);\r\n                }\r\n            });\r\n        }\r\n    };\r\n    PersistentConnection.prototype.onDataMessage_ = function (message) {\r\n        if ('r' in message) {\r\n            // this is a response\r\n            this.log_('from server: ' + (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(message));\r\n            var reqNum = message['r'];\r\n            var onResponse = this.requestCBHash_[reqNum];\r\n            if (onResponse) {\r\n                delete this.requestCBHash_[reqNum];\r\n                onResponse(message[ /*body*/'b']);\r\n            }\r\n        }\r\n        else if ('error' in message) {\r\n            throw 'A server-side error has occurred: ' + message['error'];\r\n        }\r\n        else if ('a' in message) {\r\n            // a and b are action and body, respectively\r\n            this.onDataPush_(message['a'], message['b']);\r\n        }\r\n    };\r\n    PersistentConnection.prototype.onDataPush_ = function (action, body) {\r\n        this.log_('handleServerMessage', action, body);\r\n        if (action === 'd') {\r\n            this.onDataUpdate_(body[ /*path*/'p'], body[ /*data*/'d'], \r\n            /*isMerge*/ false, body['t']);\r\n        }\r\n        else if (action === 'm') {\r\n            this.onDataUpdate_(body[ /*path*/'p'], body[ /*data*/'d'], \r\n            /*isMerge=*/ true, body['t']);\r\n        }\r\n        else if (action === 'c') {\r\n            this.onListenRevoked_(body[ /*path*/'p'], body[ /*query*/'q']);\r\n        }\r\n        else if (action === 'ac') {\r\n            this.onAuthRevoked_(body[ /*status code*/'s'], body[ /* explanation */'d']);\r\n        }\r\n        else if (action === 'sd') {\r\n            this.onSecurityDebugPacket_(body);\r\n        }\r\n        else {\r\n            error('Unrecognized action received from server: ' +\r\n                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(action) +\r\n                '\\nAre you using the latest client?');\r\n        }\r\n    };\r\n    PersistentConnection.prototype.onReady_ = function (timestamp, sessionId) {\r\n        this.log_('connection ready');\r\n        this.connected_ = true;\r\n        this.lastConnectionEstablishedTime_ = new Date().getTime();\r\n        this.handleTimestamp_(timestamp);\r\n        this.lastSessionId = sessionId;\r\n        if (this.firstConnection_) {\r\n            this.sendConnectStats_();\r\n        }\r\n        this.restoreState_();\r\n        this.firstConnection_ = false;\r\n        this.onConnectStatus_(true);\r\n    };\r\n    PersistentConnection.prototype.scheduleConnect_ = function (timeout) {\r\n        var _this = this;\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(!this.realtime_, \"Scheduling a connect when we're already connected/ing?\");\r\n        if (this.establishConnectionTimer_) {\r\n            clearTimeout(this.establishConnectionTimer_);\r\n        }\r\n        // NOTE: Even when timeout is 0, it's important to do a setTimeout to work around an infuriating \"Security Error\" in\r\n        // Firefox when trying to write to our long-polling iframe in some scenarios (e.g. Forge or our unit tests).\r\n        this.establishConnectionTimer_ = setTimeout(function () {\r\n            _this.establishConnectionTimer_ = null;\r\n            _this.establishConnection_();\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        }, Math.floor(timeout));\r\n    };\r\n    PersistentConnection.prototype.onVisible_ = function (visible) {\r\n        // NOTE: Tabbing away and back to a window will defeat our reconnect backoff, but I think that's fine.\r\n        if (visible &&\r\n            !this.visible_ &&\r\n            this.reconnectDelay_ === this.maxReconnectDelay_) {\r\n            this.log_('Window became visible.  Reducing delay.');\r\n            this.reconnectDelay_ = RECONNECT_MIN_DELAY;\r\n            if (!this.realtime_) {\r\n                this.scheduleConnect_(0);\r\n            }\r\n        }\r\n        this.visible_ = visible;\r\n    };\r\n    PersistentConnection.prototype.onOnline_ = function (online) {\r\n        if (online) {\r\n            this.log_('Browser went online.');\r\n            this.reconnectDelay_ = RECONNECT_MIN_DELAY;\r\n            if (!this.realtime_) {\r\n                this.scheduleConnect_(0);\r\n            }\r\n        }\r\n        else {\r\n            this.log_('Browser went offline.  Killing connection.');\r\n            if (this.realtime_) {\r\n                this.realtime_.close();\r\n            }\r\n        }\r\n    };\r\n    PersistentConnection.prototype.onRealtimeDisconnect_ = function () {\r\n        this.log_('data client disconnected');\r\n        this.connected_ = false;\r\n        this.realtime_ = null;\r\n        // Since we don't know if our sent transactions succeeded or not, we need to cancel them.\r\n        this.cancelSentTransactions_();\r\n        // Clear out the pending requests.\r\n        this.requestCBHash_ = {};\r\n        if (this.shouldReconnect_()) {\r\n            if (!this.visible_) {\r\n                this.log_(\"Window isn't visible.  Delaying reconnect.\");\r\n                this.reconnectDelay_ = this.maxReconnectDelay_;\r\n                this.lastConnectionAttemptTime_ = new Date().getTime();\r\n            }\r\n            else if (this.lastConnectionEstablishedTime_) {\r\n                // If we've been connected long enough, reset reconnect delay to minimum.\r\n                var timeSinceLastConnectSucceeded = new Date().getTime() - this.lastConnectionEstablishedTime_;\r\n                if (timeSinceLastConnectSucceeded > RECONNECT_DELAY_RESET_TIMEOUT) {\r\n                    this.reconnectDelay_ = RECONNECT_MIN_DELAY;\r\n                }\r\n                this.lastConnectionEstablishedTime_ = null;\r\n            }\r\n            var timeSinceLastConnectAttempt = new Date().getTime() - this.lastConnectionAttemptTime_;\r\n            var reconnectDelay = Math.max(0, this.reconnectDelay_ - timeSinceLastConnectAttempt);\r\n            reconnectDelay = Math.random() * reconnectDelay;\r\n            this.log_('Trying to reconnect in ' + reconnectDelay + 'ms');\r\n            this.scheduleConnect_(reconnectDelay);\r\n            // Adjust reconnect delay for next time.\r\n            this.reconnectDelay_ = Math.min(this.maxReconnectDelay_, this.reconnectDelay_ * RECONNECT_DELAY_MULTIPLIER);\r\n        }\r\n        this.onConnectStatus_(false);\r\n    };\r\n    PersistentConnection.prototype.establishConnection_ = function () {\r\n        var _this = this;\r\n        if (this.shouldReconnect_()) {\r\n            this.log_('Making a connection attempt');\r\n            this.lastConnectionAttemptTime_ = new Date().getTime();\r\n            this.lastConnectionEstablishedTime_ = null;\r\n            var onDataMessage_1 = this.onDataMessage_.bind(this);\r\n            var onReady_1 = this.onReady_.bind(this);\r\n            var onDisconnect_1 = this.onRealtimeDisconnect_.bind(this);\r\n            var connId_1 = this.id + ':' + PersistentConnection.nextConnectionId_++;\r\n            var self_1 = this;\r\n            var lastSessionId_1 = this.lastSessionId;\r\n            var canceled_1 = false;\r\n            var connection_1 = null;\r\n            var closeFn_1 = function () {\r\n                if (connection_1) {\r\n                    connection_1.close();\r\n                }\r\n                else {\r\n                    canceled_1 = true;\r\n                    onDisconnect_1();\r\n                }\r\n            };\r\n            var sendRequestFn = function (msg) {\r\n                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(connection_1, \"sendRequest call when we're not connected not allowed.\");\r\n                connection_1.sendRequest(msg);\r\n            };\r\n            this.realtime_ = {\r\n                close: closeFn_1,\r\n                sendRequest: sendRequestFn\r\n            };\r\n            var forceRefresh = this.forceTokenRefresh_;\r\n            this.forceTokenRefresh_ = false;\r\n            // First fetch auth token, and establish connection after fetching the token was successful\r\n            this.authTokenProvider_\r\n                .getToken(forceRefresh)\r\n                .then(function (result) {\r\n                if (!canceled_1) {\r\n                    log('getToken() completed. Creating connection.');\r\n                    self_1.authToken_ = result && result.accessToken;\r\n                    connection_1 = new Connection(connId_1, self_1.repoInfo_, self_1.applicationId_, onDataMessage_1, onReady_1, onDisconnect_1, \r\n                    /* onKill= */ function (reason) {\r\n                        warn(reason + ' (' + self_1.repoInfo_.toString() + ')');\r\n                        self_1.interrupt(SERVER_KILL_INTERRUPT_REASON);\r\n                    }, lastSessionId_1);\r\n                }\r\n                else {\r\n                    log('getToken() completed but was canceled');\r\n                }\r\n            })\r\n                .then(null, function (error) {\r\n                self_1.log_('Failed to get token: ' + error);\r\n                if (!canceled_1) {\r\n                    if (_this.repoInfo_.nodeAdmin) {\r\n                        // This may be a critical error for the Admin Node.js SDK, so log a warning.\r\n                        // But getToken() may also just have temporarily failed, so we still want to\r\n                        // continue retrying.\r\n                        warn(error);\r\n                    }\r\n                    closeFn_1();\r\n                }\r\n            });\r\n        }\r\n    };\r\n    PersistentConnection.prototype.interrupt = function (reason) {\r\n        log('Interrupting connection for reason: ' + reason);\r\n        this.interruptReasons_[reason] = true;\r\n        if (this.realtime_) {\r\n            this.realtime_.close();\r\n        }\r\n        else {\r\n            if (this.establishConnectionTimer_) {\r\n                clearTimeout(this.establishConnectionTimer_);\r\n                this.establishConnectionTimer_ = null;\r\n            }\r\n            if (this.connected_) {\r\n                this.onRealtimeDisconnect_();\r\n            }\r\n        }\r\n    };\r\n    PersistentConnection.prototype.resume = function (reason) {\r\n        log('Resuming connection for reason: ' + reason);\r\n        delete this.interruptReasons_[reason];\r\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isEmpty)(this.interruptReasons_)) {\r\n            this.reconnectDelay_ = RECONNECT_MIN_DELAY;\r\n            if (!this.realtime_) {\r\n                this.scheduleConnect_(0);\r\n            }\r\n        }\r\n    };\r\n    PersistentConnection.prototype.handleTimestamp_ = function (timestamp) {\r\n        var delta = timestamp - new Date().getTime();\r\n        this.onServerInfoUpdate_({ serverTimeOffset: delta });\r\n    };\r\n    PersistentConnection.prototype.cancelSentTransactions_ = function () {\r\n        for (var i = 0; i < this.outstandingPuts_.length; i++) {\r\n            var put = this.outstandingPuts_[i];\r\n            if (put && /*hash*/ 'h' in put.request && put.queued) {\r\n                if (put.onComplete) {\r\n                    put.onComplete('disconnect');\r\n                }\r\n                delete this.outstandingPuts_[i];\r\n                this.outstandingPutCount_--;\r\n            }\r\n        }\r\n        // Clean up array occasionally.\r\n        if (this.outstandingPutCount_ === 0) {\r\n            this.outstandingPuts_ = [];\r\n        }\r\n    };\r\n    PersistentConnection.prototype.onListenRevoked_ = function (pathString, query) {\r\n        // Remove the listen and manufacture a \"permission_denied\" error for the failed listen.\r\n        var queryId;\r\n        if (!query) {\r\n            queryId = 'default';\r\n        }\r\n        else {\r\n            queryId = query.map(function (q) { return ObjectToUniqueKey(q); }).join('$');\r\n        }\r\n        var listen = this.removeListen_(pathString, queryId);\r\n        if (listen && listen.onComplete) {\r\n            listen.onComplete('permission_denied');\r\n        }\r\n    };\r\n    PersistentConnection.prototype.removeListen_ = function (pathString, queryId) {\r\n        var normalizedPathString = new Path(pathString).toString(); // normalize path.\r\n        var listen;\r\n        if (this.listens.has(normalizedPathString)) {\r\n            var map = this.listens.get(normalizedPathString);\r\n            listen = map.get(queryId);\r\n            map.delete(queryId);\r\n            if (map.size === 0) {\r\n                this.listens.delete(normalizedPathString);\r\n            }\r\n        }\r\n        else {\r\n            // all listens for this path has already been removed\r\n            listen = undefined;\r\n        }\r\n        return listen;\r\n    };\r\n    PersistentConnection.prototype.onAuthRevoked_ = function (statusCode, explanation) {\r\n        log('Auth token revoked: ' + statusCode + '/' + explanation);\r\n        this.authToken_ = null;\r\n        this.forceTokenRefresh_ = true;\r\n        this.realtime_.close();\r\n        if (statusCode === 'invalid_token' || statusCode === 'permission_denied') {\r\n            // We'll wait a couple times before logging the warning / increasing the\r\n            // retry period since oauth tokens will report as \"invalid\" if they're\r\n            // just expired. Plus there may be transient issues that resolve themselves.\r\n            this.invalidAuthTokenCount_++;\r\n            if (this.invalidAuthTokenCount_ >= INVALID_AUTH_TOKEN_THRESHOLD) {\r\n                // Set a long reconnect delay because recovery is unlikely\r\n                this.reconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;\r\n                // Notify the auth token provider that the token is invalid, which will log\r\n                // a warning\r\n                this.authTokenProvider_.notifyForInvalidToken();\r\n            }\r\n        }\r\n    };\r\n    PersistentConnection.prototype.onSecurityDebugPacket_ = function (body) {\r\n        if (this.securityDebugCallback_) {\r\n            this.securityDebugCallback_(body);\r\n        }\r\n        else {\r\n            if ('msg' in body) {\r\n                console.log('FIREBASE: ' + body['msg'].replace('\\n', '\\nFIREBASE: '));\r\n            }\r\n        }\r\n    };\r\n    PersistentConnection.prototype.restoreState_ = function () {\r\n        var e_1, _a, e_2, _b;\r\n        //Re-authenticate ourselves if we have a credential stored.\r\n        this.tryAuth();\r\n        try {\r\n            // Puts depend on having received the corresponding data update from the server before they complete, so we must\r\n            // make sure to send listens before puts.\r\n            for (var _c = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__values)(this.listens.values()), _d = _c.next(); !_d.done; _d = _c.next()) {\r\n                var queries = _d.value;\r\n                try {\r\n                    for (var _e = (e_2 = void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__values)(queries.values())), _f = _e.next(); !_f.done; _f = _e.next()) {\r\n                        var listenSpec = _f.value;\r\n                        this.sendListen_(listenSpec);\r\n                    }\r\n                }\r\n                catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n                finally {\r\n                    try {\r\n                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\r\n                    }\r\n                    finally { if (e_2) throw e_2.error; }\r\n                }\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n        for (var i = 0; i < this.outstandingPuts_.length; i++) {\r\n            if (this.outstandingPuts_[i]) {\r\n                this.sendPut_(i);\r\n            }\r\n        }\r\n        while (this.onDisconnectRequestQueue_.length) {\r\n            var request = this.onDisconnectRequestQueue_.shift();\r\n            this.sendOnDisconnect_(request.action, request.pathString, request.data, request.onComplete);\r\n        }\r\n    };\r\n    /**\r\n     * Sends client stats for first connection\r\n     */\r\n    PersistentConnection.prototype.sendConnectStats_ = function () {\r\n        var stats = {};\r\n        var clientName = 'js';\r\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isNodeSdk)()) {\r\n            if (this.repoInfo_.nodeAdmin) {\r\n                clientName = 'admin_node';\r\n            }\r\n            else {\r\n                clientName = 'node';\r\n            }\r\n        }\r\n        stats['sdk.' + clientName + '.' + SDK_VERSION.replace(/\\./g, '-')] = 1;\r\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isMobileCordova)()) {\r\n            stats['framework.cordova'] = 1;\r\n        }\r\n        else if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isReactNative)()) {\r\n            stats['framework.reactnative'] = 1;\r\n        }\r\n        this.reportStats(stats);\r\n    };\r\n    PersistentConnection.prototype.shouldReconnect_ = function () {\r\n        var online = OnlineMonitor.getInstance().currentlyOnline();\r\n        return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isEmpty)(this.interruptReasons_) && online;\r\n    };\r\n    PersistentConnection.nextPersistentConnectionId_ = 0;\r\n    /**\r\n     * Counter for number of connections created. Mainly used for tagging in the logs\r\n     */\r\n    PersistentConnection.nextConnectionId_ = 0;\r\n    return PersistentConnection;\r\n}(ServerActions));\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An implementation of ServerActions that communicates with the server via REST requests.\r\n * This is mostly useful for compatibility with crawlers, where we don't want to spin up a full\r\n * persistent connection (using WebSockets or long-polling)\r\n */\r\nvar ReadonlyRestClient = /** @class */ (function (_super) {\r\n    (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(ReadonlyRestClient, _super);\r\n    /**\r\n     * @param {!RepoInfo} repoInfo_ Data about the namespace we are connecting to\r\n     * @param {function(string, *, boolean, ?number)} onDataUpdate_ A callback for new data from the server\r\n     * @param {AuthTokenProvider} authTokenProvider_\r\n     * @implements {ServerActions}\r\n     */\r\n    function ReadonlyRestClient(repoInfo_, onDataUpdate_, authTokenProvider_) {\r\n        var _this = _super.call(this) || this;\r\n        _this.repoInfo_ = repoInfo_;\r\n        _this.onDataUpdate_ = onDataUpdate_;\r\n        _this.authTokenProvider_ = authTokenProvider_;\r\n        /** @private {function(...[*])} */\r\n        _this.log_ = logWrapper('p:rest:');\r\n        /**\r\n         * We don't actually need to track listens, except to prevent us calling an onComplete for a listen\r\n         * that's been removed. :-/\r\n         *\r\n         * @private {!Object.<string, !Object>}\r\n         */\r\n        _this.listens_ = {};\r\n        return _this;\r\n    }\r\n    ReadonlyRestClient.prototype.reportStats = function (stats) {\r\n        throw new Error('Method not implemented.');\r\n    };\r\n    /**\r\n     * @param {!Query} query\r\n     * @param {?number=} tag\r\n     * @return {string}\r\n     * @private\r\n     */\r\n    ReadonlyRestClient.getListenId_ = function (query, tag) {\r\n        if (tag !== undefined) {\r\n            return 'tag$' + tag;\r\n        }\r\n        else {\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(query.getQueryParams().isDefault(), \"should have a tag if it's not a default query.\");\r\n            return query.path.toString();\r\n        }\r\n    };\r\n    /** @inheritDoc */\r\n    ReadonlyRestClient.prototype.listen = function (query, currentHashFn, tag, onComplete) {\r\n        var _this = this;\r\n        var pathString = query.path.toString();\r\n        this.log_('Listen called for ' + pathString + ' ' + query.queryIdentifier());\r\n        // Mark this listener so we can tell if it's removed.\r\n        var listenId = ReadonlyRestClient.getListenId_(query, tag);\r\n        var thisListen = {};\r\n        this.listens_[listenId] = thisListen;\r\n        var queryStringParameters = query\r\n            .getQueryParams()\r\n            .toRestQueryStringParameters();\r\n        this.restRequest_(pathString + '.json', queryStringParameters, function (error, result) {\r\n            var data = result;\r\n            if (error === 404) {\r\n                data = null;\r\n                error = null;\r\n            }\r\n            if (error === null) {\r\n                _this.onDataUpdate_(pathString, data, /*isMerge=*/ false, tag);\r\n            }\r\n            if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.safeGet)(_this.listens_, listenId) === thisListen) {\r\n                var status_1;\r\n                if (!error) {\r\n                    status_1 = 'ok';\r\n                }\r\n                else if (error === 401) {\r\n                    status_1 = 'permission_denied';\r\n                }\r\n                else {\r\n                    status_1 = 'rest_error:' + error;\r\n                }\r\n                onComplete(status_1, null);\r\n            }\r\n        });\r\n    };\r\n    /** @inheritDoc */\r\n    ReadonlyRestClient.prototype.unlisten = function (query, tag) {\r\n        var listenId = ReadonlyRestClient.getListenId_(query, tag);\r\n        delete this.listens_[listenId];\r\n    };\r\n    /** @inheritDoc */\r\n    ReadonlyRestClient.prototype.refreshAuthToken = function (token) {\r\n        // no-op since we just always call getToken.\r\n    };\r\n    /**\r\n     * Performs a REST request to the given path, with the provided query string parameters,\r\n     * and any auth credentials we have.\r\n     *\r\n     * @param {!string} pathString\r\n     * @param {!Object.<string, *>} queryStringParameters\r\n     * @param {?function(?number, *=)} callback\r\n     * @private\r\n     */\r\n    ReadonlyRestClient.prototype.restRequest_ = function (pathString, queryStringParameters, callback) {\r\n        var _this = this;\r\n        if (queryStringParameters === void 0) { queryStringParameters = {}; }\r\n        queryStringParameters['format'] = 'export';\r\n        this.authTokenProvider_\r\n            .getToken(/*forceRefresh=*/ false)\r\n            .then(function (authTokenData) {\r\n            var authToken = authTokenData && authTokenData.accessToken;\r\n            if (authToken) {\r\n                queryStringParameters['auth'] = authToken;\r\n            }\r\n            var url = (_this.repoInfo_.secure ? 'https://' : 'http://') +\r\n                _this.repoInfo_.host +\r\n                pathString +\r\n                '?' +\r\n                'ns=' +\r\n                _this.repoInfo_.namespace +\r\n                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.querystring)(queryStringParameters);\r\n            _this.log_('Sending REST request for ' + url);\r\n            var xhr = new XMLHttpRequest();\r\n            xhr.onreadystatechange = function () {\r\n                if (callback && xhr.readyState === 4) {\r\n                    _this.log_('REST Response for ' + url + ' received. status:', xhr.status, 'response:', xhr.responseText);\r\n                    var res = null;\r\n                    if (xhr.status >= 200 && xhr.status < 300) {\r\n                        try {\r\n                            res = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.jsonEval)(xhr.responseText);\r\n                        }\r\n                        catch (e) {\r\n                            warn('Failed to parse JSON response for ' +\r\n                                url +\r\n                                ': ' +\r\n                                xhr.responseText);\r\n                        }\r\n                        callback(null, res);\r\n                    }\r\n                    else {\r\n                        // 401 and 404 are expected.\r\n                        if (xhr.status !== 401 && xhr.status !== 404) {\r\n                            warn('Got unsuccessful REST response for ' +\r\n                                url +\r\n                                ' Status: ' +\r\n                                xhr.status);\r\n                        }\r\n                        callback(xhr.status);\r\n                    }\r\n                    callback = null;\r\n                }\r\n            };\r\n            xhr.open('GET', url, /*asynchronous=*/ true);\r\n            xhr.send();\r\n        });\r\n    };\r\n    return ReadonlyRestClient;\r\n}(ServerActions));\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar INTERRUPT_REASON = 'repo_interrupt';\r\n/**\r\n * A connection to a single data repository.\r\n */\r\nvar Repo = /** @class */ (function () {\r\n    function Repo(repoInfo_, forceRestClient, app, authTokenProvider) {\r\n        var _this = this;\r\n        this.repoInfo_ = repoInfo_;\r\n        this.app = app;\r\n        this.dataUpdateCount = 0;\r\n        this.statsListener_ = null;\r\n        this.eventQueue_ = new EventQueue();\r\n        this.nextWriteId_ = 1;\r\n        this.interceptServerDataCallback_ = null;\r\n        /** A list of data pieces and paths to be set when this client disconnects. */\r\n        this.onDisconnect_ = new SparseSnapshotTree();\r\n        // TODO: This should be @private but it's used by test_access.js and internal.js\r\n        this.persistentConnection_ = null;\r\n        this.stats_ = StatsManager.getCollection(repoInfo_);\r\n        if (forceRestClient || beingCrawled()) {\r\n            this.server_ = new ReadonlyRestClient(this.repoInfo_, this.onDataUpdate_.bind(this), authTokenProvider);\r\n            // Minor hack: Fire onConnect immediately, since there's no actual connection.\r\n            setTimeout(this.onConnectStatus_.bind(this, true), 0);\r\n        }\r\n        else {\r\n            var authOverride = app.options['databaseAuthVariableOverride'];\r\n            // Validate authOverride\r\n            if (typeof authOverride !== 'undefined' && authOverride !== null) {\r\n                if (typeof authOverride !== 'object') {\r\n                    throw new Error('Only objects are supported for option databaseAuthVariableOverride');\r\n                }\r\n                try {\r\n                    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(authOverride);\r\n                }\r\n                catch (e) {\r\n                    throw new Error('Invalid authOverride provided: ' + e);\r\n                }\r\n            }\r\n            this.persistentConnection_ = new PersistentConnection(this.repoInfo_, app.options.appId, this.onDataUpdate_.bind(this), this.onConnectStatus_.bind(this), this.onServerInfoUpdate_.bind(this), authTokenProvider, authOverride);\r\n            this.server_ = this.persistentConnection_;\r\n        }\r\n        authTokenProvider.addTokenChangeListener(function (token) {\r\n            _this.server_.refreshAuthToken(token);\r\n        });\r\n        // In the case of multiple Repos for the same repoInfo (i.e. there are multiple Firebase.Contexts being used),\r\n        // we only want to create one StatsReporter.  As such, we'll report stats over the first Repo created.\r\n        this.statsReporter_ = StatsManager.getOrCreateReporter(repoInfo_, function () { return new StatsReporter(_this.stats_, _this.server_); });\r\n        this.transactionsInit_();\r\n        // Used for .info.\r\n        this.infoData_ = new SnapshotHolder();\r\n        this.infoSyncTree_ = new SyncTree({\r\n            startListening: function (query, tag, currentHashFn, onComplete) {\r\n                var infoEvents = [];\r\n                var node = _this.infoData_.getNode(query.path);\r\n                // This is possibly a hack, but we have different semantics for .info endpoints. We don't raise null events\r\n                // on initial data...\r\n                if (!node.isEmpty()) {\r\n                    infoEvents = _this.infoSyncTree_.applyServerOverwrite(query.path, node);\r\n                    setTimeout(function () {\r\n                        onComplete('ok');\r\n                    }, 0);\r\n                }\r\n                return infoEvents;\r\n            },\r\n            stopListening: function () { }\r\n        });\r\n        this.updateInfo_('connected', false);\r\n        this.serverSyncTree_ = new SyncTree({\r\n            startListening: function (query, tag, currentHashFn, onComplete) {\r\n                _this.server_.listen(query, currentHashFn, tag, function (status, data) {\r\n                    var events = onComplete(status, data);\r\n                    _this.eventQueue_.raiseEventsForChangedPath(query.path, events);\r\n                });\r\n                // No synchronous events for network-backed sync trees\r\n                return [];\r\n            },\r\n            stopListening: function (query, tag) {\r\n                _this.server_.unlisten(query, tag);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * @return The URL corresponding to the root of this Firebase.\r\n     */\r\n    Repo.prototype.toString = function () {\r\n        return ((this.repoInfo_.secure ? 'https://' : 'http://') + this.repoInfo_.host);\r\n    };\r\n    /**\r\n     * @return The namespace represented by the repo.\r\n     */\r\n    Repo.prototype.name = function () {\r\n        return this.repoInfo_.namespace;\r\n    };\r\n    /**\r\n     * @return The time in milliseconds, taking the server offset into account if we have one.\r\n     */\r\n    Repo.prototype.serverTime = function () {\r\n        var offsetNode = this.infoData_.getNode(new Path('.info/serverTimeOffset'));\r\n        var offset = offsetNode.val() || 0;\r\n        return new Date().getTime() + offset;\r\n    };\r\n    /**\r\n     * Generate ServerValues using some variables from the repo object.\r\n     */\r\n    Repo.prototype.generateServerValues = function () {\r\n        return generateWithValues({\r\n            timestamp: this.serverTime()\r\n        });\r\n    };\r\n    /**\r\n     * Called by realtime when we get new messages from the server.\r\n     */\r\n    Repo.prototype.onDataUpdate_ = function (pathString, data, isMerge, tag) {\r\n        // For testing.\r\n        this.dataUpdateCount++;\r\n        var path = new Path(pathString);\r\n        data = this.interceptServerDataCallback_\r\n            ? this.interceptServerDataCallback_(pathString, data)\r\n            : data;\r\n        var events = [];\r\n        if (tag) {\r\n            if (isMerge) {\r\n                var taggedChildren = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.map)(data, function (raw) { return nodeFromJSON$1(raw); });\r\n                events = this.serverSyncTree_.applyTaggedQueryMerge(path, taggedChildren, tag);\r\n            }\r\n            else {\r\n                var taggedSnap = nodeFromJSON$1(data);\r\n                events = this.serverSyncTree_.applyTaggedQueryOverwrite(path, taggedSnap, tag);\r\n            }\r\n        }\r\n        else if (isMerge) {\r\n            var changedChildren = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.map)(data, function (raw) { return nodeFromJSON$1(raw); });\r\n            events = this.serverSyncTree_.applyServerMerge(path, changedChildren);\r\n        }\r\n        else {\r\n            var snap = nodeFromJSON$1(data);\r\n            events = this.serverSyncTree_.applyServerOverwrite(path, snap);\r\n        }\r\n        var affectedPath = path;\r\n        if (events.length > 0) {\r\n            // Since we have a listener outstanding for each transaction, receiving any events\r\n            // is a proxy for some change having occurred.\r\n            affectedPath = this.rerunTransactions_(path);\r\n        }\r\n        this.eventQueue_.raiseEventsForChangedPath(affectedPath, events);\r\n    };\r\n    // TODO: This should be @private but it's used by test_access.js and internal.js\r\n    Repo.prototype.interceptServerData_ = function (callback) {\r\n        this.interceptServerDataCallback_ = callback;\r\n    };\r\n    Repo.prototype.onConnectStatus_ = function (connectStatus) {\r\n        this.updateInfo_('connected', connectStatus);\r\n        if (connectStatus === false) {\r\n            this.runOnDisconnectEvents_();\r\n        }\r\n    };\r\n    Repo.prototype.onServerInfoUpdate_ = function (updates) {\r\n        var _this = this;\r\n        each(updates, function (key, value) {\r\n            _this.updateInfo_(key, value);\r\n        });\r\n    };\r\n    Repo.prototype.updateInfo_ = function (pathString, value) {\r\n        var path = new Path('/.info/' + pathString);\r\n        var newNode = nodeFromJSON$1(value);\r\n        this.infoData_.updateSnapshot(path, newNode);\r\n        var events = this.infoSyncTree_.applyServerOverwrite(path, newNode);\r\n        this.eventQueue_.raiseEventsForChangedPath(path, events);\r\n    };\r\n    Repo.prototype.getNextWriteId_ = function () {\r\n        return this.nextWriteId_++;\r\n    };\r\n    Repo.prototype.setWithPriority = function (path, newVal, newPriority, onComplete) {\r\n        var _this = this;\r\n        this.log_('set', {\r\n            path: path.toString(),\r\n            value: newVal,\r\n            priority: newPriority\r\n        });\r\n        // TODO: Optimize this behavior to either (a) store flag to skip resolving where possible and / or\r\n        // (b) store unresolved paths on JSON parse\r\n        var serverValues = this.generateServerValues();\r\n        var newNodeUnresolved = nodeFromJSON$1(newVal, newPriority);\r\n        var existing = this.serverSyncTree_.calcCompleteEventCache(path);\r\n        var newNode = resolveDeferredValueSnapshot(newNodeUnresolved, existing, serverValues);\r\n        var writeId = this.getNextWriteId_();\r\n        var events = this.serverSyncTree_.applyUserOverwrite(path, newNode, writeId, true);\r\n        this.eventQueue_.queueEvents(events);\r\n        this.server_.put(path.toString(), newNodeUnresolved.val(/*export=*/ true), function (status, errorReason) {\r\n            var success = status === 'ok';\r\n            if (!success) {\r\n                warn('set at ' + path + ' failed: ' + status);\r\n            }\r\n            var clearEvents = _this.serverSyncTree_.ackUserWrite(writeId, !success);\r\n            _this.eventQueue_.raiseEventsForChangedPath(path, clearEvents);\r\n            _this.callOnCompleteCallback(onComplete, status, errorReason);\r\n        });\r\n        var affectedPath = this.abortTransactions_(path);\r\n        this.rerunTransactions_(affectedPath);\r\n        // We queued the events above, so just flush the queue here\r\n        this.eventQueue_.raiseEventsForChangedPath(affectedPath, []);\r\n    };\r\n    Repo.prototype.update = function (path, childrenToMerge, onComplete) {\r\n        var _this = this;\r\n        this.log_('update', { path: path.toString(), value: childrenToMerge });\r\n        // Start with our existing data and merge each child into it.\r\n        var empty = true;\r\n        var serverValues = this.generateServerValues();\r\n        var changedChildren = {};\r\n        each(childrenToMerge, function (changedKey, changedValue) {\r\n            empty = false;\r\n            changedChildren[changedKey] = resolveDeferredValueTree(path.child(changedKey), nodeFromJSON$1(changedValue), _this.serverSyncTree_, serverValues);\r\n        });\r\n        if (!empty) {\r\n            var writeId_1 = this.getNextWriteId_();\r\n            var events = this.serverSyncTree_.applyUserMerge(path, changedChildren, writeId_1);\r\n            this.eventQueue_.queueEvents(events);\r\n            this.server_.merge(path.toString(), childrenToMerge, function (status, errorReason) {\r\n                var success = status === 'ok';\r\n                if (!success) {\r\n                    warn('update at ' + path + ' failed: ' + status);\r\n                }\r\n                var clearEvents = _this.serverSyncTree_.ackUserWrite(writeId_1, !success);\r\n                var affectedPath = clearEvents.length > 0 ? _this.rerunTransactions_(path) : path;\r\n                _this.eventQueue_.raiseEventsForChangedPath(affectedPath, clearEvents);\r\n                _this.callOnCompleteCallback(onComplete, status, errorReason);\r\n            });\r\n            each(childrenToMerge, function (changedPath) {\r\n                var affectedPath = _this.abortTransactions_(path.child(changedPath));\r\n                _this.rerunTransactions_(affectedPath);\r\n            });\r\n            // We queued the events above, so just flush the queue here\r\n            this.eventQueue_.raiseEventsForChangedPath(path, []);\r\n        }\r\n        else {\r\n            log(\"update() called with empty data.  Don't do anything.\");\r\n            this.callOnCompleteCallback(onComplete, 'ok');\r\n        }\r\n    };\r\n    /**\r\n     * Applies all of the changes stored up in the onDisconnect_ tree.\r\n     */\r\n    Repo.prototype.runOnDisconnectEvents_ = function () {\r\n        var _this = this;\r\n        this.log_('onDisconnectEvents');\r\n        var serverValues = this.generateServerValues();\r\n        var resolvedOnDisconnectTree = new SparseSnapshotTree();\r\n        this.onDisconnect_.forEachTree(Path.Empty, function (path, node) {\r\n            var resolved = resolveDeferredValueTree(path, node, _this.serverSyncTree_, serverValues);\r\n            resolvedOnDisconnectTree.remember(path, resolved);\r\n        });\r\n        var events = [];\r\n        resolvedOnDisconnectTree.forEachTree(Path.Empty, function (path, snap) {\r\n            events = events.concat(_this.serverSyncTree_.applyServerOverwrite(path, snap));\r\n            var affectedPath = _this.abortTransactions_(path);\r\n            _this.rerunTransactions_(affectedPath);\r\n        });\r\n        this.onDisconnect_ = new SparseSnapshotTree();\r\n        this.eventQueue_.raiseEventsForChangedPath(Path.Empty, events);\r\n    };\r\n    Repo.prototype.onDisconnectCancel = function (path, onComplete) {\r\n        var _this = this;\r\n        this.server_.onDisconnectCancel(path.toString(), function (status, errorReason) {\r\n            if (status === 'ok') {\r\n                _this.onDisconnect_.forget(path);\r\n            }\r\n            _this.callOnCompleteCallback(onComplete, status, errorReason);\r\n        });\r\n    };\r\n    Repo.prototype.onDisconnectSet = function (path, value, onComplete) {\r\n        var _this = this;\r\n        var newNode = nodeFromJSON$1(value);\r\n        this.server_.onDisconnectPut(path.toString(), newNode.val(/*export=*/ true), function (status, errorReason) {\r\n            if (status === 'ok') {\r\n                _this.onDisconnect_.remember(path, newNode);\r\n            }\r\n            _this.callOnCompleteCallback(onComplete, status, errorReason);\r\n        });\r\n    };\r\n    Repo.prototype.onDisconnectSetWithPriority = function (path, value, priority, onComplete) {\r\n        var _this = this;\r\n        var newNode = nodeFromJSON$1(value, priority);\r\n        this.server_.onDisconnectPut(path.toString(), newNode.val(/*export=*/ true), function (status, errorReason) {\r\n            if (status === 'ok') {\r\n                _this.onDisconnect_.remember(path, newNode);\r\n            }\r\n            _this.callOnCompleteCallback(onComplete, status, errorReason);\r\n        });\r\n    };\r\n    Repo.prototype.onDisconnectUpdate = function (path, childrenToMerge, onComplete) {\r\n        var _this = this;\r\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isEmpty)(childrenToMerge)) {\r\n            log(\"onDisconnect().update() called with empty data.  Don't do anything.\");\r\n            this.callOnCompleteCallback(onComplete, 'ok');\r\n            return;\r\n        }\r\n        this.server_.onDisconnectMerge(path.toString(), childrenToMerge, function (status, errorReason) {\r\n            if (status === 'ok') {\r\n                each(childrenToMerge, function (childName, childNode) {\r\n                    var newChildNode = nodeFromJSON$1(childNode);\r\n                    _this.onDisconnect_.remember(path.child(childName), newChildNode);\r\n                });\r\n            }\r\n            _this.callOnCompleteCallback(onComplete, status, errorReason);\r\n        });\r\n    };\r\n    Repo.prototype.addEventCallbackForQuery = function (query, eventRegistration) {\r\n        var events;\r\n        if (query.path.getFront() === '.info') {\r\n            events = this.infoSyncTree_.addEventRegistration(query, eventRegistration);\r\n        }\r\n        else {\r\n            events = this.serverSyncTree_.addEventRegistration(query, eventRegistration);\r\n        }\r\n        this.eventQueue_.raiseEventsAtPath(query.path, events);\r\n    };\r\n    Repo.prototype.removeEventCallbackForQuery = function (query, eventRegistration) {\r\n        // These are guaranteed not to raise events, since we're not passing in a cancelError. However, we can future-proof\r\n        // a little bit by handling the return values anyways.\r\n        var events;\r\n        if (query.path.getFront() === '.info') {\r\n            events = this.infoSyncTree_.removeEventRegistration(query, eventRegistration);\r\n        }\r\n        else {\r\n            events = this.serverSyncTree_.removeEventRegistration(query, eventRegistration);\r\n        }\r\n        this.eventQueue_.raiseEventsAtPath(query.path, events);\r\n    };\r\n    Repo.prototype.interrupt = function () {\r\n        if (this.persistentConnection_) {\r\n            this.persistentConnection_.interrupt(INTERRUPT_REASON);\r\n        }\r\n    };\r\n    Repo.prototype.resume = function () {\r\n        if (this.persistentConnection_) {\r\n            this.persistentConnection_.resume(INTERRUPT_REASON);\r\n        }\r\n    };\r\n    Repo.prototype.stats = function (showDelta) {\r\n        if (showDelta === void 0) { showDelta = false; }\r\n        if (typeof console === 'undefined') {\r\n            return;\r\n        }\r\n        var stats;\r\n        if (showDelta) {\r\n            if (!this.statsListener_) {\r\n                this.statsListener_ = new StatsListener(this.stats_);\r\n            }\r\n            stats = this.statsListener_.get();\r\n        }\r\n        else {\r\n            stats = this.stats_.get();\r\n        }\r\n        var longestName = Object.keys(stats).reduce(function (previousValue, currentValue) {\r\n            return Math.max(currentValue.length, previousValue);\r\n        }, 0);\r\n        each(stats, function (stat, value) {\r\n            var paddedStat = stat;\r\n            // pad stat names to be the same length (plus 2 extra spaces).\r\n            for (var i = stat.length; i < longestName + 2; i++) {\r\n                paddedStat += ' ';\r\n            }\r\n            console.log(paddedStat + value);\r\n        });\r\n    };\r\n    Repo.prototype.statsIncrementCounter = function (metric) {\r\n        this.stats_.incrementCounter(metric);\r\n        this.statsReporter_.includeStat(metric);\r\n    };\r\n    Repo.prototype.log_ = function () {\r\n        var varArgs = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            varArgs[_i] = arguments[_i];\r\n        }\r\n        var prefix = '';\r\n        if (this.persistentConnection_) {\r\n            prefix = this.persistentConnection_.id + ':';\r\n        }\r\n        log.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__spread)([prefix], varArgs));\r\n    };\r\n    Repo.prototype.callOnCompleteCallback = function (callback, status, errorReason) {\r\n        if (callback) {\r\n            exceptionGuard(function () {\r\n                if (status === 'ok') {\r\n                    callback(null);\r\n                }\r\n                else {\r\n                    var code = (status || 'error').toUpperCase();\r\n                    var message = code;\r\n                    if (errorReason) {\r\n                        message += ': ' + errorReason;\r\n                    }\r\n                    var error = new Error(message);\r\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                    error.code = code;\r\n                    callback(error);\r\n                }\r\n            });\r\n        }\r\n    };\r\n    Object.defineProperty(Repo.prototype, \"database\", {\r\n        get: function () {\r\n            return this.__database || (this.__database = new Database(this));\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    return Repo;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Filters nodes by range and uses an IndexFilter to track any changes after filtering the node\r\n *\r\n * @constructor\r\n * @implements {NodeFilter}\r\n */\r\nvar RangedFilter = /** @class */ (function () {\r\n    /**\r\n     * @param {!QueryParams} params\r\n     */\r\n    function RangedFilter(params) {\r\n        this.indexedFilter_ = new IndexedFilter(params.getIndex());\r\n        this.index_ = params.getIndex();\r\n        this.startPost_ = RangedFilter.getStartPost_(params);\r\n        this.endPost_ = RangedFilter.getEndPost_(params);\r\n    }\r\n    /**\r\n     * @return {!NamedNode}\r\n     */\r\n    RangedFilter.prototype.getStartPost = function () {\r\n        return this.startPost_;\r\n    };\r\n    /**\r\n     * @return {!NamedNode}\r\n     */\r\n    RangedFilter.prototype.getEndPost = function () {\r\n        return this.endPost_;\r\n    };\r\n    /**\r\n     * @param {!NamedNode} node\r\n     * @return {boolean}\r\n     */\r\n    RangedFilter.prototype.matches = function (node) {\r\n        return (this.index_.compare(this.getStartPost(), node) <= 0 &&\r\n            this.index_.compare(node, this.getEndPost()) <= 0);\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    RangedFilter.prototype.updateChild = function (snap, key, newChild, affectedPath, source, optChangeAccumulator) {\r\n        if (!this.matches(new NamedNode(key, newChild))) {\r\n            newChild = ChildrenNode.EMPTY_NODE;\r\n        }\r\n        return this.indexedFilter_.updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator);\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    RangedFilter.prototype.updateFullNode = function (oldSnap, newSnap, optChangeAccumulator) {\r\n        if (newSnap.isLeafNode()) {\r\n            // Make sure we have a children node with the correct index, not a leaf node;\r\n            newSnap = ChildrenNode.EMPTY_NODE;\r\n        }\r\n        var filtered = newSnap.withIndex(this.index_);\r\n        // Don't support priorities on queries\r\n        filtered = filtered.updatePriority(ChildrenNode.EMPTY_NODE);\r\n        var self = this;\r\n        newSnap.forEachChild(PRIORITY_INDEX, function (key, childNode) {\r\n            if (!self.matches(new NamedNode(key, childNode))) {\r\n                filtered = filtered.updateImmediateChild(key, ChildrenNode.EMPTY_NODE);\r\n            }\r\n        });\r\n        return this.indexedFilter_.updateFullNode(oldSnap, filtered, optChangeAccumulator);\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    RangedFilter.prototype.updatePriority = function (oldSnap, newPriority) {\r\n        // Don't support priorities on queries\r\n        return oldSnap;\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    RangedFilter.prototype.filtersNodes = function () {\r\n        return true;\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    RangedFilter.prototype.getIndexedFilter = function () {\r\n        return this.indexedFilter_;\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    RangedFilter.prototype.getIndex = function () {\r\n        return this.index_;\r\n    };\r\n    /**\r\n     * @param {!QueryParams} params\r\n     * @return {!NamedNode}\r\n     * @private\r\n     */\r\n    RangedFilter.getStartPost_ = function (params) {\r\n        if (params.hasStart()) {\r\n            var startName = params.getIndexStartName();\r\n            return params.getIndex().makePost(params.getIndexStartValue(), startName);\r\n        }\r\n        else {\r\n            return params.getIndex().minPost();\r\n        }\r\n    };\r\n    /**\r\n     * @param {!QueryParams} params\r\n     * @return {!NamedNode}\r\n     * @private\r\n     */\r\n    RangedFilter.getEndPost_ = function (params) {\r\n        if (params.hasEnd()) {\r\n            var endName = params.getIndexEndName();\r\n            return params.getIndex().makePost(params.getIndexEndValue(), endName);\r\n        }\r\n        else {\r\n            return params.getIndex().maxPost();\r\n        }\r\n    };\r\n    return RangedFilter;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Applies a limit and a range to a node and uses RangedFilter to do the heavy lifting where possible\r\n *\r\n * @constructor\r\n * @implements {NodeFilter}\r\n */\r\nvar LimitedFilter = /** @class */ (function () {\r\n    /**\r\n     * @param {!QueryParams} params\r\n     */\r\n    function LimitedFilter(params) {\r\n        this.rangedFilter_ = new RangedFilter(params);\r\n        this.index_ = params.getIndex();\r\n        this.limit_ = params.getLimit();\r\n        this.reverse_ = !params.isViewFromLeft();\r\n    }\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    LimitedFilter.prototype.updateChild = function (snap, key, newChild, affectedPath, source, optChangeAccumulator) {\r\n        if (!this.rangedFilter_.matches(new NamedNode(key, newChild))) {\r\n            newChild = ChildrenNode.EMPTY_NODE;\r\n        }\r\n        if (snap.getImmediateChild(key).equals(newChild)) {\r\n            // No change\r\n            return snap;\r\n        }\r\n        else if (snap.numChildren() < this.limit_) {\r\n            return this.rangedFilter_\r\n                .getIndexedFilter()\r\n                .updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator);\r\n        }\r\n        else {\r\n            return this.fullLimitUpdateChild_(snap, key, newChild, source, optChangeAccumulator);\r\n        }\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    LimitedFilter.prototype.updateFullNode = function (oldSnap, newSnap, optChangeAccumulator) {\r\n        var filtered;\r\n        if (newSnap.isLeafNode() || newSnap.isEmpty()) {\r\n            // Make sure we have a children node with the correct index, not a leaf node;\r\n            filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);\r\n        }\r\n        else {\r\n            if (this.limit_ * 2 < newSnap.numChildren() &&\r\n                newSnap.isIndexed(this.index_)) {\r\n                // Easier to build up a snapshot, since what we're given has more than twice the elements we want\r\n                filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);\r\n                // anchor to the startPost, endPost, or last element as appropriate\r\n                var iterator = void 0;\r\n                if (this.reverse_) {\r\n                    iterator = newSnap.getReverseIteratorFrom(this.rangedFilter_.getEndPost(), this.index_);\r\n                }\r\n                else {\r\n                    iterator = newSnap.getIteratorFrom(this.rangedFilter_.getStartPost(), this.index_);\r\n                }\r\n                var count = 0;\r\n                while (iterator.hasNext() && count < this.limit_) {\r\n                    var next = iterator.getNext();\r\n                    var inRange = void 0;\r\n                    if (this.reverse_) {\r\n                        inRange =\r\n                            this.index_.compare(this.rangedFilter_.getStartPost(), next) <= 0;\r\n                    }\r\n                    else {\r\n                        inRange =\r\n                            this.index_.compare(next, this.rangedFilter_.getEndPost()) <= 0;\r\n                    }\r\n                    if (inRange) {\r\n                        filtered = filtered.updateImmediateChild(next.name, next.node);\r\n                        count++;\r\n                    }\r\n                    else {\r\n                        // if we have reached the end post, we cannot keep adding elemments\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // The snap contains less than twice the limit. Faster to delete from the snap than build up a new one\r\n                filtered = newSnap.withIndex(this.index_);\r\n                // Don't support priorities on queries\r\n                filtered = filtered.updatePriority(ChildrenNode.EMPTY_NODE);\r\n                var startPost = void 0;\r\n                var endPost = void 0;\r\n                var cmp = void 0;\r\n                var iterator = void 0;\r\n                if (this.reverse_) {\r\n                    iterator = filtered.getReverseIterator(this.index_);\r\n                    startPost = this.rangedFilter_.getEndPost();\r\n                    endPost = this.rangedFilter_.getStartPost();\r\n                    var indexCompare_1 = this.index_.getCompare();\r\n                    cmp = function (a, b) { return indexCompare_1(b, a); };\r\n                }\r\n                else {\r\n                    iterator = filtered.getIterator(this.index_);\r\n                    startPost = this.rangedFilter_.getStartPost();\r\n                    endPost = this.rangedFilter_.getEndPost();\r\n                    cmp = this.index_.getCompare();\r\n                }\r\n                var count = 0;\r\n                var foundStartPost = false;\r\n                while (iterator.hasNext()) {\r\n                    var next = iterator.getNext();\r\n                    if (!foundStartPost && cmp(startPost, next) <= 0) {\r\n                        // start adding\r\n                        foundStartPost = true;\r\n                    }\r\n                    var inRange = foundStartPost && count < this.limit_ && cmp(next, endPost) <= 0;\r\n                    if (inRange) {\r\n                        count++;\r\n                    }\r\n                    else {\r\n                        filtered = filtered.updateImmediateChild(next.name, ChildrenNode.EMPTY_NODE);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return this.rangedFilter_\r\n            .getIndexedFilter()\r\n            .updateFullNode(oldSnap, filtered, optChangeAccumulator);\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    LimitedFilter.prototype.updatePriority = function (oldSnap, newPriority) {\r\n        // Don't support priorities on queries\r\n        return oldSnap;\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    LimitedFilter.prototype.filtersNodes = function () {\r\n        return true;\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    LimitedFilter.prototype.getIndexedFilter = function () {\r\n        return this.rangedFilter_.getIndexedFilter();\r\n    };\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    LimitedFilter.prototype.getIndex = function () {\r\n        return this.index_;\r\n    };\r\n    /**\r\n     * @param {!Node} snap\r\n     * @param {string} childKey\r\n     * @param {!Node} childSnap\r\n     * @param {!CompleteChildSource} source\r\n     * @param {?ChildChangeAccumulator} changeAccumulator\r\n     * @return {!Node}\r\n     * @private\r\n     */\r\n    LimitedFilter.prototype.fullLimitUpdateChild_ = function (snap, childKey, childSnap, source, changeAccumulator) {\r\n        // TODO: rename all cache stuff etc to general snap terminology\r\n        var cmp;\r\n        if (this.reverse_) {\r\n            var indexCmp_1 = this.index_.getCompare();\r\n            cmp = function (a, b) { return indexCmp_1(b, a); };\r\n        }\r\n        else {\r\n            cmp = this.index_.getCompare();\r\n        }\r\n        var oldEventCache = snap;\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(oldEventCache.numChildren() === this.limit_, '');\r\n        var newChildNamedNode = new NamedNode(childKey, childSnap);\r\n        var windowBoundary = this.reverse_\r\n            ? oldEventCache.getFirstChild(this.index_)\r\n            : oldEventCache.getLastChild(this.index_);\r\n        var inRange = this.rangedFilter_.matches(newChildNamedNode);\r\n        if (oldEventCache.hasChild(childKey)) {\r\n            var oldChildSnap = oldEventCache.getImmediateChild(childKey);\r\n            var nextChild = source.getChildAfterChild(this.index_, windowBoundary, this.reverse_);\r\n            while (nextChild != null &&\r\n                (nextChild.name === childKey || oldEventCache.hasChild(nextChild.name))) {\r\n                // There is a weird edge case where a node is updated as part of a merge in the write tree, but hasn't\r\n                // been applied to the limited filter yet. Ignore this next child which will be updated later in\r\n                // the limited filter...\r\n                nextChild = source.getChildAfterChild(this.index_, nextChild, this.reverse_);\r\n            }\r\n            var compareNext = nextChild == null ? 1 : cmp(nextChild, newChildNamedNode);\r\n            var remainsInWindow = inRange && !childSnap.isEmpty() && compareNext >= 0;\r\n            if (remainsInWindow) {\r\n                if (changeAccumulator != null) {\r\n                    changeAccumulator.trackChildChange(Change.childChangedChange(childKey, childSnap, oldChildSnap));\r\n                }\r\n                return oldEventCache.updateImmediateChild(childKey, childSnap);\r\n            }\r\n            else {\r\n                if (changeAccumulator != null) {\r\n                    changeAccumulator.trackChildChange(Change.childRemovedChange(childKey, oldChildSnap));\r\n                }\r\n                var newEventCache = oldEventCache.updateImmediateChild(childKey, ChildrenNode.EMPTY_NODE);\r\n                var nextChildInRange = nextChild != null && this.rangedFilter_.matches(nextChild);\r\n                if (nextChildInRange) {\r\n                    if (changeAccumulator != null) {\r\n                        changeAccumulator.trackChildChange(Change.childAddedChange(nextChild.name, nextChild.node));\r\n                    }\r\n                    return newEventCache.updateImmediateChild(nextChild.name, nextChild.node);\r\n                }\r\n                else {\r\n                    return newEventCache;\r\n                }\r\n            }\r\n        }\r\n        else if (childSnap.isEmpty()) {\r\n            // we're deleting a node, but it was not in the window, so ignore it\r\n            return snap;\r\n        }\r\n        else if (inRange) {\r\n            if (cmp(windowBoundary, newChildNamedNode) >= 0) {\r\n                if (changeAccumulator != null) {\r\n                    changeAccumulator.trackChildChange(Change.childRemovedChange(windowBoundary.name, windowBoundary.node));\r\n                    changeAccumulator.trackChildChange(Change.childAddedChange(childKey, childSnap));\r\n                }\r\n                return oldEventCache\r\n                    .updateImmediateChild(childKey, childSnap)\r\n                    .updateImmediateChild(windowBoundary.name, ChildrenNode.EMPTY_NODE);\r\n            }\r\n            else {\r\n                return snap;\r\n            }\r\n        }\r\n        else {\r\n            return snap;\r\n        }\r\n    };\r\n    return LimitedFilter;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * This class is an immutable-from-the-public-api struct containing a set of query parameters defining a\r\n * range to be returned for a particular location. It is assumed that validation of parameters is done at the\r\n * user-facing API level, so it is not done here.\r\n * @constructor\r\n */\r\nvar QueryParams = /** @class */ (function () {\r\n    function QueryParams() {\r\n        this.limitSet_ = false;\r\n        this.startSet_ = false;\r\n        this.startNameSet_ = false;\r\n        this.endSet_ = false;\r\n        this.endNameSet_ = false;\r\n        this.limit_ = 0;\r\n        this.viewFrom_ = '';\r\n        this.indexStartValue_ = null;\r\n        this.indexStartName_ = '';\r\n        this.indexEndValue_ = null;\r\n        this.indexEndName_ = '';\r\n        this.index_ = PRIORITY_INDEX;\r\n    }\r\n    /**\r\n     * @return {boolean}\r\n     */\r\n    QueryParams.prototype.hasStart = function () {\r\n        return this.startSet_;\r\n    };\r\n    /**\r\n     * @return {boolean} True if it would return from left.\r\n     */\r\n    QueryParams.prototype.isViewFromLeft = function () {\r\n        if (this.viewFrom_ === '') {\r\n            // limit(), rather than limitToFirst or limitToLast was called.\r\n            // This means that only one of startSet_ and endSet_ is true. Use them\r\n            // to calculate which side of the view to anchor to. If neither is set,\r\n            // anchor to the end.\r\n            return this.startSet_;\r\n        }\r\n        else {\r\n            return (this.viewFrom_ === QueryParams.WIRE_PROTOCOL_CONSTANTS_.VIEW_FROM_LEFT);\r\n        }\r\n    };\r\n    /**\r\n     * Only valid to call if hasStart() returns true\r\n     * @return {*}\r\n     */\r\n    QueryParams.prototype.getIndexStartValue = function () {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.startSet_, 'Only valid if start has been set');\r\n        return this.indexStartValue_;\r\n    };\r\n    /**\r\n     * Only valid to call if hasStart() returns true.\r\n     * Returns the starting key name for the range defined by these query parameters\r\n     * @return {!string}\r\n     */\r\n    QueryParams.prototype.getIndexStartName = function () {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.startSet_, 'Only valid if start has been set');\r\n        if (this.startNameSet_) {\r\n            return this.indexStartName_;\r\n        }\r\n        else {\r\n            return MIN_NAME;\r\n        }\r\n    };\r\n    /**\r\n     * @return {boolean}\r\n     */\r\n    QueryParams.prototype.hasEnd = function () {\r\n        return this.endSet_;\r\n    };\r\n    /**\r\n     * Only valid to call if hasEnd() returns true.\r\n     * @return {*}\r\n     */\r\n    QueryParams.prototype.getIndexEndValue = function () {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.endSet_, 'Only valid if end has been set');\r\n        return this.indexEndValue_;\r\n    };\r\n    /**\r\n     * Only valid to call if hasEnd() returns true.\r\n     * Returns the end key name for the range defined by these query parameters\r\n     * @return {!string}\r\n     */\r\n    QueryParams.prototype.getIndexEndName = function () {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.endSet_, 'Only valid if end has been set');\r\n        if (this.endNameSet_) {\r\n            return this.indexEndName_;\r\n        }\r\n        else {\r\n            return MAX_NAME;\r\n        }\r\n    };\r\n    /**\r\n     * @return {boolean}\r\n     */\r\n    QueryParams.prototype.hasLimit = function () {\r\n        return this.limitSet_;\r\n    };\r\n    /**\r\n     * @return {boolean} True if a limit has been set and it has been explicitly anchored\r\n     */\r\n    QueryParams.prototype.hasAnchoredLimit = function () {\r\n        return this.limitSet_ && this.viewFrom_ !== '';\r\n    };\r\n    /**\r\n     * Only valid to call if hasLimit() returns true\r\n     * @return {!number}\r\n     */\r\n    QueryParams.prototype.getLimit = function () {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.limitSet_, 'Only valid if limit has been set');\r\n        return this.limit_;\r\n    };\r\n    /**\r\n     * @return {!Index}\r\n     */\r\n    QueryParams.prototype.getIndex = function () {\r\n        return this.index_;\r\n    };\r\n    /**\r\n     * @return {!QueryParams}\r\n     * @private\r\n     */\r\n    QueryParams.prototype.copy_ = function () {\r\n        var copy = new QueryParams();\r\n        copy.limitSet_ = this.limitSet_;\r\n        copy.limit_ = this.limit_;\r\n        copy.startSet_ = this.startSet_;\r\n        copy.indexStartValue_ = this.indexStartValue_;\r\n        copy.startNameSet_ = this.startNameSet_;\r\n        copy.indexStartName_ = this.indexStartName_;\r\n        copy.endSet_ = this.endSet_;\r\n        copy.indexEndValue_ = this.indexEndValue_;\r\n        copy.endNameSet_ = this.endNameSet_;\r\n        copy.indexEndName_ = this.indexEndName_;\r\n        copy.index_ = this.index_;\r\n        copy.viewFrom_ = this.viewFrom_;\r\n        return copy;\r\n    };\r\n    /**\r\n     * @param {!number} newLimit\r\n     * @return {!QueryParams}\r\n     */\r\n    QueryParams.prototype.limit = function (newLimit) {\r\n        var newParams = this.copy_();\r\n        newParams.limitSet_ = true;\r\n        newParams.limit_ = newLimit;\r\n        newParams.viewFrom_ = '';\r\n        return newParams;\r\n    };\r\n    /**\r\n     * @param {!number} newLimit\r\n     * @return {!QueryParams}\r\n     */\r\n    QueryParams.prototype.limitToFirst = function (newLimit) {\r\n        var newParams = this.copy_();\r\n        newParams.limitSet_ = true;\r\n        newParams.limit_ = newLimit;\r\n        newParams.viewFrom_ = QueryParams.WIRE_PROTOCOL_CONSTANTS_.VIEW_FROM_LEFT;\r\n        return newParams;\r\n    };\r\n    /**\r\n     * @param {!number} newLimit\r\n     * @return {!QueryParams}\r\n     */\r\n    QueryParams.prototype.limitToLast = function (newLimit) {\r\n        var newParams = this.copy_();\r\n        newParams.limitSet_ = true;\r\n        newParams.limit_ = newLimit;\r\n        newParams.viewFrom_ = QueryParams.WIRE_PROTOCOL_CONSTANTS_.VIEW_FROM_RIGHT;\r\n        return newParams;\r\n    };\r\n    /**\r\n     * @param {*} indexValue\r\n     * @param {?string=} key\r\n     * @return {!QueryParams}\r\n     */\r\n    QueryParams.prototype.startAt = function (indexValue, key) {\r\n        var newParams = this.copy_();\r\n        newParams.startSet_ = true;\r\n        if (indexValue === undefined) {\r\n            indexValue = null;\r\n        }\r\n        newParams.indexStartValue_ = indexValue;\r\n        if (key != null) {\r\n            newParams.startNameSet_ = true;\r\n            newParams.indexStartName_ = key;\r\n        }\r\n        else {\r\n            newParams.startNameSet_ = false;\r\n            newParams.indexStartName_ = '';\r\n        }\r\n        return newParams;\r\n    };\r\n    /**\r\n     * @param {*} indexValue\r\n     * @param {?string=} key\r\n     * @return {!QueryParams}\r\n     */\r\n    QueryParams.prototype.endAt = function (indexValue, key) {\r\n        var newParams = this.copy_();\r\n        newParams.endSet_ = true;\r\n        if (indexValue === undefined) {\r\n            indexValue = null;\r\n        }\r\n        newParams.indexEndValue_ = indexValue;\r\n        if (key !== undefined) {\r\n            newParams.endNameSet_ = true;\r\n            newParams.indexEndName_ = key;\r\n        }\r\n        else {\r\n            newParams.endNameSet_ = false;\r\n            newParams.indexEndName_ = '';\r\n        }\r\n        return newParams;\r\n    };\r\n    /**\r\n     * @param {!Index} index\r\n     * @return {!QueryParams}\r\n     */\r\n    QueryParams.prototype.orderBy = function (index) {\r\n        var newParams = this.copy_();\r\n        newParams.index_ = index;\r\n        return newParams;\r\n    };\r\n    /**\r\n     * @return {!Object}\r\n     */\r\n    QueryParams.prototype.getQueryObject = function () {\r\n        var WIRE_PROTOCOL_CONSTANTS = QueryParams.WIRE_PROTOCOL_CONSTANTS_;\r\n        var obj = {};\r\n        if (this.startSet_) {\r\n            obj[WIRE_PROTOCOL_CONSTANTS.INDEX_START_VALUE] = this.indexStartValue_;\r\n            if (this.startNameSet_) {\r\n                obj[WIRE_PROTOCOL_CONSTANTS.INDEX_START_NAME] = this.indexStartName_;\r\n            }\r\n        }\r\n        if (this.endSet_) {\r\n            obj[WIRE_PROTOCOL_CONSTANTS.INDEX_END_VALUE] = this.indexEndValue_;\r\n            if (this.endNameSet_) {\r\n                obj[WIRE_PROTOCOL_CONSTANTS.INDEX_END_NAME] = this.indexEndName_;\r\n            }\r\n        }\r\n        if (this.limitSet_) {\r\n            obj[WIRE_PROTOCOL_CONSTANTS.LIMIT] = this.limit_;\r\n            var viewFrom = this.viewFrom_;\r\n            if (viewFrom === '') {\r\n                if (this.isViewFromLeft()) {\r\n                    viewFrom = WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_LEFT;\r\n                }\r\n                else {\r\n                    viewFrom = WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_RIGHT;\r\n                }\r\n            }\r\n            obj[WIRE_PROTOCOL_CONSTANTS.VIEW_FROM] = viewFrom;\r\n        }\r\n        // For now, priority index is the default, so we only specify if it's some other index\r\n        if (this.index_ !== PRIORITY_INDEX) {\r\n            obj[WIRE_PROTOCOL_CONSTANTS.INDEX] = this.index_.toString();\r\n        }\r\n        return obj;\r\n    };\r\n    /**\r\n     * @return {boolean}\r\n     */\r\n    QueryParams.prototype.loadsAllData = function () {\r\n        return !(this.startSet_ || this.endSet_ || this.limitSet_);\r\n    };\r\n    /**\r\n     * @return {boolean}\r\n     */\r\n    QueryParams.prototype.isDefault = function () {\r\n        return this.loadsAllData() && this.index_ === PRIORITY_INDEX;\r\n    };\r\n    /**\r\n     * @return {!NodeFilter}\r\n     */\r\n    QueryParams.prototype.getNodeFilter = function () {\r\n        if (this.loadsAllData()) {\r\n            return new IndexedFilter(this.getIndex());\r\n        }\r\n        else if (this.hasLimit()) {\r\n            return new LimitedFilter(this);\r\n        }\r\n        else {\r\n            return new RangedFilter(this);\r\n        }\r\n    };\r\n    /**\r\n     * Returns a set of REST query string parameters representing this query.\r\n     *\r\n     * @return {!Object.<string,*>} query string parameters\r\n     */\r\n    QueryParams.prototype.toRestQueryStringParameters = function () {\r\n        var REST_CONSTANTS = QueryParams.REST_QUERY_CONSTANTS_;\r\n        var qs = {};\r\n        if (this.isDefault()) {\r\n            return qs;\r\n        }\r\n        var orderBy;\r\n        if (this.index_ === PRIORITY_INDEX) {\r\n            orderBy = REST_CONSTANTS.PRIORITY_INDEX;\r\n        }\r\n        else if (this.index_ === VALUE_INDEX) {\r\n            orderBy = REST_CONSTANTS.VALUE_INDEX;\r\n        }\r\n        else if (this.index_ === KEY_INDEX) {\r\n            orderBy = REST_CONSTANTS.KEY_INDEX;\r\n        }\r\n        else {\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(this.index_ instanceof PathIndex, 'Unrecognized index type!');\r\n            orderBy = this.index_.toString();\r\n        }\r\n        qs[REST_CONSTANTS.ORDER_BY] = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(orderBy);\r\n        if (this.startSet_) {\r\n            qs[REST_CONSTANTS.START_AT] = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(this.indexStartValue_);\r\n            if (this.startNameSet_) {\r\n                qs[REST_CONSTANTS.START_AT] += ',' + (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(this.indexStartName_);\r\n            }\r\n        }\r\n        if (this.endSet_) {\r\n            qs[REST_CONSTANTS.END_AT] = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(this.indexEndValue_);\r\n            if (this.endNameSet_) {\r\n                qs[REST_CONSTANTS.END_AT] += ',' + (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.stringify)(this.indexEndName_);\r\n            }\r\n        }\r\n        if (this.limitSet_) {\r\n            if (this.isViewFromLeft()) {\r\n                qs[REST_CONSTANTS.LIMIT_TO_FIRST] = this.limit_;\r\n            }\r\n            else {\r\n                qs[REST_CONSTANTS.LIMIT_TO_LAST] = this.limit_;\r\n            }\r\n        }\r\n        return qs;\r\n    };\r\n    /**\r\n     * Wire Protocol Constants\r\n     * @const\r\n     * @enum {string}\r\n     * @private\r\n     */\r\n    QueryParams.WIRE_PROTOCOL_CONSTANTS_ = {\r\n        INDEX_START_VALUE: 'sp',\r\n        INDEX_START_NAME: 'sn',\r\n        INDEX_END_VALUE: 'ep',\r\n        INDEX_END_NAME: 'en',\r\n        LIMIT: 'l',\r\n        VIEW_FROM: 'vf',\r\n        VIEW_FROM_LEFT: 'l',\r\n        VIEW_FROM_RIGHT: 'r',\r\n        INDEX: 'i'\r\n    };\r\n    /**\r\n     * REST Query Constants\r\n     * @const\r\n     * @enum {string}\r\n     * @private\r\n     */\r\n    QueryParams.REST_QUERY_CONSTANTS_ = {\r\n        ORDER_BY: 'orderBy',\r\n        PRIORITY_INDEX: '$priority',\r\n        VALUE_INDEX: '$value',\r\n        KEY_INDEX: '$key',\r\n        START_AT: 'startAt',\r\n        END_AT: 'endAt',\r\n        LIMIT_TO_FIRST: 'limitToFirst',\r\n        LIMIT_TO_LAST: 'limitToLast'\r\n    };\r\n    /**\r\n     * Default, empty query parameters\r\n     * @type {!QueryParams}\r\n     * @const\r\n     */\r\n    QueryParams.DEFAULT = new QueryParams();\r\n    return QueryParams;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar Reference = /** @class */ (function (_super) {\r\n    (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(Reference, _super);\r\n    /**\r\n     * Call options:\r\n     *   new Reference(Repo, Path) or\r\n     *   new Reference(url: string, string|RepoManager)\r\n     *\r\n     * Externally - this is the firebase.database.Reference type.\r\n     *\r\n     * @param {!Repo} repo\r\n     * @param {(!Path)} path\r\n     * @extends {Query}\r\n     */\r\n    function Reference(repo, path) {\r\n        var _this = this;\r\n        if (!(repo instanceof Repo)) {\r\n            throw new Error('new Reference() no longer supported - use app.database().');\r\n        }\r\n        // call Query's constructor, passing in the repo and path.\r\n        _this = _super.call(this, repo, path, QueryParams.DEFAULT, false) || this;\r\n        return _this;\r\n    }\r\n    /** @return {?string} */\r\n    Reference.prototype.getKey = function () {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('Reference.key', 0, 0, arguments.length);\r\n        if (this.path.isEmpty()) {\r\n            return null;\r\n        }\r\n        else {\r\n            return this.path.getBack();\r\n        }\r\n    };\r\n    /**\r\n     * @param {!(string|Path)} pathString\r\n     * @return {!Reference}\r\n     */\r\n    Reference.prototype.child = function (pathString) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('Reference.child', 1, 1, arguments.length);\r\n        if (typeof pathString === 'number') {\r\n            pathString = String(pathString);\r\n        }\r\n        else if (!(pathString instanceof Path)) {\r\n            if (this.path.getFront() === null) {\r\n                validateRootPathString('Reference.child', 1, pathString, false);\r\n            }\r\n            else {\r\n                validatePathString('Reference.child', 1, pathString, false);\r\n            }\r\n        }\r\n        return new Reference(this.repo, this.path.child(pathString));\r\n    };\r\n    /** @return {?Reference} */\r\n    Reference.prototype.getParent = function () {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('Reference.parent', 0, 0, arguments.length);\r\n        var parentPath = this.path.parent();\r\n        return parentPath === null ? null : new Reference(this.repo, parentPath);\r\n    };\r\n    /** @return {!Reference} */\r\n    Reference.prototype.getRoot = function () {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('Reference.root', 0, 0, arguments.length);\r\n        var ref = this;\r\n        while (ref.getParent() !== null) {\r\n            ref = ref.getParent();\r\n        }\r\n        return ref;\r\n    };\r\n    /** @return {!Database} */\r\n    Reference.prototype.databaseProp = function () {\r\n        return this.repo.database;\r\n    };\r\n    /**\r\n     * @param {*} newVal\r\n     * @param {function(?Error)=} onComplete\r\n     * @return {!Promise}\r\n     */\r\n    Reference.prototype.set = function (newVal, onComplete) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('Reference.set', 1, 2, arguments.length);\r\n        validateWritablePath('Reference.set', this.path);\r\n        validateFirebaseDataArg('Reference.set', 1, newVal, this.path, false);\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateCallback)('Reference.set', 2, onComplete, true);\r\n        var deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();\r\n        this.repo.setWithPriority(this.path, newVal, \r\n        /*priority=*/ null, deferred.wrapCallback(onComplete));\r\n        return deferred.promise;\r\n    };\r\n    /**\r\n     * @param {!Object} objectToMerge\r\n     * @param {function(?Error)=} onComplete\r\n     * @return {!Promise}\r\n     */\r\n    Reference.prototype.update = function (objectToMerge, onComplete) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('Reference.update', 1, 2, arguments.length);\r\n        validateWritablePath('Reference.update', this.path);\r\n        if (Array.isArray(objectToMerge)) {\r\n            var newObjectToMerge = {};\r\n            for (var i = 0; i < objectToMerge.length; ++i) {\r\n                newObjectToMerge['' + i] = objectToMerge[i];\r\n            }\r\n            objectToMerge = newObjectToMerge;\r\n            warn('Passing an Array to Firebase.update() is deprecated. ' +\r\n                'Use set() if you want to overwrite the existing data, or ' +\r\n                'an Object with integer keys if you really do want to ' +\r\n                'only update some of the children.');\r\n        }\r\n        validateFirebaseMergeDataArg('Reference.update', 1, objectToMerge, this.path, false);\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateCallback)('Reference.update', 2, onComplete, true);\r\n        var deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();\r\n        this.repo.update(this.path, objectToMerge, deferred.wrapCallback(onComplete));\r\n        return deferred.promise;\r\n    };\r\n    /**\r\n     * @param {*} newVal\r\n     * @param {string|number|null} newPriority\r\n     * @param {function(?Error)=} onComplete\r\n     * @return {!Promise}\r\n     */\r\n    Reference.prototype.setWithPriority = function (newVal, newPriority, onComplete) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('Reference.setWithPriority', 2, 3, arguments.length);\r\n        validateWritablePath('Reference.setWithPriority', this.path);\r\n        validateFirebaseDataArg('Reference.setWithPriority', 1, newVal, this.path, false);\r\n        validatePriority('Reference.setWithPriority', 2, newPriority, false);\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateCallback)('Reference.setWithPriority', 3, onComplete, true);\r\n        if (this.getKey() === '.length' || this.getKey() === '.keys') {\r\n            throw ('Reference.setWithPriority failed: ' +\r\n                this.getKey() +\r\n                ' is a read-only object.');\r\n        }\r\n        var deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();\r\n        this.repo.setWithPriority(this.path, newVal, newPriority, deferred.wrapCallback(onComplete));\r\n        return deferred.promise;\r\n    };\r\n    /**\r\n     * @param {function(?Error)=} onComplete\r\n     * @return {!Promise}\r\n     */\r\n    Reference.prototype.remove = function (onComplete) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('Reference.remove', 0, 1, arguments.length);\r\n        validateWritablePath('Reference.remove', this.path);\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateCallback)('Reference.remove', 1, onComplete, true);\r\n        return this.set(null, onComplete);\r\n    };\r\n    /**\r\n     * @param {function(*):*} transactionUpdate\r\n     * @param {(function(?Error, boolean, ?DataSnapshot))=} onComplete\r\n     * @param {boolean=} applyLocally\r\n     * @return {!Promise}\r\n     */\r\n    Reference.prototype.transaction = function (transactionUpdate, onComplete, applyLocally) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('Reference.transaction', 1, 3, arguments.length);\r\n        validateWritablePath('Reference.transaction', this.path);\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateCallback)('Reference.transaction', 1, transactionUpdate, false);\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateCallback)('Reference.transaction', 2, onComplete, true);\r\n        // NOTE: applyLocally is an internal-only option for now.  We need to decide if we want to keep it and how\r\n        // to expose it.\r\n        validateBoolean('Reference.transaction', 3, applyLocally, true);\r\n        if (this.getKey() === '.length' || this.getKey() === '.keys') {\r\n            throw ('Reference.transaction failed: ' +\r\n                this.getKey() +\r\n                ' is a read-only object.');\r\n        }\r\n        if (applyLocally === undefined) {\r\n            applyLocally = true;\r\n        }\r\n        var deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();\r\n        if (typeof onComplete === 'function') {\r\n            deferred.promise.catch(function () { });\r\n        }\r\n        var promiseComplete = function (error, committed, snapshot) {\r\n            if (error) {\r\n                deferred.reject(error);\r\n            }\r\n            else {\r\n                deferred.resolve(new TransactionResult(committed, snapshot));\r\n            }\r\n            if (typeof onComplete === 'function') {\r\n                onComplete(error, committed, snapshot);\r\n            }\r\n        };\r\n        this.repo.startTransaction(this.path, transactionUpdate, promiseComplete, applyLocally);\r\n        return deferred.promise;\r\n    };\r\n    /**\r\n     * @param {string|number|null} priority\r\n     * @param {function(?Error)=} onComplete\r\n     * @return {!Promise}\r\n     */\r\n    Reference.prototype.setPriority = function (priority, onComplete) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('Reference.setPriority', 1, 2, arguments.length);\r\n        validateWritablePath('Reference.setPriority', this.path);\r\n        validatePriority('Reference.setPriority', 1, priority, false);\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateCallback)('Reference.setPriority', 2, onComplete, true);\r\n        var deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.Deferred();\r\n        this.repo.setWithPriority(this.path.child('.priority'), priority, null, deferred.wrapCallback(onComplete));\r\n        return deferred.promise;\r\n    };\r\n    /**\r\n     * @param {*=} value\r\n     * @param {function(?Error)=} onComplete\r\n     * @return {!Reference}\r\n     */\r\n    Reference.prototype.push = function (value, onComplete) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('Reference.push', 0, 2, arguments.length);\r\n        validateWritablePath('Reference.push', this.path);\r\n        validateFirebaseDataArg('Reference.push', 1, value, this.path, true);\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateCallback)('Reference.push', 2, onComplete, true);\r\n        var now = this.repo.serverTime();\r\n        var name = nextPushId(now);\r\n        // push() returns a ThennableReference whose promise is fulfilled with a regular Reference.\r\n        // We use child() to create handles to two different references. The first is turned into a\r\n        // ThennableReference below by adding then() and catch() methods and is used as the\r\n        // return value of push(). The second remains a regular Reference and is used as the fulfilled\r\n        // value of the first ThennableReference.\r\n        var thennablePushRef = this.child(name);\r\n        var pushRef = this.child(name);\r\n        var promise;\r\n        if (value != null) {\r\n            promise = thennablePushRef.set(value, onComplete).then(function () { return pushRef; });\r\n        }\r\n        else {\r\n            promise = Promise.resolve(pushRef);\r\n        }\r\n        thennablePushRef.then = promise.then.bind(promise);\r\n        thennablePushRef.catch = promise.then.bind(promise, undefined);\r\n        if (typeof onComplete === 'function') {\r\n            promise.catch(function () { });\r\n        }\r\n        return thennablePushRef;\r\n    };\r\n    /**\r\n     * @return {!OnDisconnect}\r\n     */\r\n    Reference.prototype.onDisconnect = function () {\r\n        validateWritablePath('Reference.onDisconnect', this.path);\r\n        return new OnDisconnect(this.repo, this.path);\r\n    };\r\n    Object.defineProperty(Reference.prototype, \"database\", {\r\n        get: function () {\r\n            return this.databaseProp();\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Reference.prototype, \"key\", {\r\n        get: function () {\r\n            return this.getKey();\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Reference.prototype, \"parent\", {\r\n        get: function () {\r\n            return this.getParent();\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Reference.prototype, \"root\", {\r\n        get: function () {\r\n            return this.getRoot();\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    return Reference;\r\n}(Query));\r\n/**\r\n * Define reference constructor in various modules\r\n *\r\n * We are doing this here to avoid several circular\r\n * dependency issues\r\n */\r\nQuery.__referenceConstructor = Reference;\r\nSyncPoint.__referenceConstructor = Reference;\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Node in a Tree.\r\n */\r\nvar TreeNode = /** @class */ (function () {\r\n    function TreeNode() {\r\n        // TODO: Consider making accessors that create children and value lazily or\r\n        // separate Internal / Leaf 'types'.\r\n        this.children = {};\r\n        this.childCount = 0;\r\n        this.value = null;\r\n    }\r\n    return TreeNode;\r\n}());\r\n/**\r\n * A light-weight tree, traversable by path.  Nodes can have both values and children.\r\n * Nodes are not enumerated (by forEachChild) unless they have a value or non-empty\r\n * children.\r\n */\r\nvar Tree = /** @class */ (function () {\r\n    /**\r\n     * @template T\r\n     * @param {string=} name_ Optional name of the node.\r\n     * @param {Tree=} parent_ Optional parent node.\r\n     * @param {TreeNode=} node_ Optional node to wrap.\r\n     */\r\n    function Tree(name_, parent_, node_) {\r\n        if (name_ === void 0) { name_ = ''; }\r\n        if (parent_ === void 0) { parent_ = null; }\r\n        if (node_ === void 0) { node_ = new TreeNode(); }\r\n        this.name_ = name_;\r\n        this.parent_ = parent_;\r\n        this.node_ = node_;\r\n    }\r\n    /**\r\n     * Returns a sub-Tree for the given path.\r\n     *\r\n     * @param {!(string|Path)} pathObj Path to look up.\r\n     * @return {!Tree.<T>} Tree for path.\r\n     */\r\n    Tree.prototype.subTree = function (pathObj) {\r\n        // TODO: Require pathObj to be Path?\r\n        var path = pathObj instanceof Path ? pathObj : new Path(pathObj);\r\n        var child = this, next = path.getFront();\r\n        while (next !== null) {\r\n            var childNode = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.safeGet)(child.node_.children, next) || new TreeNode();\r\n            child = new Tree(next, child, childNode);\r\n            path = path.popFront();\r\n            next = path.getFront();\r\n        }\r\n        return child;\r\n    };\r\n    /**\r\n     * Returns the data associated with this tree node.\r\n     *\r\n     * @return {?T} The data or null if no data exists.\r\n     */\r\n    Tree.prototype.getValue = function () {\r\n        return this.node_.value;\r\n    };\r\n    /**\r\n     * Sets data to this tree node.\r\n     *\r\n     * @param {!T} value Value to set.\r\n     */\r\n    Tree.prototype.setValue = function (value) {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(typeof value !== 'undefined', 'Cannot set value to undefined');\r\n        this.node_.value = value;\r\n        this.updateParents_();\r\n    };\r\n    /**\r\n     * Clears the contents of the tree node (its value and all children).\r\n     */\r\n    Tree.prototype.clear = function () {\r\n        this.node_.value = null;\r\n        this.node_.children = {};\r\n        this.node_.childCount = 0;\r\n        this.updateParents_();\r\n    };\r\n    /**\r\n     * @return {boolean} Whether the tree has any children.\r\n     */\r\n    Tree.prototype.hasChildren = function () {\r\n        return this.node_.childCount > 0;\r\n    };\r\n    /**\r\n     * @return {boolean} Whether the tree is empty (no value or children).\r\n     */\r\n    Tree.prototype.isEmpty = function () {\r\n        return this.getValue() === null && !this.hasChildren();\r\n    };\r\n    /**\r\n     * Calls action for each child of this tree node.\r\n     *\r\n     * @param {function(!Tree.<T>)} action Action to be called for each child.\r\n     */\r\n    Tree.prototype.forEachChild = function (action) {\r\n        var _this = this;\r\n        each(this.node_.children, function (child, childTree) {\r\n            action(new Tree(child, _this, childTree));\r\n        });\r\n    };\r\n    /**\r\n     * Does a depth-first traversal of this node's descendants, calling action for each one.\r\n     *\r\n     * @param {function(!Tree.<T>)} action Action to be called for each child.\r\n     * @param {boolean=} includeSelf Whether to call action on this node as well. Defaults to\r\n     *   false.\r\n     * @param {boolean=} childrenFirst Whether to call action on children before calling it on\r\n     *   parent.\r\n     */\r\n    Tree.prototype.forEachDescendant = function (action, includeSelf, childrenFirst) {\r\n        if (includeSelf && !childrenFirst) {\r\n            action(this);\r\n        }\r\n        this.forEachChild(function (child) {\r\n            child.forEachDescendant(action, /*includeSelf=*/ true, childrenFirst);\r\n        });\r\n        if (includeSelf && childrenFirst) {\r\n            action(this);\r\n        }\r\n    };\r\n    /**\r\n     * Calls action on each ancestor node.\r\n     *\r\n     * @param {function(!Tree.<T>)} action Action to be called on each parent; return\r\n     *   true to abort.\r\n     * @param {boolean=} includeSelf Whether to call action on this node as well.\r\n     * @return {boolean} true if the action callback returned true.\r\n     */\r\n    Tree.prototype.forEachAncestor = function (action, includeSelf) {\r\n        var node = includeSelf ? this : this.parent();\r\n        while (node !== null) {\r\n            if (action(node)) {\r\n                return true;\r\n            }\r\n            node = node.parent();\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * Does a depth-first traversal of this node's descendants.  When a descendant with a value\r\n     * is found, action is called on it and traversal does not continue inside the node.\r\n     * Action is *not* called on this node.\r\n     *\r\n     * @param {function(!Tree.<T>)} action Action to be called for each child.\r\n     */\r\n    Tree.prototype.forEachImmediateDescendantWithValue = function (action) {\r\n        this.forEachChild(function (child) {\r\n            if (child.getValue() !== null) {\r\n                action(child);\r\n            }\r\n            else {\r\n                child.forEachImmediateDescendantWithValue(action);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * @return {!Path} The path of this tree node, as a Path.\r\n     */\r\n    Tree.prototype.path = function () {\r\n        return new Path(this.parent_ === null\r\n            ? this.name_\r\n            : this.parent_.path() + '/' + this.name_);\r\n    };\r\n    /**\r\n     * @return {string} The name of the tree node.\r\n     */\r\n    Tree.prototype.name = function () {\r\n        return this.name_;\r\n    };\r\n    /**\r\n     * @return {?Tree} The parent tree node, or null if this is the root of the tree.\r\n     */\r\n    Tree.prototype.parent = function () {\r\n        return this.parent_;\r\n    };\r\n    /**\r\n     * Adds or removes this child from its parent based on whether it's empty or not.\r\n     *\r\n     * @private\r\n     */\r\n    Tree.prototype.updateParents_ = function () {\r\n        if (this.parent_ !== null) {\r\n            this.parent_.updateChild_(this.name_, this);\r\n        }\r\n    };\r\n    /**\r\n     * Adds or removes the passed child to this tree node, depending on whether it's empty.\r\n     *\r\n     * @param {string} childName The name of the child to update.\r\n     * @param {!Tree.<T>} child The child to update.\r\n     * @private\r\n     */\r\n    Tree.prototype.updateChild_ = function (childName, child) {\r\n        var childEmpty = child.isEmpty();\r\n        var childExists = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(this.node_.children, childName);\r\n        if (childEmpty && childExists) {\r\n            delete this.node_.children[childName];\r\n            this.node_.childCount--;\r\n            this.updateParents_();\r\n        }\r\n        else if (!childEmpty && !childExists) {\r\n            this.node_.children[childName] = child.node_;\r\n            this.node_.childCount++;\r\n            this.updateParents_();\r\n        }\r\n    };\r\n    return Tree;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// TODO: This is pretty messy.  Ideally, a lot of this would move into FirebaseData, or a transaction-specific\r\n// component used by FirebaseData, but it has ties to user callbacks (transaction update and onComplete) as well\r\n// as the realtime connection (to send transactions to the server).  So that all needs to be decoupled first.\r\n// For now it's part of Repo, but in its own file.\r\n/**\r\n * @enum {number}\r\n */\r\nvar TransactionStatus;\r\n(function (TransactionStatus) {\r\n    // We've run the transaction and updated transactionResultData_ with the result, but it isn't currently sent to the\r\n    // server. A transaction will go from RUN -> SENT -> RUN if it comes back from the server as rejected due to\r\n    // mismatched hash.\r\n    TransactionStatus[TransactionStatus[\"RUN\"] = 0] = \"RUN\";\r\n    // We've run the transaction and sent it to the server and it's currently outstanding (hasn't come back as accepted\r\n    // or rejected yet).\r\n    TransactionStatus[TransactionStatus[\"SENT\"] = 1] = \"SENT\";\r\n    // Temporary state used to mark completed transactions (whether successful or aborted).  The transaction will be\r\n    // removed when we get a chance to prune completed ones.\r\n    TransactionStatus[TransactionStatus[\"COMPLETED\"] = 2] = \"COMPLETED\";\r\n    // Used when an already-sent transaction needs to be aborted (e.g. due to a conflicting set() call that was made).\r\n    // If it comes back as unsuccessful, we'll abort it.\r\n    TransactionStatus[TransactionStatus[\"SENT_NEEDS_ABORT\"] = 3] = \"SENT_NEEDS_ABORT\";\r\n    // Temporary state used to mark transactions that need to be aborted.\r\n    TransactionStatus[TransactionStatus[\"NEEDS_ABORT\"] = 4] = \"NEEDS_ABORT\";\r\n})(TransactionStatus || (TransactionStatus = {}));\r\n/**\r\n * If a transaction does not succeed after 25 retries, we abort it.  Among other things this ensure that if there's\r\n * ever a bug causing a mismatch between client / server hashes for some data, we won't retry indefinitely.\r\n * @type {number}\r\n * @const\r\n * @private\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nRepo.MAX_TRANSACTION_RETRIES_ = 25;\r\n/**\r\n * Setup the transaction data structures\r\n * @private\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nRepo.prototype.transactionsInit_ = function () {\r\n    /**\r\n     * Stores queues of outstanding transactions for Firebase locations.\r\n     *\r\n     * @type {!Tree.<Array.<!Transaction>>}\r\n     * @private\r\n     */\r\n    this.transactionQueueTree_ = new Tree();\r\n};\r\n/**\r\n * Creates a new transaction, adds it to the transactions we're tracking, and sends it to the server if possible.\r\n *\r\n * @param {!Path} path Path at which to do transaction.\r\n * @param {function(*):*} transactionUpdate Update callback.\r\n * @param {?function(?Error, boolean, ?DataSnapshot)} onComplete Completion callback.\r\n * @param {boolean} applyLocally Whether or not to make intermediate results visible\r\n */\r\nRepo.prototype.startTransaction = function (path, transactionUpdate, onComplete, applyLocally) {\r\n    this.log_('transaction on ' + path);\r\n    // Add a watch to make sure we get server updates.\r\n    var valueCallback = function () { };\r\n    var watchRef = new Reference(this, path);\r\n    watchRef.on('value', valueCallback);\r\n    var unwatcher = function () {\r\n        watchRef.off('value', valueCallback);\r\n    };\r\n    // Initialize transaction.\r\n    var transaction = {\r\n        path: path,\r\n        update: transactionUpdate,\r\n        onComplete: onComplete,\r\n        // One of TransactionStatus enums.\r\n        status: null,\r\n        // Used when combining transactions at different locations to figure out which one goes first.\r\n        order: LUIDGenerator(),\r\n        // Whether to raise local events for this transaction.\r\n        applyLocally: applyLocally,\r\n        // Count of how many times we've retried the transaction.\r\n        retryCount: 0,\r\n        // Function to call to clean up our .on() listener.\r\n        unwatcher: unwatcher,\r\n        // Stores why a transaction was aborted.\r\n        abortReason: null,\r\n        currentWriteId: null,\r\n        currentInputSnapshot: null,\r\n        currentOutputSnapshotRaw: null,\r\n        currentOutputSnapshotResolved: null\r\n    };\r\n    // Run transaction initially.\r\n    var currentState = this.getLatestState_(path);\r\n    transaction.currentInputSnapshot = currentState;\r\n    var newVal = transaction.update(currentState.val());\r\n    if (newVal === undefined) {\r\n        // Abort transaction.\r\n        transaction.unwatcher();\r\n        transaction.currentOutputSnapshotRaw = null;\r\n        transaction.currentOutputSnapshotResolved = null;\r\n        if (transaction.onComplete) {\r\n            // We just set the input snapshot, so this cast should be safe\r\n            var snapshot = new DataSnapshot(transaction.currentInputSnapshot, new Reference(this, transaction.path), PRIORITY_INDEX);\r\n            transaction.onComplete(null, false, snapshot);\r\n        }\r\n    }\r\n    else {\r\n        validateFirebaseData('transaction failed: Data returned ', newVal, transaction.path);\r\n        // Mark as run and add to our queue.\r\n        transaction.status = TransactionStatus.RUN;\r\n        var queueNode = this.transactionQueueTree_.subTree(path);\r\n        var nodeQueue = queueNode.getValue() || [];\r\n        nodeQueue.push(transaction);\r\n        queueNode.setValue(nodeQueue);\r\n        // Update visibleData and raise events\r\n        // Note: We intentionally raise events after updating all of our transaction state, since the user could\r\n        // start new transactions from the event callbacks.\r\n        var priorityForNode = void 0;\r\n        if (typeof newVal === 'object' &&\r\n            newVal !== null &&\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(newVal, '.priority')) {\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            priorityForNode = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.safeGet)(newVal, '.priority');\r\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(isValidPriority(priorityForNode), 'Invalid priority returned by transaction. ' +\r\n                'Priority must be a valid string, finite number, server value, or null.');\r\n        }\r\n        else {\r\n            var currentNode = this.serverSyncTree_.calcCompleteEventCache(path) ||\r\n                ChildrenNode.EMPTY_NODE;\r\n            priorityForNode = currentNode.getPriority().val();\r\n        }\r\n        priorityForNode /** @type {null|number|string} */ = priorityForNode;\r\n        var serverValues = this.generateServerValues();\r\n        var newNodeUnresolved = nodeFromJSON$1(newVal, priorityForNode);\r\n        var newNode = resolveDeferredValueSnapshot(newNodeUnresolved, currentState, serverValues);\r\n        transaction.currentOutputSnapshotRaw = newNodeUnresolved;\r\n        transaction.currentOutputSnapshotResolved = newNode;\r\n        transaction.currentWriteId = this.getNextWriteId_();\r\n        var events = this.serverSyncTree_.applyUserOverwrite(path, newNode, transaction.currentWriteId, transaction.applyLocally);\r\n        this.eventQueue_.raiseEventsForChangedPath(path, events);\r\n        this.sendReadyTransactions_();\r\n    }\r\n};\r\n/**\r\n * @param {!Path} path\r\n * @param {Array.<number>=} excludeSets A specific set to exclude\r\n * @return {Node}\r\n * @private\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nRepo.prototype.getLatestState_ = function (path, excludeSets) {\r\n    return (this.serverSyncTree_.calcCompleteEventCache(path, excludeSets) ||\r\n        ChildrenNode.EMPTY_NODE);\r\n};\r\n/**\r\n * Sends any already-run transactions that aren't waiting for outstanding transactions to\r\n * complete.\r\n *\r\n * Externally it's called with no arguments, but it calls itself recursively with a particular\r\n * transactionQueueTree node to recurse through the tree.\r\n *\r\n * @param {Tree.<Array.<Transaction>>=} node  transactionQueueTree node to start at.\r\n * @private\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nRepo.prototype.sendReadyTransactions_ = function (node) {\r\n    var _this = this;\r\n    if (node === void 0) { node = this.transactionQueueTree_; }\r\n    // Before recursing, make sure any completed transactions are removed.\r\n    if (!node) {\r\n        this.pruneCompletedTransactionsBelowNode_(node);\r\n    }\r\n    if (node.getValue() !== null) {\r\n        var queue = this.buildTransactionQueue_(node);\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(queue.length > 0, 'Sending zero length transaction queue');\r\n        var allRun = queue.every(function (transaction) { return transaction.status === TransactionStatus.RUN; });\r\n        // If they're all run (and not sent), we can send them.  Else, we must wait.\r\n        if (allRun) {\r\n            this.sendTransactionQueue_(node.path(), queue);\r\n        }\r\n    }\r\n    else if (node.hasChildren()) {\r\n        node.forEachChild(function (childNode) {\r\n            _this.sendReadyTransactions_(childNode);\r\n        });\r\n    }\r\n};\r\n/**\r\n * Given a list of run transactions, send them to the server and then handle the result (success or failure).\r\n *\r\n * @param {!Path} path The location of the queue.\r\n * @param {!Array.<Transaction>} queue Queue of transactions under the specified location.\r\n * @private\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nRepo.prototype.sendTransactionQueue_ = function (path, queue) {\r\n    var _this = this;\r\n    // Mark transactions as sent and increment retry count!\r\n    var setsToIgnore = queue.map(function (txn) {\r\n        return txn.currentWriteId;\r\n    });\r\n    var latestState = this.getLatestState_(path, setsToIgnore);\r\n    var snapToSend = latestState;\r\n    var latestHash = latestState.hash();\r\n    for (var i = 0; i < queue.length; i++) {\r\n        var txn = queue[i];\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(txn.status === TransactionStatus.RUN, 'tryToSendTransactionQueue_: items in queue should all be run.');\r\n        txn.status = TransactionStatus.SENT;\r\n        txn.retryCount++;\r\n        var relativePath = Path.relativePath(path, txn.path);\r\n        // If we've gotten to this point, the output snapshot must be defined.\r\n        snapToSend = snapToSend.updateChild(relativePath /** @type {!Node} */, txn.currentOutputSnapshotRaw);\r\n    }\r\n    var dataToSend = snapToSend.val(true);\r\n    var pathToSend = path;\r\n    // Send the put.\r\n    this.server_.put(pathToSend.toString(), dataToSend, function (status) {\r\n        _this.log_('transaction put response', {\r\n            path: pathToSend.toString(),\r\n            status: status\r\n        });\r\n        var events = [];\r\n        if (status === 'ok') {\r\n            // Queue up the callbacks and fire them after cleaning up all of our transaction state, since\r\n            // the callback could trigger more transactions or sets.\r\n            var callbacks = [];\r\n            for (var i = 0; i < queue.length; i++) {\r\n                queue[i].status = TransactionStatus.COMPLETED;\r\n                events = events.concat(_this.serverSyncTree_.ackUserWrite(queue[i].currentWriteId));\r\n                if (queue[i].onComplete) {\r\n                    // We never unset the output snapshot, and given that this transaction is complete, it should be set\r\n                    var node = queue[i].currentOutputSnapshotResolved;\r\n                    var ref = new Reference(_this, queue[i].path);\r\n                    var snapshot = new DataSnapshot(node, ref, PRIORITY_INDEX);\r\n                    callbacks.push(queue[i].onComplete.bind(null, null, true, snapshot));\r\n                }\r\n                queue[i].unwatcher();\r\n            }\r\n            // Now remove the completed transactions.\r\n            _this.pruneCompletedTransactionsBelowNode_(_this.transactionQueueTree_.subTree(path));\r\n            // There may be pending transactions that we can now send.\r\n            _this.sendReadyTransactions_();\r\n            _this.eventQueue_.raiseEventsForChangedPath(path, events);\r\n            // Finally, trigger onComplete callbacks.\r\n            for (var i = 0; i < callbacks.length; i++) {\r\n                exceptionGuard(callbacks[i]);\r\n            }\r\n        }\r\n        else {\r\n            // transactions are no longer sent.  Update their status appropriately.\r\n            if (status === 'datastale') {\r\n                for (var i = 0; i < queue.length; i++) {\r\n                    if (queue[i].status === TransactionStatus.SENT_NEEDS_ABORT) {\r\n                        queue[i].status = TransactionStatus.NEEDS_ABORT;\r\n                    }\r\n                    else {\r\n                        queue[i].status = TransactionStatus.RUN;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                warn('transaction at ' + pathToSend.toString() + ' failed: ' + status);\r\n                for (var i = 0; i < queue.length; i++) {\r\n                    queue[i].status = TransactionStatus.NEEDS_ABORT;\r\n                    queue[i].abortReason = status;\r\n                }\r\n            }\r\n            _this.rerunTransactions_(path);\r\n        }\r\n    }, latestHash);\r\n};\r\n/**\r\n * Finds all transactions dependent on the data at changedPath and reruns them.\r\n *\r\n * Should be called any time cached data changes.\r\n *\r\n * Return the highest path that was affected by rerunning transactions.  This is the path at which events need to\r\n * be raised for.\r\n *\r\n * @param {!Path} changedPath The path in mergedData that changed.\r\n * @return {!Path} The rootmost path that was affected by rerunning transactions.\r\n * @private\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nRepo.prototype.rerunTransactions_ = function (changedPath) {\r\n    var rootMostTransactionNode = this.getAncestorTransactionNode_(changedPath);\r\n    var path = rootMostTransactionNode.path();\r\n    var queue = this.buildTransactionQueue_(rootMostTransactionNode);\r\n    this.rerunTransactionQueue_(queue, path);\r\n    return path;\r\n};\r\n/**\r\n * Does all the work of rerunning transactions (as well as cleans up aborted transactions and whatnot).\r\n *\r\n * @param {Array.<Transaction>} queue The queue of transactions to run.\r\n * @param {!Path} path The path the queue is for.\r\n * @private\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nRepo.prototype.rerunTransactionQueue_ = function (queue, path) {\r\n    if (queue.length === 0) {\r\n        return; // Nothing to do!\r\n    }\r\n    // Queue up the callbacks and fire them after cleaning up all of our transaction state, since\r\n    // the callback could trigger more transactions or sets.\r\n    var callbacks = [];\r\n    var events = [];\r\n    // Ignore all of the sets we're going to re-run.\r\n    var txnsToRerun = queue.filter(function (q) {\r\n        return q.status === TransactionStatus.RUN;\r\n    });\r\n    var setsToIgnore = txnsToRerun.map(function (q) {\r\n        return q.currentWriteId;\r\n    });\r\n    for (var i = 0; i < queue.length; i++) {\r\n        var transaction = queue[i];\r\n        var relativePath = Path.relativePath(path, transaction.path);\r\n        var abortTransaction = false, abortReason = void 0;\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(relativePath !== null, 'rerunTransactionsUnderNode_: relativePath should not be null.');\r\n        if (transaction.status === TransactionStatus.NEEDS_ABORT) {\r\n            abortTransaction = true;\r\n            abortReason = transaction.abortReason;\r\n            events = events.concat(this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true));\r\n        }\r\n        else if (transaction.status === TransactionStatus.RUN) {\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            if (transaction.retryCount >= Repo.MAX_TRANSACTION_RETRIES_) {\r\n                abortTransaction = true;\r\n                abortReason = 'maxretry';\r\n                events = events.concat(this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true));\r\n            }\r\n            else {\r\n                // This code reruns a transaction\r\n                var currentNode = this.getLatestState_(transaction.path, setsToIgnore);\r\n                transaction.currentInputSnapshot = currentNode;\r\n                var newData = queue[i].update(currentNode.val());\r\n                if (newData !== undefined) {\r\n                    validateFirebaseData('transaction failed: Data returned ', newData, transaction.path);\r\n                    var newDataNode = nodeFromJSON$1(newData);\r\n                    var hasExplicitPriority = typeof newData === 'object' &&\r\n                        newData != null &&\r\n                        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.contains)(newData, '.priority');\r\n                    if (!hasExplicitPriority) {\r\n                        // Keep the old priority if there wasn't a priority explicitly specified.\r\n                        newDataNode = newDataNode.updatePriority(currentNode.getPriority());\r\n                    }\r\n                    var oldWriteId = transaction.currentWriteId;\r\n                    var serverValues = this.generateServerValues();\r\n                    var newNodeResolved = resolveDeferredValueSnapshot(newDataNode, currentNode, serverValues);\r\n                    transaction.currentOutputSnapshotRaw = newDataNode;\r\n                    transaction.currentOutputSnapshotResolved = newNodeResolved;\r\n                    transaction.currentWriteId = this.getNextWriteId_();\r\n                    // Mutates setsToIgnore in place\r\n                    setsToIgnore.splice(setsToIgnore.indexOf(oldWriteId), 1);\r\n                    events = events.concat(this.serverSyncTree_.applyUserOverwrite(transaction.path, newNodeResolved, transaction.currentWriteId, transaction.applyLocally));\r\n                    events = events.concat(this.serverSyncTree_.ackUserWrite(oldWriteId, true));\r\n                }\r\n                else {\r\n                    abortTransaction = true;\r\n                    abortReason = 'nodata';\r\n                    events = events.concat(this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true));\r\n                }\r\n            }\r\n        }\r\n        this.eventQueue_.raiseEventsForChangedPath(path, events);\r\n        events = [];\r\n        if (abortTransaction) {\r\n            // Abort.\r\n            queue[i].status = TransactionStatus.COMPLETED;\r\n            // Removing a listener can trigger pruning which can muck with mergedData/visibleData (as it prunes data).\r\n            // So defer the unwatcher until we're done.\r\n            (function (unwatcher) {\r\n                setTimeout(unwatcher, Math.floor(0));\r\n            })(queue[i].unwatcher);\r\n            if (queue[i].onComplete) {\r\n                if (abortReason === 'nodata') {\r\n                    var ref = new Reference(this, queue[i].path);\r\n                    // We set this field immediately, so it's safe to cast to an actual snapshot\r\n                    var lastInput /** @type {!Node} */ = queue[i].currentInputSnapshot;\r\n                    var snapshot = new DataSnapshot(lastInput, ref, PRIORITY_INDEX);\r\n                    callbacks.push(queue[i].onComplete.bind(null, null, false, snapshot));\r\n                }\r\n                else {\r\n                    callbacks.push(queue[i].onComplete.bind(null, new Error(abortReason), false, null));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Clean up completed transactions.\r\n    this.pruneCompletedTransactionsBelowNode_(this.transactionQueueTree_);\r\n    // Now fire callbacks, now that we're in a good, known state.\r\n    for (var i = 0; i < callbacks.length; i++) {\r\n        exceptionGuard(callbacks[i]);\r\n    }\r\n    // Try to send the transaction result to the server.\r\n    this.sendReadyTransactions_();\r\n};\r\n/**\r\n * Returns the rootmost ancestor node of the specified path that has a pending transaction on it, or just returns\r\n * the node for the given path if there are no pending transactions on any ancestor.\r\n *\r\n * @param {!Path} path The location to start at.\r\n * @return {!Tree.<Array.<!Transaction>>} The rootmost node with a transaction.\r\n * @private\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nRepo.prototype.getAncestorTransactionNode_ = function (path) {\r\n    var front;\r\n    // Start at the root and walk deeper into the tree towards path until we find a node with pending transactions.\r\n    var transactionNode = this.transactionQueueTree_;\r\n    front = path.getFront();\r\n    while (front !== null && transactionNode.getValue() === null) {\r\n        transactionNode = transactionNode.subTree(front);\r\n        path = path.popFront();\r\n        front = path.getFront();\r\n    }\r\n    return transactionNode;\r\n};\r\n/**\r\n * Builds the queue of all transactions at or below the specified transactionNode.\r\n *\r\n * @param {!Tree.<Array.<Transaction>>} transactionNode\r\n * @return {Array.<Transaction>} The generated queue.\r\n * @private\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nRepo.prototype.buildTransactionQueue_ = function (transactionNode) {\r\n    // Walk any child transaction queues and aggregate them into a single queue.\r\n    var transactionQueue = [];\r\n    this.aggregateTransactionQueuesForNode_(transactionNode, transactionQueue);\r\n    // Sort them by the order the transactions were created.\r\n    transactionQueue.sort(function (a, b) {\r\n        return a.order - b.order;\r\n    });\r\n    return transactionQueue;\r\n};\r\n/**\r\n * @param {!Tree.<Array.<Transaction>>} node\r\n * @param {Array.<Transaction>} queue\r\n * @private\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nRepo.prototype.aggregateTransactionQueuesForNode_ = function (node, queue) {\r\n    var _this = this;\r\n    var nodeQueue = node.getValue();\r\n    if (nodeQueue !== null) {\r\n        for (var i = 0; i < nodeQueue.length; i++) {\r\n            queue.push(nodeQueue[i]);\r\n        }\r\n    }\r\n    node.forEachChild(function (child) {\r\n        _this.aggregateTransactionQueuesForNode_(child, queue);\r\n    });\r\n};\r\n/**\r\n * Remove COMPLETED transactions at or below this node in the transactionQueueTree_.\r\n *\r\n * @param {!Tree.<Array.<!Transaction>>} node\r\n * @private\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nRepo.prototype.pruneCompletedTransactionsBelowNode_ = function (node) {\r\n    var _this = this;\r\n    var queue = node.getValue();\r\n    if (queue) {\r\n        var to = 0;\r\n        for (var from = 0; from < queue.length; from++) {\r\n            if (queue[from].status !== TransactionStatus.COMPLETED) {\r\n                queue[to] = queue[from];\r\n                to++;\r\n            }\r\n        }\r\n        queue.length = to;\r\n        node.setValue(queue.length > 0 ? queue : null);\r\n    }\r\n    node.forEachChild(function (childNode) {\r\n        _this.pruneCompletedTransactionsBelowNode_(childNode);\r\n    });\r\n};\r\n/**\r\n * Aborts all transactions on ancestors or descendants of the specified path.  Called when doing a set() or update()\r\n * since we consider them incompatible with transactions.\r\n *\r\n * @param {!Path} path Path for which we want to abort related transactions.\r\n * @return {!Path}\r\n * @private\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nRepo.prototype.abortTransactions_ = function (path) {\r\n    var _this = this;\r\n    var affectedPath = this.getAncestorTransactionNode_(path).path();\r\n    var transactionNode = this.transactionQueueTree_.subTree(path);\r\n    transactionNode.forEachAncestor(function (node) {\r\n        _this.abortTransactionsOnNode_(node);\r\n    });\r\n    this.abortTransactionsOnNode_(transactionNode);\r\n    transactionNode.forEachDescendant(function (node) {\r\n        _this.abortTransactionsOnNode_(node);\r\n    });\r\n    return affectedPath;\r\n};\r\n/**\r\n * Abort transactions stored in this transaction queue node.\r\n *\r\n * @param {!Tree.<Array.<Transaction>>} node Node to abort transactions for.\r\n * @private\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nRepo.prototype.abortTransactionsOnNode_ = function (node) {\r\n    var queue = node.getValue();\r\n    if (queue !== null) {\r\n        // Queue up the callbacks and fire them after cleaning up all of our transaction state, since\r\n        // the callback could trigger more transactions or sets.\r\n        var callbacks = [];\r\n        // Go through queue.  Any already-sent transactions must be marked for abort, while the unsent ones\r\n        // can be immediately aborted and removed.\r\n        var events = [];\r\n        var lastSent = -1;\r\n        for (var i = 0; i < queue.length; i++) {\r\n            if (queue[i].status === TransactionStatus.SENT_NEEDS_ABORT) ;\r\n            else if (queue[i].status === TransactionStatus.SENT) {\r\n                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(lastSent === i - 1, 'All SENT items should be at beginning of queue.');\r\n                lastSent = i;\r\n                // Mark transaction for abort when it comes back.\r\n                queue[i].status = TransactionStatus.SENT_NEEDS_ABORT;\r\n                queue[i].abortReason = 'set';\r\n            }\r\n            else {\r\n                (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.assert)(queue[i].status === TransactionStatus.RUN, 'Unexpected transaction status in abort');\r\n                // We can abort it immediately.\r\n                queue[i].unwatcher();\r\n                events = events.concat(this.serverSyncTree_.ackUserWrite(queue[i].currentWriteId, true));\r\n                if (queue[i].onComplete) {\r\n                    var snapshot = null;\r\n                    callbacks.push(queue[i].onComplete.bind(null, new Error('set'), false, snapshot));\r\n                }\r\n            }\r\n        }\r\n        if (lastSent === -1) {\r\n            // We're not waiting for any sent transactions.  We can clear the queue.\r\n            node.setValue(null);\r\n        }\r\n        else {\r\n            // Remove the transactions we aborted.\r\n            queue.length = lastSent + 1;\r\n        }\r\n        // Now fire the callbacks.\r\n        this.eventQueue_.raiseEventsForChangedPath(node.path(), events);\r\n        for (var i = 0; i < callbacks.length; i++) {\r\n            exceptionGuard(callbacks[i]);\r\n        }\r\n    }\r\n};\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Abstraction around FirebaseApp's token fetching capabilities.\r\n */\r\nvar FirebaseAuthTokenProvider = /** @class */ (function () {\r\n    function FirebaseAuthTokenProvider(app_, authProvider_) {\r\n        var _this = this;\r\n        this.app_ = app_;\r\n        this.authProvider_ = authProvider_;\r\n        this.auth_ = null;\r\n        this.auth_ = authProvider_.getImmediate({ optional: true });\r\n        if (!this.auth_) {\r\n            authProvider_.get().then(function (auth) { return (_this.auth_ = auth); });\r\n        }\r\n    }\r\n    /**\r\n     * @param {boolean} forceRefresh\r\n     * @return {!Promise<FirebaseAuthTokenData>}\r\n     */\r\n    FirebaseAuthTokenProvider.prototype.getToken = function (forceRefresh) {\r\n        if (!this.auth_) {\r\n            return Promise.resolve(null);\r\n        }\r\n        return this.auth_.getToken(forceRefresh).catch(function (error) {\r\n            // TODO: Need to figure out all the cases this is raised and whether\r\n            // this makes sense.\r\n            if (error && error.code === 'auth/token-not-initialized') {\r\n                log('Got auth/token-not-initialized error.  Treating as null token.');\r\n                return null;\r\n            }\r\n            else {\r\n                return Promise.reject(error);\r\n            }\r\n        });\r\n    };\r\n    FirebaseAuthTokenProvider.prototype.addTokenChangeListener = function (listener) {\r\n        // TODO: We might want to wrap the listener and call it with no args to\r\n        // avoid a leaky abstraction, but that makes removing the listener harder.\r\n        if (this.auth_) {\r\n            this.auth_.addAuthTokenListener(listener);\r\n        }\r\n        else {\r\n            setTimeout(function () { return listener(null); }, 0);\r\n            this.authProvider_\r\n                .get()\r\n                .then(function (auth) { return auth.addAuthTokenListener(listener); });\r\n        }\r\n    };\r\n    FirebaseAuthTokenProvider.prototype.removeTokenChangeListener = function (listener) {\r\n        this.authProvider_\r\n            .get()\r\n            .then(function (auth) { return auth.removeAuthTokenListener(listener); });\r\n    };\r\n    FirebaseAuthTokenProvider.prototype.notifyForInvalidToken = function () {\r\n        var errorMessage = 'Provided authentication credentials for the app named \"' +\r\n            this.app_.name +\r\n            '\" are invalid. This usually indicates your app was not ' +\r\n            'initialized correctly. ';\r\n        if ('credential' in this.app_.options) {\r\n            errorMessage +=\r\n                'Make sure the \"credential\" property provided to initializeApp() ' +\r\n                    'is authorized to access the specified \"databaseURL\" and is from the correct ' +\r\n                    'project.';\r\n        }\r\n        else if ('serviceAccount' in this.app_.options) {\r\n            errorMessage +=\r\n                'Make sure the \"serviceAccount\" property provided to initializeApp() ' +\r\n                    'is authorized to access the specified \"databaseURL\" and is from the correct ' +\r\n                    'project.';\r\n        }\r\n        else {\r\n            errorMessage +=\r\n                'Make sure the \"apiKey\" and \"databaseURL\" properties provided to ' +\r\n                    'initializeApp() match the values provided for your app at ' +\r\n                    'https://console.firebase.google.com/.';\r\n        }\r\n        warn(errorMessage);\r\n    };\r\n    return FirebaseAuthTokenProvider;\r\n}());\r\n/* Auth token provider that the Admin SDK uses to connect to the Emulator. */\r\nvar EmulatorAdminTokenProvider = /** @class */ (function () {\r\n    function EmulatorAdminTokenProvider() {\r\n    }\r\n    EmulatorAdminTokenProvider.prototype.getToken = function (forceRefresh) {\r\n        return Promise.resolve({\r\n            accessToken: EmulatorAdminTokenProvider.EMULATOR_AUTH_TOKEN\r\n        });\r\n    };\r\n    EmulatorAdminTokenProvider.prototype.addTokenChangeListener = function (listener) {\r\n        // Invoke the listener immediately to match the behavior in Firebase Auth\r\n        // (see packages/auth/src/auth.js#L1807)\r\n        listener(EmulatorAdminTokenProvider.EMULATOR_AUTH_TOKEN);\r\n    };\r\n    EmulatorAdminTokenProvider.prototype.removeTokenChangeListener = function (listener) { };\r\n    EmulatorAdminTokenProvider.prototype.notifyForInvalidToken = function () { };\r\n    EmulatorAdminTokenProvider.EMULATOR_AUTH_TOKEN = 'owner';\r\n    return EmulatorAdminTokenProvider;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * This variable is also defined in the firebase node.js admin SDK. Before\r\n * modifying this definition, consult the definition in:\r\n *\r\n * https://github.com/firebase/firebase-admin-node\r\n *\r\n * and make sure the two are consistent.\r\n */\r\nvar FIREBASE_DATABASE_EMULATOR_HOST_VAR = 'FIREBASE_DATABASE_EMULATOR_HOST';\r\nvar _staticInstance;\r\n/**\r\n * Creates and caches Repo instances.\r\n */\r\nvar RepoManager = /** @class */ (function () {\r\n    function RepoManager() {\r\n        /**\r\n         * @private {!Object.<string, Object<string, !fb.core.Repo>>}\r\n         */\r\n        this.repos_ = {};\r\n        /**\r\n         * If true, new Repos will be created to use ReadonlyRestClient (for testing purposes).\r\n         * @private {boolean}\r\n         */\r\n        this.useRestClient_ = false;\r\n    }\r\n    RepoManager.getInstance = function () {\r\n        if (!_staticInstance) {\r\n            _staticInstance = new RepoManager();\r\n        }\r\n        return _staticInstance;\r\n    };\r\n    // TODO(koss): Remove these functions unless used in tests?\r\n    RepoManager.prototype.interrupt = function () {\r\n        var e_1, _a, e_2, _b;\r\n        try {\r\n            for (var _c = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__values)(Object.keys(this.repos_)), _d = _c.next(); !_d.done; _d = _c.next()) {\r\n                var appName = _d.value;\r\n                try {\r\n                    for (var _e = (e_2 = void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__values)(Object.keys(this.repos_[appName]))), _f = _e.next(); !_f.done; _f = _e.next()) {\r\n                        var dbUrl = _f.value;\r\n                        this.repos_[appName][dbUrl].interrupt();\r\n                    }\r\n                }\r\n                catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n                finally {\r\n                    try {\r\n                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\r\n                    }\r\n                    finally { if (e_2) throw e_2.error; }\r\n                }\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n    };\r\n    RepoManager.prototype.resume = function () {\r\n        var e_3, _a, e_4, _b;\r\n        try {\r\n            for (var _c = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__values)(Object.keys(this.repos_)), _d = _c.next(); !_d.done; _d = _c.next()) {\r\n                var appName = _d.value;\r\n                try {\r\n                    for (var _e = (e_4 = void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__values)(Object.keys(this.repos_[appName]))), _f = _e.next(); !_f.done; _f = _e.next()) {\r\n                        var dbUrl = _f.value;\r\n                        this.repos_[appName][dbUrl].resume();\r\n                    }\r\n                }\r\n                catch (e_4_1) { e_4 = { error: e_4_1 }; }\r\n                finally {\r\n                    try {\r\n                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\r\n                    }\r\n                    finally { if (e_4) throw e_4.error; }\r\n                }\r\n            }\r\n        }\r\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\r\n        finally {\r\n            try {\r\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\r\n            }\r\n            finally { if (e_3) throw e_3.error; }\r\n        }\r\n    };\r\n    /**\r\n     * This function should only ever be called to CREATE a new database instance.\r\n     *\r\n     * @param {!FirebaseApp} app\r\n     * @return {!Database}\r\n     */\r\n    RepoManager.prototype.databaseFromApp = function (app, authProvider, url, nodeAdmin) {\r\n        var dbUrl = url || app.options.databaseURL;\r\n        if (dbUrl === undefined) {\r\n            if (!app.options.projectId) {\r\n                fatal(\"Can't determine Firebase Database URL. Be sure to include \" +\r\n                    ' a Project ID when calling firebase.initializeApp().');\r\n            }\r\n            log('Using default host for project ', app.options.projectId);\r\n            dbUrl = app.options.projectId + \"-default-rtdb.firebaseio.com\";\r\n        }\r\n        var parsedUrl = parseRepoInfo(dbUrl, nodeAdmin);\r\n        var repoInfo = parsedUrl.repoInfo;\r\n        var isEmulator;\r\n        var dbEmulatorHost = undefined;\r\n        if (typeof process !== 'undefined') {\r\n            dbEmulatorHost = process.env[FIREBASE_DATABASE_EMULATOR_HOST_VAR];\r\n        }\r\n        if (dbEmulatorHost) {\r\n            isEmulator = true;\r\n            dbUrl = \"http://\" + dbEmulatorHost + \"?ns=\" + repoInfo.namespace;\r\n            parsedUrl = parseRepoInfo(dbUrl, nodeAdmin);\r\n            repoInfo = parsedUrl.repoInfo;\r\n        }\r\n        else {\r\n            isEmulator = !parsedUrl.repoInfo.secure;\r\n        }\r\n        var authTokenProvider = nodeAdmin && isEmulator\r\n            ? new EmulatorAdminTokenProvider()\r\n            : new FirebaseAuthTokenProvider(app, authProvider);\r\n        validateUrl('Invalid Firebase Database URL', 1, parsedUrl);\r\n        if (!parsedUrl.path.isEmpty()) {\r\n            fatal('Database URL must point to the root of a Firebase Database ' +\r\n                '(not including a child path).');\r\n        }\r\n        var repo = this.createRepo(repoInfo, app, authTokenProvider);\r\n        return repo.database;\r\n    };\r\n    /**\r\n     * Remove the repo and make sure it is disconnected.\r\n     *\r\n     * @param {!Repo} repo\r\n     */\r\n    RepoManager.prototype.deleteRepo = function (repo) {\r\n        var appRepos = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.safeGet)(this.repos_, repo.app.name);\r\n        // This should never happen...\r\n        if (!appRepos || (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.safeGet)(appRepos, repo.repoInfo_.toURLString()) !== repo) {\r\n            fatal(\"Database \" + repo.app.name + \"(\" + repo.repoInfo_ + \") has already been deleted.\");\r\n        }\r\n        repo.interrupt();\r\n        delete appRepos[repo.repoInfo_.toURLString()];\r\n    };\r\n    /**\r\n     * Ensures a repo doesn't already exist and then creates one using the\r\n     * provided app.\r\n     *\r\n     * @param {!RepoInfo} repoInfo The metadata about the Repo\r\n     * @param {!FirebaseApp} app\r\n     * @return {!Repo} The Repo object for the specified server / repoName.\r\n     */\r\n    RepoManager.prototype.createRepo = function (repoInfo, app, authTokenProvider) {\r\n        var appRepos = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.safeGet)(this.repos_, app.name);\r\n        if (!appRepos) {\r\n            appRepos = {};\r\n            this.repos_[app.name] = appRepos;\r\n        }\r\n        var repo = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.safeGet)(appRepos, repoInfo.toURLString());\r\n        if (repo) {\r\n            fatal('Database initialized multiple times. Please make sure the format of the database URL matches with each database() call.');\r\n        }\r\n        repo = new Repo(repoInfo, this.useRestClient_, app, authTokenProvider);\r\n        appRepos[repoInfo.toURLString()] = repo;\r\n        return repo;\r\n    };\r\n    /**\r\n     * Forces us to use ReadonlyRestClient instead of PersistentConnection for new Repos.\r\n     * @param {boolean} forceRestClient\r\n     */\r\n    RepoManager.prototype.forceRestClient = function (forceRestClient) {\r\n        this.useRestClient_ = forceRestClient;\r\n    };\r\n    return RepoManager;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Class representing a firebase database.\r\n * @implements {FirebaseService}\r\n */\r\nvar Database = /** @class */ (function () {\r\n    /**\r\n     * The constructor should not be called by users of our public API.\r\n     * @param {!Repo} repo_\r\n     */\r\n    function Database(repo_) {\r\n        this.repo_ = repo_;\r\n        if (!(repo_ instanceof Repo)) {\r\n            fatal(\"Don't call new Database() directly - please use firebase.database().\");\r\n        }\r\n        /** @type {Reference} */\r\n        this.root_ = new Reference(repo_, Path.Empty);\r\n        this.INTERNAL = new DatabaseInternals(this);\r\n    }\r\n    Object.defineProperty(Database.prototype, \"app\", {\r\n        get: function () {\r\n            return this.repo_.app;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Database.prototype.ref = function (path) {\r\n        this.checkDeleted_('ref');\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('database.ref', 0, 1, arguments.length);\r\n        if (path instanceof Reference) {\r\n            return this.refFromURL(path.toString());\r\n        }\r\n        return path !== undefined ? this.root_.child(path) : this.root_;\r\n    };\r\n    /**\r\n     * Returns a reference to the root or the path specified in url.\r\n     * We throw a exception if the url is not in the same domain as the\r\n     * current repo.\r\n     * @param {string} url\r\n     * @return {!Reference} Firebase reference.\r\n     */\r\n    Database.prototype.refFromURL = function (url) {\r\n        /** @const {string} */\r\n        var apiName = 'database.refFromURL';\r\n        this.checkDeleted_(apiName);\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)(apiName, 1, 1, arguments.length);\r\n        var parsedURL = parseRepoInfo(url, this.repo_.repoInfo_.nodeAdmin);\r\n        validateUrl(apiName, 1, parsedURL);\r\n        var repoInfo = parsedURL.repoInfo;\r\n        if (repoInfo.host !== this.repo_.repoInfo_.host) {\r\n            fatal(apiName +\r\n                ': Host name does not match the current database: ' +\r\n                '(found ' +\r\n                repoInfo.host +\r\n                ' but expected ' +\r\n                this.repo_.repoInfo_.host +\r\n                ')');\r\n        }\r\n        return this.ref(parsedURL.path.toString());\r\n    };\r\n    /**\r\n     * @param {string} apiName\r\n     */\r\n    Database.prototype.checkDeleted_ = function (apiName) {\r\n        if (this.repo_ === null) {\r\n            fatal('Cannot call ' + apiName + ' on a deleted database.');\r\n        }\r\n    };\r\n    // Make individual repo go offline.\r\n    Database.prototype.goOffline = function () {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('database.goOffline', 0, 0, arguments.length);\r\n        this.checkDeleted_('goOffline');\r\n        this.repo_.interrupt();\r\n    };\r\n    Database.prototype.goOnline = function () {\r\n        (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateArgCount)('database.goOnline', 0, 0, arguments.length);\r\n        this.checkDeleted_('goOnline');\r\n        this.repo_.resume();\r\n    };\r\n    Database.ServerValue = {\r\n        TIMESTAMP: {\r\n            '.sv': 'timestamp'\r\n        },\r\n        increment: function (delta) {\r\n            return {\r\n                '.sv': {\r\n                    'increment': delta\r\n                }\r\n            };\r\n        }\r\n    };\r\n    return Database;\r\n}());\r\nvar DatabaseInternals = /** @class */ (function () {\r\n    /** @param {!Database} database */\r\n    function DatabaseInternals(database) {\r\n        this.database = database;\r\n    }\r\n    /** @return {Promise<void>} */\r\n    DatabaseInternals.prototype.delete = function () {\r\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function () {\r\n            return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__generator)(this, function (_a) {\r\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                this.database.checkDeleted_('delete');\r\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                RepoManager.getInstance().deleteRepo(this.database.repo_);\r\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                this.database.repo_ = null;\r\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                this.database.root_ = null;\r\n                this.database.INTERNAL = null;\r\n                this.database = null;\r\n                return [2 /*return*/];\r\n            });\r\n        });\r\n    };\r\n    return DatabaseInternals;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * INTERNAL methods for internal-use only (tests, etc.).\r\n *\r\n * Customers shouldn't use these or else should be aware that they could break at any time.\r\n *\r\n * @const\r\n */\r\nvar forceLongPolling = function () {\r\n    WebSocketConnection.forceDisallow();\r\n    BrowserPollConnection.forceAllow();\r\n};\r\nvar forceWebSockets = function () {\r\n    BrowserPollConnection.forceDisallow();\r\n};\r\n/* Used by App Manager */\r\nvar isWebSocketsAvailable = function () {\r\n    return WebSocketConnection['isAvailable']();\r\n};\r\nvar setSecurityDebugCallback = function (ref, callback) {\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    ref.repo.persistentConnection_.securityDebugCallback_ = callback;\r\n};\r\nvar stats = function (ref, showDelta) {\r\n    ref.repo.stats(showDelta);\r\n};\r\nvar statsIncrementCounter = function (ref, metric) {\r\n    ref.repo.statsIncrementCounter(metric);\r\n};\r\nvar dataUpdateCount = function (ref) {\r\n    return ref.repo.dataUpdateCount;\r\n};\r\nvar interceptServerData = function (ref, callback) {\r\n    return ref.repo.interceptServerData_(callback);\r\n};\n\nvar INTERNAL = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  forceLongPolling: forceLongPolling,\n  forceWebSockets: forceWebSockets,\n  isWebSocketsAvailable: isWebSocketsAvailable,\n  setSecurityDebugCallback: setSecurityDebugCallback,\n  stats: stats,\n  statsIncrementCounter: statsIncrementCounter,\n  dataUpdateCount: dataUpdateCount,\n  interceptServerData: interceptServerData\n});\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar DataConnection = PersistentConnection;\r\n/**\r\n * @param {!string} pathString\r\n * @param {function(*)} onComplete\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nPersistentConnection.prototype.simpleListen = function (pathString, onComplete) {\r\n    this.sendRequest('q', { p: pathString }, onComplete);\r\n};\r\n/**\r\n * @param {*} data\r\n * @param {function(*)} onEcho\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nPersistentConnection.prototype.echo = function (data, onEcho) {\r\n    this.sendRequest('echo', { d: data }, onEcho);\r\n};\r\n// RealTimeConnection properties that we use in tests.\r\nvar RealTimeConnection = Connection;\r\n/**\r\n * @param {function(): string} newHash\r\n * @return {function()}\r\n */\r\nvar hijackHash = function (newHash) {\r\n    var oldPut = PersistentConnection.prototype.put;\r\n    PersistentConnection.prototype.put = function (pathString, data, onComplete, hash) {\r\n        if (hash !== undefined) {\r\n            hash = newHash();\r\n        }\r\n        oldPut.call(this, pathString, data, onComplete, hash);\r\n    };\r\n    return function () {\r\n        PersistentConnection.prototype.put = oldPut;\r\n    };\r\n};\r\n/**\r\n * @type {function(new:RepoInfo, !string, boolean, !string, boolean): undefined}\r\n */\r\nvar ConnectionTarget = RepoInfo;\r\n/**\r\n * @param {!Query} query\r\n * @return {!string}\r\n */\r\nvar queryIdentifier = function (query) {\r\n    return query.queryIdentifier();\r\n};\r\n/**\r\n * Forces the RepoManager to create Repos that use ReadonlyRestClient instead of PersistentConnection.\r\n *\r\n * @param {boolean} forceRestClient\r\n */\r\nvar forceRestClient = function (forceRestClient) {\r\n    RepoManager.getInstance().forceRestClient(forceRestClient);\r\n};\n\nvar TEST_ACCESS = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  DataConnection: DataConnection,\n  RealTimeConnection: RealTimeConnection,\n  hijackHash: hijackHash,\n  ConnectionTarget: ConnectionTarget,\n  queryIdentifier: queryIdentifier,\n  forceRestClient: forceRestClient\n});\n\nvar name = \"@firebase/database\";\nvar version = \"0.6.13\";\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar ServerValue = Database.ServerValue;\r\nfunction registerDatabase(instance) {\r\n    // set SDK_VERSION\r\n    setSDKVersion(instance.SDK_VERSION);\r\n    // Register the Database Service with the 'firebase' namespace.\r\n    var namespace = instance.INTERNAL.registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_4__.Component('database', function (container, url) {\r\n        /* Dependencies */\r\n        // getImmediate for FirebaseApp will always succeed\r\n        var app = container.getProvider('app').getImmediate();\r\n        var authProvider = container.getProvider('auth-internal');\r\n        return RepoManager.getInstance().databaseFromApp(app, authProvider, url);\r\n    }, \"PUBLIC\" /* PUBLIC */)\r\n        .setServiceProps(\r\n    // firebase.database namespace properties\r\n    {\r\n        Reference: Reference,\r\n        Query: Query,\r\n        Database: Database,\r\n        DataSnapshot: DataSnapshot,\r\n        enableLogging: enableLogging,\r\n        INTERNAL: INTERNAL,\r\n        ServerValue: ServerValue,\r\n        TEST_ACCESS: TEST_ACCESS\r\n    })\r\n        .setMultipleInstances(true));\r\n    instance.registerVersion(name, version);\r\n    if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isNodeSdk)()) {\r\n        module.exports = namespace;\r\n    }\r\n}\r\nregisterDatabase(_firebase_app__WEBPACK_IMPORTED_MODULE_0__.default);\n\n\n//# sourceMappingURL=index.esm.js.map\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@firebase/database/dist/index.esm.js?");

/***/ }),

/***/ "./src/node_modules/@firebase/logger/dist/index.esm.js":
/*!*************************************************************!*\
  !*** ./src/node_modules/@firebase/logger/dist/index.esm.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LogLevel\": () => (/* binding */ LogLevel),\n/* harmony export */   \"Logger\": () => (/* binding */ Logger),\n/* harmony export */   \"setLogLevel\": () => (/* binding */ setLogLevel),\n/* harmony export */   \"setUserLogHandler\": () => (/* binding */ setUserLogHandler)\n/* harmony export */ });\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar _a;\r\n/**\r\n * A container for all of the Logger instances\r\n */\r\nvar instances = [];\r\n/**\r\n * The JS SDK supports 5 log levels and also allows a user the ability to\r\n * silence the logs altogether.\r\n *\r\n * The order is a follows:\r\n * DEBUG < VERBOSE < INFO < WARN < ERROR\r\n *\r\n * All of the log types above the current log level will be captured (i.e. if\r\n * you set the log level to `INFO`, errors will still be logged, but `DEBUG` and\r\n * `VERBOSE` logs will not)\r\n */\r\nvar LogLevel;\r\n(function (LogLevel) {\r\n    LogLevel[LogLevel[\"DEBUG\"] = 0] = \"DEBUG\";\r\n    LogLevel[LogLevel[\"VERBOSE\"] = 1] = \"VERBOSE\";\r\n    LogLevel[LogLevel[\"INFO\"] = 2] = \"INFO\";\r\n    LogLevel[LogLevel[\"WARN\"] = 3] = \"WARN\";\r\n    LogLevel[LogLevel[\"ERROR\"] = 4] = \"ERROR\";\r\n    LogLevel[LogLevel[\"SILENT\"] = 5] = \"SILENT\";\r\n})(LogLevel || (LogLevel = {}));\r\nvar levelStringToEnum = {\r\n    'debug': LogLevel.DEBUG,\r\n    'verbose': LogLevel.VERBOSE,\r\n    'info': LogLevel.INFO,\r\n    'warn': LogLevel.WARN,\r\n    'error': LogLevel.ERROR,\r\n    'silent': LogLevel.SILENT\r\n};\r\n/**\r\n * The default log level\r\n */\r\nvar defaultLogLevel = LogLevel.INFO;\r\n/**\r\n * By default, `console.debug` is not displayed in the developer console (in\r\n * chrome). To avoid forcing users to have to opt-in to these logs twice\r\n * (i.e. once for firebase, and once in the console), we are sending `DEBUG`\r\n * logs to the `console.log` function.\r\n */\r\nvar ConsoleMethod = (_a = {},\r\n    _a[LogLevel.DEBUG] = 'log',\r\n    _a[LogLevel.VERBOSE] = 'log',\r\n    _a[LogLevel.INFO] = 'info',\r\n    _a[LogLevel.WARN] = 'warn',\r\n    _a[LogLevel.ERROR] = 'error',\r\n    _a);\r\n/**\r\n * The default log handler will forward DEBUG, VERBOSE, INFO, WARN, and ERROR\r\n * messages on to their corresponding console counterparts (if the log method\r\n * is supported by the current log level)\r\n */\r\nvar defaultLogHandler = function (instance, logType) {\r\n    var args = [];\r\n    for (var _i = 2; _i < arguments.length; _i++) {\r\n        args[_i - 2] = arguments[_i];\r\n    }\r\n    if (logType < instance.logLevel) {\r\n        return;\r\n    }\r\n    var now = new Date().toISOString();\r\n    var method = ConsoleMethod[logType];\r\n    if (method) {\r\n        console[method].apply(console, __spreadArrays([\"[\" + now + \"]  \" + instance.name + \":\"], args));\r\n    }\r\n    else {\r\n        throw new Error(\"Attempted to log a message with an invalid logType (value: \" + logType + \")\");\r\n    }\r\n};\r\nvar Logger = /** @class */ (function () {\r\n    /**\r\n     * Gives you an instance of a Logger to capture messages according to\r\n     * Firebase's logging scheme.\r\n     *\r\n     * @param name The name that the logs will be associated with\r\n     */\r\n    function Logger(name) {\r\n        this.name = name;\r\n        /**\r\n         * The log level of the given Logger instance.\r\n         */\r\n        this._logLevel = defaultLogLevel;\r\n        /**\r\n         * The main (internal) log handler for the Logger instance.\r\n         * Can be set to a new function in internal package code but not by user.\r\n         */\r\n        this._logHandler = defaultLogHandler;\r\n        /**\r\n         * The optional, additional, user-defined log handler for the Logger instance.\r\n         */\r\n        this._userLogHandler = null;\r\n        /**\r\n         * Capture the current instance for later use\r\n         */\r\n        instances.push(this);\r\n    }\r\n    Object.defineProperty(Logger.prototype, \"logLevel\", {\r\n        get: function () {\r\n            return this._logLevel;\r\n        },\r\n        set: function (val) {\r\n            if (!(val in LogLevel)) {\r\n                throw new TypeError(\"Invalid value \\\"\" + val + \"\\\" assigned to `logLevel`\");\r\n            }\r\n            this._logLevel = val;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    // Workaround for setter/getter having to be the same type.\r\n    Logger.prototype.setLogLevel = function (val) {\r\n        this._logLevel = typeof val === 'string' ? levelStringToEnum[val] : val;\r\n    };\r\n    Object.defineProperty(Logger.prototype, \"logHandler\", {\r\n        get: function () {\r\n            return this._logHandler;\r\n        },\r\n        set: function (val) {\r\n            if (typeof val !== 'function') {\r\n                throw new TypeError('Value assigned to `logHandler` must be a function');\r\n            }\r\n            this._logHandler = val;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Logger.prototype, \"userLogHandler\", {\r\n        get: function () {\r\n            return this._userLogHandler;\r\n        },\r\n        set: function (val) {\r\n            this._userLogHandler = val;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * The functions below are all based on the `console` interface\r\n     */\r\n    Logger.prototype.debug = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        this._userLogHandler && this._userLogHandler.apply(this, __spreadArrays([this, LogLevel.DEBUG], args));\r\n        this._logHandler.apply(this, __spreadArrays([this, LogLevel.DEBUG], args));\r\n    };\r\n    Logger.prototype.log = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        this._userLogHandler && this._userLogHandler.apply(this, __spreadArrays([this, LogLevel.VERBOSE], args));\r\n        this._logHandler.apply(this, __spreadArrays([this, LogLevel.VERBOSE], args));\r\n    };\r\n    Logger.prototype.info = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        this._userLogHandler && this._userLogHandler.apply(this, __spreadArrays([this, LogLevel.INFO], args));\r\n        this._logHandler.apply(this, __spreadArrays([this, LogLevel.INFO], args));\r\n    };\r\n    Logger.prototype.warn = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        this._userLogHandler && this._userLogHandler.apply(this, __spreadArrays([this, LogLevel.WARN], args));\r\n        this._logHandler.apply(this, __spreadArrays([this, LogLevel.WARN], args));\r\n    };\r\n    Logger.prototype.error = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        this._userLogHandler && this._userLogHandler.apply(this, __spreadArrays([this, LogLevel.ERROR], args));\r\n        this._logHandler.apply(this, __spreadArrays([this, LogLevel.ERROR], args));\r\n    };\r\n    return Logger;\r\n}());\r\nfunction setLogLevel(level) {\r\n    instances.forEach(function (inst) {\r\n        inst.setLogLevel(level);\r\n    });\r\n}\r\nfunction setUserLogHandler(logCallback, options) {\r\n    var _loop_1 = function (instance) {\r\n        var customLogLevel = null;\r\n        if (options && options.level) {\r\n            customLogLevel = levelStringToEnum[options.level];\r\n        }\r\n        if (logCallback === null) {\r\n            instance.userLogHandler = null;\r\n        }\r\n        else {\r\n            instance.userLogHandler = function (instance, level) {\r\n                var args = [];\r\n                for (var _i = 2; _i < arguments.length; _i++) {\r\n                    args[_i - 2] = arguments[_i];\r\n                }\r\n                var message = args\r\n                    .map(function (arg) {\r\n                    if (arg == null) {\r\n                        return null;\r\n                    }\r\n                    else if (typeof arg === 'string') {\r\n                        return arg;\r\n                    }\r\n                    else if (typeof arg === 'number' || typeof arg === 'boolean') {\r\n                        return arg.toString();\r\n                    }\r\n                    else if (arg instanceof Error) {\r\n                        return arg.message;\r\n                    }\r\n                    else {\r\n                        try {\r\n                            return JSON.stringify(arg);\r\n                        }\r\n                        catch (ignored) {\r\n                            return null;\r\n                        }\r\n                    }\r\n                })\r\n                    .filter(function (arg) { return arg; })\r\n                    .join(' ');\r\n                if (level >= (customLogLevel !== null && customLogLevel !== void 0 ? customLogLevel : instance.logLevel)) {\r\n                    logCallback({\r\n                        level: LogLevel[level].toLowerCase(),\r\n                        message: message,\r\n                        args: args,\r\n                        type: instance.name\r\n                    });\r\n                }\r\n            };\r\n        }\r\n    };\r\n    for (var _i = 0, instances_1 = instances; _i < instances_1.length; _i++) {\r\n        var instance = instances_1[_i];\r\n        _loop_1(instance);\r\n    }\r\n}\n\n\n//# sourceMappingURL=index.esm.js.map\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@firebase/logger/dist/index.esm.js?");

/***/ }),

/***/ "./src/node_modules/@firebase/util/dist/index.esm.js":
/*!***********************************************************!*\
  !*** ./src/node_modules/@firebase/util/dist/index.esm.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CONSTANTS\": () => (/* binding */ CONSTANTS),\n/* harmony export */   \"Deferred\": () => (/* binding */ Deferred),\n/* harmony export */   \"ErrorFactory\": () => (/* binding */ ErrorFactory),\n/* harmony export */   \"FirebaseError\": () => (/* binding */ FirebaseError),\n/* harmony export */   \"MAX_VALUE_MILLIS\": () => (/* binding */ MAX_VALUE_MILLIS),\n/* harmony export */   \"RANDOM_FACTOR\": () => (/* binding */ RANDOM_FACTOR),\n/* harmony export */   \"Sha1\": () => (/* binding */ Sha1),\n/* harmony export */   \"areCookiesEnabled\": () => (/* binding */ areCookiesEnabled),\n/* harmony export */   \"assert\": () => (/* binding */ assert),\n/* harmony export */   \"assertionError\": () => (/* binding */ assertionError),\n/* harmony export */   \"async\": () => (/* binding */ async),\n/* harmony export */   \"base64\": () => (/* binding */ base64),\n/* harmony export */   \"base64Decode\": () => (/* binding */ base64Decode),\n/* harmony export */   \"base64Encode\": () => (/* binding */ base64Encode),\n/* harmony export */   \"calculateBackoffMillis\": () => (/* binding */ calculateBackoffMillis),\n/* harmony export */   \"contains\": () => (/* binding */ contains),\n/* harmony export */   \"createSubscribe\": () => (/* binding */ createSubscribe),\n/* harmony export */   \"decode\": () => (/* binding */ decode),\n/* harmony export */   \"deepCopy\": () => (/* binding */ deepCopy),\n/* harmony export */   \"deepExtend\": () => (/* binding */ deepExtend),\n/* harmony export */   \"errorPrefix\": () => (/* binding */ errorPrefix),\n/* harmony export */   \"getUA\": () => (/* binding */ getUA),\n/* harmony export */   \"isAdmin\": () => (/* binding */ isAdmin),\n/* harmony export */   \"isBrowser\": () => (/* binding */ isBrowser),\n/* harmony export */   \"isBrowserExtension\": () => (/* binding */ isBrowserExtension),\n/* harmony export */   \"isElectron\": () => (/* binding */ isElectron),\n/* harmony export */   \"isEmpty\": () => (/* binding */ isEmpty),\n/* harmony export */   \"isIE\": () => (/* binding */ isIE),\n/* harmony export */   \"isIndexedDBAvailable\": () => (/* binding */ isIndexedDBAvailable),\n/* harmony export */   \"isMobileCordova\": () => (/* binding */ isMobileCordova),\n/* harmony export */   \"isNode\": () => (/* binding */ isNode),\n/* harmony export */   \"isNodeSdk\": () => (/* binding */ isNodeSdk),\n/* harmony export */   \"isReactNative\": () => (/* binding */ isReactNative),\n/* harmony export */   \"isSafari\": () => (/* binding */ isSafari),\n/* harmony export */   \"isUWP\": () => (/* binding */ isUWP),\n/* harmony export */   \"isValidFormat\": () => (/* binding */ isValidFormat),\n/* harmony export */   \"isValidTimestamp\": () => (/* binding */ isValidTimestamp),\n/* harmony export */   \"issuedAtTime\": () => (/* binding */ issuedAtTime),\n/* harmony export */   \"jsonEval\": () => (/* binding */ jsonEval),\n/* harmony export */   \"map\": () => (/* binding */ map),\n/* harmony export */   \"querystring\": () => (/* binding */ querystring),\n/* harmony export */   \"querystringDecode\": () => (/* binding */ querystringDecode),\n/* harmony export */   \"safeGet\": () => (/* binding */ safeGet),\n/* harmony export */   \"stringLength\": () => (/* binding */ stringLength),\n/* harmony export */   \"stringToByteArray\": () => (/* binding */ stringToByteArray$1),\n/* harmony export */   \"stringify\": () => (/* binding */ stringify),\n/* harmony export */   \"validateArgCount\": () => (/* binding */ validateArgCount),\n/* harmony export */   \"validateCallback\": () => (/* binding */ validateCallback),\n/* harmony export */   \"validateContextObject\": () => (/* binding */ validateContextObject),\n/* harmony export */   \"validateIndexedDBOpenable\": () => (/* binding */ validateIndexedDBOpenable),\n/* harmony export */   \"validateNamespace\": () => (/* binding */ validateNamespace)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"tslib\");\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tslib__WEBPACK_IMPORTED_MODULE_0__);\n\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * @fileoverview Firebase constants.  Some of these (@defines) can be overridden at compile-time.\r\n */\r\nvar CONSTANTS = {\r\n    /**\r\n     * @define {boolean} Whether this is the client Node.js SDK.\r\n     */\r\n    NODE_CLIENT: false,\r\n    /**\r\n     * @define {boolean} Whether this is the Admin Node.js SDK.\r\n     */\r\n    NODE_ADMIN: false,\r\n    /**\r\n     * Firebase SDK Version\r\n     */\r\n    SDK_VERSION: '${JSCORE_VERSION}'\r\n};\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Throws an error if the provided assertion is falsy\r\n */\r\nvar assert = function (assertion, message) {\r\n    if (!assertion) {\r\n        throw assertionError(message);\r\n    }\r\n};\r\n/**\r\n * Returns an Error object suitable for throwing.\r\n */\r\nvar assertionError = function (message) {\r\n    return new Error('Firebase Database (' +\r\n        CONSTANTS.SDK_VERSION +\r\n        ') INTERNAL ASSERT FAILED: ' +\r\n        message);\r\n};\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar stringToByteArray = function (str) {\r\n    // TODO(user): Use native implementations if/when available\r\n    var out = [];\r\n    var p = 0;\r\n    for (var i = 0; i < str.length; i++) {\r\n        var c = str.charCodeAt(i);\r\n        if (c < 128) {\r\n            out[p++] = c;\r\n        }\r\n        else if (c < 2048) {\r\n            out[p++] = (c >> 6) | 192;\r\n            out[p++] = (c & 63) | 128;\r\n        }\r\n        else if ((c & 0xfc00) === 0xd800 &&\r\n            i + 1 < str.length &&\r\n            (str.charCodeAt(i + 1) & 0xfc00) === 0xdc00) {\r\n            // Surrogate Pair\r\n            c = 0x10000 + ((c & 0x03ff) << 10) + (str.charCodeAt(++i) & 0x03ff);\r\n            out[p++] = (c >> 18) | 240;\r\n            out[p++] = ((c >> 12) & 63) | 128;\r\n            out[p++] = ((c >> 6) & 63) | 128;\r\n            out[p++] = (c & 63) | 128;\r\n        }\r\n        else {\r\n            out[p++] = (c >> 12) | 224;\r\n            out[p++] = ((c >> 6) & 63) | 128;\r\n            out[p++] = (c & 63) | 128;\r\n        }\r\n    }\r\n    return out;\r\n};\r\n/**\r\n * Turns an array of numbers into the string given by the concatenation of the\r\n * characters to which the numbers correspond.\r\n * @param bytes Array of numbers representing characters.\r\n * @return Stringification of the array.\r\n */\r\nvar byteArrayToString = function (bytes) {\r\n    // TODO(user): Use native implementations if/when available\r\n    var out = [];\r\n    var pos = 0, c = 0;\r\n    while (pos < bytes.length) {\r\n        var c1 = bytes[pos++];\r\n        if (c1 < 128) {\r\n            out[c++] = String.fromCharCode(c1);\r\n        }\r\n        else if (c1 > 191 && c1 < 224) {\r\n            var c2 = bytes[pos++];\r\n            out[c++] = String.fromCharCode(((c1 & 31) << 6) | (c2 & 63));\r\n        }\r\n        else if (c1 > 239 && c1 < 365) {\r\n            // Surrogate Pair\r\n            var c2 = bytes[pos++];\r\n            var c3 = bytes[pos++];\r\n            var c4 = bytes[pos++];\r\n            var u = (((c1 & 7) << 18) | ((c2 & 63) << 12) | ((c3 & 63) << 6) | (c4 & 63)) -\r\n                0x10000;\r\n            out[c++] = String.fromCharCode(0xd800 + (u >> 10));\r\n            out[c++] = String.fromCharCode(0xdc00 + (u & 1023));\r\n        }\r\n        else {\r\n            var c2 = bytes[pos++];\r\n            var c3 = bytes[pos++];\r\n            out[c++] = String.fromCharCode(((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\r\n        }\r\n    }\r\n    return out.join('');\r\n};\r\n// We define it as an object literal instead of a class because a class compiled down to es5 can't\r\n// be treeshaked. https://github.com/rollup/rollup/issues/1691\r\n// Static lookup maps, lazily populated by init_()\r\nvar base64 = {\r\n    /**\r\n     * Maps bytes to characters.\r\n     */\r\n    byteToCharMap_: null,\r\n    /**\r\n     * Maps characters to bytes.\r\n     */\r\n    charToByteMap_: null,\r\n    /**\r\n     * Maps bytes to websafe characters.\r\n     * @private\r\n     */\r\n    byteToCharMapWebSafe_: null,\r\n    /**\r\n     * Maps websafe characters to bytes.\r\n     * @private\r\n     */\r\n    charToByteMapWebSafe_: null,\r\n    /**\r\n     * Our default alphabet, shared between\r\n     * ENCODED_VALS and ENCODED_VALS_WEBSAFE\r\n     */\r\n    ENCODED_VALS_BASE: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + 'abcdefghijklmnopqrstuvwxyz' + '0123456789',\r\n    /**\r\n     * Our default alphabet. Value 64 (=) is special; it means \"nothing.\"\r\n     */\r\n    get ENCODED_VALS() {\r\n        return this.ENCODED_VALS_BASE + '+/=';\r\n    },\r\n    /**\r\n     * Our websafe alphabet.\r\n     */\r\n    get ENCODED_VALS_WEBSAFE() {\r\n        return this.ENCODED_VALS_BASE + '-_.';\r\n    },\r\n    /**\r\n     * Whether this browser supports the atob and btoa functions. This extension\r\n     * started at Mozilla but is now implemented by many browsers. We use the\r\n     * ASSUME_* variables to avoid pulling in the full useragent detection library\r\n     * but still allowing the standard per-browser compilations.\r\n     *\r\n     */\r\n    HAS_NATIVE_SUPPORT: typeof atob === 'function',\r\n    /**\r\n     * Base64-encode an array of bytes.\r\n     *\r\n     * @param input An array of bytes (numbers with\r\n     *     value in [0, 255]) to encode.\r\n     * @param webSafe Boolean indicating we should use the\r\n     *     alternative alphabet.\r\n     * @return The base64 encoded string.\r\n     */\r\n    encodeByteArray: function (input, webSafe) {\r\n        if (!Array.isArray(input)) {\r\n            throw Error('encodeByteArray takes an array as a parameter');\r\n        }\r\n        this.init_();\r\n        var byteToCharMap = webSafe\r\n            ? this.byteToCharMapWebSafe_\r\n            : this.byteToCharMap_;\r\n        var output = [];\r\n        for (var i = 0; i < input.length; i += 3) {\r\n            var byte1 = input[i];\r\n            var haveByte2 = i + 1 < input.length;\r\n            var byte2 = haveByte2 ? input[i + 1] : 0;\r\n            var haveByte3 = i + 2 < input.length;\r\n            var byte3 = haveByte3 ? input[i + 2] : 0;\r\n            var outByte1 = byte1 >> 2;\r\n            var outByte2 = ((byte1 & 0x03) << 4) | (byte2 >> 4);\r\n            var outByte3 = ((byte2 & 0x0f) << 2) | (byte3 >> 6);\r\n            var outByte4 = byte3 & 0x3f;\r\n            if (!haveByte3) {\r\n                outByte4 = 64;\r\n                if (!haveByte2) {\r\n                    outByte3 = 64;\r\n                }\r\n            }\r\n            output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);\r\n        }\r\n        return output.join('');\r\n    },\r\n    /**\r\n     * Base64-encode a string.\r\n     *\r\n     * @param input A string to encode.\r\n     * @param webSafe If true, we should use the\r\n     *     alternative alphabet.\r\n     * @return The base64 encoded string.\r\n     */\r\n    encodeString: function (input, webSafe) {\r\n        // Shortcut for Mozilla browsers that implement\r\n        // a native base64 encoder in the form of \"btoa/atob\"\r\n        if (this.HAS_NATIVE_SUPPORT && !webSafe) {\r\n            return btoa(input);\r\n        }\r\n        return this.encodeByteArray(stringToByteArray(input), webSafe);\r\n    },\r\n    /**\r\n     * Base64-decode a string.\r\n     *\r\n     * @param input to decode.\r\n     * @param webSafe True if we should use the\r\n     *     alternative alphabet.\r\n     * @return string representing the decoded value.\r\n     */\r\n    decodeString: function (input, webSafe) {\r\n        // Shortcut for Mozilla browsers that implement\r\n        // a native base64 encoder in the form of \"btoa/atob\"\r\n        if (this.HAS_NATIVE_SUPPORT && !webSafe) {\r\n            return atob(input);\r\n        }\r\n        return byteArrayToString(this.decodeStringToByteArray(input, webSafe));\r\n    },\r\n    /**\r\n     * Base64-decode a string.\r\n     *\r\n     * In base-64 decoding, groups of four characters are converted into three\r\n     * bytes.  If the encoder did not apply padding, the input length may not\r\n     * be a multiple of 4.\r\n     *\r\n     * In this case, the last group will have fewer than 4 characters, and\r\n     * padding will be inferred.  If the group has one or two characters, it decodes\r\n     * to one byte.  If the group has three characters, it decodes to two bytes.\r\n     *\r\n     * @param input Input to decode.\r\n     * @param webSafe True if we should use the web-safe alphabet.\r\n     * @return bytes representing the decoded value.\r\n     */\r\n    decodeStringToByteArray: function (input, webSafe) {\r\n        this.init_();\r\n        var charToByteMap = webSafe\r\n            ? this.charToByteMapWebSafe_\r\n            : this.charToByteMap_;\r\n        var output = [];\r\n        for (var i = 0; i < input.length;) {\r\n            var byte1 = charToByteMap[input.charAt(i++)];\r\n            var haveByte2 = i < input.length;\r\n            var byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;\r\n            ++i;\r\n            var haveByte3 = i < input.length;\r\n            var byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;\r\n            ++i;\r\n            var haveByte4 = i < input.length;\r\n            var byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;\r\n            ++i;\r\n            if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {\r\n                throw Error();\r\n            }\r\n            var outByte1 = (byte1 << 2) | (byte2 >> 4);\r\n            output.push(outByte1);\r\n            if (byte3 !== 64) {\r\n                var outByte2 = ((byte2 << 4) & 0xf0) | (byte3 >> 2);\r\n                output.push(outByte2);\r\n                if (byte4 !== 64) {\r\n                    var outByte3 = ((byte3 << 6) & 0xc0) | byte4;\r\n                    output.push(outByte3);\r\n                }\r\n            }\r\n        }\r\n        return output;\r\n    },\r\n    /**\r\n     * Lazy static initialization function. Called before\r\n     * accessing any of the static map variables.\r\n     * @private\r\n     */\r\n    init_: function () {\r\n        if (!this.byteToCharMap_) {\r\n            this.byteToCharMap_ = {};\r\n            this.charToByteMap_ = {};\r\n            this.byteToCharMapWebSafe_ = {};\r\n            this.charToByteMapWebSafe_ = {};\r\n            // We want quick mappings back and forth, so we precompute two maps.\r\n            for (var i = 0; i < this.ENCODED_VALS.length; i++) {\r\n                this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);\r\n                this.charToByteMap_[this.byteToCharMap_[i]] = i;\r\n                this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);\r\n                this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;\r\n                // Be forgiving when decoding and correctly decode both encodings.\r\n                if (i >= this.ENCODED_VALS_BASE.length) {\r\n                    this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;\r\n                    this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n/**\r\n * URL-safe base64 encoding\r\n */\r\nvar base64Encode = function (str) {\r\n    var utf8Bytes = stringToByteArray(str);\r\n    return base64.encodeByteArray(utf8Bytes, true);\r\n};\r\n/**\r\n * URL-safe base64 decoding\r\n *\r\n * NOTE: DO NOT use the global atob() function - it does NOT support the\r\n * base64Url variant encoding.\r\n *\r\n * @param str To be decoded\r\n * @return Decoded result, if possible\r\n */\r\nvar base64Decode = function (str) {\r\n    try {\r\n        return base64.decodeString(str, true);\r\n    }\r\n    catch (e) {\r\n        console.error('base64Decode failed: ', e);\r\n    }\r\n    return null;\r\n};\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Do a deep-copy of basic JavaScript Objects or Arrays.\r\n */\r\nfunction deepCopy(value) {\r\n    return deepExtend(undefined, value);\r\n}\r\n/**\r\n * Copy properties from source to target (recursively allows extension\r\n * of Objects and Arrays).  Scalar values in the target are over-written.\r\n * If target is undefined, an object of the appropriate type will be created\r\n * (and returned).\r\n *\r\n * We recursively copy all child properties of plain Objects in the source- so\r\n * that namespace- like dictionaries are merged.\r\n *\r\n * Note that the target can be a function, in which case the properties in\r\n * the source Object are copied onto it as static properties of the Function.\r\n */\r\nfunction deepExtend(target, source) {\r\n    if (!(source instanceof Object)) {\r\n        return source;\r\n    }\r\n    switch (source.constructor) {\r\n        case Date:\r\n            // Treat Dates like scalars; if the target date object had any child\r\n            // properties - they will be lost!\r\n            var dateValue = source;\r\n            return new Date(dateValue.getTime());\r\n        case Object:\r\n            if (target === undefined) {\r\n                target = {};\r\n            }\r\n            break;\r\n        case Array:\r\n            // Always copy the array source and overwrite the target.\r\n            target = [];\r\n            break;\r\n        default:\r\n            // Not a plain Object - treat it as a scalar.\r\n            return source;\r\n    }\r\n    for (var prop in source) {\r\n        if (!source.hasOwnProperty(prop)) {\r\n            continue;\r\n        }\r\n        target[prop] = deepExtend(target[prop], source[prop]);\r\n    }\r\n    return target;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar Deferred = /** @class */ (function () {\r\n    function Deferred() {\r\n        var _this = this;\r\n        this.reject = function () { };\r\n        this.resolve = function () { };\r\n        this.promise = new Promise(function (resolve, reject) {\r\n            _this.resolve = resolve;\r\n            _this.reject = reject;\r\n        });\r\n    }\r\n    /**\r\n     * Our API internals are not promiseified and cannot because our callback APIs have subtle expectations around\r\n     * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback\r\n     * and returns a node-style callback which will resolve or reject the Deferred's promise.\r\n     */\r\n    Deferred.prototype.wrapCallback = function (callback) {\r\n        var _this = this;\r\n        return function (error, value) {\r\n            if (error) {\r\n                _this.reject(error);\r\n            }\r\n            else {\r\n                _this.resolve(value);\r\n            }\r\n            if (typeof callback === 'function') {\r\n                // Attaching noop handler just in case developer wasn't expecting\r\n                // promises\r\n                _this.promise.catch(function () { });\r\n                // Some of our callbacks don't expect a value and our own tests\r\n                // assert that the parameter length is 1\r\n                if (callback.length === 1) {\r\n                    callback(error);\r\n                }\r\n                else {\r\n                    callback(error, value);\r\n                }\r\n            }\r\n        };\r\n    };\r\n    return Deferred;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Returns navigator.userAgent string or '' if it's not defined.\r\n * @return user agent string\r\n */\r\nfunction getUA() {\r\n    if (typeof navigator !== 'undefined' &&\r\n        typeof navigator['userAgent'] === 'string') {\r\n        return navigator['userAgent'];\r\n    }\r\n    else {\r\n        return '';\r\n    }\r\n}\r\n/**\r\n * Detect Cordova / PhoneGap / Ionic frameworks on a mobile device.\r\n *\r\n * Deliberately does not rely on checking `file://` URLs (as this fails PhoneGap\r\n * in the Ripple emulator) nor Cordova `onDeviceReady`, which would normally\r\n * wait for a callback.\r\n */\r\nfunction isMobileCordova() {\r\n    return (typeof window !== 'undefined' &&\r\n        // @ts-ignore Setting up an broadly applicable index signature for Window\r\n        // just to deal with this case would probably be a bad idea.\r\n        !!(window['cordova'] || window['phonegap'] || window['PhoneGap']) &&\r\n        /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(getUA()));\r\n}\r\n/**\r\n * Detect Node.js.\r\n *\r\n * @return true if Node.js environment is detected.\r\n */\r\n// Node detection logic from: https://github.com/iliakan/detect-node/\r\nfunction isNode() {\r\n    try {\r\n        return (Object.prototype.toString.call(global.process) === '[object process]');\r\n    }\r\n    catch (e) {\r\n        return false;\r\n    }\r\n}\r\n/**\r\n * Detect Browser Environment\r\n */\r\nfunction isBrowser() {\r\n    return typeof self === 'object' && self.self === self;\r\n}\r\nfunction isBrowserExtension() {\r\n    var runtime = typeof chrome === 'object'\r\n        ? chrome.runtime\r\n        : typeof browser === 'object'\r\n            ? browser.runtime\r\n            : undefined;\r\n    return typeof runtime === 'object' && runtime.id !== undefined;\r\n}\r\n/**\r\n * Detect React Native.\r\n *\r\n * @return true if ReactNative environment is detected.\r\n */\r\nfunction isReactNative() {\r\n    return (typeof navigator === 'object' && navigator['product'] === 'ReactNative');\r\n}\r\n/** Detects Electron apps. */\r\nfunction isElectron() {\r\n    return getUA().indexOf('Electron/') >= 0;\r\n}\r\n/** Detects Internet Explorer. */\r\nfunction isIE() {\r\n    var ua = getUA();\r\n    return ua.indexOf('MSIE ') >= 0 || ua.indexOf('Trident/') >= 0;\r\n}\r\n/** Detects Universal Windows Platform apps. */\r\nfunction isUWP() {\r\n    return getUA().indexOf('MSAppHost/') >= 0;\r\n}\r\n/**\r\n * Detect whether the current SDK build is the Node version.\r\n *\r\n * @return true if it's the Node SDK build.\r\n */\r\nfunction isNodeSdk() {\r\n    return CONSTANTS.NODE_CLIENT === true || CONSTANTS.NODE_ADMIN === true;\r\n}\r\n/** Returns true if we are running in Safari. */\r\nfunction isSafari() {\r\n    return (!isNode() &&\r\n        navigator.userAgent.includes('Safari') &&\r\n        !navigator.userAgent.includes('Chrome'));\r\n}\r\n/**\r\n * This method checks if indexedDB is supported by current browser/service worker context\r\n * @return true if indexedDB is supported by current browser/service worker context\r\n */\r\nfunction isIndexedDBAvailable() {\r\n    return 'indexedDB' in self && indexedDB != null;\r\n}\r\n/**\r\n * This method validates browser context for indexedDB by opening a dummy indexedDB database and reject\r\n * if errors occur during the database open operation.\r\n */\r\nfunction validateIndexedDBOpenable() {\r\n    return new Promise(function (resolve, reject) {\r\n        try {\r\n            var preExist_1 = true;\r\n            var DB_CHECK_NAME_1 = 'validate-browser-context-for-indexeddb-analytics-module';\r\n            var request_1 = window.indexedDB.open(DB_CHECK_NAME_1);\r\n            request_1.onsuccess = function () {\r\n                request_1.result.close();\r\n                // delete database only when it doesn't pre-exist\r\n                if (!preExist_1) {\r\n                    window.indexedDB.deleteDatabase(DB_CHECK_NAME_1);\r\n                }\r\n                resolve(true);\r\n            };\r\n            request_1.onupgradeneeded = function () {\r\n                preExist_1 = false;\r\n            };\r\n            request_1.onerror = function () {\r\n                var _a;\r\n                reject(((_a = request_1.error) === null || _a === void 0 ? void 0 : _a.message) || '');\r\n            };\r\n        }\r\n        catch (error) {\r\n            reject(error);\r\n        }\r\n    });\r\n}\r\n/**\r\n *\r\n * This method checks whether cookie is enabled within current browser\r\n * @return true if cookie is enabled within current browser\r\n */\r\nfunction areCookiesEnabled() {\r\n    if (!navigator || !navigator.cookieEnabled) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar ERROR_NAME = 'FirebaseError';\r\n// Based on code from:\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Custom_Error_Types\r\nvar FirebaseError = /** @class */ (function (_super) {\r\n    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(FirebaseError, _super);\r\n    function FirebaseError(code, message) {\r\n        var _this = _super.call(this, message) || this;\r\n        _this.code = code;\r\n        _this.name = ERROR_NAME;\r\n        // Fix For ES5\r\n        // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(_this, FirebaseError.prototype);\r\n        // Maintains proper stack trace for where our error was thrown.\r\n        // Only available on V8.\r\n        if (Error.captureStackTrace) {\r\n            Error.captureStackTrace(_this, ErrorFactory.prototype.create);\r\n        }\r\n        return _this;\r\n    }\r\n    return FirebaseError;\r\n}(Error));\r\nvar ErrorFactory = /** @class */ (function () {\r\n    function ErrorFactory(service, serviceName, errors) {\r\n        this.service = service;\r\n        this.serviceName = serviceName;\r\n        this.errors = errors;\r\n    }\r\n    ErrorFactory.prototype.create = function (code) {\r\n        var data = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            data[_i - 1] = arguments[_i];\r\n        }\r\n        var customData = data[0] || {};\r\n        var fullCode = this.service + \"/\" + code;\r\n        var template = this.errors[code];\r\n        var message = template ? replaceTemplate(template, customData) : 'Error';\r\n        // Service Name: Error message (service/code).\r\n        var fullMessage = this.serviceName + \": \" + message + \" (\" + fullCode + \").\";\r\n        var error = new FirebaseError(fullCode, fullMessage);\r\n        // Keys with an underscore at the end of their name are not included in\r\n        // error.data for some reason.\r\n        // TODO: Replace with Object.entries when lib is updated to es2017.\r\n        for (var _a = 0, _b = Object.keys(customData); _a < _b.length; _a++) {\r\n            var key = _b[_a];\r\n            if (key.slice(-1) !== '_') {\r\n                if (key in error) {\r\n                    console.warn(\"Overwriting FirebaseError base field \\\"\" + key + \"\\\" can cause unexpected behavior.\");\r\n                }\r\n                error[key] = customData[key];\r\n            }\r\n        }\r\n        return error;\r\n    };\r\n    return ErrorFactory;\r\n}());\r\nfunction replaceTemplate(template, data) {\r\n    return template.replace(PATTERN, function (_, key) {\r\n        var value = data[key];\r\n        return value != null ? String(value) : \"<\" + key + \"?>\";\r\n    });\r\n}\r\nvar PATTERN = /\\{\\$([^}]+)}/g;\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Evaluates a JSON string into a javascript object.\r\n *\r\n * @param {string} str A string containing JSON.\r\n * @return {*} The javascript object representing the specified JSON.\r\n */\r\nfunction jsonEval(str) {\r\n    return JSON.parse(str);\r\n}\r\n/**\r\n * Returns JSON representing a javascript object.\r\n * @param {*} data Javascript object to be stringified.\r\n * @return {string} The JSON contents of the object.\r\n */\r\nfunction stringify(data) {\r\n    return JSON.stringify(data);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Decodes a Firebase auth. token into constituent parts.\r\n *\r\n * Notes:\r\n * - May return with invalid / incomplete claims if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */\r\nvar decode = function (token) {\r\n    var header = {}, claims = {}, data = {}, signature = '';\r\n    try {\r\n        var parts = token.split('.');\r\n        header = jsonEval(base64Decode(parts[0]) || '');\r\n        claims = jsonEval(base64Decode(parts[1]) || '');\r\n        signature = parts[2];\r\n        data = claims['d'] || {};\r\n        delete claims['d'];\r\n    }\r\n    catch (e) { }\r\n    return {\r\n        header: header,\r\n        claims: claims,\r\n        data: data,\r\n        signature: signature\r\n    };\r\n};\r\n/**\r\n * Decodes a Firebase auth. token and checks the validity of its time-based claims. Will return true if the\r\n * token is within the time window authorized by the 'nbf' (not-before) and 'iat' (issued-at) claims.\r\n *\r\n * Notes:\r\n * - May return a false negative if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */\r\nvar isValidTimestamp = function (token) {\r\n    var claims = decode(token).claims;\r\n    var now = Math.floor(new Date().getTime() / 1000);\r\n    var validSince = 0, validUntil = 0;\r\n    if (typeof claims === 'object') {\r\n        if (claims.hasOwnProperty('nbf')) {\r\n            validSince = claims['nbf'];\r\n        }\r\n        else if (claims.hasOwnProperty('iat')) {\r\n            validSince = claims['iat'];\r\n        }\r\n        if (claims.hasOwnProperty('exp')) {\r\n            validUntil = claims['exp'];\r\n        }\r\n        else {\r\n            // token will expire after 24h by default\r\n            validUntil = validSince + 86400;\r\n        }\r\n    }\r\n    return (!!now &&\r\n        !!validSince &&\r\n        !!validUntil &&\r\n        now >= validSince &&\r\n        now <= validUntil);\r\n};\r\n/**\r\n * Decodes a Firebase auth. token and returns its issued at time if valid, null otherwise.\r\n *\r\n * Notes:\r\n * - May return null if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */\r\nvar issuedAtTime = function (token) {\r\n    var claims = decode(token).claims;\r\n    if (typeof claims === 'object' && claims.hasOwnProperty('iat')) {\r\n        return claims['iat'];\r\n    }\r\n    return null;\r\n};\r\n/**\r\n * Decodes a Firebase auth. token and checks the validity of its format. Expects a valid issued-at time.\r\n *\r\n * Notes:\r\n * - May return a false negative if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */\r\nvar isValidFormat = function (token) {\r\n    var decoded = decode(token), claims = decoded.claims;\r\n    return !!claims && typeof claims === 'object' && claims.hasOwnProperty('iat');\r\n};\r\n/**\r\n * Attempts to peer into an auth token and determine if it's an admin auth token by looking at the claims portion.\r\n *\r\n * Notes:\r\n * - May return a false negative if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */\r\nvar isAdmin = function (token) {\r\n    var claims = decode(token).claims;\r\n    return typeof claims === 'object' && claims['admin'] === true;\r\n};\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction contains(obj, key) {\r\n    return Object.prototype.hasOwnProperty.call(obj, key);\r\n}\r\nfunction safeGet(obj, key) {\r\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n        return obj[key];\r\n    }\r\n    else {\r\n        return undefined;\r\n    }\r\n}\r\nfunction isEmpty(obj) {\r\n    for (var key in obj) {\r\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction map(obj, fn, contextObj) {\r\n    var res = {};\r\n    for (var key in obj) {\r\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n            res[key] = fn.call(contextObj, obj[key], key, obj);\r\n        }\r\n    }\r\n    return res;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Returns a querystring-formatted string (e.g. &arg=val&arg2=val2) from a\r\n * params object (e.g. {arg: 'val', arg2: 'val2'})\r\n * Note: You must prepend it with ? when adding it to a URL.\r\n */\r\nfunction querystring(querystringParams) {\r\n    var params = [];\r\n    var _loop_1 = function (key, value) {\r\n        if (Array.isArray(value)) {\r\n            value.forEach(function (arrayVal) {\r\n                params.push(encodeURIComponent(key) + '=' + encodeURIComponent(arrayVal));\r\n            });\r\n        }\r\n        else {\r\n            params.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));\r\n        }\r\n    };\r\n    for (var _i = 0, _a = Object.entries(querystringParams); _i < _a.length; _i++) {\r\n        var _b = _a[_i], key = _b[0], value = _b[1];\r\n        _loop_1(key, value);\r\n    }\r\n    return params.length ? '&' + params.join('&') : '';\r\n}\r\n/**\r\n * Decodes a querystring (e.g. ?arg=val&arg2=val2) into a params object\r\n * (e.g. {arg: 'val', arg2: 'val2'})\r\n */\r\nfunction querystringDecode(querystring) {\r\n    var obj = {};\r\n    var tokens = querystring.replace(/^\\?/, '').split('&');\r\n    tokens.forEach(function (token) {\r\n        if (token) {\r\n            var key = token.split('=');\r\n            obj[key[0]] = key[1];\r\n        }\r\n    });\r\n    return obj;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * @fileoverview SHA-1 cryptographic hash.\r\n * Variable names follow the notation in FIPS PUB 180-3:\r\n * http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf.\r\n *\r\n * Usage:\r\n *   var sha1 = new sha1();\r\n *   sha1.update(bytes);\r\n *   var hash = sha1.digest();\r\n *\r\n * Performance:\r\n *   Chrome 23:   ~400 Mbit/s\r\n *   Firefox 16:  ~250 Mbit/s\r\n *\r\n */\r\n/**\r\n * SHA-1 cryptographic hash constructor.\r\n *\r\n * The properties declared here are discussed in the above algorithm document.\r\n * @constructor\r\n * @final\r\n * @struct\r\n */\r\nvar Sha1 = /** @class */ (function () {\r\n    function Sha1() {\r\n        /**\r\n         * Holds the previous values of accumulated variables a-e in the compress_\r\n         * function.\r\n         * @private\r\n         */\r\n        this.chain_ = [];\r\n        /**\r\n         * A buffer holding the partially computed hash result.\r\n         * @private\r\n         */\r\n        this.buf_ = [];\r\n        /**\r\n         * An array of 80 bytes, each a part of the message to be hashed.  Referred to\r\n         * as the message schedule in the docs.\r\n         * @private\r\n         */\r\n        this.W_ = [];\r\n        /**\r\n         * Contains data needed to pad messages less than 64 bytes.\r\n         * @private\r\n         */\r\n        this.pad_ = [];\r\n        /**\r\n         * @private {number}\r\n         */\r\n        this.inbuf_ = 0;\r\n        /**\r\n         * @private {number}\r\n         */\r\n        this.total_ = 0;\r\n        this.blockSize = 512 / 8;\r\n        this.pad_[0] = 128;\r\n        for (var i = 1; i < this.blockSize; ++i) {\r\n            this.pad_[i] = 0;\r\n        }\r\n        this.reset();\r\n    }\r\n    Sha1.prototype.reset = function () {\r\n        this.chain_[0] = 0x67452301;\r\n        this.chain_[1] = 0xefcdab89;\r\n        this.chain_[2] = 0x98badcfe;\r\n        this.chain_[3] = 0x10325476;\r\n        this.chain_[4] = 0xc3d2e1f0;\r\n        this.inbuf_ = 0;\r\n        this.total_ = 0;\r\n    };\r\n    /**\r\n     * Internal compress helper function.\r\n     * @param buf Block to compress.\r\n     * @param offset Offset of the block in the buffer.\r\n     * @private\r\n     */\r\n    Sha1.prototype.compress_ = function (buf, offset) {\r\n        if (!offset) {\r\n            offset = 0;\r\n        }\r\n        var W = this.W_;\r\n        // get 16 big endian words\r\n        if (typeof buf === 'string') {\r\n            for (var i = 0; i < 16; i++) {\r\n                // TODO(user): [bug 8140122] Recent versions of Safari for Mac OS and iOS\r\n                // have a bug that turns the post-increment ++ operator into pre-increment\r\n                // during JIT compilation.  We have code that depends heavily on SHA-1 for\r\n                // correctness and which is affected by this bug, so I've removed all uses\r\n                // of post-increment ++ in which the result value is used.  We can revert\r\n                // this change once the Safari bug\r\n                // (https://bugs.webkit.org/show_bug.cgi?id=109036) has been fixed and\r\n                // most clients have been updated.\r\n                W[i] =\r\n                    (buf.charCodeAt(offset) << 24) |\r\n                        (buf.charCodeAt(offset + 1) << 16) |\r\n                        (buf.charCodeAt(offset + 2) << 8) |\r\n                        buf.charCodeAt(offset + 3);\r\n                offset += 4;\r\n            }\r\n        }\r\n        else {\r\n            for (var i = 0; i < 16; i++) {\r\n                W[i] =\r\n                    (buf[offset] << 24) |\r\n                        (buf[offset + 1] << 16) |\r\n                        (buf[offset + 2] << 8) |\r\n                        buf[offset + 3];\r\n                offset += 4;\r\n            }\r\n        }\r\n        // expand to 80 words\r\n        for (var i = 16; i < 80; i++) {\r\n            var t = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];\r\n            W[i] = ((t << 1) | (t >>> 31)) & 0xffffffff;\r\n        }\r\n        var a = this.chain_[0];\r\n        var b = this.chain_[1];\r\n        var c = this.chain_[2];\r\n        var d = this.chain_[3];\r\n        var e = this.chain_[4];\r\n        var f, k;\r\n        // TODO(user): Try to unroll this loop to speed up the computation.\r\n        for (var i = 0; i < 80; i++) {\r\n            if (i < 40) {\r\n                if (i < 20) {\r\n                    f = d ^ (b & (c ^ d));\r\n                    k = 0x5a827999;\r\n                }\r\n                else {\r\n                    f = b ^ c ^ d;\r\n                    k = 0x6ed9eba1;\r\n                }\r\n            }\r\n            else {\r\n                if (i < 60) {\r\n                    f = (b & c) | (d & (b | c));\r\n                    k = 0x8f1bbcdc;\r\n                }\r\n                else {\r\n                    f = b ^ c ^ d;\r\n                    k = 0xca62c1d6;\r\n                }\r\n            }\r\n            var t = (((a << 5) | (a >>> 27)) + f + e + k + W[i]) & 0xffffffff;\r\n            e = d;\r\n            d = c;\r\n            c = ((b << 30) | (b >>> 2)) & 0xffffffff;\r\n            b = a;\r\n            a = t;\r\n        }\r\n        this.chain_[0] = (this.chain_[0] + a) & 0xffffffff;\r\n        this.chain_[1] = (this.chain_[1] + b) & 0xffffffff;\r\n        this.chain_[2] = (this.chain_[2] + c) & 0xffffffff;\r\n        this.chain_[3] = (this.chain_[3] + d) & 0xffffffff;\r\n        this.chain_[4] = (this.chain_[4] + e) & 0xffffffff;\r\n    };\r\n    Sha1.prototype.update = function (bytes, length) {\r\n        // TODO(johnlenz): tighten the function signature and remove this check\r\n        if (bytes == null) {\r\n            return;\r\n        }\r\n        if (length === undefined) {\r\n            length = bytes.length;\r\n        }\r\n        var lengthMinusBlock = length - this.blockSize;\r\n        var n = 0;\r\n        // Using local instead of member variables gives ~5% speedup on Firefox 16.\r\n        var buf = this.buf_;\r\n        var inbuf = this.inbuf_;\r\n        // The outer while loop should execute at most twice.\r\n        while (n < length) {\r\n            // When we have no data in the block to top up, we can directly process the\r\n            // input buffer (assuming it contains sufficient data). This gives ~25%\r\n            // speedup on Chrome 23 and ~15% speedup on Firefox 16, but requires that\r\n            // the data is provided in large chunks (or in multiples of 64 bytes).\r\n            if (inbuf === 0) {\r\n                while (n <= lengthMinusBlock) {\r\n                    this.compress_(bytes, n);\r\n                    n += this.blockSize;\r\n                }\r\n            }\r\n            if (typeof bytes === 'string') {\r\n                while (n < length) {\r\n                    buf[inbuf] = bytes.charCodeAt(n);\r\n                    ++inbuf;\r\n                    ++n;\r\n                    if (inbuf === this.blockSize) {\r\n                        this.compress_(buf);\r\n                        inbuf = 0;\r\n                        // Jump to the outer loop so we use the full-block optimization.\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                while (n < length) {\r\n                    buf[inbuf] = bytes[n];\r\n                    ++inbuf;\r\n                    ++n;\r\n                    if (inbuf === this.blockSize) {\r\n                        this.compress_(buf);\r\n                        inbuf = 0;\r\n                        // Jump to the outer loop so we use the full-block optimization.\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.inbuf_ = inbuf;\r\n        this.total_ += length;\r\n    };\r\n    /** @override */\r\n    Sha1.prototype.digest = function () {\r\n        var digest = [];\r\n        var totalBits = this.total_ * 8;\r\n        // Add pad 0x80 0x00*.\r\n        if (this.inbuf_ < 56) {\r\n            this.update(this.pad_, 56 - this.inbuf_);\r\n        }\r\n        else {\r\n            this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));\r\n        }\r\n        // Add # bits.\r\n        for (var i = this.blockSize - 1; i >= 56; i--) {\r\n            this.buf_[i] = totalBits & 255;\r\n            totalBits /= 256; // Don't use bit-shifting here!\r\n        }\r\n        this.compress_(this.buf_);\r\n        var n = 0;\r\n        for (var i = 0; i < 5; i++) {\r\n            for (var j = 24; j >= 0; j -= 8) {\r\n                digest[n] = (this.chain_[i] >> j) & 255;\r\n                ++n;\r\n            }\r\n        }\r\n        return digest;\r\n    };\r\n    return Sha1;\r\n}());\n\n/**\r\n * Helper to make a Subscribe function (just like Promise helps make a\r\n * Thenable).\r\n *\r\n * @param executor Function which can make calls to a single Observer\r\n *     as a proxy.\r\n * @param onNoObservers Callback when count of Observers goes to zero.\r\n */\r\nfunction createSubscribe(executor, onNoObservers) {\r\n    var proxy = new ObserverProxy(executor, onNoObservers);\r\n    return proxy.subscribe.bind(proxy);\r\n}\r\n/**\r\n * Implement fan-out for any number of Observers attached via a subscribe\r\n * function.\r\n */\r\nvar ObserverProxy = /** @class */ (function () {\r\n    /**\r\n     * @param executor Function which can make calls to a single Observer\r\n     *     as a proxy.\r\n     * @param onNoObservers Callback when count of Observers goes to zero.\r\n     */\r\n    function ObserverProxy(executor, onNoObservers) {\r\n        var _this = this;\r\n        this.observers = [];\r\n        this.unsubscribes = [];\r\n        this.observerCount = 0;\r\n        // Micro-task scheduling by calling task.then().\r\n        this.task = Promise.resolve();\r\n        this.finalized = false;\r\n        this.onNoObservers = onNoObservers;\r\n        // Call the executor asynchronously so subscribers that are called\r\n        // synchronously after the creation of the subscribe function\r\n        // can still receive the very first value generated in the executor.\r\n        this.task\r\n            .then(function () {\r\n            executor(_this);\r\n        })\r\n            .catch(function (e) {\r\n            _this.error(e);\r\n        });\r\n    }\r\n    ObserverProxy.prototype.next = function (value) {\r\n        this.forEachObserver(function (observer) {\r\n            observer.next(value);\r\n        });\r\n    };\r\n    ObserverProxy.prototype.error = function (error) {\r\n        this.forEachObserver(function (observer) {\r\n            observer.error(error);\r\n        });\r\n        this.close(error);\r\n    };\r\n    ObserverProxy.prototype.complete = function () {\r\n        this.forEachObserver(function (observer) {\r\n            observer.complete();\r\n        });\r\n        this.close();\r\n    };\r\n    /**\r\n     * Subscribe function that can be used to add an Observer to the fan-out list.\r\n     *\r\n     * - We require that no event is sent to a subscriber sychronously to their\r\n     *   call to subscribe().\r\n     */\r\n    ObserverProxy.prototype.subscribe = function (nextOrObserver, error, complete) {\r\n        var _this = this;\r\n        var observer;\r\n        if (nextOrObserver === undefined &&\r\n            error === undefined &&\r\n            complete === undefined) {\r\n            throw new Error('Missing Observer.');\r\n        }\r\n        // Assemble an Observer object when passed as callback functions.\r\n        if (implementsAnyMethods(nextOrObserver, [\r\n            'next',\r\n            'error',\r\n            'complete'\r\n        ])) {\r\n            observer = nextOrObserver;\r\n        }\r\n        else {\r\n            observer = {\r\n                next: nextOrObserver,\r\n                error: error,\r\n                complete: complete\r\n            };\r\n        }\r\n        if (observer.next === undefined) {\r\n            observer.next = noop;\r\n        }\r\n        if (observer.error === undefined) {\r\n            observer.error = noop;\r\n        }\r\n        if (observer.complete === undefined) {\r\n            observer.complete = noop;\r\n        }\r\n        var unsub = this.unsubscribeOne.bind(this, this.observers.length);\r\n        // Attempt to subscribe to a terminated Observable - we\r\n        // just respond to the Observer with the final error or complete\r\n        // event.\r\n        if (this.finalized) {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n            this.task.then(function () {\r\n                try {\r\n                    if (_this.finalError) {\r\n                        observer.error(_this.finalError);\r\n                    }\r\n                    else {\r\n                        observer.complete();\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    // nothing\r\n                }\r\n                return;\r\n            });\r\n        }\r\n        this.observers.push(observer);\r\n        return unsub;\r\n    };\r\n    // Unsubscribe is synchronous - we guarantee that no events are sent to\r\n    // any unsubscribed Observer.\r\n    ObserverProxy.prototype.unsubscribeOne = function (i) {\r\n        if (this.observers === undefined || this.observers[i] === undefined) {\r\n            return;\r\n        }\r\n        delete this.observers[i];\r\n        this.observerCount -= 1;\r\n        if (this.observerCount === 0 && this.onNoObservers !== undefined) {\r\n            this.onNoObservers(this);\r\n        }\r\n    };\r\n    ObserverProxy.prototype.forEachObserver = function (fn) {\r\n        if (this.finalized) {\r\n            // Already closed by previous event....just eat the additional values.\r\n            return;\r\n        }\r\n        // Since sendOne calls asynchronously - there is no chance that\r\n        // this.observers will become undefined.\r\n        for (var i = 0; i < this.observers.length; i++) {\r\n            this.sendOne(i, fn);\r\n        }\r\n    };\r\n    // Call the Observer via one of it's callback function. We are careful to\r\n    // confirm that the observe has not been unsubscribed since this asynchronous\r\n    // function had been queued.\r\n    ObserverProxy.prototype.sendOne = function (i, fn) {\r\n        var _this = this;\r\n        // Execute the callback asynchronously\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this.task.then(function () {\r\n            if (_this.observers !== undefined && _this.observers[i] !== undefined) {\r\n                try {\r\n                    fn(_this.observers[i]);\r\n                }\r\n                catch (e) {\r\n                    // Ignore exceptions raised in Observers or missing methods of an\r\n                    // Observer.\r\n                    // Log error to console. b/31404806\r\n                    if (typeof console !== 'undefined' && console.error) {\r\n                        console.error(e);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    };\r\n    ObserverProxy.prototype.close = function (err) {\r\n        var _this = this;\r\n        if (this.finalized) {\r\n            return;\r\n        }\r\n        this.finalized = true;\r\n        if (err !== undefined) {\r\n            this.finalError = err;\r\n        }\r\n        // Proxy is no longer needed - garbage collect references\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this.task.then(function () {\r\n            _this.observers = undefined;\r\n            _this.onNoObservers = undefined;\r\n        });\r\n    };\r\n    return ObserverProxy;\r\n}());\r\n/** Turn synchronous function into one called asynchronously. */\r\n// eslint-disable-next-line @typescript-eslint/ban-types\r\nfunction async(fn, onError) {\r\n    return function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        Promise.resolve(true)\r\n            .then(function () {\r\n            fn.apply(void 0, args);\r\n        })\r\n            .catch(function (error) {\r\n            if (onError) {\r\n                onError(error);\r\n            }\r\n        });\r\n    };\r\n}\r\n/**\r\n * Return true if the object passed in implements any of the named methods.\r\n */\r\nfunction implementsAnyMethods(obj, methods) {\r\n    if (typeof obj !== 'object' || obj === null) {\r\n        return false;\r\n    }\r\n    for (var _i = 0, methods_1 = methods; _i < methods_1.length; _i++) {\r\n        var method = methods_1[_i];\r\n        if (method in obj && typeof obj[method] === 'function') {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction noop() {\r\n    // do nothing\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Check to make sure the appropriate number of arguments are provided for a public function.\r\n * Throws an error if it fails.\r\n *\r\n * @param fnName The function name\r\n * @param minCount The minimum number of arguments to allow for the function call\r\n * @param maxCount The maximum number of argument to allow for the function call\r\n * @param argCount The actual number of arguments provided.\r\n */\r\nvar validateArgCount = function (fnName, minCount, maxCount, argCount) {\r\n    var argError;\r\n    if (argCount < minCount) {\r\n        argError = 'at least ' + minCount;\r\n    }\r\n    else if (argCount > maxCount) {\r\n        argError = maxCount === 0 ? 'none' : 'no more than ' + maxCount;\r\n    }\r\n    if (argError) {\r\n        var error = fnName +\r\n            ' failed: Was called with ' +\r\n            argCount +\r\n            (argCount === 1 ? ' argument.' : ' arguments.') +\r\n            ' Expects ' +\r\n            argError +\r\n            '.';\r\n        throw new Error(error);\r\n    }\r\n};\r\n/**\r\n * Generates a string to prefix an error message about failed argument validation\r\n *\r\n * @param fnName The function name\r\n * @param argumentNumber The index of the argument\r\n * @param optional Whether or not the argument is optional\r\n * @return The prefix to add to the error thrown for validation.\r\n */\r\nfunction errorPrefix(fnName, argumentNumber, optional) {\r\n    var argName = '';\r\n    switch (argumentNumber) {\r\n        case 1:\r\n            argName = optional ? 'first' : 'First';\r\n            break;\r\n        case 2:\r\n            argName = optional ? 'second' : 'Second';\r\n            break;\r\n        case 3:\r\n            argName = optional ? 'third' : 'Third';\r\n            break;\r\n        case 4:\r\n            argName = optional ? 'fourth' : 'Fourth';\r\n            break;\r\n        default:\r\n            throw new Error('errorPrefix called with argumentNumber > 4.  Need to update it?');\r\n    }\r\n    var error = fnName + ' failed: ';\r\n    error += argName + ' argument ';\r\n    return error;\r\n}\r\n/**\r\n * @param fnName\r\n * @param argumentNumber\r\n * @param namespace\r\n * @param optional\r\n */\r\nfunction validateNamespace(fnName, argumentNumber, namespace, optional) {\r\n    if (optional && !namespace) {\r\n        return;\r\n    }\r\n    if (typeof namespace !== 'string') {\r\n        //TODO: I should do more validation here. We only allow certain chars in namespaces.\r\n        throw new Error(errorPrefix(fnName, argumentNumber, optional) +\r\n            'must be a valid firebase namespace.');\r\n    }\r\n}\r\nfunction validateCallback(fnName, argumentNumber, \r\n// eslint-disable-next-line @typescript-eslint/ban-types\r\ncallback, optional) {\r\n    if (optional && !callback) {\r\n        return;\r\n    }\r\n    if (typeof callback !== 'function') {\r\n        throw new Error(errorPrefix(fnName, argumentNumber, optional) +\r\n            'must be a valid function.');\r\n    }\r\n}\r\nfunction validateContextObject(fnName, argumentNumber, context, optional) {\r\n    if (optional && !context) {\r\n        return;\r\n    }\r\n    if (typeof context !== 'object' || context === null) {\r\n        throw new Error(errorPrefix(fnName, argumentNumber, optional) +\r\n            'must be a valid context object.');\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// Code originally came from goog.crypt.stringToUtf8ByteArray, but for some reason they\r\n// automatically replaced '\\r\\n' with '\\n', and they didn't handle surrogate pairs,\r\n// so it's been modified.\r\n// Note that not all Unicode characters appear as single characters in JavaScript strings.\r\n// fromCharCode returns the UTF-16 encoding of a character - so some Unicode characters\r\n// use 2 characters in Javascript.  All 4-byte UTF-8 characters begin with a first\r\n// character in the range 0xD800 - 0xDBFF (the first character of a so-called surrogate\r\n// pair).\r\n// See http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.3\r\n/**\r\n * @param {string} str\r\n * @return {Array}\r\n */\r\nvar stringToByteArray$1 = function (str) {\r\n    var out = [];\r\n    var p = 0;\r\n    for (var i = 0; i < str.length; i++) {\r\n        var c = str.charCodeAt(i);\r\n        // Is this the lead surrogate in a surrogate pair?\r\n        if (c >= 0xd800 && c <= 0xdbff) {\r\n            var high = c - 0xd800; // the high 10 bits.\r\n            i++;\r\n            assert(i < str.length, 'Surrogate pair missing trail surrogate.');\r\n            var low = str.charCodeAt(i) - 0xdc00; // the low 10 bits.\r\n            c = 0x10000 + (high << 10) + low;\r\n        }\r\n        if (c < 128) {\r\n            out[p++] = c;\r\n        }\r\n        else if (c < 2048) {\r\n            out[p++] = (c >> 6) | 192;\r\n            out[p++] = (c & 63) | 128;\r\n        }\r\n        else if (c < 65536) {\r\n            out[p++] = (c >> 12) | 224;\r\n            out[p++] = ((c >> 6) & 63) | 128;\r\n            out[p++] = (c & 63) | 128;\r\n        }\r\n        else {\r\n            out[p++] = (c >> 18) | 240;\r\n            out[p++] = ((c >> 12) & 63) | 128;\r\n            out[p++] = ((c >> 6) & 63) | 128;\r\n            out[p++] = (c & 63) | 128;\r\n        }\r\n    }\r\n    return out;\r\n};\r\n/**\r\n * Calculate length without actually converting; useful for doing cheaper validation.\r\n * @param {string} str\r\n * @return {number}\r\n */\r\nvar stringLength = function (str) {\r\n    var p = 0;\r\n    for (var i = 0; i < str.length; i++) {\r\n        var c = str.charCodeAt(i);\r\n        if (c < 128) {\r\n            p++;\r\n        }\r\n        else if (c < 2048) {\r\n            p += 2;\r\n        }\r\n        else if (c >= 0xd800 && c <= 0xdbff) {\r\n            // Lead surrogate of a surrogate pair.  The pair together will take 4 bytes to represent.\r\n            p += 4;\r\n            i++; // skip trail surrogate.\r\n        }\r\n        else {\r\n            p += 3;\r\n        }\r\n    }\r\n    return p;\r\n};\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * The amount of milliseconds to exponentially increase.\r\n */\r\nvar DEFAULT_INTERVAL_MILLIS = 1000;\r\n/**\r\n * The factor to backoff by.\r\n * Should be a number greater than 1.\r\n */\r\nvar DEFAULT_BACKOFF_FACTOR = 2;\r\n/**\r\n * The maximum milliseconds to increase to.\r\n *\r\n * <p>Visible for testing\r\n */\r\nvar MAX_VALUE_MILLIS = 4 * 60 * 60 * 1000; // Four hours, like iOS and Android.\r\n/**\r\n * The percentage of backoff time to randomize by.\r\n * See\r\n * http://go/safe-client-behavior#step-1-determine-the-appropriate-retry-interval-to-handle-spike-traffic\r\n * for context.\r\n *\r\n * <p>Visible for testing\r\n */\r\nvar RANDOM_FACTOR = 0.5;\r\n/**\r\n * Based on the backoff method from\r\n * https://github.com/google/closure-library/blob/master/closure/goog/math/exponentialbackoff.js.\r\n * Extracted here so we don't need to pass metadata and a stateful ExponentialBackoff object around.\r\n */\r\nfunction calculateBackoffMillis(backoffCount, intervalMillis, backoffFactor) {\r\n    if (intervalMillis === void 0) { intervalMillis = DEFAULT_INTERVAL_MILLIS; }\r\n    if (backoffFactor === void 0) { backoffFactor = DEFAULT_BACKOFF_FACTOR; }\r\n    // Calculates an exponentially increasing value.\r\n    // Deviation: calculates value from count and a constant interval, so we only need to save value\r\n    // and count to restore state.\r\n    var currBaseValue = intervalMillis * Math.pow(backoffFactor, backoffCount);\r\n    // A random \"fuzz\" to avoid waves of retries.\r\n    // Deviation: randomFactor is required.\r\n    var randomWait = Math.round(\r\n    // A fraction of the backoff value to add/subtract.\r\n    // Deviation: changes multiplication order to improve readability.\r\n    RANDOM_FACTOR *\r\n        currBaseValue *\r\n        // A random float (rounded to int by Math.round above) in the range [-1, 1]. Determines\r\n        // if we add or subtract.\r\n        (Math.random() - 0.5) *\r\n        2);\r\n    // Limits backoff to max to avoid effectively permanent backoff.\r\n    return Math.min(MAX_VALUE_MILLIS, currBaseValue + randomWait);\r\n}\n\n\n//# sourceMappingURL=index.esm.js.map\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@firebase/util/dist/index.esm.js?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/common/build/src/index.js":
/*!******************************************************************!*\
  !*** ./src/node_modules/@google-cloud/common/build/src/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * @type {module:common/operation}\n * @private\n */\nvar operation_1 = __webpack_require__(/*! ./operation */ \"./src/node_modules/@google-cloud/common/build/src/operation.js\");\nexports.Operation = operation_1.Operation;\n/**\n * @type {module:common/service}\n * @private\n */\nvar service_1 = __webpack_require__(/*! ./service */ \"./src/node_modules/@google-cloud/common/build/src/service.js\");\nexports.Service = service_1.Service;\n/**\n * @type {module:common/serviceObject}\n * @private\n */\nvar service_object_1 = __webpack_require__(/*! ./service-object */ \"./src/node_modules/@google-cloud/common/build/src/service-object.js\");\nexports.ServiceObject = service_object_1.ServiceObject;\n/**\n * @type {module:common/util}\n * @private\n */\nvar util_1 = __webpack_require__(/*! ./util */ \"./src/node_modules/@google-cloud/common/build/src/util.js\");\nexports.ApiError = util_1.ApiError;\nexports.util = util_1.util;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/common/build/src/index.js?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/common/build/src/operation.js":
/*!**********************************************************************!*\
  !*** ./src/node_modules/@google-cloud/common/build/src/operation.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*!\n * @module common/operation\n */\nconst service_object_1 = __webpack_require__(/*! ./service-object */ \"./src/node_modules/@google-cloud/common/build/src/service-object.js\");\nconst util_1 = __webpack_require__(/*! util */ \"util\");\n// tslint:disable-next-line no-any\nclass Operation extends service_object_1.ServiceObject {\n    /**\n     * An Operation object allows you to interact with APIs that take longer to\n     * process things.\n     *\n     * @constructor\n     * @alias module:common/operation\n     *\n     * @param {object} config - Configuration object.\n     * @param {module:common/service|module:common/serviceObject|module:common/grpcService|module:common/grpcServiceObject} config.parent - The parent object.\n     */\n    constructor(config) {\n        const methods = {\n            /**\n             * Checks to see if an operation exists.\n             */\n            exists: true,\n            /**\n             * Retrieves the operation.\n             */\n            get: true,\n            /**\n             * Retrieves metadata for the operation.\n             */\n            getMetadata: {\n                reqOpts: {\n                    name: config.id,\n                },\n            },\n        };\n        config = Object.assign({\n            baseUrl: '',\n        }, config);\n        // tslint:disable-next-line:no-any\n        config.methods = (config.methods || methods);\n        super(config);\n        this.completeListeners = 0;\n        this.hasActiveListeners = false;\n        this.listenForEvents_();\n    }\n    /**\n     * Wraps the `complete` and `error` events in a Promise.\n     *\n     * @return {promise}\n     */\n    promise() {\n        return new this.Promise((resolve, reject) => {\n            this.on('error', reject).on('complete', (metadata) => {\n                resolve([metadata]);\n            });\n        });\n    }\n    /**\n     * Begin listening for events on the operation. This method keeps track of how\n     * many \"complete\" listeners are registered and removed, making sure polling\n     * is handled automatically.\n     *\n     * As long as there is one active \"complete\" listener, the connection is open.\n     * When there are no more listeners, the polling stops.\n     *\n     * @private\n     */\n    listenForEvents_() {\n        this.on('newListener', (event) => {\n            if (event === 'complete') {\n                this.completeListeners++;\n                if (!this.hasActiveListeners) {\n                    this.hasActiveListeners = true;\n                    this.startPolling_();\n                }\n            }\n        });\n        this.on('removeListener', (event) => {\n            if (event === 'complete' && --this.completeListeners === 0) {\n                this.hasActiveListeners = false;\n            }\n        });\n    }\n    /**\n     * Poll for a status update. Returns null for an incomplete\n     * status, and metadata for a complete status.\n     *\n     * @private\n     */\n    poll_(callback) {\n        this.getMetadata((err, body) => {\n            if (err || body.error) {\n                callback(err || body.error);\n                return;\n            }\n            if (!body.done) {\n                callback(null);\n                return;\n            }\n            callback(null, body);\n        });\n    }\n    /**\n     * Poll `getMetadata` to check the operation's status. This runs a loop to\n     * ping the API on an interval.\n     *\n     * Note: This method is automatically called once a \"complete\" event handler\n     * is registered on the operation.\n     *\n     * @private\n     */\n    async startPolling_() {\n        if (!this.hasActiveListeners) {\n            return;\n        }\n        try {\n            const metadata = await util_1.promisify(this.poll_.bind(this))();\n            if (!metadata) {\n                setTimeout(this.startPolling_.bind(this), this.pollIntervalMs || 500);\n                return;\n            }\n            this.emit('complete', metadata);\n        }\n        catch (err) {\n            this.emit('error', err);\n        }\n    }\n}\nexports.Operation = Operation;\n//# sourceMappingURL=operation.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/common/build/src/operation.js?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/common/build/src/service-object.js":
/*!***************************************************************************!*\
  !*** ./src/node_modules/@google-cloud/common/build/src/service-object.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*!\n * @module common/service-object\n */\nconst promisify_1 = __webpack_require__(/*! @google-cloud/promisify */ \"@google-cloud/promisify\");\nconst arrify = __webpack_require__(/*! arrify */ \"arrify\");\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst extend = __webpack_require__(/*! extend */ \"extend\");\nconst util_1 = __webpack_require__(/*! ./util */ \"./src/node_modules/@google-cloud/common/build/src/util.js\");\n/**\n * ServiceObject is a base class, meant to be inherited from by a \"service\n * object,\" like a BigQuery dataset or Storage bucket.\n *\n * Most of the time, these objects share common functionality; they can be\n * created or deleted, and you can get or set their metadata.\n *\n * By inheriting from this class, a service object will be extended with these\n * shared behaviors. Note that any method can be overridden when the service\n * object requires specific behavior.\n */\n// tslint:disable-next-line no-any\nclass ServiceObject extends events_1.EventEmitter {\n    /*\n     * @constructor\n     * @alias module:common/service-object\n     *\n     * @private\n     *\n     * @param {object} config - Configuration object.\n     * @param {string} config.baseUrl - The base URL to make API requests to.\n     * @param {string} config.createMethod - The method which creates this object.\n     * @param {string=} config.id - The identifier of the object. For example, the\n     *     name of a Storage bucket or Pub/Sub topic.\n     * @param {object=} config.methods - A map of each method name that should be inherited.\n     * @param {object} config.methods[].reqOpts - Default request options for this\n     *     particular method. A common use case is when `setMetadata` requires a\n     *     `PUT` method to override the default `PATCH`.\n     * @param {object} config.parent - The parent service instance. For example, an\n     *     instance of Storage if the object is Bucket.\n     */\n    constructor(config) {\n        super();\n        this.metadata = {};\n        this.baseUrl = config.baseUrl;\n        this.parent = config.parent; // Parent class.\n        this.id = config.id; // Name or ID (e.g. dataset ID, bucket name, etc).\n        this.createMethod = config.createMethod;\n        this.methods = config.methods || {};\n        this.interceptors = [];\n        this.pollIntervalMs = config.pollIntervalMs;\n        this.Promise = this.parent ? this.parent.Promise : undefined;\n        if (config.methods) {\n            Object.getOwnPropertyNames(ServiceObject.prototype)\n                .filter(methodName => {\n                return (\n                // All ServiceObjects need `request`.\n                // clang-format off\n                !/^request/.test(methodName) &&\n                    // clang-format on\n                    // The ServiceObject didn't redefine the method.\n                    // tslint:disable-next-line no-any\n                    this[methodName] ===\n                        // tslint:disable-next-line no-any\n                        ServiceObject.prototype[methodName] &&\n                    // This method isn't wanted.\n                    !config.methods[methodName]);\n            })\n                .forEach(methodName => {\n                // tslint:disable-next-line no-any\n                this[methodName] = undefined;\n            });\n        }\n    }\n    create(optionsOrCallback, callback) {\n        const self = this;\n        const args = [this.id];\n        if (typeof optionsOrCallback === 'function') {\n            callback = optionsOrCallback;\n        }\n        if (typeof optionsOrCallback === 'object') {\n            args.push(optionsOrCallback);\n        }\n        // Wrap the callback to return *this* instance of the object, not the\n        // newly-created one.\n        // tslint: disable-next-line no-any\n        function onCreate(...args) {\n            const [err, instance] = args;\n            if (!err) {\n                self.metadata = instance.metadata;\n                args[1] = self; // replace the created `instance` with this one.\n            }\n            callback(...args);\n        }\n        args.push(onCreate);\n        this.createMethod.apply(null, args);\n    }\n    delete(optionsOrCallback, cb) {\n        const [options, callback] = util_1.util.maybeOptionsOrCallback(optionsOrCallback, cb);\n        const methodConfig = (typeof this.methods.delete === 'object' && this.methods.delete) || {};\n        const reqOpts = extend(true, {\n            method: 'DELETE',\n            uri: '',\n        }, methodConfig.reqOpts, {\n            qs: options,\n        });\n        // The `request` method may have been overridden to hold any special\n        // behavior. Ensure we call the original `request` method.\n        ServiceObject.prototype.request.call(this, reqOpts, callback);\n    }\n    exists(optionsOrCallback, cb) {\n        const [options, callback] = util_1.util.maybeOptionsOrCallback(optionsOrCallback, cb);\n        this.get(options, err => {\n            if (err) {\n                if (err.code === 404) {\n                    callback(null, false);\n                }\n                else {\n                    callback(err);\n                }\n                return;\n            }\n            callback(null, true);\n        });\n    }\n    get(optionsOrCallback, cb) {\n        const self = this;\n        const [opts, callback] = util_1.util.maybeOptionsOrCallback(optionsOrCallback, cb);\n        const options = Object.assign({}, opts);\n        const autoCreate = options.autoCreate && typeof this.create === 'function';\n        delete options.autoCreate;\n        function onCreate(err, instance, apiResponse) {\n            if (err) {\n                if (err.code === 409) {\n                    self.get(options, callback);\n                    return;\n                }\n                callback(err, null, apiResponse);\n                return;\n            }\n            callback(null, instance, apiResponse);\n        }\n        this.getMetadata(options, (err, metadata) => {\n            if (err) {\n                if (err.code === 404 && autoCreate) {\n                    const args = [];\n                    if (Object.keys(options).length > 0) {\n                        args.push(options);\n                    }\n                    args.push(onCreate);\n                    self.create(...args);\n                    return;\n                }\n                callback(err, null, metadata);\n                return;\n            }\n            callback(null, self, metadata);\n        });\n    }\n    getMetadata(optionsOrCallback, cb) {\n        const [options, callback] = util_1.util.maybeOptionsOrCallback(optionsOrCallback, cb);\n        const methodConfig = (typeof this.methods.getMetadata === 'object' &&\n            this.methods.getMetadata) ||\n            {};\n        const reqOpts = extend(true, {\n            uri: '',\n        }, methodConfig.reqOpts, {\n            qs: options,\n        });\n        // The `request` method may have been overridden to hold any special\n        // behavior. Ensure we call the original `request` method.\n        ServiceObject.prototype.request.call(this, reqOpts, (err, body, res) => {\n            this.metadata = body;\n            callback(err, this.metadata, res);\n        });\n    }\n    setMetadata(metadata, optionsOrCallback, cb) {\n        const [options, callback] = util_1.util.maybeOptionsOrCallback(optionsOrCallback, cb);\n        const methodConfig = (typeof this.methods.setMetadata === 'object' &&\n            this.methods.setMetadata) ||\n            {};\n        const reqOpts = extend(true, {}, {\n            method: 'PATCH',\n            uri: '',\n        }, methodConfig.reqOpts, {\n            json: metadata,\n            qs: options,\n        });\n        // The `request` method may have been overridden to hold any special\n        // behavior. Ensure we call the original `request` method.\n        ServiceObject.prototype.request.call(this, reqOpts, (err, body, res) => {\n            this.metadata = body;\n            callback(err, this.metadata, res);\n        });\n    }\n    request_(reqOpts, callback) {\n        reqOpts = extend(true, {}, reqOpts);\n        const isAbsoluteUrl = reqOpts.uri.indexOf('http') === 0;\n        const uriComponents = [this.baseUrl, this.id || '', reqOpts.uri];\n        if (isAbsoluteUrl) {\n            uriComponents.splice(0, uriComponents.indexOf(reqOpts.uri));\n        }\n        reqOpts.uri = uriComponents\n            .filter(x => x.trim()) // Limit to non-empty strings.\n            .map(uriComponent => {\n            const trimSlashesRegex = /^\\/*|\\/*$/g;\n            return uriComponent.replace(trimSlashesRegex, '');\n        })\n            .join('/');\n        const childInterceptors = arrify(reqOpts.interceptors_);\n        const localInterceptors = [].slice.call(this.interceptors);\n        reqOpts.interceptors_ = childInterceptors.concat(localInterceptors);\n        if (reqOpts.shouldReturnStream) {\n            return this.parent.requestStream(reqOpts);\n        }\n        this.parent.request(reqOpts, callback);\n    }\n    request(reqOpts, callback) {\n        this.request_(reqOpts, callback);\n    }\n    /**\n     * Make an authenticated API request.\n     *\n     * @param {object} reqOpts - Request options that are passed to `request`.\n     * @param {string} reqOpts.uri - A URI relative to the baseUrl.\n     */\n    requestStream(reqOpts) {\n        const opts = extend(true, reqOpts, { shouldReturnStream: true });\n        return this.request_(opts);\n    }\n}\nexports.ServiceObject = ServiceObject;\npromisify_1.promisifyAll(ServiceObject);\n//# sourceMappingURL=service-object.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/common/build/src/service-object.js?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/common/build/src/service.js":
/*!********************************************************************!*\
  !*** ./src/node_modules/@google-cloud/common/build/src/service.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*!\n * @module common/service\n */\nconst arrify = __webpack_require__(/*! arrify */ \"arrify\");\nconst extend = __webpack_require__(/*! extend */ \"extend\");\nconst util_1 = __webpack_require__(/*! ./util */ \"./src/node_modules/@google-cloud/common/build/src/util.js\");\nconst PROJECT_ID_TOKEN = '{{projectId}}';\nclass Service {\n    /**\n     * Service is a base class, meant to be inherited from by a \"service,\" like\n     * BigQuery or Storage.\n     *\n     * This handles making authenticated requests by exposing a `makeReq_`\n     * function.\n     *\n     * @constructor\n     * @alias module:common/service\n     *\n     * @param {object} config - Configuration object.\n     * @param {string} config.baseUrl - The base URL to make API requests to.\n     * @param {string[]} config.scopes - The scopes required for the request.\n     * @param {object=} options - [Configuration object](#/docs).\n     */\n    constructor(config, options = {}) {\n        this.baseUrl = config.baseUrl;\n        this.apiEndpoint = config.apiEndpoint;\n        this.timeout = options.timeout;\n        this.globalInterceptors = arrify(options.interceptors_);\n        this.interceptors = [];\n        this.packageJson = config.packageJson;\n        this.projectId = options.projectId || PROJECT_ID_TOKEN;\n        this.projectIdRequired = config.projectIdRequired !== false;\n        this.Promise = options.promise || Promise;\n        const reqCfg = extend({}, config, {\n            projectIdRequired: this.projectIdRequired,\n            projectId: this.projectId,\n            credentials: options.credentials,\n            keyFile: options.keyFilename,\n            email: options.email,\n            token: options.token,\n        });\n        this.makeAuthenticatedRequest = util_1.util.makeAuthenticatedRequestFactory(reqCfg);\n        this.authClient = this.makeAuthenticatedRequest.authClient;\n        this.getCredentials = this.makeAuthenticatedRequest.getCredentials;\n        const isCloudFunctionEnv = !!process.env.FUNCTION_NAME;\n        if (isCloudFunctionEnv) {\n            this.interceptors.push({\n                request(reqOpts) {\n                    reqOpts.forever = false;\n                    return reqOpts;\n                },\n            });\n        }\n    }\n    getProjectId(callback) {\n        if (!callback) {\n            return this.getProjectIdAsync();\n        }\n        this.getProjectIdAsync().then(p => callback(null, p), callback);\n    }\n    async getProjectIdAsync() {\n        const projectId = await this.authClient.getProjectId();\n        if (this.projectId === PROJECT_ID_TOKEN && projectId) {\n            this.projectId = projectId;\n        }\n        return this.projectId;\n    }\n    request_(reqOpts, callback) {\n        reqOpts = extend(true, {}, reqOpts, { timeout: this.timeout });\n        const isAbsoluteUrl = reqOpts.uri.indexOf('http') === 0;\n        const uriComponents = [this.baseUrl];\n        if (this.projectIdRequired) {\n            uriComponents.push('projects');\n            uriComponents.push(this.projectId);\n        }\n        uriComponents.push(reqOpts.uri);\n        if (isAbsoluteUrl) {\n            uriComponents.splice(0, uriComponents.indexOf(reqOpts.uri));\n        }\n        reqOpts.uri = uriComponents\n            .map(uriComponent => {\n            const trimSlashesRegex = /^\\/*|\\/*$/g;\n            return uriComponent.replace(trimSlashesRegex, '');\n        })\n            .join('/')\n            // Some URIs have colon separators.\n            // Bad: https://.../projects/:list\n            // Good: https://.../projects:list\n            .replace(/\\/:/g, ':');\n        // Interceptors should be called in the order they were assigned.\n        const combinedInterceptors = [].slice\n            .call(this.globalInterceptors)\n            .concat(this.interceptors)\n            .concat(arrify(reqOpts.interceptors_));\n        let interceptor;\n        while (\n        // tslint:disable-next-line:no-conditional-assignment\n        (interceptor = combinedInterceptors.shift()) &&\n            interceptor.request) {\n            reqOpts = interceptor.request(reqOpts);\n        }\n        delete reqOpts.interceptors_;\n        const pkg = this.packageJson;\n        reqOpts.headers = extend({}, reqOpts.headers, {\n            'User-Agent': util_1.util.getUserAgentFromPackageJson(pkg),\n            'x-goog-api-client': `gl-node/${process.versions.node} gccl/${pkg.version}`,\n        });\n        if (reqOpts.shouldReturnStream) {\n            return this.makeAuthenticatedRequest(reqOpts);\n        }\n        else {\n            this.makeAuthenticatedRequest(reqOpts, callback);\n        }\n    }\n    /**\n     * Make an authenticated API request.\n     *\n     * @param {object} reqOpts - Request options that are passed to `request`.\n     * @param {string} reqOpts.uri - A URI relative to the baseUrl.\n     * @param {function} callback - The callback function passed to `request`.\n     */\n    request(reqOpts, callback) {\n        Service.prototype.request_.call(this, reqOpts, callback);\n    }\n    /**\n     * Make an authenticated API request.\n     *\n     * @param {object} reqOpts - Request options that are passed to `request`.\n     * @param {string} reqOpts.uri - A URI relative to the baseUrl.\n     */\n    requestStream(reqOpts) {\n        const opts = extend(true, reqOpts, { shouldReturnStream: true });\n        return Service.prototype.request_.call(this, opts);\n    }\n}\nexports.Service = Service;\n//# sourceMappingURL=service.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/common/build/src/service.js?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/common/build/src/util.js":
/*!*****************************************************************!*\
  !*** ./src/node_modules/@google-cloud/common/build/src/util.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// Copyright 2014 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*!\n * @module common/util\n */\nconst projectify_1 = __webpack_require__(/*! @google-cloud/projectify */ \"@google-cloud/projectify\");\nconst ent = __webpack_require__(/*! ent */ \"./src/node_modules/ent/index.js\");\nconst extend = __webpack_require__(/*! extend */ \"extend\");\nconst google_auth_library_1 = __webpack_require__(/*! google-auth-library */ \"google-auth-library\");\nconst retryRequest = __webpack_require__(/*! retry-request */ \"retry-request\");\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst teeny_request_1 = __webpack_require__(/*! teeny-request */ \"./src/node_modules/teeny-request/build/src/index.js\");\nconst duplexify = __webpack_require__(/*! duplexify */ \"duplexify\");\nconst requestDefaults = {\n    timeout: 60000,\n    gzip: true,\n    forever: true,\n    pool: {\n        maxSockets: Infinity,\n    },\n};\n/**\n * Custom error type for API errors.\n *\n * @param {object} errorBody - Error object.\n */\nclass ApiError extends Error {\n    constructor(errorBodyOrMessage) {\n        super();\n        if (typeof errorBodyOrMessage !== 'object') {\n            this.message = errorBodyOrMessage || '';\n            return;\n        }\n        const errorBody = errorBodyOrMessage;\n        this.code = errorBody.code;\n        this.errors = errorBody.errors;\n        this.response = errorBody.response;\n        try {\n            this.errors = JSON.parse(this.response.body).error.errors;\n        }\n        catch (e) {\n            this.errors = errorBody.errors;\n        }\n        this.message = ApiError.createMultiErrorMessage(errorBody, this.errors);\n        Error.captureStackTrace(this);\n    }\n    /**\n     * Pieces together an error message by combining all unique error messages\n     * returned from a single GoogleError\n     *\n     * @private\n     *\n     * @param {GoogleErrorBody} err The original error.\n     * @param {GoogleInnerError[]} [errors] Inner errors, if any.\n     * @returns {string}\n     */\n    static createMultiErrorMessage(err, errors) {\n        const messages = new Set();\n        if (err.message) {\n            messages.add(err.message);\n        }\n        if (errors && errors.length) {\n            errors.forEach(({ message }) => messages.add(message));\n        }\n        else if (err.response && err.response.body) {\n            messages.add(ent.decode(err.response.body.toString()));\n        }\n        else if (!err.message) {\n            messages.add('A failure occurred during this request.');\n        }\n        let messageArr = Array.from(messages);\n        if (messageArr.length > 1) {\n            messageArr = messageArr.map((message, i) => `    ${i + 1}. ${message}`);\n            messageArr.unshift('Multiple errors occurred during the request. Please see the `errors` array for complete details.\\n');\n            messageArr.push('\\n');\n        }\n        return messageArr.join('\\n');\n    }\n}\nexports.ApiError = ApiError;\n/**\n * Custom error type for partial errors returned from the API.\n *\n * @param {object} b - Error object.\n */\nclass PartialFailureError extends Error {\n    constructor(b) {\n        super();\n        const errorObject = b;\n        this.errors = errorObject.errors;\n        this.name = 'PartialFailureError';\n        this.response = errorObject.response;\n        this.message = ApiError.createMultiErrorMessage(errorObject, this.errors);\n    }\n}\nexports.PartialFailureError = PartialFailureError;\nclass Util {\n    constructor() {\n        this.ApiError = ApiError;\n        this.PartialFailureError = PartialFailureError;\n    }\n    /**\n     * No op.\n     *\n     * @example\n     * function doSomething(callback) {\n     *   callback = callback || noop;\n     * }\n     */\n    noop() { }\n    /**\n     * Uniformly process an API response.\n     *\n     * @param {*} err - Error value.\n     * @param {*} resp - Response value.\n     * @param {*} body - Body value.\n     * @param {function} callback - The callback function.\n     */\n    handleResp(err, resp, body, callback) {\n        callback = callback || util.noop;\n        const parsedResp = extend(true, { err: err || null }, resp && util.parseHttpRespMessage(resp), body && util.parseHttpRespBody(body));\n        // Assign the parsed body to resp.body, even if { json: false } was passed\n        // as a request option.\n        // We assume that nobody uses the previously unparsed value of resp.body.\n        if (!parsedResp.err && resp && typeof parsedResp.body === 'object') {\n            parsedResp.resp.body = parsedResp.body;\n        }\n        if (parsedResp.err && resp) {\n            parsedResp.err.response = resp;\n        }\n        callback(parsedResp.err, parsedResp.body, parsedResp.resp);\n    }\n    /**\n     * Sniff an incoming HTTP response message for errors.\n     *\n     * @param {object} httpRespMessage - An incoming HTTP response message from `request`.\n     * @return {object} parsedHttpRespMessage - The parsed response.\n     * @param {?error} parsedHttpRespMessage.err - An error detected.\n     * @param {object} parsedHttpRespMessage.resp - The original response object.\n     */\n    parseHttpRespMessage(httpRespMessage) {\n        const parsedHttpRespMessage = {\n            resp: httpRespMessage,\n        };\n        if (httpRespMessage.statusCode < 200 || httpRespMessage.statusCode > 299) {\n            // Unknown error. Format according to ApiError standard.\n            parsedHttpRespMessage.err = new ApiError({\n                errors: new Array(),\n                code: httpRespMessage.statusCode,\n                message: httpRespMessage.statusMessage,\n                response: httpRespMessage,\n            });\n        }\n        return parsedHttpRespMessage;\n    }\n    /**\n     * Parse the response body from an HTTP request.\n     *\n     * @param {object} body - The response body.\n     * @return {object} parsedHttpRespMessage - The parsed response.\n     * @param {?error} parsedHttpRespMessage.err - An error detected.\n     * @param {object} parsedHttpRespMessage.body - The original body value provided\n     *     will try to be JSON.parse'd. If it's successful, the parsed value will\n     * be returned here, otherwise the original value and an error will be returned.\n     */\n    parseHttpRespBody(body) {\n        const parsedHttpRespBody = {\n            body,\n        };\n        if (typeof body === 'string') {\n            try {\n                parsedHttpRespBody.body = JSON.parse(body);\n            }\n            catch (err) {\n                parsedHttpRespBody.err = new ApiError(`Cannot parse response as JSON: ${body}`);\n            }\n        }\n        if (parsedHttpRespBody.body && parsedHttpRespBody.body.error) {\n            // Error from JSON API.\n            parsedHttpRespBody.err = new ApiError(parsedHttpRespBody.body.error);\n        }\n        return parsedHttpRespBody;\n    }\n    /**\n     * Take a Duplexify stream, fetch an authenticated connection header, and\n     * create an outgoing writable stream.\n     *\n     * @param {Duplexify} dup - Duplexify stream.\n     * @param {object} options - Configuration object.\n     * @param {module:common/connection} options.connection - A connection instance used to get a token with and send the request through.\n     * @param {object} options.metadata - Metadata to send at the head of the request.\n     * @param {object} options.request - Request object, in the format of a standard Node.js http.request() object.\n     * @param {string=} options.request.method - Default: \"POST\".\n     * @param {string=} options.request.qs.uploadType - Default: \"multipart\".\n     * @param {string=} options.streamContentType - Default: \"application/octet-stream\".\n     * @param {function} onComplete - Callback, executed after the writable Request stream has completed.\n     */\n    makeWritableStream(dup, options, onComplete) {\n        onComplete = onComplete || util.noop;\n        const writeStream = new stream_1.PassThrough();\n        dup.setWritable(writeStream);\n        const defaultReqOpts = {\n            method: 'POST',\n            qs: {\n                uploadType: 'multipart',\n            },\n            timeout: 0,\n            maxRetries: 0,\n        };\n        const metadata = options.metadata || {};\n        const reqOpts = extend(true, defaultReqOpts, options.request, {\n            multipart: [\n                {\n                    'Content-Type': 'application/json',\n                    body: JSON.stringify(metadata),\n                },\n                {\n                    'Content-Type': metadata.contentType || 'application/octet-stream',\n                    body: writeStream,\n                },\n            ],\n        });\n        options.makeAuthenticatedRequest(reqOpts, {\n            onAuthenticated(err, authenticatedReqOpts) {\n                if (err) {\n                    dup.destroy(err);\n                    return;\n                }\n                const request = teeny_request_1.teenyRequest.defaults(requestDefaults);\n                request(authenticatedReqOpts, (err, resp, body) => {\n                    util.handleResp(err, resp, body, (err, data) => {\n                        if (err) {\n                            dup.destroy(err);\n                            return;\n                        }\n                        dup.emit('response', resp);\n                        onComplete(data);\n                    });\n                });\n            },\n        });\n    }\n    /**\n     * Returns true if the API request should be retried, given the error that was\n     * given the first time the request was attempted. This is used for rate limit\n     * related errors as well as intermittent server errors.\n     *\n     * @param {error} err - The API error to check if it is appropriate to retry.\n     * @return {boolean} True if the API request should be retried, false otherwise.\n     */\n    shouldRetryRequest(err) {\n        if (err) {\n            if ([429, 500, 502, 503].indexOf(err.code) !== -1) {\n                return true;\n            }\n            if (err.errors) {\n                for (const e of err.errors) {\n                    const reason = e.reason;\n                    if (reason === 'rateLimitExceeded') {\n                        return true;\n                    }\n                    if (reason === 'userRateLimitExceeded') {\n                        return true;\n                    }\n                    if (reason && reason.includes('EAI_AGAIN')) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    /**\n     * Get a function for making authenticated requests.\n     *\n     * @param {object} config - Configuration object.\n     * @param {boolean=} config.autoRetry - Automatically retry requests if the\n     *     response is related to rate limits or certain intermittent server\n     * errors. We will exponentially backoff subsequent requests by default.\n     * (default: true)\n     * @param {object=} config.credentials - Credentials object.\n     * @param {boolean=} config.customEndpoint - If true, just return the provided request options. Default: false.\n     * @param {string=} config.email - Account email address, required for PEM/P12 usage.\n     * @param {number=} config.maxRetries - Maximum number of automatic retries attempted before returning the error. (default: 3)\n     * @param {string=} config.keyFile - Path to a .json, .pem, or .p12 keyfile.\n     * @param {array} config.scopes - Array of scopes required for the API.\n     */\n    makeAuthenticatedRequestFactory(config) {\n        const googleAutoAuthConfig = extend({}, config);\n        if (googleAutoAuthConfig.projectId === '{{projectId}}') {\n            delete googleAutoAuthConfig.projectId;\n        }\n        const authClient = googleAutoAuthConfig.authClient || new google_auth_library_1.GoogleAuth(googleAutoAuthConfig);\n        function makeAuthenticatedRequest(reqOpts, optionsOrCallback) {\n            let stream;\n            const reqConfig = extend({}, config);\n            let activeRequest_;\n            if (!optionsOrCallback) {\n                stream = duplexify();\n                reqConfig.stream = stream;\n            }\n            const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : undefined;\n            const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : undefined;\n            const onAuthenticated = (err, authenticatedReqOpts) => {\n                const authLibraryError = err;\n                const autoAuthFailed = err &&\n                    err.message.indexOf('Could not load the default credentials') > -1;\n                if (autoAuthFailed) {\n                    // Even though authentication failed, the API might not actually\n                    // care.\n                    authenticatedReqOpts = reqOpts;\n                }\n                if (!err || autoAuthFailed) {\n                    // tslint:disable-next-line:no-any\n                    let projectId = authClient._cachedProjectId;\n                    if (config.projectId && config.projectId !== '{{projectId}}') {\n                        projectId = config.projectId;\n                    }\n                    try {\n                        authenticatedReqOpts = util.decorateRequest(authenticatedReqOpts, projectId);\n                        err = null;\n                    }\n                    catch (e) {\n                        // A projectId was required, but we don't have one.\n                        // Re-use the \"Could not load the default credentials error\" if\n                        // auto auth failed.\n                        err = err || e;\n                    }\n                }\n                if (err) {\n                    if (stream) {\n                        stream.destroy(err);\n                    }\n                    else {\n                        const fn = options && options.onAuthenticated\n                            ? options.onAuthenticated\n                            : callback;\n                        fn(err);\n                    }\n                    return;\n                }\n                if (options && options.onAuthenticated) {\n                    options.onAuthenticated(null, authenticatedReqOpts);\n                }\n                else {\n                    activeRequest_ = util.makeRequest(authenticatedReqOpts, reqConfig, (apiResponseError, ...params) => {\n                        if (apiResponseError &&\n                            apiResponseError.code === 401 &&\n                            authLibraryError) {\n                            // Re-use the \"Could not load the default credentials error\" if\n                            // the API request failed due to missing credentials.\n                            apiResponseError = authLibraryError;\n                        }\n                        callback(apiResponseError, ...params);\n                    });\n                }\n            };\n            if (reqConfig.customEndpoint) {\n                // Using a custom API override. Do not use `google-auth-library` for\n                // authentication. (ex: connecting to a local Datastore server)\n                onAuthenticated(null, reqOpts);\n            }\n            else {\n                authClient.authorizeRequest(reqOpts).then(res => {\n                    const opts = extend(true, {}, reqOpts, res);\n                    onAuthenticated(null, opts);\n                }, err => {\n                    onAuthenticated(err);\n                });\n            }\n            if (stream) {\n                return stream;\n            }\n            return {\n                abort() {\n                    setImmediate(() => {\n                        if (activeRequest_) {\n                            activeRequest_.abort();\n                            activeRequest_ = null;\n                        }\n                    });\n                },\n            };\n        }\n        const mar = makeAuthenticatedRequest;\n        mar.getCredentials = authClient.getCredentials.bind(authClient);\n        mar.authClient = authClient;\n        return mar;\n    }\n    /**\n     * Make a request through the `retryRequest` module with built-in error\n     * handling and exponential back off.\n     *\n     * @param {object} reqOpts - Request options in the format `request` expects.\n     * @param {object=} config - Configuration object.\n     * @param {boolean=} config.autoRetry - Automatically retry requests if the\n     *     response is related to rate limits or certain intermittent server\n     * errors. We will exponentially backoff subsequent requests by default.\n     * (default: true)\n     * @param {number=} config.maxRetries - Maximum number of automatic retries\n     *     attempted before returning the error. (default: 3)\n     * @param {object=} config.request - HTTP module for request calls.\n     * @param {function} callback - The callback function.\n     */\n    makeRequest(reqOpts, config, callback) {\n        const options = {\n            request: teeny_request_1.teenyRequest.defaults(requestDefaults),\n            retries: config.autoRetry !== false ? config.maxRetries || 3 : 0,\n            shouldRetryFn(httpRespMessage) {\n                const err = util.parseHttpRespMessage(httpRespMessage).err;\n                return err && util.shouldRetryRequest(err);\n            },\n        };\n        if (typeof reqOpts.maxRetries === 'number') {\n            options.retries = reqOpts.maxRetries;\n        }\n        if (!config.stream) {\n            return retryRequest(reqOpts, options, (err, response, body) => {\n                util.handleResp(err, response, body, callback);\n            });\n        }\n        const dup = config.stream;\n        // tslint:disable-next-line:no-any\n        let requestStream;\n        const isGetRequest = (reqOpts.method || 'GET').toUpperCase() === 'GET';\n        if (isGetRequest) {\n            requestStream = retryRequest(reqOpts, options);\n            dup.setReadable(requestStream);\n        }\n        else {\n            // Streaming writable HTTP requests cannot be retried.\n            requestStream = options.request(reqOpts);\n            dup.setWritable(requestStream);\n        }\n        // Replay the Request events back to the stream.\n        requestStream\n            .on('error', dup.destroy.bind(dup))\n            .on('response', dup.emit.bind(dup, 'response'))\n            .on('complete', dup.emit.bind(dup, 'complete'));\n        dup.abort = requestStream.abort;\n        return dup;\n    }\n    /**\n     * Decorate the options about to be made in a request.\n     *\n     * @param {object} reqOpts - The options to be passed to `request`.\n     * @param {string} projectId - The project ID.\n     * @return {object} reqOpts - The decorated reqOpts.\n     */\n    decorateRequest(reqOpts, projectId) {\n        delete reqOpts.autoPaginate;\n        delete reqOpts.autoPaginateVal;\n        delete reqOpts.objectMode;\n        if (reqOpts.qs !== null && typeof reqOpts.qs === 'object') {\n            delete reqOpts.qs.autoPaginate;\n            delete reqOpts.qs.autoPaginateVal;\n            reqOpts.qs = projectify_1.replaceProjectIdToken(reqOpts.qs, projectId);\n        }\n        if (Array.isArray(reqOpts.multipart)) {\n            reqOpts.multipart = reqOpts.multipart.map(part => {\n                return projectify_1.replaceProjectIdToken(part, projectId);\n            });\n        }\n        if (reqOpts.json !== null && typeof reqOpts.json === 'object') {\n            delete reqOpts.json.autoPaginate;\n            delete reqOpts.json.autoPaginateVal;\n            reqOpts.json = projectify_1.replaceProjectIdToken(reqOpts.json, projectId);\n        }\n        reqOpts.uri = projectify_1.replaceProjectIdToken(reqOpts.uri, projectId);\n        return reqOpts;\n    }\n    // tslint:disable-next-line:no-any\n    isCustomType(unknown, module) {\n        function getConstructorName(obj) {\n            return obj.constructor && obj.constructor.name.toLowerCase();\n        }\n        const moduleNameParts = module.split('/');\n        const parentModuleName = moduleNameParts[0] && moduleNameParts[0].toLowerCase();\n        const subModuleName = moduleNameParts[1] && moduleNameParts[1].toLowerCase();\n        if (subModuleName && getConstructorName(unknown) !== subModuleName) {\n            return false;\n        }\n        let walkingModule = unknown;\n        while (true) {\n            if (getConstructorName(walkingModule) === parentModuleName) {\n                return true;\n            }\n            walkingModule = walkingModule.parent;\n            if (!walkingModule) {\n                return false;\n            }\n        }\n    }\n    /**\n     * Create a properly-formatted User-Agent string from a package.json file.\n     *\n     * @param {object} packageJson - A module's package.json file.\n     * @return {string} userAgent - The formatted User-Agent string.\n     */\n    getUserAgentFromPackageJson(packageJson) {\n        const hyphenatedPackageName = packageJson.name\n            .replace('@google-cloud', 'gcloud-node') // For legacy purposes.\n            .replace('/', '-'); // For UA spec-compliance purposes.\n        return hyphenatedPackageName + '/' + packageJson.version;\n    }\n    /**\n     * Given two parameters, figure out if this is either:\n     *  - Just a callback function\n     *  - An options object, and then a callback function\n     * @param optionsOrCallback An options object or callback.\n     * @param cb A potentially undefined callback.\n     */\n    maybeOptionsOrCallback(optionsOrCallback, cb) {\n        return typeof optionsOrCallback === 'function'\n            ? [{}, optionsOrCallback]\n            : [optionsOrCallback, cb];\n    }\n}\nexports.Util = Util;\nconst util = new Util();\nexports.util = util;\n//# sourceMappingURL=util.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/common/build/src/util.js?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/firestore/build/protos/protos.json":
/*!***************************************************************************!*\
  !*** ./src/node_modules/@google-cloud/firestore/build/protos/protos.json ***!
  \***************************************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"nested\":{\"google\":{\"nested\":{\"firestore\":{\"nested\":{\"admin\":{\"nested\":{\"v1\":{\"options\":{\"csharp_namespace\":\"Google.Cloud.Firestore.Admin.V1\",\"go_package\":\"google.golang.org/genproto/googleapis/firestore/admin/v1;admin\",\"java_multiple_files\":true,\"java_outer_classname\":\"OperationProto\",\"java_package\":\"com.google.firestore.admin.v1\",\"objc_class_prefix\":\"GCFS\",\"php_namespace\":\"Google\\\\\\\\Cloud\\\\\\\\Firestore\\\\\\\\Admin\\\\\\\\V1\",\"(google.api.resource_definition).type\":\"firestore.googleapis.com/CollectionGroup\",\"(google.api.resource_definition).pattern\":\"projects/{project}/databases/{database}/collectionGroups/{collection}\"},\"nested\":{\"Field\":{\"options\":{\"(google.api.resource).type\":\"firestore.googleapis.com/Field\",\"(google.api.resource).pattern\":\"projects/{project}/databases/{database}/collectionGroups/{collection}/fields/{field}\"},\"fields\":{\"name\":{\"type\":\"string\",\"id\":1},\"indexConfig\":{\"type\":\"IndexConfig\",\"id\":2}},\"nested\":{\"IndexConfig\":{\"fields\":{\"indexes\":{\"rule\":\"repeated\",\"type\":\"Index\",\"id\":1},\"usesAncestorConfig\":{\"type\":\"bool\",\"id\":2},\"ancestorField\":{\"type\":\"string\",\"id\":3},\"reverting\":{\"type\":\"bool\",\"id\":4}}}}},\"Index\":{\"options\":{\"(google.api.resource).type\":\"firestore.googleapis.com/Index\",\"(google.api.resource).pattern\":\"projects/{project}/databases/{database}/collectionGroups/{collection}/indexes/{index}\"},\"fields\":{\"name\":{\"type\":\"string\",\"id\":1},\"queryScope\":{\"type\":\"QueryScope\",\"id\":2},\"fields\":{\"rule\":\"repeated\",\"type\":\"IndexField\",\"id\":3},\"state\":{\"type\":\"State\",\"id\":4}},\"nested\":{\"IndexField\":{\"oneofs\":{\"valueMode\":{\"oneof\":[\"order\",\"arrayConfig\"]}},\"fields\":{\"fieldPath\":{\"type\":\"string\",\"id\":1},\"order\":{\"type\":\"Order\",\"id\":2},\"arrayConfig\":{\"type\":\"ArrayConfig\",\"id\":3}},\"nested\":{\"Order\":{\"values\":{\"ORDER_UNSPECIFIED\":0,\"ASCENDING\":1,\"DESCENDING\":2}},\"ArrayConfig\":{\"values\":{\"ARRAY_CONFIG_UNSPECIFIED\":0,\"CONTAINS\":1}}}},\"QueryScope\":{\"values\":{\"QUERY_SCOPE_UNSPECIFIED\":0,\"COLLECTION\":1,\"COLLECTION_GROUP\":2}},\"State\":{\"values\":{\"STATE_UNSPECIFIED\":0,\"CREATING\":1,\"READY\":2,\"NEEDS_REPAIR\":3}}}},\"FirestoreAdmin\":{\"options\":{\"(google.api.default_host)\":\"firestore.googleapis.com\",\"(google.api.oauth_scopes)\":\"https://www.googleapis.com/auth/cloud-platform,https://www.googleapis.com/auth/datastore\"},\"methods\":{\"CreateIndex\":{\"requestType\":\"CreateIndexRequest\",\"responseType\":\"google.longrunning.Operation\",\"options\":{\"(google.api.http).post\":\"/v1/{parent=projects/*/databases/*/collectionGroups/*}/indexes\",\"(google.api.http).body\":\"index\",\"(google.api.method_signature)\":\"parent,index\",\"(google.longrunning.operation_info).response_type\":\"Index\",\"(google.longrunning.operation_info).metadata_type\":\"IndexOperationMetadata\"}},\"ListIndexes\":{\"requestType\":\"ListIndexesRequest\",\"responseType\":\"ListIndexesResponse\",\"options\":{\"(google.api.http).get\":\"/v1/{parent=projects/*/databases/*/collectionGroups/*}/indexes\",\"(google.api.method_signature)\":\"parent\"}},\"GetIndex\":{\"requestType\":\"GetIndexRequest\",\"responseType\":\"Index\",\"options\":{\"(google.api.http).get\":\"/v1/{name=projects/*/databases/*/collectionGroups/*/indexes/*}\",\"(google.api.method_signature)\":\"name\"}},\"DeleteIndex\":{\"requestType\":\"DeleteIndexRequest\",\"responseType\":\"google.protobuf.Empty\",\"options\":{\"(google.api.http).delete\":\"/v1/{name=projects/*/databases/*/collectionGroups/*/indexes/*}\",\"(google.api.method_signature)\":\"name\"}},\"GetField\":{\"requestType\":\"GetFieldRequest\",\"responseType\":\"Field\",\"options\":{\"(google.api.http).get\":\"/v1/{name=projects/*/databases/*/collectionGroups/*/fields/*}\",\"(google.api.method_signature)\":\"name\"}},\"UpdateField\":{\"requestType\":\"UpdateFieldRequest\",\"responseType\":\"google.longrunning.Operation\",\"options\":{\"(google.api.http).patch\":\"/v1/{field.name=projects/*/databases/*/collectionGroups/*/fields/*}\",\"(google.api.http).body\":\"field\",\"(google.api.method_signature)\":\"field\",\"(google.longrunning.operation_info).response_type\":\"Field\",\"(google.longrunning.operation_info).metadata_type\":\"FieldOperationMetadata\"}},\"ListFields\":{\"requestType\":\"ListFieldsRequest\",\"responseType\":\"ListFieldsResponse\",\"options\":{\"(google.api.http).get\":\"/v1/{parent=projects/*/databases/*/collectionGroups/*}/fields\",\"(google.api.method_signature)\":\"parent\"}},\"ExportDocuments\":{\"requestType\":\"ExportDocumentsRequest\",\"responseType\":\"google.longrunning.Operation\",\"options\":{\"(google.api.http).post\":\"/v1/{name=projects/*/databases/*}:exportDocuments\",\"(google.api.http).body\":\"*\",\"(google.api.method_signature)\":\"name\",\"(google.longrunning.operation_info).response_type\":\"ExportDocumentsResponse\",\"(google.longrunning.operation_info).metadata_type\":\"ExportDocumentsMetadata\"}},\"ImportDocuments\":{\"requestType\":\"ImportDocumentsRequest\",\"responseType\":\"google.longrunning.Operation\",\"options\":{\"(google.api.http).post\":\"/v1/{name=projects/*/databases/*}:importDocuments\",\"(google.api.http).body\":\"*\",\"(google.api.method_signature)\":\"name\",\"(google.longrunning.operation_info).response_type\":\"google.protobuf.Empty\",\"(google.longrunning.operation_info).metadata_type\":\"ImportDocumentsMetadata\"}}}},\"CreateIndexRequest\":{\"fields\":{\"parent\":{\"type\":\"string\",\"id\":1,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\",\"(google.api.resource_reference).type\":\"firestore.googleapis.com/CollectionGroup\"}},\"index\":{\"type\":\"Index\",\"id\":2,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\"}}}},\"ListIndexesRequest\":{\"fields\":{\"parent\":{\"type\":\"string\",\"id\":1,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\",\"(google.api.resource_reference).type\":\"firestore.googleapis.com/CollectionGroup\"}},\"filter\":{\"type\":\"string\",\"id\":2},\"pageSize\":{\"type\":\"int32\",\"id\":3},\"pageToken\":{\"type\":\"string\",\"id\":4}}},\"ListIndexesResponse\":{\"fields\":{\"indexes\":{\"rule\":\"repeated\",\"type\":\"Index\",\"id\":1},\"nextPageToken\":{\"type\":\"string\",\"id\":2}}},\"GetIndexRequest\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\",\"(google.api.resource_reference).type\":\"firestore.googleapis.com/Index\"}}}},\"DeleteIndexRequest\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\",\"(google.api.resource_reference).type\":\"firestore.googleapis.com/Index\"}}}},\"UpdateFieldRequest\":{\"fields\":{\"field\":{\"type\":\"Field\",\"id\":1,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\"}},\"updateMask\":{\"type\":\"google.protobuf.FieldMask\",\"id\":2}}},\"GetFieldRequest\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\",\"(google.api.resource_reference).type\":\"firestore.googleapis.com/Field\"}}}},\"ListFieldsRequest\":{\"fields\":{\"parent\":{\"type\":\"string\",\"id\":1,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\",\"(google.api.resource_reference).type\":\"firestore.googleapis.com/CollectionGroup\"}},\"filter\":{\"type\":\"string\",\"id\":2},\"pageSize\":{\"type\":\"int32\",\"id\":3},\"pageToken\":{\"type\":\"string\",\"id\":4}}},\"ListFieldsResponse\":{\"fields\":{\"fields\":{\"rule\":\"repeated\",\"type\":\"Field\",\"id\":1},\"nextPageToken\":{\"type\":\"string\",\"id\":2}}},\"ExportDocumentsRequest\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\",\"(google.api.resource_reference).type\":\"firestore.googleapis.com/Database\"}},\"collectionIds\":{\"rule\":\"repeated\",\"type\":\"string\",\"id\":2},\"outputUriPrefix\":{\"type\":\"string\",\"id\":3}}},\"ImportDocumentsRequest\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\",\"(google.api.resource_reference).type\":\"firestore.googleapis.com/Database\"}},\"collectionIds\":{\"rule\":\"repeated\",\"type\":\"string\",\"id\":2},\"inputUriPrefix\":{\"type\":\"string\",\"id\":3}}},\"LocationMetadata\":{\"fields\":{}},\"IndexOperationMetadata\":{\"fields\":{\"startTime\":{\"type\":\"google.protobuf.Timestamp\",\"id\":1},\"endTime\":{\"type\":\"google.protobuf.Timestamp\",\"id\":2},\"index\":{\"type\":\"string\",\"id\":3},\"state\":{\"type\":\"OperationState\",\"id\":4},\"progressDocuments\":{\"type\":\"Progress\",\"id\":5},\"progressBytes\":{\"type\":\"Progress\",\"id\":6}}},\"FieldOperationMetadata\":{\"fields\":{\"startTime\":{\"type\":\"google.protobuf.Timestamp\",\"id\":1},\"endTime\":{\"type\":\"google.protobuf.Timestamp\",\"id\":2},\"field\":{\"type\":\"string\",\"id\":3},\"indexConfigDeltas\":{\"rule\":\"repeated\",\"type\":\"IndexConfigDelta\",\"id\":4},\"state\":{\"type\":\"OperationState\",\"id\":5},\"progressDocuments\":{\"type\":\"Progress\",\"id\":6},\"progressBytes\":{\"type\":\"Progress\",\"id\":7}},\"nested\":{\"IndexConfigDelta\":{\"fields\":{\"changeType\":{\"type\":\"ChangeType\",\"id\":1},\"index\":{\"type\":\"Index\",\"id\":2}},\"nested\":{\"ChangeType\":{\"values\":{\"CHANGE_TYPE_UNSPECIFIED\":0,\"ADD\":1,\"REMOVE\":2}}}}}},\"ExportDocumentsMetadata\":{\"fields\":{\"startTime\":{\"type\":\"google.protobuf.Timestamp\",\"id\":1},\"endTime\":{\"type\":\"google.protobuf.Timestamp\",\"id\":2},\"operationState\":{\"type\":\"OperationState\",\"id\":3},\"progressDocuments\":{\"type\":\"Progress\",\"id\":4},\"progressBytes\":{\"type\":\"Progress\",\"id\":5},\"collectionIds\":{\"rule\":\"repeated\",\"type\":\"string\",\"id\":6},\"outputUriPrefix\":{\"type\":\"string\",\"id\":7}}},\"ImportDocumentsMetadata\":{\"fields\":{\"startTime\":{\"type\":\"google.protobuf.Timestamp\",\"id\":1},\"endTime\":{\"type\":\"google.protobuf.Timestamp\",\"id\":2},\"operationState\":{\"type\":\"OperationState\",\"id\":3},\"progressDocuments\":{\"type\":\"Progress\",\"id\":4},\"progressBytes\":{\"type\":\"Progress\",\"id\":5},\"collectionIds\":{\"rule\":\"repeated\",\"type\":\"string\",\"id\":6},\"inputUriPrefix\":{\"type\":\"string\",\"id\":7}}},\"ExportDocumentsResponse\":{\"fields\":{\"outputUriPrefix\":{\"type\":\"string\",\"id\":1}}},\"Progress\":{\"fields\":{\"estimatedWork\":{\"type\":\"int64\",\"id\":1},\"completedWork\":{\"type\":\"int64\",\"id\":2}}},\"OperationState\":{\"values\":{\"OPERATION_STATE_UNSPECIFIED\":0,\"INITIALIZING\":1,\"PROCESSING\":2,\"CANCELLING\":3,\"FINALIZING\":4,\"SUCCESSFUL\":5,\"FAILED\":6,\"CANCELLED\":7}}}}}},\"v1\":{\"options\":{\"csharp_namespace\":\"Google.Cloud.Firestore.V1\",\"go_package\":\"google.golang.org/genproto/googleapis/firestore/v1;firestore\",\"java_multiple_files\":true,\"java_outer_classname\":\"WriteProto\",\"java_package\":\"com.google.firestore.v1\",\"objc_class_prefix\":\"GCFS\",\"php_namespace\":\"Google\\\\\\\\Cloud\\\\\\\\Firestore\\\\\\\\V1\"},\"nested\":{\"DocumentMask\":{\"fields\":{\"fieldPaths\":{\"rule\":\"repeated\",\"type\":\"string\",\"id\":1}}},\"Precondition\":{\"oneofs\":{\"conditionType\":{\"oneof\":[\"exists\",\"updateTime\"]}},\"fields\":{\"exists\":{\"type\":\"bool\",\"id\":1},\"updateTime\":{\"type\":\"google.protobuf.Timestamp\",\"id\":2}}},\"TransactionOptions\":{\"oneofs\":{\"mode\":{\"oneof\":[\"readOnly\",\"readWrite\"]}},\"fields\":{\"readOnly\":{\"type\":\"ReadOnly\",\"id\":2},\"readWrite\":{\"type\":\"ReadWrite\",\"id\":3}},\"nested\":{\"ReadWrite\":{\"fields\":{\"retryTransaction\":{\"type\":\"bytes\",\"id\":1}}},\"ReadOnly\":{\"oneofs\":{\"consistencySelector\":{\"oneof\":[\"readTime\"]}},\"fields\":{\"readTime\":{\"type\":\"google.protobuf.Timestamp\",\"id\":2}}}}},\"Document\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1},\"fields\":{\"keyType\":\"string\",\"type\":\"Value\",\"id\":2},\"createTime\":{\"type\":\"google.protobuf.Timestamp\",\"id\":3},\"updateTime\":{\"type\":\"google.protobuf.Timestamp\",\"id\":4}}},\"Value\":{\"oneofs\":{\"valueType\":{\"oneof\":[\"nullValue\",\"booleanValue\",\"integerValue\",\"doubleValue\",\"timestampValue\",\"stringValue\",\"bytesValue\",\"referenceValue\",\"geoPointValue\",\"arrayValue\",\"mapValue\"]}},\"fields\":{\"nullValue\":{\"type\":\"google.protobuf.NullValue\",\"id\":11},\"booleanValue\":{\"type\":\"bool\",\"id\":1},\"integerValue\":{\"type\":\"int64\",\"id\":2},\"doubleValue\":{\"type\":\"double\",\"id\":3},\"timestampValue\":{\"type\":\"google.protobuf.Timestamp\",\"id\":10},\"stringValue\":{\"type\":\"string\",\"id\":17},\"bytesValue\":{\"type\":\"bytes\",\"id\":18},\"referenceValue\":{\"type\":\"string\",\"id\":5},\"geoPointValue\":{\"type\":\"google.type.LatLng\",\"id\":8},\"arrayValue\":{\"type\":\"ArrayValue\",\"id\":9},\"mapValue\":{\"type\":\"MapValue\",\"id\":6}}},\"ArrayValue\":{\"fields\":{\"values\":{\"rule\":\"repeated\",\"type\":\"Value\",\"id\":1}}},\"MapValue\":{\"fields\":{\"fields\":{\"keyType\":\"string\",\"type\":\"Value\",\"id\":1}}},\"Firestore\":{\"options\":{\"(google.api.default_host)\":\"firestore.googleapis.com\",\"(google.api.oauth_scopes)\":\"https://www.googleapis.com/auth/cloud-platform,https://www.googleapis.com/auth/datastore\"},\"methods\":{\"GetDocument\":{\"requestType\":\"GetDocumentRequest\",\"responseType\":\"Document\",\"options\":{\"(google.api.http).get\":\"/v1/{name=projects/*/databases/*/documents/*/**}\"}},\"ListDocuments\":{\"requestType\":\"ListDocumentsRequest\",\"responseType\":\"ListDocumentsResponse\",\"options\":{\"(google.api.http).get\":\"/v1/{parent=projects/*/databases/*/documents/*/**}/{collection_id}\"}},\"UpdateDocument\":{\"requestType\":\"UpdateDocumentRequest\",\"responseType\":\"Document\",\"options\":{\"(google.api.http).patch\":\"/v1/{document.name=projects/*/databases/*/documents/*/**}\",\"(google.api.http).body\":\"document\",\"(google.api.method_signature)\":\"document,update_mask\"}},\"DeleteDocument\":{\"requestType\":\"DeleteDocumentRequest\",\"responseType\":\"google.protobuf.Empty\",\"options\":{\"(google.api.http).delete\":\"/v1/{name=projects/*/databases/*/documents/*/**}\",\"(google.api.method_signature)\":\"name\"}},\"BatchGetDocuments\":{\"requestType\":\"BatchGetDocumentsRequest\",\"responseType\":\"BatchGetDocumentsResponse\",\"responseStream\":true,\"options\":{\"(google.api.http).post\":\"/v1/{database=projects/*/databases/*}/documents:batchGet\",\"(google.api.http).body\":\"*\"}},\"BeginTransaction\":{\"requestType\":\"BeginTransactionRequest\",\"responseType\":\"BeginTransactionResponse\",\"options\":{\"(google.api.http).post\":\"/v1/{database=projects/*/databases/*}/documents:beginTransaction\",\"(google.api.http).body\":\"*\",\"(google.api.method_signature)\":\"database\"}},\"Commit\":{\"requestType\":\"CommitRequest\",\"responseType\":\"CommitResponse\",\"options\":{\"(google.api.http).post\":\"/v1/{database=projects/*/databases/*}/documents:commit\",\"(google.api.http).body\":\"*\",\"(google.api.method_signature)\":\"database,writes\"}},\"Rollback\":{\"requestType\":\"RollbackRequest\",\"responseType\":\"google.protobuf.Empty\",\"options\":{\"(google.api.http).post\":\"/v1/{database=projects/*/databases/*}/documents:rollback\",\"(google.api.http).body\":\"*\",\"(google.api.method_signature)\":\"database,transaction\"}},\"RunQuery\":{\"requestType\":\"RunQueryRequest\",\"responseType\":\"RunQueryResponse\",\"responseStream\":true,\"options\":{\"(google.api.http).post\":\"/v1/{parent=projects/*/databases/*/documents}:runQuery\",\"(google.api.http).body\":\"*\",\"(google.api.http).additional_bindings.post\":\"/v1/{parent=projects/*/databases/*/documents/*/**}:runQuery\",\"(google.api.http).additional_bindings.body\":\"*\"}},\"Write\":{\"requestType\":\"WriteRequest\",\"requestStream\":true,\"responseType\":\"WriteResponse\",\"responseStream\":true,\"options\":{\"(google.api.http).post\":\"/v1/{database=projects/*/databases/*}/documents:write\",\"(google.api.http).body\":\"*\"}},\"Listen\":{\"requestType\":\"ListenRequest\",\"requestStream\":true,\"responseType\":\"ListenResponse\",\"responseStream\":true,\"options\":{\"(google.api.http).post\":\"/v1/{database=projects/*/databases/*}/documents:listen\",\"(google.api.http).body\":\"*\"}},\"ListCollectionIds\":{\"requestType\":\"ListCollectionIdsRequest\",\"responseType\":\"ListCollectionIdsResponse\",\"options\":{\"(google.api.http).post\":\"/v1/{parent=projects/*/databases/*/documents}:listCollectionIds\",\"(google.api.http).body\":\"*\",\"(google.api.http).additional_bindings.post\":\"/v1/{parent=projects/*/databases/*/documents/*/**}:listCollectionIds\",\"(google.api.http).additional_bindings.body\":\"*\",\"(google.api.method_signature)\":\"parent\"}},\"CreateDocument\":{\"requestType\":\"CreateDocumentRequest\",\"responseType\":\"Document\",\"options\":{\"(google.api.http).post\":\"/v1/{parent=projects/*/databases/*/documents/**}/{collection_id}\",\"(google.api.http).body\":\"document\"}}}},\"GetDocumentRequest\":{\"oneofs\":{\"consistencySelector\":{\"oneof\":[\"transaction\",\"readTime\"]}},\"fields\":{\"name\":{\"type\":\"string\",\"id\":1,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\"}},\"mask\":{\"type\":\"DocumentMask\",\"id\":2},\"transaction\":{\"type\":\"bytes\",\"id\":3},\"readTime\":{\"type\":\"google.protobuf.Timestamp\",\"id\":5}}},\"ListDocumentsRequest\":{\"oneofs\":{\"consistencySelector\":{\"oneof\":[\"transaction\",\"readTime\"]}},\"fields\":{\"parent\":{\"type\":\"string\",\"id\":1,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\"}},\"collectionId\":{\"type\":\"string\",\"id\":2,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\"}},\"pageSize\":{\"type\":\"int32\",\"id\":3},\"pageToken\":{\"type\":\"string\",\"id\":4},\"orderBy\":{\"type\":\"string\",\"id\":6},\"mask\":{\"type\":\"DocumentMask\",\"id\":7},\"transaction\":{\"type\":\"bytes\",\"id\":8},\"readTime\":{\"type\":\"google.protobuf.Timestamp\",\"id\":10},\"showMissing\":{\"type\":\"bool\",\"id\":12}}},\"ListDocumentsResponse\":{\"fields\":{\"documents\":{\"rule\":\"repeated\",\"type\":\"Document\",\"id\":1},\"nextPageToken\":{\"type\":\"string\",\"id\":2}}},\"CreateDocumentRequest\":{\"fields\":{\"parent\":{\"type\":\"string\",\"id\":1,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\"}},\"collectionId\":{\"type\":\"string\",\"id\":2,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\"}},\"documentId\":{\"type\":\"string\",\"id\":3},\"document\":{\"type\":\"Document\",\"id\":4,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\"}},\"mask\":{\"type\":\"DocumentMask\",\"id\":5}}},\"UpdateDocumentRequest\":{\"fields\":{\"document\":{\"type\":\"Document\",\"id\":1,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\"}},\"updateMask\":{\"type\":\"DocumentMask\",\"id\":2},\"mask\":{\"type\":\"DocumentMask\",\"id\":3},\"currentDocument\":{\"type\":\"Precondition\",\"id\":4}}},\"DeleteDocumentRequest\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\"}},\"currentDocument\":{\"type\":\"Precondition\",\"id\":2}}},\"BatchGetDocumentsRequest\":{\"oneofs\":{\"consistencySelector\":{\"oneof\":[\"transaction\",\"newTransaction\",\"readTime\"]}},\"fields\":{\"database\":{\"type\":\"string\",\"id\":1,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\"}},\"documents\":{\"rule\":\"repeated\",\"type\":\"string\",\"id\":2},\"mask\":{\"type\":\"DocumentMask\",\"id\":3},\"transaction\":{\"type\":\"bytes\",\"id\":4},\"newTransaction\":{\"type\":\"TransactionOptions\",\"id\":5},\"readTime\":{\"type\":\"google.protobuf.Timestamp\",\"id\":7}}},\"BatchGetDocumentsResponse\":{\"oneofs\":{\"result\":{\"oneof\":[\"found\",\"missing\"]}},\"fields\":{\"found\":{\"type\":\"Document\",\"id\":1},\"missing\":{\"type\":\"string\",\"id\":2},\"transaction\":{\"type\":\"bytes\",\"id\":3},\"readTime\":{\"type\":\"google.protobuf.Timestamp\",\"id\":4}}},\"BeginTransactionRequest\":{\"fields\":{\"database\":{\"type\":\"string\",\"id\":1,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\"}},\"options\":{\"type\":\"TransactionOptions\",\"id\":2}}},\"BeginTransactionResponse\":{\"fields\":{\"transaction\":{\"type\":\"bytes\",\"id\":1}}},\"CommitRequest\":{\"fields\":{\"database\":{\"type\":\"string\",\"id\":1,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\"}},\"writes\":{\"rule\":\"repeated\",\"type\":\"Write\",\"id\":2},\"transaction\":{\"type\":\"bytes\",\"id\":3}}},\"CommitResponse\":{\"fields\":{\"writeResults\":{\"rule\":\"repeated\",\"type\":\"WriteResult\",\"id\":1},\"commitTime\":{\"type\":\"google.protobuf.Timestamp\",\"id\":2}}},\"RollbackRequest\":{\"fields\":{\"database\":{\"type\":\"string\",\"id\":1,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\"}},\"transaction\":{\"type\":\"bytes\",\"id\":2,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\"}}}},\"RunQueryRequest\":{\"oneofs\":{\"queryType\":{\"oneof\":[\"structuredQuery\"]},\"consistencySelector\":{\"oneof\":[\"transaction\",\"newTransaction\",\"readTime\"]}},\"fields\":{\"parent\":{\"type\":\"string\",\"id\":1,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\"}},\"structuredQuery\":{\"type\":\"StructuredQuery\",\"id\":2},\"transaction\":{\"type\":\"bytes\",\"id\":5},\"newTransaction\":{\"type\":\"TransactionOptions\",\"id\":6},\"readTime\":{\"type\":\"google.protobuf.Timestamp\",\"id\":7}}},\"RunQueryResponse\":{\"fields\":{\"transaction\":{\"type\":\"bytes\",\"id\":2},\"document\":{\"type\":\"Document\",\"id\":1},\"readTime\":{\"type\":\"google.protobuf.Timestamp\",\"id\":3},\"skippedResults\":{\"type\":\"int32\",\"id\":4}}},\"WriteRequest\":{\"fields\":{\"database\":{\"type\":\"string\",\"id\":1,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\"}},\"streamId\":{\"type\":\"string\",\"id\":2},\"writes\":{\"rule\":\"repeated\",\"type\":\"Write\",\"id\":3},\"streamToken\":{\"type\":\"bytes\",\"id\":4},\"labels\":{\"keyType\":\"string\",\"type\":\"string\",\"id\":5}}},\"WriteResponse\":{\"fields\":{\"streamId\":{\"type\":\"string\",\"id\":1},\"streamToken\":{\"type\":\"bytes\",\"id\":2},\"writeResults\":{\"rule\":\"repeated\",\"type\":\"WriteResult\",\"id\":3},\"commitTime\":{\"type\":\"google.protobuf.Timestamp\",\"id\":4}}},\"ListenRequest\":{\"oneofs\":{\"targetChange\":{\"oneof\":[\"addTarget\",\"removeTarget\"]}},\"fields\":{\"database\":{\"type\":\"string\",\"id\":1,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\"}},\"addTarget\":{\"type\":\"Target\",\"id\":2},\"removeTarget\":{\"type\":\"int32\",\"id\":3},\"labels\":{\"keyType\":\"string\",\"type\":\"string\",\"id\":4}}},\"ListenResponse\":{\"oneofs\":{\"responseType\":{\"oneof\":[\"targetChange\",\"documentChange\",\"documentDelete\",\"documentRemove\",\"filter\"]}},\"fields\":{\"targetChange\":{\"type\":\"TargetChange\",\"id\":2},\"documentChange\":{\"type\":\"DocumentChange\",\"id\":3},\"documentDelete\":{\"type\":\"DocumentDelete\",\"id\":4},\"documentRemove\":{\"type\":\"DocumentRemove\",\"id\":6},\"filter\":{\"type\":\"ExistenceFilter\",\"id\":5}}},\"Target\":{\"oneofs\":{\"targetType\":{\"oneof\":[\"query\",\"documents\"]},\"resumeType\":{\"oneof\":[\"resumeToken\",\"readTime\"]}},\"fields\":{\"query\":{\"type\":\"QueryTarget\",\"id\":2},\"documents\":{\"type\":\"DocumentsTarget\",\"id\":3},\"resumeToken\":{\"type\":\"bytes\",\"id\":4},\"readTime\":{\"type\":\"google.protobuf.Timestamp\",\"id\":11},\"targetId\":{\"type\":\"int32\",\"id\":5},\"once\":{\"type\":\"bool\",\"id\":6}},\"nested\":{\"DocumentsTarget\":{\"fields\":{\"documents\":{\"rule\":\"repeated\",\"type\":\"string\",\"id\":2}}},\"QueryTarget\":{\"oneofs\":{\"queryType\":{\"oneof\":[\"structuredQuery\"]}},\"fields\":{\"parent\":{\"type\":\"string\",\"id\":1},\"structuredQuery\":{\"type\":\"StructuredQuery\",\"id\":2}}}}},\"TargetChange\":{\"fields\":{\"targetChangeType\":{\"type\":\"TargetChangeType\",\"id\":1},\"targetIds\":{\"rule\":\"repeated\",\"type\":\"int32\",\"id\":2},\"cause\":{\"type\":\"google.rpc.Status\",\"id\":3},\"resumeToken\":{\"type\":\"bytes\",\"id\":4},\"readTime\":{\"type\":\"google.protobuf.Timestamp\",\"id\":6}},\"nested\":{\"TargetChangeType\":{\"values\":{\"NO_CHANGE\":0,\"ADD\":1,\"REMOVE\":2,\"CURRENT\":3,\"RESET\":4}}}},\"ListCollectionIdsRequest\":{\"fields\":{\"parent\":{\"type\":\"string\",\"id\":1,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\"}},\"pageSize\":{\"type\":\"int32\",\"id\":2},\"pageToken\":{\"type\":\"string\",\"id\":3}}},\"ListCollectionIdsResponse\":{\"fields\":{\"collectionIds\":{\"rule\":\"repeated\",\"type\":\"string\",\"id\":1},\"nextPageToken\":{\"type\":\"string\",\"id\":2}}},\"StructuredQuery\":{\"fields\":{\"select\":{\"type\":\"Projection\",\"id\":1},\"from\":{\"rule\":\"repeated\",\"type\":\"CollectionSelector\",\"id\":2},\"where\":{\"type\":\"Filter\",\"id\":3},\"orderBy\":{\"rule\":\"repeated\",\"type\":\"Order\",\"id\":4},\"startAt\":{\"type\":\"Cursor\",\"id\":7},\"endAt\":{\"type\":\"Cursor\",\"id\":8},\"offset\":{\"type\":\"int32\",\"id\":6},\"limit\":{\"type\":\"google.protobuf.Int32Value\",\"id\":5}},\"nested\":{\"CollectionSelector\":{\"fields\":{\"collectionId\":{\"type\":\"string\",\"id\":2},\"allDescendants\":{\"type\":\"bool\",\"id\":3}}},\"Filter\":{\"oneofs\":{\"filterType\":{\"oneof\":[\"compositeFilter\",\"fieldFilter\",\"unaryFilter\"]}},\"fields\":{\"compositeFilter\":{\"type\":\"CompositeFilter\",\"id\":1},\"fieldFilter\":{\"type\":\"FieldFilter\",\"id\":2},\"unaryFilter\":{\"type\":\"UnaryFilter\",\"id\":3}}},\"CompositeFilter\":{\"fields\":{\"op\":{\"type\":\"Operator\",\"id\":1},\"filters\":{\"rule\":\"repeated\",\"type\":\"Filter\",\"id\":2}},\"nested\":{\"Operator\":{\"values\":{\"OPERATOR_UNSPECIFIED\":0,\"AND\":1}}}},\"FieldFilter\":{\"fields\":{\"field\":{\"type\":\"FieldReference\",\"id\":1},\"op\":{\"type\":\"Operator\",\"id\":2},\"value\":{\"type\":\"Value\",\"id\":3}},\"nested\":{\"Operator\":{\"values\":{\"OPERATOR_UNSPECIFIED\":0,\"LESS_THAN\":1,\"LESS_THAN_OR_EQUAL\":2,\"GREATER_THAN\":3,\"GREATER_THAN_OR_EQUAL\":4,\"EQUAL\":5,\"ARRAY_CONTAINS\":7,\"IN\":8,\"ARRAY_CONTAINS_ANY\":9}}}},\"Projection\":{\"fields\":{\"fields\":{\"rule\":\"repeated\",\"type\":\"FieldReference\",\"id\":2}}},\"UnaryFilter\":{\"oneofs\":{\"operandType\":{\"oneof\":[\"field\"]}},\"fields\":{\"op\":{\"type\":\"Operator\",\"id\":1},\"field\":{\"type\":\"FieldReference\",\"id\":2}},\"nested\":{\"Operator\":{\"values\":{\"OPERATOR_UNSPECIFIED\":0,\"IS_NAN\":2,\"IS_NULL\":3}}}},\"FieldReference\":{\"fields\":{\"fieldPath\":{\"type\":\"string\",\"id\":2}}},\"Order\":{\"fields\":{\"field\":{\"type\":\"FieldReference\",\"id\":1},\"direction\":{\"type\":\"Direction\",\"id\":2}}},\"Direction\":{\"values\":{\"DIRECTION_UNSPECIFIED\":0,\"ASCENDING\":1,\"DESCENDING\":2}}}},\"Cursor\":{\"fields\":{\"values\":{\"rule\":\"repeated\",\"type\":\"Value\",\"id\":1},\"before\":{\"type\":\"bool\",\"id\":2}}},\"Write\":{\"oneofs\":{\"operation\":{\"oneof\":[\"update\",\"delete\",\"transform\"]}},\"fields\":{\"update\":{\"type\":\"Document\",\"id\":1},\"delete\":{\"type\":\"string\",\"id\":2},\"transform\":{\"type\":\"DocumentTransform\",\"id\":6},\"updateMask\":{\"type\":\"DocumentMask\",\"id\":3},\"updateTransforms\":{\"rule\":\"repeated\",\"type\":\"DocumentTransform.FieldTransform\",\"id\":7},\"currentDocument\":{\"type\":\"Precondition\",\"id\":4}}},\"DocumentTransform\":{\"fields\":{\"document\":{\"type\":\"string\",\"id\":1},\"fieldTransforms\":{\"rule\":\"repeated\",\"type\":\"FieldTransform\",\"id\":2}},\"nested\":{\"FieldTransform\":{\"oneofs\":{\"transformType\":{\"oneof\":[\"setToServerValue\",\"increment\",\"maximum\",\"minimum\",\"appendMissingElements\",\"removeAllFromArray\"]}},\"fields\":{\"fieldPath\":{\"type\":\"string\",\"id\":1},\"setToServerValue\":{\"type\":\"ServerValue\",\"id\":2},\"increment\":{\"type\":\"Value\",\"id\":3},\"maximum\":{\"type\":\"Value\",\"id\":4},\"minimum\":{\"type\":\"Value\",\"id\":5},\"appendMissingElements\":{\"type\":\"ArrayValue\",\"id\":6},\"removeAllFromArray\":{\"type\":\"ArrayValue\",\"id\":7}},\"nested\":{\"ServerValue\":{\"values\":{\"SERVER_VALUE_UNSPECIFIED\":0,\"REQUEST_TIME\":1}}}}}},\"WriteResult\":{\"fields\":{\"updateTime\":{\"type\":\"google.protobuf.Timestamp\",\"id\":1},\"transformResults\":{\"rule\":\"repeated\",\"type\":\"Value\",\"id\":2}}},\"DocumentChange\":{\"fields\":{\"document\":{\"type\":\"Document\",\"id\":1},\"targetIds\":{\"rule\":\"repeated\",\"type\":\"int32\",\"id\":5},\"removedTargetIds\":{\"rule\":\"repeated\",\"type\":\"int32\",\"id\":6}}},\"DocumentDelete\":{\"fields\":{\"document\":{\"type\":\"string\",\"id\":1},\"removedTargetIds\":{\"rule\":\"repeated\",\"type\":\"int32\",\"id\":6},\"readTime\":{\"type\":\"google.protobuf.Timestamp\",\"id\":4}}},\"DocumentRemove\":{\"fields\":{\"document\":{\"type\":\"string\",\"id\":1},\"removedTargetIds\":{\"rule\":\"repeated\",\"type\":\"int32\",\"id\":2},\"readTime\":{\"type\":\"google.protobuf.Timestamp\",\"id\":4}}},\"ExistenceFilter\":{\"fields\":{\"targetId\":{\"type\":\"int32\",\"id\":1},\"count\":{\"type\":\"int32\",\"id\":2}}}}},\"v1beta1\":{\"options\":{\"csharp_namespace\":\"Google.Cloud.Firestore.V1Beta1\",\"go_package\":\"google.golang.org/genproto/googleapis/firestore/v1beta1;firestore\",\"java_multiple_files\":true,\"java_outer_classname\":\"WriteProto\",\"java_package\":\"com.google.firestore.v1beta1\",\"objc_class_prefix\":\"GCFS\",\"php_namespace\":\"Google\\\\\\\\Cloud\\\\\\\\Firestore\\\\\\\\V1beta1\"},\"nested\":{\"DocumentMask\":{\"fields\":{\"fieldPaths\":{\"rule\":\"repeated\",\"type\":\"string\",\"id\":1}}},\"Precondition\":{\"oneofs\":{\"conditionType\":{\"oneof\":[\"exists\",\"updateTime\"]}},\"fields\":{\"exists\":{\"type\":\"bool\",\"id\":1},\"updateTime\":{\"type\":\"google.protobuf.Timestamp\",\"id\":2}}},\"TransactionOptions\":{\"oneofs\":{\"mode\":{\"oneof\":[\"readOnly\",\"readWrite\"]}},\"fields\":{\"readOnly\":{\"type\":\"ReadOnly\",\"id\":2},\"readWrite\":{\"type\":\"ReadWrite\",\"id\":3}},\"nested\":{\"ReadWrite\":{\"fields\":{\"retryTransaction\":{\"type\":\"bytes\",\"id\":1}}},\"ReadOnly\":{\"oneofs\":{\"consistencySelector\":{\"oneof\":[\"readTime\"]}},\"fields\":{\"readTime\":{\"type\":\"google.protobuf.Timestamp\",\"id\":2}}}}},\"Document\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1},\"fields\":{\"keyType\":\"string\",\"type\":\"Value\",\"id\":2},\"createTime\":{\"type\":\"google.protobuf.Timestamp\",\"id\":3},\"updateTime\":{\"type\":\"google.protobuf.Timestamp\",\"id\":4}}},\"Value\":{\"oneofs\":{\"valueType\":{\"oneof\":[\"nullValue\",\"booleanValue\",\"integerValue\",\"doubleValue\",\"timestampValue\",\"stringValue\",\"bytesValue\",\"referenceValue\",\"geoPointValue\",\"arrayValue\",\"mapValue\"]}},\"fields\":{\"nullValue\":{\"type\":\"google.protobuf.NullValue\",\"id\":11},\"booleanValue\":{\"type\":\"bool\",\"id\":1},\"integerValue\":{\"type\":\"int64\",\"id\":2},\"doubleValue\":{\"type\":\"double\",\"id\":3},\"timestampValue\":{\"type\":\"google.protobuf.Timestamp\",\"id\":10},\"stringValue\":{\"type\":\"string\",\"id\":17},\"bytesValue\":{\"type\":\"bytes\",\"id\":18},\"referenceValue\":{\"type\":\"string\",\"id\":5},\"geoPointValue\":{\"type\":\"google.type.LatLng\",\"id\":8},\"arrayValue\":{\"type\":\"ArrayValue\",\"id\":9},\"mapValue\":{\"type\":\"MapValue\",\"id\":6}}},\"ArrayValue\":{\"fields\":{\"values\":{\"rule\":\"repeated\",\"type\":\"Value\",\"id\":1}}},\"MapValue\":{\"fields\":{\"fields\":{\"keyType\":\"string\",\"type\":\"Value\",\"id\":1}}},\"Firestore\":{\"options\":{\"(google.api.default_host)\":\"firestore.googleapis.com\",\"(google.api.oauth_scopes)\":\"https://www.googleapis.com/auth/cloud-platform,https://www.googleapis.com/auth/datastore\"},\"methods\":{\"GetDocument\":{\"requestType\":\"GetDocumentRequest\",\"responseType\":\"Document\",\"options\":{\"(google.api.http).get\":\"/v1beta1/{name=projects/*/databases/*/documents/*/**}\"}},\"ListDocuments\":{\"requestType\":\"ListDocumentsRequest\",\"responseType\":\"ListDocumentsResponse\",\"options\":{\"(google.api.http).get\":\"/v1beta1/{parent=projects/*/databases/*/documents/*/**}/{collection_id}\"}},\"CreateDocument\":{\"requestType\":\"CreateDocumentRequest\",\"responseType\":\"Document\",\"options\":{\"(google.api.http).post\":\"/v1beta1/{parent=projects/*/databases/*/documents/**}/{collection_id}\",\"(google.api.http).body\":\"document\"}},\"UpdateDocument\":{\"requestType\":\"UpdateDocumentRequest\",\"responseType\":\"Document\",\"options\":{\"(google.api.http).patch\":\"/v1beta1/{document.name=projects/*/databases/*/documents/*/**}\",\"(google.api.http).body\":\"document\",\"(google.api.method_signature)\":\"document,update_mask\"}},\"DeleteDocument\":{\"requestType\":\"DeleteDocumentRequest\",\"responseType\":\"google.protobuf.Empty\",\"options\":{\"(google.api.http).delete\":\"/v1beta1/{name=projects/*/databases/*/documents/*/**}\",\"(google.api.method_signature)\":\"name\"}},\"BatchGetDocuments\":{\"requestType\":\"BatchGetDocumentsRequest\",\"responseType\":\"BatchGetDocumentsResponse\",\"responseStream\":true,\"options\":{\"(google.api.http).post\":\"/v1beta1/{database=projects/*/databases/*}/documents:batchGet\",\"(google.api.http).body\":\"*\"}},\"BeginTransaction\":{\"requestType\":\"BeginTransactionRequest\",\"responseType\":\"BeginTransactionResponse\",\"options\":{\"(google.api.http).post\":\"/v1beta1/{database=projects/*/databases/*}/documents:beginTransaction\",\"(google.api.http).body\":\"*\",\"(google.api.method_signature)\":\"database\"}},\"Commit\":{\"requestType\":\"CommitRequest\",\"responseType\":\"CommitResponse\",\"options\":{\"(google.api.http).post\":\"/v1beta1/{database=projects/*/databases/*}/documents:commit\",\"(google.api.http).body\":\"*\",\"(google.api.method_signature)\":\"database,writes\"}},\"Rollback\":{\"requestType\":\"RollbackRequest\",\"responseType\":\"google.protobuf.Empty\",\"options\":{\"(google.api.http).post\":\"/v1beta1/{database=projects/*/databases/*}/documents:rollback\",\"(google.api.http).body\":\"*\",\"(google.api.method_signature)\":\"database,transaction\"}},\"RunQuery\":{\"requestType\":\"RunQueryRequest\",\"responseType\":\"RunQueryResponse\",\"responseStream\":true,\"options\":{\"(google.api.http).post\":\"/v1beta1/{parent=projects/*/databases/*/documents}:runQuery\",\"(google.api.http).body\":\"*\",\"(google.api.http).additional_bindings.post\":\"/v1beta1/{parent=projects/*/databases/*/documents/*/**}:runQuery\",\"(google.api.http).additional_bindings.body\":\"*\"}},\"Write\":{\"requestType\":\"WriteRequest\",\"requestStream\":true,\"responseType\":\"WriteResponse\",\"responseStream\":true,\"options\":{\"(google.api.http).post\":\"/v1beta1/{database=projects/*/databases/*}/documents:write\",\"(google.api.http).body\":\"*\"}},\"Listen\":{\"requestType\":\"ListenRequest\",\"requestStream\":true,\"responseType\":\"ListenResponse\",\"responseStream\":true,\"options\":{\"(google.api.http).post\":\"/v1beta1/{database=projects/*/databases/*}/documents:listen\",\"(google.api.http).body\":\"*\"}},\"ListCollectionIds\":{\"requestType\":\"ListCollectionIdsRequest\",\"responseType\":\"ListCollectionIdsResponse\",\"options\":{\"(google.api.http).post\":\"/v1beta1/{parent=projects/*/databases/*/documents}:listCollectionIds\",\"(google.api.http).body\":\"*\",\"(google.api.http).additional_bindings.post\":\"/v1beta1/{parent=projects/*/databases/*/documents/*/**}:listCollectionIds\",\"(google.api.http).additional_bindings.body\":\"*\",\"(google.api.method_signature)\":\"parent\"}}}},\"GetDocumentRequest\":{\"oneofs\":{\"consistencySelector\":{\"oneof\":[\"transaction\",\"readTime\"]}},\"fields\":{\"name\":{\"type\":\"string\",\"id\":1,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\"}},\"mask\":{\"type\":\"DocumentMask\",\"id\":2},\"transaction\":{\"type\":\"bytes\",\"id\":3},\"readTime\":{\"type\":\"google.protobuf.Timestamp\",\"id\":5}}},\"ListDocumentsRequest\":{\"oneofs\":{\"consistencySelector\":{\"oneof\":[\"transaction\",\"readTime\"]}},\"fields\":{\"parent\":{\"type\":\"string\",\"id\":1,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\"}},\"collectionId\":{\"type\":\"string\",\"id\":2,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\"}},\"pageSize\":{\"type\":\"int32\",\"id\":3},\"pageToken\":{\"type\":\"string\",\"id\":4},\"orderBy\":{\"type\":\"string\",\"id\":6},\"mask\":{\"type\":\"DocumentMask\",\"id\":7},\"transaction\":{\"type\":\"bytes\",\"id\":8},\"readTime\":{\"type\":\"google.protobuf.Timestamp\",\"id\":10},\"showMissing\":{\"type\":\"bool\",\"id\":12}}},\"ListDocumentsResponse\":{\"fields\":{\"documents\":{\"rule\":\"repeated\",\"type\":\"Document\",\"id\":1},\"nextPageToken\":{\"type\":\"string\",\"id\":2}}},\"CreateDocumentRequest\":{\"fields\":{\"parent\":{\"type\":\"string\",\"id\":1,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\"}},\"collectionId\":{\"type\":\"string\",\"id\":2,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\"}},\"documentId\":{\"type\":\"string\",\"id\":3},\"document\":{\"type\":\"Document\",\"id\":4,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\"}},\"mask\":{\"type\":\"DocumentMask\",\"id\":5}}},\"UpdateDocumentRequest\":{\"fields\":{\"document\":{\"type\":\"Document\",\"id\":1,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\"}},\"updateMask\":{\"type\":\"DocumentMask\",\"id\":2},\"mask\":{\"type\":\"DocumentMask\",\"id\":3},\"currentDocument\":{\"type\":\"Precondition\",\"id\":4}}},\"DeleteDocumentRequest\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\"}},\"currentDocument\":{\"type\":\"Precondition\",\"id\":2}}},\"BatchGetDocumentsRequest\":{\"oneofs\":{\"consistencySelector\":{\"oneof\":[\"transaction\",\"newTransaction\",\"readTime\"]}},\"fields\":{\"database\":{\"type\":\"string\",\"id\":1,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\"}},\"documents\":{\"rule\":\"repeated\",\"type\":\"string\",\"id\":2},\"mask\":{\"type\":\"DocumentMask\",\"id\":3},\"transaction\":{\"type\":\"bytes\",\"id\":4},\"newTransaction\":{\"type\":\"TransactionOptions\",\"id\":5},\"readTime\":{\"type\":\"google.protobuf.Timestamp\",\"id\":7}}},\"BatchGetDocumentsResponse\":{\"oneofs\":{\"result\":{\"oneof\":[\"found\",\"missing\"]}},\"fields\":{\"found\":{\"type\":\"Document\",\"id\":1},\"missing\":{\"type\":\"string\",\"id\":2},\"transaction\":{\"type\":\"bytes\",\"id\":3},\"readTime\":{\"type\":\"google.protobuf.Timestamp\",\"id\":4}}},\"BeginTransactionRequest\":{\"fields\":{\"database\":{\"type\":\"string\",\"id\":1,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\"}},\"options\":{\"type\":\"TransactionOptions\",\"id\":2}}},\"BeginTransactionResponse\":{\"fields\":{\"transaction\":{\"type\":\"bytes\",\"id\":1}}},\"CommitRequest\":{\"fields\":{\"database\":{\"type\":\"string\",\"id\":1,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\"}},\"writes\":{\"rule\":\"repeated\",\"type\":\"Write\",\"id\":2},\"transaction\":{\"type\":\"bytes\",\"id\":3}}},\"CommitResponse\":{\"fields\":{\"writeResults\":{\"rule\":\"repeated\",\"type\":\"WriteResult\",\"id\":1},\"commitTime\":{\"type\":\"google.protobuf.Timestamp\",\"id\":2}}},\"RollbackRequest\":{\"fields\":{\"database\":{\"type\":\"string\",\"id\":1,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\"}},\"transaction\":{\"type\":\"bytes\",\"id\":2,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\"}}}},\"RunQueryRequest\":{\"oneofs\":{\"queryType\":{\"oneof\":[\"structuredQuery\"]},\"consistencySelector\":{\"oneof\":[\"transaction\",\"newTransaction\",\"readTime\"]}},\"fields\":{\"parent\":{\"type\":\"string\",\"id\":1,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\"}},\"structuredQuery\":{\"type\":\"StructuredQuery\",\"id\":2},\"transaction\":{\"type\":\"bytes\",\"id\":5},\"newTransaction\":{\"type\":\"TransactionOptions\",\"id\":6},\"readTime\":{\"type\":\"google.protobuf.Timestamp\",\"id\":7}}},\"RunQueryResponse\":{\"fields\":{\"transaction\":{\"type\":\"bytes\",\"id\":2},\"document\":{\"type\":\"Document\",\"id\":1},\"readTime\":{\"type\":\"google.protobuf.Timestamp\",\"id\":3},\"skippedResults\":{\"type\":\"int32\",\"id\":4}}},\"WriteRequest\":{\"fields\":{\"database\":{\"type\":\"string\",\"id\":1,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\"}},\"streamId\":{\"type\":\"string\",\"id\":2},\"writes\":{\"rule\":\"repeated\",\"type\":\"Write\",\"id\":3},\"streamToken\":{\"type\":\"bytes\",\"id\":4},\"labels\":{\"keyType\":\"string\",\"type\":\"string\",\"id\":5}}},\"WriteResponse\":{\"fields\":{\"streamId\":{\"type\":\"string\",\"id\":1},\"streamToken\":{\"type\":\"bytes\",\"id\":2},\"writeResults\":{\"rule\":\"repeated\",\"type\":\"WriteResult\",\"id\":3},\"commitTime\":{\"type\":\"google.protobuf.Timestamp\",\"id\":4}}},\"ListenRequest\":{\"oneofs\":{\"targetChange\":{\"oneof\":[\"addTarget\",\"removeTarget\"]}},\"fields\":{\"database\":{\"type\":\"string\",\"id\":1,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\"}},\"addTarget\":{\"type\":\"Target\",\"id\":2},\"removeTarget\":{\"type\":\"int32\",\"id\":3},\"labels\":{\"keyType\":\"string\",\"type\":\"string\",\"id\":4}}},\"ListenResponse\":{\"oneofs\":{\"responseType\":{\"oneof\":[\"targetChange\",\"documentChange\",\"documentDelete\",\"documentRemove\",\"filter\"]}},\"fields\":{\"targetChange\":{\"type\":\"TargetChange\",\"id\":2},\"documentChange\":{\"type\":\"DocumentChange\",\"id\":3},\"documentDelete\":{\"type\":\"DocumentDelete\",\"id\":4},\"documentRemove\":{\"type\":\"DocumentRemove\",\"id\":6},\"filter\":{\"type\":\"ExistenceFilter\",\"id\":5}}},\"Target\":{\"oneofs\":{\"targetType\":{\"oneof\":[\"query\",\"documents\"]},\"resumeType\":{\"oneof\":[\"resumeToken\",\"readTime\"]}},\"fields\":{\"query\":{\"type\":\"QueryTarget\",\"id\":2},\"documents\":{\"type\":\"DocumentsTarget\",\"id\":3},\"resumeToken\":{\"type\":\"bytes\",\"id\":4},\"readTime\":{\"type\":\"google.protobuf.Timestamp\",\"id\":11},\"targetId\":{\"type\":\"int32\",\"id\":5},\"once\":{\"type\":\"bool\",\"id\":6}},\"nested\":{\"DocumentsTarget\":{\"fields\":{\"documents\":{\"rule\":\"repeated\",\"type\":\"string\",\"id\":2}}},\"QueryTarget\":{\"oneofs\":{\"queryType\":{\"oneof\":[\"structuredQuery\"]}},\"fields\":{\"parent\":{\"type\":\"string\",\"id\":1},\"structuredQuery\":{\"type\":\"StructuredQuery\",\"id\":2}}}}},\"TargetChange\":{\"fields\":{\"targetChangeType\":{\"type\":\"TargetChangeType\",\"id\":1},\"targetIds\":{\"rule\":\"repeated\",\"type\":\"int32\",\"id\":2},\"cause\":{\"type\":\"google.rpc.Status\",\"id\":3},\"resumeToken\":{\"type\":\"bytes\",\"id\":4},\"readTime\":{\"type\":\"google.protobuf.Timestamp\",\"id\":6}},\"nested\":{\"TargetChangeType\":{\"values\":{\"NO_CHANGE\":0,\"ADD\":1,\"REMOVE\":2,\"CURRENT\":3,\"RESET\":4}}}},\"ListCollectionIdsRequest\":{\"fields\":{\"parent\":{\"type\":\"string\",\"id\":1,\"options\":{\"(google.api.field_behavior)\":\"REQUIRED\"}},\"pageSize\":{\"type\":\"int32\",\"id\":2},\"pageToken\":{\"type\":\"string\",\"id\":3}}},\"ListCollectionIdsResponse\":{\"fields\":{\"collectionIds\":{\"rule\":\"repeated\",\"type\":\"string\",\"id\":1},\"nextPageToken\":{\"type\":\"string\",\"id\":2}}},\"StructuredQuery\":{\"fields\":{\"select\":{\"type\":\"Projection\",\"id\":1},\"from\":{\"rule\":\"repeated\",\"type\":\"CollectionSelector\",\"id\":2},\"where\":{\"type\":\"Filter\",\"id\":3},\"orderBy\":{\"rule\":\"repeated\",\"type\":\"Order\",\"id\":4},\"startAt\":{\"type\":\"Cursor\",\"id\":7},\"endAt\":{\"type\":\"Cursor\",\"id\":8},\"offset\":{\"type\":\"int32\",\"id\":6},\"limit\":{\"type\":\"google.protobuf.Int32Value\",\"id\":5}},\"nested\":{\"CollectionSelector\":{\"fields\":{\"collectionId\":{\"type\":\"string\",\"id\":2},\"allDescendants\":{\"type\":\"bool\",\"id\":3}}},\"Filter\":{\"oneofs\":{\"filterType\":{\"oneof\":[\"compositeFilter\",\"fieldFilter\",\"unaryFilter\"]}},\"fields\":{\"compositeFilter\":{\"type\":\"CompositeFilter\",\"id\":1},\"fieldFilter\":{\"type\":\"FieldFilter\",\"id\":2},\"unaryFilter\":{\"type\":\"UnaryFilter\",\"id\":3}}},\"CompositeFilter\":{\"fields\":{\"op\":{\"type\":\"Operator\",\"id\":1},\"filters\":{\"rule\":\"repeated\",\"type\":\"Filter\",\"id\":2}},\"nested\":{\"Operator\":{\"values\":{\"OPERATOR_UNSPECIFIED\":0,\"AND\":1}}}},\"FieldFilter\":{\"fields\":{\"field\":{\"type\":\"FieldReference\",\"id\":1},\"op\":{\"type\":\"Operator\",\"id\":2},\"value\":{\"type\":\"Value\",\"id\":3}},\"nested\":{\"Operator\":{\"values\":{\"OPERATOR_UNSPECIFIED\":0,\"LESS_THAN\":1,\"LESS_THAN_OR_EQUAL\":2,\"GREATER_THAN\":3,\"GREATER_THAN_OR_EQUAL\":4,\"EQUAL\":5,\"ARRAY_CONTAINS\":7,\"IN\":8,\"ARRAY_CONTAINS_ANY\":9}}}},\"UnaryFilter\":{\"oneofs\":{\"operandType\":{\"oneof\":[\"field\"]}},\"fields\":{\"op\":{\"type\":\"Operator\",\"id\":1},\"field\":{\"type\":\"FieldReference\",\"id\":2}},\"nested\":{\"Operator\":{\"values\":{\"OPERATOR_UNSPECIFIED\":0,\"IS_NAN\":2,\"IS_NULL\":3}}}},\"Order\":{\"fields\":{\"field\":{\"type\":\"FieldReference\",\"id\":1},\"direction\":{\"type\":\"Direction\",\"id\":2}}},\"FieldReference\":{\"fields\":{\"fieldPath\":{\"type\":\"string\",\"id\":2}}},\"Projection\":{\"fields\":{\"fields\":{\"rule\":\"repeated\",\"type\":\"FieldReference\",\"id\":2}}},\"Direction\":{\"values\":{\"DIRECTION_UNSPECIFIED\":0,\"ASCENDING\":1,\"DESCENDING\":2}}}},\"Cursor\":{\"fields\":{\"values\":{\"rule\":\"repeated\",\"type\":\"Value\",\"id\":1},\"before\":{\"type\":\"bool\",\"id\":2}}},\"Write\":{\"oneofs\":{\"operation\":{\"oneof\":[\"update\",\"delete\",\"transform\"]}},\"fields\":{\"update\":{\"type\":\"Document\",\"id\":1},\"delete\":{\"type\":\"string\",\"id\":2},\"transform\":{\"type\":\"DocumentTransform\",\"id\":6},\"updateMask\":{\"type\":\"DocumentMask\",\"id\":3},\"currentDocument\":{\"type\":\"Precondition\",\"id\":4}}},\"DocumentTransform\":{\"fields\":{\"document\":{\"type\":\"string\",\"id\":1},\"fieldTransforms\":{\"rule\":\"repeated\",\"type\":\"FieldTransform\",\"id\":2}},\"nested\":{\"FieldTransform\":{\"oneofs\":{\"transformType\":{\"oneof\":[\"setToServerValue\",\"increment\",\"maximum\",\"minimum\",\"appendMissingElements\",\"removeAllFromArray\"]}},\"fields\":{\"fieldPath\":{\"type\":\"string\",\"id\":1},\"setToServerValue\":{\"type\":\"ServerValue\",\"id\":2},\"increment\":{\"type\":\"Value\",\"id\":3},\"maximum\":{\"type\":\"Value\",\"id\":4},\"minimum\":{\"type\":\"Value\",\"id\":5},\"appendMissingElements\":{\"type\":\"ArrayValue\",\"id\":6},\"removeAllFromArray\":{\"type\":\"ArrayValue\",\"id\":7}},\"nested\":{\"ServerValue\":{\"values\":{\"SERVER_VALUE_UNSPECIFIED\":0,\"REQUEST_TIME\":1}}}}}},\"WriteResult\":{\"fields\":{\"updateTime\":{\"type\":\"google.protobuf.Timestamp\",\"id\":1},\"transformResults\":{\"rule\":\"repeated\",\"type\":\"Value\",\"id\":2}}},\"DocumentChange\":{\"fields\":{\"document\":{\"type\":\"Document\",\"id\":1},\"targetIds\":{\"rule\":\"repeated\",\"type\":\"int32\",\"id\":5},\"removedTargetIds\":{\"rule\":\"repeated\",\"type\":\"int32\",\"id\":6}}},\"DocumentDelete\":{\"fields\":{\"document\":{\"type\":\"string\",\"id\":1},\"removedTargetIds\":{\"rule\":\"repeated\",\"type\":\"int32\",\"id\":6},\"readTime\":{\"type\":\"google.protobuf.Timestamp\",\"id\":4}}},\"DocumentRemove\":{\"fields\":{\"document\":{\"type\":\"string\",\"id\":1},\"removedTargetIds\":{\"rule\":\"repeated\",\"type\":\"int32\",\"id\":2},\"readTime\":{\"type\":\"google.protobuf.Timestamp\",\"id\":4}}},\"ExistenceFilter\":{\"fields\":{\"targetId\":{\"type\":\"int32\",\"id\":1},\"count\":{\"type\":\"int32\",\"id\":2}}}}}}},\"api\":{\"options\":{\"cc_enable_arenas\":true,\"go_package\":\"google.golang.org/genproto/googleapis/api/annotations;annotations\",\"java_multiple_files\":true,\"java_outer_classname\":\"FieldBehaviorProto\",\"java_package\":\"com.google.api\",\"objc_class_prefix\":\"GAPI\"},\"nested\":{\"resourceReference\":{\"type\":\"google.api.ResourceReference\",\"id\":1055,\"extend\":\"google.protobuf.FieldOptions\"},\"resourceDefinition\":{\"rule\":\"repeated\",\"type\":\"google.api.ResourceDescriptor\",\"id\":1053,\"extend\":\"google.protobuf.FileOptions\"},\"resource\":{\"type\":\"google.api.ResourceDescriptor\",\"id\":1053,\"extend\":\"google.protobuf.MessageOptions\"},\"ResourceDescriptor\":{\"fields\":{\"type\":{\"type\":\"string\",\"id\":1},\"pattern\":{\"rule\":\"repeated\",\"type\":\"string\",\"id\":2},\"nameField\":{\"type\":\"string\",\"id\":3},\"history\":{\"type\":\"History\",\"id\":4},\"plural\":{\"type\":\"string\",\"id\":5},\"singular\":{\"type\":\"string\",\"id\":6}},\"nested\":{\"History\":{\"values\":{\"HISTORY_UNSPECIFIED\":0,\"ORIGINALLY_SINGLE_PATTERN\":1,\"FUTURE_MULTI_PATTERN\":2}}}},\"ResourceReference\":{\"fields\":{\"type\":{\"type\":\"string\",\"id\":1},\"childType\":{\"type\":\"string\",\"id\":2}}},\"http\":{\"type\":\"HttpRule\",\"id\":72295728,\"extend\":\"google.protobuf.MethodOptions\"},\"Http\":{\"fields\":{\"rules\":{\"rule\":\"repeated\",\"type\":\"HttpRule\",\"id\":1},\"fullyDecodeReservedExpansion\":{\"type\":\"bool\",\"id\":2}}},\"HttpRule\":{\"oneofs\":{\"pattern\":{\"oneof\":[\"get\",\"put\",\"post\",\"delete\",\"patch\",\"custom\"]}},\"fields\":{\"selector\":{\"type\":\"string\",\"id\":1},\"get\":{\"type\":\"string\",\"id\":2},\"put\":{\"type\":\"string\",\"id\":3},\"post\":{\"type\":\"string\",\"id\":4},\"delete\":{\"type\":\"string\",\"id\":5},\"patch\":{\"type\":\"string\",\"id\":6},\"custom\":{\"type\":\"CustomHttpPattern\",\"id\":8},\"body\":{\"type\":\"string\",\"id\":7},\"responseBody\":{\"type\":\"string\",\"id\":12},\"additionalBindings\":{\"rule\":\"repeated\",\"type\":\"HttpRule\",\"id\":11}}},\"CustomHttpPattern\":{\"fields\":{\"kind\":{\"type\":\"string\",\"id\":1},\"path\":{\"type\":\"string\",\"id\":2}}},\"methodSignature\":{\"rule\":\"repeated\",\"type\":\"string\",\"id\":1051,\"extend\":\"google.protobuf.MethodOptions\"},\"defaultHost\":{\"type\":\"string\",\"id\":1049,\"extend\":\"google.protobuf.ServiceOptions\"},\"oauthScopes\":{\"type\":\"string\",\"id\":1050,\"extend\":\"google.protobuf.ServiceOptions\"},\"fieldBehavior\":{\"rule\":\"repeated\",\"type\":\"google.api.FieldBehavior\",\"id\":1052,\"extend\":\"google.protobuf.FieldOptions\"},\"FieldBehavior\":{\"values\":{\"FIELD_BEHAVIOR_UNSPECIFIED\":0,\"OPTIONAL\":1,\"REQUIRED\":2,\"OUTPUT_ONLY\":3,\"INPUT_ONLY\":4,\"IMMUTABLE\":5}}}},\"protobuf\":{\"options\":{\"go_package\":\"github.com/golang/protobuf/protoc-gen-go/descriptor;descriptor\",\"java_package\":\"com.google.protobuf\",\"java_outer_classname\":\"DescriptorProtos\",\"csharp_namespace\":\"Google.Protobuf.Reflection\",\"objc_class_prefix\":\"GPB\",\"cc_enable_arenas\":true,\"optimize_for\":\"SPEED\"},\"nested\":{\"FileDescriptorSet\":{\"fields\":{\"file\":{\"rule\":\"repeated\",\"type\":\"FileDescriptorProto\",\"id\":1}}},\"FileDescriptorProto\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1},\"package\":{\"type\":\"string\",\"id\":2},\"dependency\":{\"rule\":\"repeated\",\"type\":\"string\",\"id\":3},\"publicDependency\":{\"rule\":\"repeated\",\"type\":\"int32\",\"id\":10,\"options\":{\"packed\":false}},\"weakDependency\":{\"rule\":\"repeated\",\"type\":\"int32\",\"id\":11,\"options\":{\"packed\":false}},\"messageType\":{\"rule\":\"repeated\",\"type\":\"DescriptorProto\",\"id\":4},\"enumType\":{\"rule\":\"repeated\",\"type\":\"EnumDescriptorProto\",\"id\":5},\"service\":{\"rule\":\"repeated\",\"type\":\"ServiceDescriptorProto\",\"id\":6},\"extension\":{\"rule\":\"repeated\",\"type\":\"FieldDescriptorProto\",\"id\":7},\"options\":{\"type\":\"FileOptions\",\"id\":8},\"sourceCodeInfo\":{\"type\":\"SourceCodeInfo\",\"id\":9},\"syntax\":{\"type\":\"string\",\"id\":12}}},\"DescriptorProto\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1},\"field\":{\"rule\":\"repeated\",\"type\":\"FieldDescriptorProto\",\"id\":2},\"extension\":{\"rule\":\"repeated\",\"type\":\"FieldDescriptorProto\",\"id\":6},\"nestedType\":{\"rule\":\"repeated\",\"type\":\"DescriptorProto\",\"id\":3},\"enumType\":{\"rule\":\"repeated\",\"type\":\"EnumDescriptorProto\",\"id\":4},\"extensionRange\":{\"rule\":\"repeated\",\"type\":\"ExtensionRange\",\"id\":5},\"oneofDecl\":{\"rule\":\"repeated\",\"type\":\"OneofDescriptorProto\",\"id\":8},\"options\":{\"type\":\"MessageOptions\",\"id\":7},\"reservedRange\":{\"rule\":\"repeated\",\"type\":\"ReservedRange\",\"id\":9},\"reservedName\":{\"rule\":\"repeated\",\"type\":\"string\",\"id\":10}},\"nested\":{\"ExtensionRange\":{\"fields\":{\"start\":{\"type\":\"int32\",\"id\":1},\"end\":{\"type\":\"int32\",\"id\":2},\"options\":{\"type\":\"ExtensionRangeOptions\",\"id\":3}}},\"ReservedRange\":{\"fields\":{\"start\":{\"type\":\"int32\",\"id\":1},\"end\":{\"type\":\"int32\",\"id\":2}}}}},\"ExtensionRangeOptions\":{\"fields\":{\"uninterpretedOption\":{\"rule\":\"repeated\",\"type\":\"UninterpretedOption\",\"id\":999}},\"extensions\":[[1000,536870911]]},\"FieldDescriptorProto\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1},\"number\":{\"type\":\"int32\",\"id\":3},\"label\":{\"type\":\"Label\",\"id\":4},\"type\":{\"type\":\"Type\",\"id\":5},\"typeName\":{\"type\":\"string\",\"id\":6},\"extendee\":{\"type\":\"string\",\"id\":2},\"defaultValue\":{\"type\":\"string\",\"id\":7},\"oneofIndex\":{\"type\":\"int32\",\"id\":9},\"jsonName\":{\"type\":\"string\",\"id\":10},\"options\":{\"type\":\"FieldOptions\",\"id\":8}},\"nested\":{\"Type\":{\"values\":{\"TYPE_DOUBLE\":1,\"TYPE_FLOAT\":2,\"TYPE_INT64\":3,\"TYPE_UINT64\":4,\"TYPE_INT32\":5,\"TYPE_FIXED64\":6,\"TYPE_FIXED32\":7,\"TYPE_BOOL\":8,\"TYPE_STRING\":9,\"TYPE_GROUP\":10,\"TYPE_MESSAGE\":11,\"TYPE_BYTES\":12,\"TYPE_UINT32\":13,\"TYPE_ENUM\":14,\"TYPE_SFIXED32\":15,\"TYPE_SFIXED64\":16,\"TYPE_SINT32\":17,\"TYPE_SINT64\":18}},\"Label\":{\"values\":{\"LABEL_OPTIONAL\":1,\"LABEL_REQUIRED\":2,\"LABEL_REPEATED\":3}}}},\"OneofDescriptorProto\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1},\"options\":{\"type\":\"OneofOptions\",\"id\":2}}},\"EnumDescriptorProto\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1},\"value\":{\"rule\":\"repeated\",\"type\":\"EnumValueDescriptorProto\",\"id\":2},\"options\":{\"type\":\"EnumOptions\",\"id\":3},\"reservedRange\":{\"rule\":\"repeated\",\"type\":\"EnumReservedRange\",\"id\":4},\"reservedName\":{\"rule\":\"repeated\",\"type\":\"string\",\"id\":5}},\"nested\":{\"EnumReservedRange\":{\"fields\":{\"start\":{\"type\":\"int32\",\"id\":1},\"end\":{\"type\":\"int32\",\"id\":2}}}}},\"EnumValueDescriptorProto\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1},\"number\":{\"type\":\"int32\",\"id\":2},\"options\":{\"type\":\"EnumValueOptions\",\"id\":3}}},\"ServiceDescriptorProto\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1},\"method\":{\"rule\":\"repeated\",\"type\":\"MethodDescriptorProto\",\"id\":2},\"options\":{\"type\":\"ServiceOptions\",\"id\":3}}},\"MethodDescriptorProto\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1},\"inputType\":{\"type\":\"string\",\"id\":2},\"outputType\":{\"type\":\"string\",\"id\":3},\"options\":{\"type\":\"MethodOptions\",\"id\":4},\"clientStreaming\":{\"type\":\"bool\",\"id\":5,\"options\":{\"default\":false}},\"serverStreaming\":{\"type\":\"bool\",\"id\":6,\"options\":{\"default\":false}}}},\"FileOptions\":{\"fields\":{\"javaPackage\":{\"type\":\"string\",\"id\":1},\"javaOuterClassname\":{\"type\":\"string\",\"id\":8},\"javaMultipleFiles\":{\"type\":\"bool\",\"id\":10,\"options\":{\"default\":false}},\"javaGenerateEqualsAndHash\":{\"type\":\"bool\",\"id\":20,\"options\":{\"deprecated\":true}},\"javaStringCheckUtf8\":{\"type\":\"bool\",\"id\":27,\"options\":{\"default\":false}},\"optimizeFor\":{\"type\":\"OptimizeMode\",\"id\":9,\"options\":{\"default\":\"SPEED\"}},\"goPackage\":{\"type\":\"string\",\"id\":11},\"ccGenericServices\":{\"type\":\"bool\",\"id\":16,\"options\":{\"default\":false}},\"javaGenericServices\":{\"type\":\"bool\",\"id\":17,\"options\":{\"default\":false}},\"pyGenericServices\":{\"type\":\"bool\",\"id\":18,\"options\":{\"default\":false}},\"phpGenericServices\":{\"type\":\"bool\",\"id\":42,\"options\":{\"default\":false}},\"deprecated\":{\"type\":\"bool\",\"id\":23,\"options\":{\"default\":false}},\"ccEnableArenas\":{\"type\":\"bool\",\"id\":31,\"options\":{\"default\":false}},\"objcClassPrefix\":{\"type\":\"string\",\"id\":36},\"csharpNamespace\":{\"type\":\"string\",\"id\":37},\"swiftPrefix\":{\"type\":\"string\",\"id\":39},\"phpClassPrefix\":{\"type\":\"string\",\"id\":40},\"phpNamespace\":{\"type\":\"string\",\"id\":41},\"phpMetadataNamespace\":{\"type\":\"string\",\"id\":44},\"rubyPackage\":{\"type\":\"string\",\"id\":45},\"uninterpretedOption\":{\"rule\":\"repeated\",\"type\":\"UninterpretedOption\",\"id\":999}},\"extensions\":[[1000,536870911]],\"reserved\":[[38,38]],\"nested\":{\"OptimizeMode\":{\"values\":{\"SPEED\":1,\"CODE_SIZE\":2,\"LITE_RUNTIME\":3}}}},\"MessageOptions\":{\"fields\":{\"messageSetWireFormat\":{\"type\":\"bool\",\"id\":1,\"options\":{\"default\":false}},\"noStandardDescriptorAccessor\":{\"type\":\"bool\",\"id\":2,\"options\":{\"default\":false}},\"deprecated\":{\"type\":\"bool\",\"id\":3,\"options\":{\"default\":false}},\"mapEntry\":{\"type\":\"bool\",\"id\":7},\"uninterpretedOption\":{\"rule\":\"repeated\",\"type\":\"UninterpretedOption\",\"id\":999}},\"extensions\":[[1000,536870911]],\"reserved\":[[8,8],[9,9]]},\"FieldOptions\":{\"fields\":{\"ctype\":{\"type\":\"CType\",\"id\":1,\"options\":{\"default\":\"STRING\"}},\"packed\":{\"type\":\"bool\",\"id\":2},\"jstype\":{\"type\":\"JSType\",\"id\":6,\"options\":{\"default\":\"JS_NORMAL\"}},\"lazy\":{\"type\":\"bool\",\"id\":5,\"options\":{\"default\":false}},\"deprecated\":{\"type\":\"bool\",\"id\":3,\"options\":{\"default\":false}},\"weak\":{\"type\":\"bool\",\"id\":10,\"options\":{\"default\":false}},\"uninterpretedOption\":{\"rule\":\"repeated\",\"type\":\"UninterpretedOption\",\"id\":999}},\"extensions\":[[1000,536870911]],\"reserved\":[[4,4]],\"nested\":{\"CType\":{\"values\":{\"STRING\":0,\"CORD\":1,\"STRING_PIECE\":2}},\"JSType\":{\"values\":{\"JS_NORMAL\":0,\"JS_STRING\":1,\"JS_NUMBER\":2}}}},\"OneofOptions\":{\"fields\":{\"uninterpretedOption\":{\"rule\":\"repeated\",\"type\":\"UninterpretedOption\",\"id\":999}},\"extensions\":[[1000,536870911]]},\"EnumOptions\":{\"fields\":{\"allowAlias\":{\"type\":\"bool\",\"id\":2},\"deprecated\":{\"type\":\"bool\",\"id\":3,\"options\":{\"default\":false}},\"uninterpretedOption\":{\"rule\":\"repeated\",\"type\":\"UninterpretedOption\",\"id\":999}},\"extensions\":[[1000,536870911]],\"reserved\":[[5,5]]},\"EnumValueOptions\":{\"fields\":{\"deprecated\":{\"type\":\"bool\",\"id\":1,\"options\":{\"default\":false}},\"uninterpretedOption\":{\"rule\":\"repeated\",\"type\":\"UninterpretedOption\",\"id\":999}},\"extensions\":[[1000,536870911]]},\"ServiceOptions\":{\"fields\":{\"deprecated\":{\"type\":\"bool\",\"id\":33,\"options\":{\"default\":false}},\"uninterpretedOption\":{\"rule\":\"repeated\",\"type\":\"UninterpretedOption\",\"id\":999}},\"extensions\":[[1000,536870911]]},\"MethodOptions\":{\"fields\":{\"deprecated\":{\"type\":\"bool\",\"id\":33,\"options\":{\"default\":false}},\"idempotencyLevel\":{\"type\":\"IdempotencyLevel\",\"id\":34,\"options\":{\"default\":\"IDEMPOTENCY_UNKNOWN\"}},\"uninterpretedOption\":{\"rule\":\"repeated\",\"type\":\"UninterpretedOption\",\"id\":999}},\"extensions\":[[1000,536870911]],\"nested\":{\"IdempotencyLevel\":{\"values\":{\"IDEMPOTENCY_UNKNOWN\":0,\"NO_SIDE_EFFECTS\":1,\"IDEMPOTENT\":2}}}},\"UninterpretedOption\":{\"fields\":{\"name\":{\"rule\":\"repeated\",\"type\":\"NamePart\",\"id\":2},\"identifierValue\":{\"type\":\"string\",\"id\":3},\"positiveIntValue\":{\"type\":\"uint64\",\"id\":4},\"negativeIntValue\":{\"type\":\"int64\",\"id\":5},\"doubleValue\":{\"type\":\"double\",\"id\":6},\"stringValue\":{\"type\":\"bytes\",\"id\":7},\"aggregateValue\":{\"type\":\"string\",\"id\":8}},\"nested\":{\"NamePart\":{\"fields\":{\"namePart\":{\"rule\":\"required\",\"type\":\"string\",\"id\":1},\"isExtension\":{\"rule\":\"required\",\"type\":\"bool\",\"id\":2}}}}},\"SourceCodeInfo\":{\"fields\":{\"location\":{\"rule\":\"repeated\",\"type\":\"Location\",\"id\":1}},\"nested\":{\"Location\":{\"fields\":{\"path\":{\"rule\":\"repeated\",\"type\":\"int32\",\"id\":1},\"span\":{\"rule\":\"repeated\",\"type\":\"int32\",\"id\":2},\"leadingComments\":{\"type\":\"string\",\"id\":3},\"trailingComments\":{\"type\":\"string\",\"id\":4},\"leadingDetachedComments\":{\"rule\":\"repeated\",\"type\":\"string\",\"id\":6}}}}},\"GeneratedCodeInfo\":{\"fields\":{\"annotation\":{\"rule\":\"repeated\",\"type\":\"Annotation\",\"id\":1}},\"nested\":{\"Annotation\":{\"fields\":{\"path\":{\"rule\":\"repeated\",\"type\":\"int32\",\"id\":1},\"sourceFile\":{\"type\":\"string\",\"id\":2},\"begin\":{\"type\":\"int32\",\"id\":3},\"end\":{\"type\":\"int32\",\"id\":4}}}}},\"Any\":{\"fields\":{\"type_url\":{\"type\":\"string\",\"id\":1},\"value\":{\"type\":\"bytes\",\"id\":2}}},\"Duration\":{\"fields\":{\"seconds\":{\"type\":\"int64\",\"id\":1},\"nanos\":{\"type\":\"int32\",\"id\":2}}},\"Empty\":{\"fields\":{}},\"FieldMask\":{\"fields\":{\"paths\":{\"rule\":\"repeated\",\"type\":\"string\",\"id\":1}}},\"Timestamp\":{\"fields\":{\"seconds\":{\"type\":\"int64\",\"id\":1},\"nanos\":{\"type\":\"int32\",\"id\":2}}},\"Struct\":{\"fields\":{\"fields\":{\"keyType\":\"string\",\"type\":\"Value\",\"id\":1}}},\"Value\":{\"oneofs\":{\"kind\":{\"oneof\":[\"nullValue\",\"numberValue\",\"stringValue\",\"boolValue\",\"structValue\",\"listValue\"]}},\"fields\":{\"nullValue\":{\"type\":\"NullValue\",\"id\":1},\"numberValue\":{\"type\":\"double\",\"id\":2},\"stringValue\":{\"type\":\"string\",\"id\":3},\"boolValue\":{\"type\":\"bool\",\"id\":4},\"structValue\":{\"type\":\"Struct\",\"id\":5},\"listValue\":{\"type\":\"ListValue\",\"id\":6}}},\"NullValue\":{\"values\":{\"NULL_VALUE\":0}},\"ListValue\":{\"fields\":{\"values\":{\"rule\":\"repeated\",\"type\":\"Value\",\"id\":1}}},\"DoubleValue\":{\"fields\":{\"value\":{\"type\":\"double\",\"id\":1}}},\"FloatValue\":{\"fields\":{\"value\":{\"type\":\"float\",\"id\":1}}},\"Int64Value\":{\"fields\":{\"value\":{\"type\":\"int64\",\"id\":1}}},\"UInt64Value\":{\"fields\":{\"value\":{\"type\":\"uint64\",\"id\":1}}},\"Int32Value\":{\"fields\":{\"value\":{\"type\":\"int32\",\"id\":1}}},\"UInt32Value\":{\"fields\":{\"value\":{\"type\":\"uint32\",\"id\":1}}},\"BoolValue\":{\"fields\":{\"value\":{\"type\":\"bool\",\"id\":1}}},\"StringValue\":{\"fields\":{\"value\":{\"type\":\"string\",\"id\":1}}},\"BytesValue\":{\"fields\":{\"value\":{\"type\":\"bytes\",\"id\":1}}}}},\"longrunning\":{\"options\":{\"cc_enable_arenas\":true,\"csharp_namespace\":\"Google.LongRunning\",\"go_package\":\"google.golang.org/genproto/googleapis/longrunning;longrunning\",\"java_multiple_files\":true,\"java_outer_classname\":\"OperationsProto\",\"java_package\":\"com.google.longrunning\",\"php_namespace\":\"Google\\\\\\\\LongRunning\"},\"nested\":{\"operationInfo\":{\"type\":\"google.longrunning.OperationInfo\",\"id\":1049,\"extend\":\"google.protobuf.MethodOptions\"},\"Operations\":{\"methods\":{\"ListOperations\":{\"requestType\":\"ListOperationsRequest\",\"responseType\":\"ListOperationsResponse\",\"options\":{\"(google.api.http).get\":\"/v1/{name=operations}\"}},\"GetOperation\":{\"requestType\":\"GetOperationRequest\",\"responseType\":\"Operation\",\"options\":{\"(google.api.http).get\":\"/v1/{name=operations/**}\"}},\"DeleteOperation\":{\"requestType\":\"DeleteOperationRequest\",\"responseType\":\"google.protobuf.Empty\",\"options\":{\"(google.api.http).delete\":\"/v1/{name=operations/**}\"}},\"CancelOperation\":{\"requestType\":\"CancelOperationRequest\",\"responseType\":\"google.protobuf.Empty\",\"options\":{\"(google.api.http).post\":\"/v1/{name=operations/**}:cancel\",\"(google.api.http).body\":\"*\"}},\"WaitOperation\":{\"requestType\":\"WaitOperationRequest\",\"responseType\":\"Operation\"}}},\"Operation\":{\"oneofs\":{\"result\":{\"oneof\":[\"error\",\"response\"]}},\"fields\":{\"name\":{\"type\":\"string\",\"id\":1},\"metadata\":{\"type\":\"google.protobuf.Any\",\"id\":2},\"done\":{\"type\":\"bool\",\"id\":3},\"error\":{\"type\":\"google.rpc.Status\",\"id\":4},\"response\":{\"type\":\"google.protobuf.Any\",\"id\":5}}},\"GetOperationRequest\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1}}},\"ListOperationsRequest\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":4},\"filter\":{\"type\":\"string\",\"id\":1},\"pageSize\":{\"type\":\"int32\",\"id\":2},\"pageToken\":{\"type\":\"string\",\"id\":3}}},\"ListOperationsResponse\":{\"fields\":{\"operations\":{\"rule\":\"repeated\",\"type\":\"Operation\",\"id\":1},\"nextPageToken\":{\"type\":\"string\",\"id\":2}}},\"CancelOperationRequest\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1}}},\"DeleteOperationRequest\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1}}},\"WaitOperationRequest\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1},\"timeout\":{\"type\":\"google.protobuf.Duration\",\"id\":2}}},\"OperationInfo\":{\"fields\":{\"responseType\":{\"type\":\"string\",\"id\":1},\"metadataType\":{\"type\":\"string\",\"id\":2}}}}},\"rpc\":{\"options\":{\"go_package\":\"google.golang.org/genproto/googleapis/rpc/status;status\",\"java_multiple_files\":true,\"java_outer_classname\":\"StatusProto\",\"java_package\":\"com.google.rpc\",\"objc_class_prefix\":\"RPC\"},\"nested\":{\"Status\":{\"fields\":{\"code\":{\"type\":\"int32\",\"id\":1},\"message\":{\"type\":\"string\",\"id\":2},\"details\":{\"rule\":\"repeated\",\"type\":\"google.protobuf.Any\",\"id\":3}}}}},\"type\":{\"options\":{\"cc_enable_arenas\":true,\"go_package\":\"google.golang.org/genproto/googleapis/type/latlng;latlng\",\"java_multiple_files\":true,\"java_outer_classname\":\"LatLngProto\",\"java_package\":\"com.google.type\",\"objc_class_prefix\":\"GTP\"},\"nested\":{\"LatLng\":{\"fields\":{\"latitude\":{\"type\":\"double\",\"id\":1},\"longitude\":{\"type\":\"double\",\"id\":2}}}}}}}}}');\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/firestore/build/protos/protos.json?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/firestore/build/src/backoff.js":
/*!***********************************************************************!*\
  !*** ./src/node_modules/@google-cloud/firestore/build/src/backoff.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst logger_1 = __webpack_require__(/*! ./logger */ \"./src/node_modules/@google-cloud/firestore/build/src/logger.js\");\n/*\n * @module firestore/backoff\n * @private\n *\n * Contains backoff logic to facilitate RPC error handling. This class derives\n * its implementation from the Firestore Mobile Web Client.\n *\n * @see https://github.com/firebase/firebase-js-sdk/blob/master/packages/firestore/src/remote/backoff.ts\n */\n/*!\n * The default initial backoff time in milliseconds after an error.\n * Set to 1s according to https://cloud.google.com/apis/design/errors.\n */\nconst DEFAULT_BACKOFF_INITIAL_DELAY_MS = 1000;\n/*!\n * The default maximum backoff time in milliseconds.\n */\nconst DEFAULT_BACKOFF_MAX_DELAY_MS = 60 * 1000;\n/*!\n * The default factor to increase the backup by after each failed attempt.\n */\nconst DEFAULT_BACKOFF_FACTOR = 1.5;\n/*!\n * The default jitter to distribute the backoff attempts by (0 means no\n * randomization, 1.0 means +/-50% randomization).\n */\nconst DEFAULT_JITTER_FACTOR = 1.0;\n/*!\n * The maximum number of retries that will be attempted by backoff\n * before stopping all retry attempts.\n */\nexports.MAX_RETRY_ATTEMPTS = 10;\n/*!\n * The timeout handler used by `ExponentialBackoff` and `BulkWriter`.\n */\nexports.delayExecution = setTimeout;\n/**\n * Allows overriding of the timeout handler used by the exponential backoff\n * implementation. If not invoked, we default to `setTimeout()`.\n *\n * Used only in testing.\n *\n * @private\n * @param {function} handler A handler than matches the API of `setTimeout()`.\n */\nfunction setTimeoutHandler(handler) {\n    exports.delayExecution = (f, ms) => {\n        handler(f, ms);\n        const timeout = {\n            hasRef: () => {\n                throw new Error('For tests only. Not Implemented');\n            },\n            ref: () => {\n                throw new Error('For tests only. Not Implemented');\n            },\n            refresh: () => {\n                throw new Error('For tests only. Not Implemented');\n            },\n            unref: () => {\n                throw new Error('For tests only. Not Implemented');\n            },\n        };\n        return timeout;\n    };\n}\nexports.setTimeoutHandler = setTimeoutHandler;\n/**\n * A helper for running delayed tasks following an exponential backoff curve\n * between attempts.\n *\n * Each delay is made up of a \"base\" delay which follows the exponential\n * backoff curve, and a \"jitter\" (+/- 50% by default)  that is calculated and\n * added to the base delay. This prevents clients from accidentally\n * synchronizing their delays causing spikes of load to the backend.\n *\n * @private\n */\nclass ExponentialBackoff {\n    constructor(options = {}) {\n        /**\n         * The number of retries that has been attempted.\n         *\n         * @private\n         */\n        this._retryCount = 0;\n        /**\n         * The backoff delay of the current attempt.\n         *\n         * @private\n         */\n        this.currentBaseMs = 0;\n        /**\n         * Whether we are currently waiting for backoff to complete.\n         *\n         * @private\n         */\n        this.awaitingBackoffCompletion = false;\n        this.initialDelayMs =\n            options.initialDelayMs !== undefined\n                ? options.initialDelayMs\n                : DEFAULT_BACKOFF_INITIAL_DELAY_MS;\n        this.backoffFactor =\n            options.backoffFactor !== undefined\n                ? options.backoffFactor\n                : DEFAULT_BACKOFF_FACTOR;\n        this.maxDelayMs =\n            options.maxDelayMs !== undefined\n                ? options.maxDelayMs\n                : DEFAULT_BACKOFF_MAX_DELAY_MS;\n        this.jitterFactor =\n            options.jitterFactor !== undefined\n                ? options.jitterFactor\n                : DEFAULT_JITTER_FACTOR;\n    }\n    /**\n     * Resets the backoff delay and retry count.\n     *\n     * The very next backoffAndWait() will have no delay. If it is called again\n     * (i.e. due to an error), initialDelayMs (plus jitter) will be used, and\n     * subsequent ones will increase according to the backoffFactor.\n     *\n     * @private\n     */\n    reset() {\n        this._retryCount = 0;\n        this.currentBaseMs = 0;\n    }\n    /**\n     * Resets the backoff delay to the maximum delay (e.g. for use after a\n     * RESOURCE_EXHAUSTED error).\n     *\n     * @private\n     */\n    resetToMax() {\n        this.currentBaseMs = this.maxDelayMs;\n    }\n    /**\n     * Returns a promise that resolves after currentDelayMs, and increases the\n     * delay for any subsequent attempts.\n     *\n     * @return A Promise that resolves when the current delay elapsed.\n     * @private\n     */\n    backoffAndWait() {\n        if (this.awaitingBackoffCompletion) {\n            return Promise.reject(new Error('A backoff operation is already in progress.'));\n        }\n        if (this.retryCount > exports.MAX_RETRY_ATTEMPTS) {\n            return Promise.reject(new Error('Exceeded maximum number of retries allowed.'));\n        }\n        // First schedule using the current base (which may be 0 and should be\n        // honored as such).\n        const delayWithJitterMs = this.currentBaseMs + this.jitterDelayMs();\n        if (this.currentBaseMs > 0) {\n            logger_1.logger('ExponentialBackoff.backoffAndWait', null, `Backing off for ${delayWithJitterMs} ms ` +\n                `(base delay: ${this.currentBaseMs} ms)`);\n        }\n        // Apply backoff factor to determine next delay and ensure it is within\n        // bounds.\n        this.currentBaseMs *= this.backoffFactor;\n        this.currentBaseMs = Math.max(this.currentBaseMs, this.initialDelayMs);\n        this.currentBaseMs = Math.min(this.currentBaseMs, this.maxDelayMs);\n        this._retryCount += 1;\n        return new Promise(resolve => {\n            this.awaitingBackoffCompletion = true;\n            exports.delayExecution(() => {\n                this.awaitingBackoffCompletion = false;\n                resolve();\n            }, delayWithJitterMs);\n        });\n    }\n    // Visible for testing.\n    get retryCount() {\n        return this._retryCount;\n    }\n    /**\n     * Returns a randomized \"jitter\" delay based on the current base and jitter\n     * factor.\n     *\n     * @returns {number} The jitter to apply based on the current delay.\n     * @private\n     */\n    jitterDelayMs() {\n        return (Math.random() - 0.5) * this.jitterFactor * this.currentBaseMs;\n    }\n}\nexports.ExponentialBackoff = ExponentialBackoff;\n//# sourceMappingURL=backoff.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/firestore/build/src/backoff.js?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/firestore/build/src/bulk-writer.js":
/*!***************************************************************************!*\
  !*** ./src/node_modules/@google-cloud/firestore/build/src/bulk-writer.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*!\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst backoff_1 = __webpack_require__(/*! ./backoff */ \"./src/node_modules/@google-cloud/firestore/build/src/backoff.js\");\nconst rate_limiter_1 = __webpack_require__(/*! ./rate-limiter */ \"./src/node_modules/@google-cloud/firestore/build/src/rate-limiter.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"./src/node_modules/@google-cloud/firestore/build/src/util.js\");\nconst write_batch_1 = __webpack_require__(/*! ./write-batch */ \"./src/node_modules/@google-cloud/firestore/build/src/write-batch.js\");\n/*!\n * The maximum number of writes that can be in a single batch.\n */\nconst MAX_BATCH_SIZE = 500;\n/*!\n * The starting maximum number of operations per second as allowed by the\n * 500/50/5 rule.\n *\n * https://cloud.google.com/datastore/docs/best-practices#ramping_up_traffic.\n */\nconst STARTING_MAXIMUM_OPS_PER_SECOND = 500;\n/*!\n * The rate by which to increase the capacity as specified by the 500/50/5 rule.\n *\n * https://cloud.google.com/datastore/docs/best-practices#ramping_up_traffic.\n */\nconst RATE_LIMITER_MULTIPLIER = 1.5;\n/*!\n * How often the operations per second capacity should increase in milliseconds\n * as specified by the 500/50/5 rule.\n *\n * https://cloud.google.com/datastore/docs/best-practices#ramping_up_traffic.\n */\nconst RATE_LIMITER_MULTIPLIER_MILLIS = 5 * 60 * 1000;\n/*!\n * Used to represent the state of batch.\n *\n * Writes can only be added while the batch is OPEN. For a batch to be sent,\n * the batch must be READY_TO_SEND. After a batch is sent, it is marked as SENT.\n */\nvar BatchState;\n(function (BatchState) {\n    BatchState[BatchState[\"OPEN\"] = 0] = \"OPEN\";\n    BatchState[BatchState[\"READY_TO_SEND\"] = 1] = \"READY_TO_SEND\";\n    BatchState[BatchState[\"SENT\"] = 2] = \"SENT\";\n})(BatchState || (BatchState = {}));\n/**\n * Used to represent a batch on the BatchQueue.\n *\n * @private\n */\nclass BulkCommitBatch {\n    constructor(writeBatch, maxBatchSize) {\n        this.writeBatch = writeBatch;\n        this.maxBatchSize = maxBatchSize;\n        /**\n         * The state of the batch.\n         */\n        this.state = BatchState.OPEN;\n        // The set of document reference paths present in the WriteBatch.\n        this.docPaths = new Set();\n        // A deferred promise that is resolved after the batch has been sent, and a\n        // response is received.\n        this.completedDeferred = new util_1.Deferred();\n        // A map from each WriteBatch operation to its corresponding result.\n        this.resultsMap = new Map();\n    }\n    /**\n     * The number of writes in this batch.\n     */\n    get opCount() {\n        return this.resultsMap.size;\n    }\n    /**\n     * Adds a `create` operation to the WriteBatch. Returns a promise that\n     * resolves with the result of the write.\n     */\n    create(documentRef, data) {\n        this.writeBatch.create(documentRef, data);\n        return this.processOperation(documentRef);\n    }\n    /**\n     * Adds a `delete` operation to the WriteBatch. Returns a promise that\n     * resolves with the result of the delete.\n     */\n    delete(documentRef, precondition) {\n        this.writeBatch.delete(documentRef, precondition);\n        return this.processOperation(documentRef);\n    }\n    /**\n     * Adds a `set` operation to the WriteBatch. Returns a promise that\n     * resolves with the result of the write.\n     */\n    set(documentRef, data, options) {\n        this.writeBatch.set(documentRef, data, options);\n        return this.processOperation(documentRef);\n    }\n    /**\n     * Adds an `update` operation to the WriteBatch. Returns a promise that\n     * resolves with the result of the write.\n     */\n    update(documentRef, dataOrField, ...preconditionOrValues) {\n        this.writeBatch.update(documentRef, dataOrField, ...preconditionOrValues);\n        return this.processOperation(documentRef);\n    }\n    /**\n     * Helper to update data structures associated with the operation and\n     * return the result.\n     */\n    processOperation(documentRef) {\n        assert(!this.docPaths.has(documentRef.path), 'Batch should not contain writes to the same document');\n        assert(this.state === BatchState.OPEN, 'Batch should be OPEN when adding writes');\n        this.docPaths.add(documentRef.path);\n        const deferred = new util_1.Deferred();\n        this.resultsMap.set(this.opCount, deferred);\n        if (this.opCount === this.maxBatchSize) {\n            this.state = BatchState.READY_TO_SEND;\n        }\n        return deferred.promise.then(result => {\n            if (result.writeTime) {\n                return new write_batch_1.WriteResult(result.writeTime);\n            }\n            else {\n                throw result.status;\n            }\n        });\n    }\n    /**\n     * Commits the batch and returns a promise that resolves with the result of\n     * all writes in this batch.\n     */\n    bulkCommit() {\n        assert(this.state === BatchState.READY_TO_SEND, 'The batch should be marked as READY_TO_SEND before committing');\n        this.state = BatchState.SENT;\n        // Capture the error stack to preserve stack tracing across async calls.\n        const stack = Error().stack;\n        return this.writeBatch.bulkCommit().catch(err => {\n            throw util_1.wrapError(err, stack);\n        });\n    }\n    /**\n     * Resolves the individual operations in the batch with the results.\n     */\n    processResults(results, error) {\n        if (error === undefined) {\n            for (let i = 0; i < this.opCount; i++) {\n                this.resultsMap.get(i).resolve(results[i]);\n            }\n        }\n        else {\n            for (let i = 0; i < this.opCount; i++) {\n                this.resultsMap.get(i).reject(error);\n            }\n        }\n        this.completedDeferred.resolve();\n    }\n    /**\n     * Returns a promise that resolves when the batch has been sent, and a\n     * response is received.\n     */\n    awaitBulkCommit() {\n        this.markReadyToSend();\n        return this.completedDeferred.promise;\n    }\n    markReadyToSend() {\n        if (this.state === BatchState.OPEN) {\n            this.state = BatchState.READY_TO_SEND;\n        }\n    }\n}\n/**\n * A Firestore BulkWriter than can be used to perform a large number of writes\n * in parallel. Writes to the same document will be executed sequentially.\n *\n * @class\n * @private\n */\nclass BulkWriter {\n    constructor(firestore, enableThrottling) {\n        this.firestore = firestore;\n        /**\n         * The maximum number of writes that can be in a single batch.\n         */\n        this.maxBatchSize = MAX_BATCH_SIZE;\n        /**\n         * A queue of batches to be written.\n         */\n        this.batchQueue = [];\n        /**\n         * Whether this BulkWriter instance is closed. Once closed, it cannot be\n         * opened again.\n         */\n        this.closed = false;\n        if (enableThrottling) {\n            this.rateLimiter = new rate_limiter_1.RateLimiter(STARTING_MAXIMUM_OPS_PER_SECOND, RATE_LIMITER_MULTIPLIER, RATE_LIMITER_MULTIPLIER_MILLIS);\n        }\n        else {\n            this.rateLimiter = new rate_limiter_1.RateLimiter(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);\n        }\n    }\n    /**\n     * Create a document with the provided data. This single operation will fail\n     * if a document exists at its location.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * created.\n     * @param {T} data The object to serialize as the document.\n     * @returns {Promise<WriteResult>} A promise that resolves with the result of\n     * the write. Throws an error if the write fails.\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     * let documentRef = firestore.collection('col').doc();\n     *\n     * bulkWriter\n     *  .create(documentRef, {foo: 'bar'})\n     *  .then(result => {\n     *    console.log('Successfully executed write at: ', result);\n     *  })\n     *  .catch(err => {\n     *    console.log('Write failed with: ', err);\n     *  });\n     * });\n     */\n    create(documentRef, data) {\n        this.verifyNotClosed();\n        const bulkCommitBatch = this.getEligibleBatch(documentRef);\n        const resultPromise = bulkCommitBatch.create(documentRef, data);\n        this.sendReadyBatches();\n        return resultPromise;\n    }\n    /**\n     * Delete a document from the database.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * deleted.\n     * @param {Precondition=} precondition A precondition to enforce for this\n     * delete.\n     * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\n     * document was last updated at lastUpdateTime. Fails the batch if the\n     * document doesn't exist or was last updated at a different time.\n     * @returns {Promise<WriteResult>} A promise that resolves with the result of\n     * the write. Throws an error if the write fails.\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * bulkWriter\n     *  .delete(documentRef)\n     *  .then(result => {\n     *    console.log('Successfully deleted document at: ', result);\n     *  })\n     *  .catch(err => {\n     *    console.log('Delete failed with: ', err);\n     *  });\n     * });\n     */\n    delete(documentRef, precondition) {\n        this.verifyNotClosed();\n        const bulkCommitBatch = this.getEligibleBatch(documentRef);\n        const resultPromise = bulkCommitBatch.delete(documentRef, precondition);\n        this.sendReadyBatches();\n        return resultPromise;\n    }\n    /**\n     * Write to the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. If the document does not\n     * exist yet, it will be created. If you pass [SetOptions]{@link SetOptions}.,\n     * the provided data can be merged into the existing document.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * set.\n     * @param {T} data The object to serialize as the document.\n     * @param {SetOptions=} options An object to configure the set behavior.\n     * @param {boolean=} options.merge - If true, set() merges the values\n     * specified in its data argument. Fields omitted from this set() call remain\n     * untouched.\n     * @param {Array.<string|FieldPath>=} options.mergeFields - If provided, set()\n     * only replaces the specified field paths. Any field path that is not\n     * specified is ignored and remains untouched.\n     * @returns {Promise<WriteResult>} A promise that resolves with the result of\n     * the write. Throws an error if the write fails.\n     *\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     * let documentRef = firestore.collection('col').doc();\n     *\n     * bulkWriter\n     *  .set(documentRef, {foo: 'bar'})\n     *  .then(result => {\n     *    console.log('Successfully executed write at: ', result);\n     *  })\n     *  .catch(err => {\n     *    console.log('Write failed with: ', err);\n     *  });\n     * });\n     */\n    set(documentRef, data, options) {\n        this.verifyNotClosed();\n        const bulkCommitBatch = this.getEligibleBatch(documentRef);\n        const resultPromise = bulkCommitBatch.set(documentRef, data, options);\n        this.sendReadyBatches();\n        return resultPromise;\n    }\n    /**\n     * Update fields of the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. If the document doesn't yet\n     * exist, the update fails and the entire batch will be rejected.\n     *\n     * The update() method accepts either an object with field paths encoded as\n     * keys and field values encoded as values, or a variable number of arguments\n     * that alternate between field paths and field values. Nested fields can be\n     * updated by providing dot-separated field path strings or by providing\n     * FieldPath objects.\n     *\n     *\n     * A Precondition restricting this update can be specified as the last\n     * argument.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * updated.\n     * @param {UpdateData|string|FieldPath} dataOrField An object containing the\n     * fields and values with which to update the document or the path of the\n     * first field to update.\n     * @param {...(Precondition|*|string|FieldPath)} preconditionOrValues - An\n     * alternating list of field paths and values to update or a Precondition to\n     * restrict this update\n     * @returns {Promise<WriteResult>} A promise that resolves with the result of\n     * the write. Throws an error if the write fails.\n     *\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * bulkWriter\n     *  .update(documentRef, {foo: 'bar'})\n     *  .then(result => {\n     *    console.log('Successfully executed write at: ', result);\n     *  })\n     *  .catch(err => {\n     *    console.log('Write failed with: ', err);\n     *  });\n     * });\n     */\n    update(documentRef, dataOrField, ...preconditionOrValues) {\n        this.verifyNotClosed();\n        const bulkCommitBatch = this.getEligibleBatch(documentRef);\n        const resultPromise = bulkCommitBatch.update(documentRef, dataOrField, ...preconditionOrValues);\n        this.sendReadyBatches();\n        return resultPromise;\n    }\n    /**\n     * Commits all writes that have been enqueued up to this point in parallel.\n     *\n     * Returns a Promise that resolves when all currently queued operations have\n     * been committed. The Promise will never be rejected since the results for\n     * each individual operation are conveyed via their individual Promises.\n     *\n     * The Promise resolves immediately if there are no pending writes. Otherwise,\n     * the Promise waits for all previously issued writes, but it does not wait\n     * for writes that were added after the method is called. If you want to wait\n     * for additional writes, call `flush()` again.\n     *\n     * @return {Promise<void>} A promise that resolves when all enqueued writes\n     * up to this point have been committed.\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     *\n     * bulkWriter.create(documentRef, {foo: 'bar'});\n     * bulkWriter.update(documentRef2, {foo: 'bar'});\n     * bulkWriter.delete(documentRef3);\n     * await flush().then(() => {\n     *   console.log('Executed all writes');\n     * });\n     */\n    async flush() {\n        this.verifyNotClosed();\n        const trackedBatches = this.batchQueue;\n        const writePromises = trackedBatches.map(batch => batch.awaitBulkCommit());\n        this.sendReadyBatches();\n        await Promise.all(writePromises);\n    }\n    /**\n     * Commits all enqueued writes and marks the BulkWriter instance as closed.\n     *\n     * After calling `close()`, calling any method wil throw an error.\n     *\n     * Returns a Promise that resolves when there are no more pending writes. The\n     * Promise will never be rejected. Calling this method will send all requests.\n     * The promise resolves immediately if there are no pending writes.\n     *\n     * @return {Promise<void>} A promise that resolves when all enqueued writes\n     * up to this point have been committed.\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     *\n     * bulkWriter.create(documentRef, {foo: 'bar'});\n     * bulkWriter.update(documentRef2, {foo: 'bar'});\n     * bulkWriter.delete(documentRef3);\n     * await close().then(() => {\n     *   console.log('Executed all writes');\n     * });\n     */\n    close() {\n        const flushPromise = this.flush();\n        this.closed = true;\n        return flushPromise;\n    }\n    verifyNotClosed() {\n        if (this.closed) {\n            throw new Error('BulkWriter has already been closed.');\n        }\n    }\n    /**\n     * Return the first eligible batch that can hold a write to the provided\n     * reference, or creates one if no eligible batches are found.\n     *\n     * @private\n     */\n    getEligibleBatch(ref) {\n        if (this.batchQueue.length > 0) {\n            const lastBatch = this.batchQueue[this.batchQueue.length - 1];\n            if (lastBatch.state === BatchState.OPEN &&\n                !lastBatch.docPaths.has(ref.path)) {\n                return lastBatch;\n            }\n        }\n        return this.createNewBatch();\n    }\n    /**\n     * Creates a new batch and adds it to the BatchQueue. If there is already a\n     * batch enqueued, sends the batch after a new one is created.\n     *\n     * @private\n     */\n    createNewBatch() {\n        const newBatch = new BulkCommitBatch(this.firestore.batch(), this.maxBatchSize);\n        if (this.batchQueue.length > 0) {\n            this.batchQueue[this.batchQueue.length - 1].markReadyToSend();\n            this.sendReadyBatches();\n        }\n        this.batchQueue.push(newBatch);\n        return newBatch;\n    }\n    /**\n     * Attempts to send batches starting from the front of the BatchQueue until a\n     * batch cannot be sent.\n     *\n     * After a batch is complete, try sending batches again.\n     *\n     * @private\n     */\n    sendReadyBatches() {\n        const unsentBatches = this.batchQueue.filter(batch => batch.state === BatchState.READY_TO_SEND);\n        let index = 0;\n        while (index < unsentBatches.length &&\n            this.isBatchSendable(unsentBatches[index])) {\n            const batch = unsentBatches[index];\n            // Send the batch if it is under the rate limit, or schedule another\n            // attempt after the appropriate timeout.\n            const delayMs = this.rateLimiter.getNextRequestDelayMs(batch.opCount);\n            assert(delayMs !== -1, 'Batch size should be under capacity');\n            if (delayMs === 0) {\n                this.sendBatch(batch);\n            }\n            else {\n                backoff_1.delayExecution(() => this.sendReadyBatches(), delayMs);\n                break;\n            }\n            index++;\n        }\n    }\n    /**\n     * Sends the provided batch and processes the results. After the batch is\n     * committed, sends the next group of ready batches.\n     *\n     * @private\n     */\n    sendBatch(batch) {\n        const success = this.rateLimiter.tryMakeRequest(batch.opCount);\n        assert(success, 'Batch should be under rate limit to be sent.');\n        batch\n            .bulkCommit()\n            .then(results => {\n            batch.processResults(results);\n        })\n            .catch((error) => {\n            batch.processResults([], error);\n        })\n            .then(() => {\n            // Remove the batch from the BatchQueue after it has been processed.\n            const batchIndex = this.batchQueue.indexOf(batch);\n            assert(batchIndex !== -1, 'The batch should be in the BatchQueue');\n            this.batchQueue.splice(batchIndex, 1);\n            this.sendReadyBatches();\n        });\n    }\n    /**\n     * Checks that the provided batch is sendable. To be sendable, a batch must:\n     * (1) be marked as READY_TO_SEND\n     * (2) not write to references that are currently in flight\n     *\n     * @private\n     */\n    isBatchSendable(batch) {\n        if (batch.state !== BatchState.READY_TO_SEND) {\n            return false;\n        }\n        for (const path of batch.docPaths) {\n            const isRefInFlight = this.batchQueue\n                .filter(batch => batch.state === BatchState.SENT)\n                .find(batch => batch.docPaths.has(path)) !== undefined;\n            if (isRefInFlight) {\n                console.warn('[BulkWriter]', `Duplicate write to document \"${path}\" detected.`, 'Writing to the same document multiple times will slow down BulkWriter. ' +\n                    'Write to unique documents in order to maximize throughput.');\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Sets the maximum number of allowed operations in a batch.\n     *\n     * @private\n     */\n    // Visible for testing.\n    _setMaxBatchSize(size) {\n        this.maxBatchSize = size;\n    }\n}\nexports.BulkWriter = BulkWriter;\n//# sourceMappingURL=bulk-writer.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/firestore/build/src/bulk-writer.js?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/firestore/build/src/convert.js":
/*!***********************************************************************!*\
  !*** ./src/node_modules/@google-cloud/firestore/build/src/convert.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Copyright 2019 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst validate_1 = __webpack_require__(/*! ./validate */ \"./src/node_modules/@google-cloud/firestore/build/src/validate.js\");\n/*!\n * @module firestore/convert\n * @private\n *\n * This module contains utility functions to convert\n * `firestore.v1.Documents` from Proto3 JSON to their equivalent\n * representation in Protobuf JS. Protobuf JS is the only encoding supported by\n * this client, and dependencies that use Proto3 JSON (such as the Google Cloud\n * Functions SDK) are supported through this conversion and its usage in\n * {@see Firestore#snapshot_}.\n */\n/**\n * Converts an ISO 8601 or google.protobuf.Timestamp proto into Protobuf JS.\n *\n * @private\n * @param timestampValue The value to convert.\n * @param argumentName The argument name to use in the error message if the\n * conversion fails. If omitted, 'timestampValue' is used.\n * @return The value as expected by Protobuf JS or undefined if no input was\n * provided.\n */\nfunction timestampFromJson(timestampValue, argumentName) {\n    let timestampProto;\n    if (typeof timestampValue === 'string') {\n        const date = new Date(timestampValue);\n        const seconds = Math.floor(date.getTime() / 1000);\n        let nanos = 0;\n        if (timestampValue.length > 20) {\n            const nanoString = timestampValue.substring(20, timestampValue.length - 1);\n            const trailingZeroes = 9 - nanoString.length;\n            nanos = Number(nanoString) * Math.pow(10, trailingZeroes);\n        }\n        if (isNaN(seconds) || isNaN(nanos)) {\n            argumentName = argumentName || 'timestampValue';\n            throw new Error(`Specify a valid ISO 8601 timestamp for \"${argumentName}\".`);\n        }\n        timestampProto = {\n            seconds: seconds || undefined,\n            nanos: nanos || undefined,\n        };\n    }\n    else if (timestampValue !== undefined) {\n        validate_1.validateObject('timestampValue', timestampValue);\n        timestampProto = {\n            seconds: timestampValue.seconds || undefined,\n            nanos: timestampValue.nanos || undefined,\n        };\n    }\n    return timestampProto;\n}\nexports.timestampFromJson = timestampFromJson;\n/**\n * Converts a Proto3 JSON 'bytesValue' field into Protobuf JS.\n *\n * @private\n * @param bytesValue The value to convert.\n * @return The value as expected by Protobuf JS.\n */\nfunction bytesFromJson(bytesValue) {\n    if (typeof bytesValue === 'string') {\n        return Buffer.from(bytesValue, 'base64');\n    }\n    else {\n        return bytesValue;\n    }\n}\n/**\n * Detects 'valueType' from a Proto3 JSON `firestore.v1.Value` proto.\n *\n * @private\n * @param proto The `firestore.v1.Value` proto.\n * @return The string value for 'valueType'.\n */\nfunction detectValueType(proto) {\n    if (proto.valueType) {\n        return proto.valueType;\n    }\n    const detectedValues = [];\n    if (proto.stringValue !== undefined) {\n        detectedValues.push('stringValue');\n    }\n    if (proto.booleanValue !== undefined) {\n        detectedValues.push('booleanValue');\n    }\n    if (proto.integerValue !== undefined) {\n        detectedValues.push('integerValue');\n    }\n    if (proto.doubleValue !== undefined) {\n        detectedValues.push('doubleValue');\n    }\n    if (proto.timestampValue !== undefined) {\n        detectedValues.push('timestampValue');\n    }\n    if (proto.referenceValue !== undefined) {\n        detectedValues.push('referenceValue');\n    }\n    if (proto.arrayValue !== undefined) {\n        detectedValues.push('arrayValue');\n    }\n    if (proto.nullValue !== undefined) {\n        detectedValues.push('nullValue');\n    }\n    if (proto.mapValue !== undefined) {\n        detectedValues.push('mapValue');\n    }\n    if (proto.geoPointValue !== undefined) {\n        detectedValues.push('geoPointValue');\n    }\n    if (proto.bytesValue !== undefined) {\n        detectedValues.push('bytesValue');\n    }\n    if (detectedValues.length !== 1) {\n        throw new Error(`Unable to infer type value fom '${JSON.stringify(proto)}'.`);\n    }\n    return detectedValues[0];\n}\nexports.detectValueType = detectValueType;\n/**\n * Converts a `firestore.v1.Value` in Proto3 JSON encoding into the\n * Protobuf JS format expected by this client.\n *\n * @private\n * @param fieldValue The `firestore.v1.Value` in Proto3 JSON format.\n * @return The `firestore.v1.Value` in Protobuf JS format.\n */\nfunction valueFromJson(fieldValue) {\n    const valueType = detectValueType(fieldValue);\n    switch (valueType) {\n        case 'timestampValue':\n            return {\n                timestampValue: timestampFromJson(fieldValue.timestampValue),\n            };\n        case 'bytesValue':\n            return {\n                bytesValue: bytesFromJson(fieldValue.bytesValue),\n            };\n        case 'integerValue':\n            return {\n                integerValue: Number(fieldValue.integerValue),\n            };\n        case 'doubleValue':\n            return {\n                doubleValue: Number(fieldValue.doubleValue),\n            };\n        case 'arrayValue': {\n            const arrayValue = [];\n            if (Array.isArray(fieldValue.arrayValue.values)) {\n                for (const value of fieldValue.arrayValue.values) {\n                    arrayValue.push(valueFromJson(value));\n                }\n            }\n            return {\n                arrayValue: {\n                    values: arrayValue,\n                },\n            };\n        }\n        case 'mapValue': {\n            const mapValue = {};\n            const fields = fieldValue.mapValue.fields;\n            if (fields) {\n                for (const prop of Object.keys(fields)) {\n                    mapValue[prop] = valueFromJson(fieldValue.mapValue.fields[prop]);\n                }\n            }\n            return {\n                mapValue: {\n                    fields: mapValue,\n                },\n            };\n        }\n        default:\n            return fieldValue;\n    }\n}\nexports.valueFromJson = valueFromJson;\n/**\n * Converts a map of IValues in Proto3 JSON encoding into the Protobuf JS format\n * expected by this client. This conversion creates a copy of the underlying\n * fields.\n *\n * @private\n * @param document An object with IValues in Proto3 JSON format.\n * @return The object in Protobuf JS format.\n */\nfunction fieldsFromJson(document) {\n    const result = {};\n    for (const prop of Object.keys(document)) {\n        result[prop] = valueFromJson(document[prop]);\n    }\n    return result;\n}\nexports.fieldsFromJson = fieldsFromJson;\n//# sourceMappingURL=convert.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/firestore/build/src/convert.js?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/firestore/build/src/document-change.js":
/*!*******************************************************************************!*\
  !*** ./src/node_modules/@google-cloud/firestore/build/src/document-change.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/*!\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * A DocumentChange represents a change to the documents matching a query.\n * It contains the document affected and the type of change that occurred.\n *\n * @class\n */\nclass DocumentChange {\n    /**\n     * @hideconstructor\n     *\n     * @param {string} type 'added' | 'removed' | 'modified'.\n     * @param {QueryDocumentSnapshot} document The document.\n     * @param {number} oldIndex The index in the documents array prior to this\n     * change.\n     * @param {number} newIndex The index in the documents array after this\n     * change.\n     */\n    constructor(type, document, oldIndex, newIndex) {\n        this._type = type;\n        this._document = document;\n        this._oldIndex = oldIndex;\n        this._newIndex = newIndex;\n    }\n    /**\n     * The type of change ('added', 'modified', or 'removed').\n     *\n     * @type {string}\n     * @name DocumentChange#type\n     * @readonly\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     * let docsArray = [];\n     *\n     * let unsubscribe = query.onSnapshot(querySnapshot => {\n     *   for (let change of querySnapshot.docChanges) {\n     *     console.log(`Type of change is ${change.type}`);\n     *   }\n     * });\n     *\n     * // Remove this listener.\n     * unsubscribe();\n     */\n    get type() {\n        return this._type;\n    }\n    /**\n     * The document affected by this change.\n     *\n     * @type {QueryDocumentSnapshot}\n     * @name DocumentChange#doc\n     * @readonly\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * let unsubscribe = query.onSnapshot(querySnapshot => {\n     *   for (let change of querySnapshot.docChanges) {\n     *     console.log(change.doc.data());\n     *   }\n     * });\n     *\n     * // Remove this listener.\n     * unsubscribe();\n     */\n    get doc() {\n        return this._document;\n    }\n    /**\n     * The index of the changed document in the result set immediately prior to\n     * this DocumentChange (i.e. supposing that all prior DocumentChange objects\n     * have been applied). Is -1 for 'added' events.\n     *\n     * @type {number}\n     * @name DocumentChange#oldIndex\n     * @readonly\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     * let docsArray = [];\n     *\n     * let unsubscribe = query.onSnapshot(querySnapshot => {\n     *   for (let change of querySnapshot.docChanges) {\n     *     if (change.oldIndex !== -1) {\n     *       docsArray.splice(change.oldIndex, 1);\n     *     }\n     *     if (change.newIndex !== -1) {\n     *       docsArray.splice(change.newIndex, 0, change.doc);\n     *     }\n     *   }\n     * });\n     *\n     * // Remove this listener.\n     * unsubscribe();\n     */\n    get oldIndex() {\n        return this._oldIndex;\n    }\n    /**\n     * The index of the changed document in the result set immediately after\n     * this DocumentChange (i.e. supposing that all prior DocumentChange\n     * objects and the current DocumentChange object have been applied).\n     * Is -1 for 'removed' events.\n     *\n     * @type {number}\n     * @name DocumentChange#newIndex\n     * @readonly\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     * let docsArray = [];\n     *\n     * let unsubscribe = query.onSnapshot(querySnapshot => {\n     *   for (let change of querySnapshot.docChanges) {\n     *     if (change.oldIndex !== -1) {\n     *       docsArray.splice(change.oldIndex, 1);\n     *     }\n     *     if (change.newIndex !== -1) {\n     *       docsArray.splice(change.newIndex, 0, change.doc);\n     *     }\n     *   }\n     * });\n     *\n     * // Remove this listener.\n     * unsubscribe();\n     */\n    get newIndex() {\n        return this._newIndex;\n    }\n    /**\n     * Returns true if the data in this `DocumentChange` is equal to the provided\n     * value.\n     *\n     * @param {*} other The value to compare against.\n     * @return true if this `DocumentChange` is equal to the provided value.\n     */\n    isEqual(other) {\n        if (this === other) {\n            return true;\n        }\n        return (other instanceof DocumentChange &&\n            this._type === other._type &&\n            this._oldIndex === other._oldIndex &&\n            this._newIndex === other._newIndex &&\n            this._document.isEqual(other._document));\n    }\n}\nexports.DocumentChange = DocumentChange;\n//# sourceMappingURL=document-change.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/firestore/build/src/document-change.js?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/firestore/build/src/document.js":
/*!************************************************************************!*\
  !*** ./src/node_modules/@google-cloud/firestore/build/src/document.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Copyright 2019 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst deepEqual = __webpack_require__(/*! deep-equal */ \"./src/node_modules/deep-equal/index.js\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst field_value_1 = __webpack_require__(/*! ./field-value */ \"./src/node_modules/@google-cloud/firestore/build/src/field-value.js\");\nconst path_1 = __webpack_require__(/*! ./path */ \"./src/node_modules/@google-cloud/firestore/build/src/path.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"./src/node_modules/@google-cloud/firestore/build/src/util.js\");\n/**\n * Returns a builder for DocumentSnapshot and QueryDocumentSnapshot instances.\n * Invoke `.build()' to assemble the final snapshot.\n *\n * @private\n */\nclass DocumentSnapshotBuilder {\n    // We include the DocumentReference in the constructor in order to allow the\n    // DocumentSnapshotBuilder to be typed with <T> when it is constructed.\n    constructor(ref) {\n        this.ref = ref;\n    }\n    /**\n     * Builds the DocumentSnapshot.\n     *\n     * @private\n     * @returns Returns either a QueryDocumentSnapshot (if `fieldsProto` was\n     * provided) or a DocumentSnapshot.\n     */\n    build() {\n        assert((this.fieldsProto !== undefined) === (this.createTime !== undefined), 'Create time should be set iff document exists.');\n        assert((this.fieldsProto !== undefined) === (this.updateTime !== undefined), 'Update time should be set iff document exists.');\n        return this.fieldsProto\n            ? new QueryDocumentSnapshot(this.ref, this.fieldsProto, this.readTime, this.createTime, this.updateTime)\n            : new DocumentSnapshot(this.ref, undefined, this.readTime);\n    }\n}\nexports.DocumentSnapshotBuilder = DocumentSnapshotBuilder;\n/**\n * A DocumentSnapshot is an immutable representation for a document in a\n * Firestore database. The data can be extracted with\n * [data()]{@link DocumentSnapshot#data} or\n * [get(fieldPath)]{@link DocumentSnapshot#get} to get a\n * specific field.\n *\n * <p>For a DocumentSnapshot that points to a non-existing document, any data\n * access will return 'undefined'. You can use the\n * [exists]{@link DocumentSnapshot#exists} property to explicitly verify a\n * document's existence.\n *\n * @class\n */\nclass DocumentSnapshot {\n    /**\n     * @hideconstructor\n     *\n     * @param ref The reference to the document.\n     * @param _fieldsProto The fields of the Firestore `Document` Protobuf backing\n     * this document (or undefined if the document does not exist).\n     * @param readTime The time when this snapshot was read  (or undefined if\n     * the document exists only locally).\n     * @param createTime The time when the document was created (or undefined if\n     * the document does not exist).\n     * @param updateTime The time when the document was last updated (or undefined\n     * if the document does not exist).\n     */\n    constructor(ref, _fieldsProto, readTime, createTime, updateTime) {\n        this._fieldsProto = _fieldsProto;\n        this._ref = ref;\n        this._serializer = ref.firestore._serializer;\n        this._readTime = readTime;\n        this._createTime = createTime;\n        this._updateTime = updateTime;\n    }\n    /**\n     * Creates a DocumentSnapshot from an object.\n     *\n     * @private\n     * @param ref The reference to the document.\n     * @param obj The object to store in the DocumentSnapshot.\n     * @return The created DocumentSnapshot.\n     */\n    static fromObject(ref, obj) {\n        const serializer = ref.firestore._serializer;\n        return new DocumentSnapshot(ref, serializer.encodeFields(obj));\n    }\n    /**\n     * Creates a DocumentSnapshot from an UpdateMap.\n     *\n     * This methods expands the top-level field paths in a JavaScript map and\n     * turns { foo.bar : foobar } into { foo { bar : foobar }}\n     *\n     * @private\n     * @param ref The reference to the document.\n     * @param data The field/value map to expand.\n     * @return The created DocumentSnapshot.\n     */\n    static fromUpdateMap(ref, data) {\n        const serializer = ref.firestore._serializer;\n        /**\n         * Merges 'value' at the field path specified by the path array into\n         * 'target'.\n         */\n        function merge(target, value, path, pos) {\n            const key = path[pos];\n            const isLast = pos === path.length - 1;\n            if (target[key] === undefined) {\n                if (isLast) {\n                    if (value instanceof field_value_1.FieldTransform) {\n                        // If there is already data at this path, we need to retain it.\n                        // Otherwise, we don't include it in the DocumentSnapshot.\n                        return !util_1.isEmpty(target) ? target : null;\n                    }\n                    // The merge is done.\n                    const leafNode = serializer.encodeValue(value);\n                    if (leafNode) {\n                        target[key] = leafNode;\n                    }\n                    return target;\n                }\n                else {\n                    // We need to expand the target object.\n                    const childNode = {\n                        mapValue: {\n                            fields: {},\n                        },\n                    };\n                    const nestedValue = merge(childNode.mapValue.fields, value, path, pos + 1);\n                    if (nestedValue) {\n                        childNode.mapValue.fields = nestedValue;\n                        target[key] = childNode;\n                        return target;\n                    }\n                    else {\n                        return !util_1.isEmpty(target) ? target : null;\n                    }\n                }\n            }\n            else {\n                assert(!isLast, \"Can't merge current value into a nested object\");\n                target[key].mapValue.fields = merge(target[key].mapValue.fields, value, path, pos + 1);\n                return target;\n            }\n        }\n        const res = {};\n        for (const [key, value] of data) {\n            const path = key.toArray();\n            merge(res, value, path, 0);\n        }\n        return new DocumentSnapshot(ref, res);\n    }\n    /**\n     * True if the document exists.\n     *\n     * @type {boolean}\n     * @name DocumentSnapshot#exists\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then((documentSnapshot) => {\n     *   if (documentSnapshot.exists) {\n     *     console.log(`Data: ${JSON.stringify(documentSnapshot.data())}`);\n     *   }\n     * });\n     */\n    get exists() {\n        return this._fieldsProto !== undefined;\n    }\n    /**\n     * A [DocumentReference]{@link DocumentReference} for the document\n     * stored in this snapshot.\n     *\n     * @type {DocumentReference}\n     * @name DocumentSnapshot#ref\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then((documentSnapshot) => {\n     *   if (documentSnapshot.exists) {\n     *     console.log(`Found document at '${documentSnapshot.ref.path}'`);\n     *   }\n     * });\n     */\n    get ref() {\n        return this._ref;\n    }\n    /**\n     * The ID of the document for which this DocumentSnapshot contains data.\n     *\n     * @type {string}\n     * @name DocumentSnapshot#id\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then((documentSnapshot) => {\n     *   if (documentSnapshot.exists) {\n     *     console.log(`Document found with name '${documentSnapshot.id}'`);\n     *   }\n     * });\n     */\n    get id() {\n        return this._ref.id;\n    }\n    /**\n     * The time the document was created. Undefined for documents that don't\n     * exist.\n     *\n     * @type {Timestamp|undefined}\n     * @name DocumentSnapshot#createTime\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(documentSnapshot => {\n     *   if (documentSnapshot.exists) {\n     *     let createTime = documentSnapshot.createTime;\n     *     console.log(`Document created at '${createTime.toDate()}'`);\n     *   }\n     * });\n     */\n    get createTime() {\n        return this._createTime;\n    }\n    /**\n     * The time the document was last updated (at the time the snapshot was\n     * generated). Undefined for documents that don't exist.\n     *\n     * @type {Timestamp|undefined}\n     * @name DocumentSnapshot#updateTime\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(documentSnapshot => {\n     *   if (documentSnapshot.exists) {\n     *     let updateTime = documentSnapshot.updateTime;\n     *     console.log(`Document updated at '${updateTime.toDate()}'`);\n     *   }\n     * });\n     */\n    get updateTime() {\n        return this._updateTime;\n    }\n    /**\n     * The time this snapshot was read.\n     *\n     * @type {Timestamp}\n     * @name DocumentSnapshot#readTime\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(documentSnapshot => {\n     *   let readTime = documentSnapshot.readTime;\n     *   console.log(`Document read at '${readTime.toDate()}'`);\n     * });\n     */\n    get readTime() {\n        if (this._readTime === undefined) {\n            throw new Error(`Called 'readTime' on a local document`);\n        }\n        return this._readTime;\n    }\n    /**\n     * Retrieves all fields in the document as an object. Returns 'undefined' if\n     * the document doesn't exist.\n     *\n     * @returns {T|undefined} An object containing all fields in the document or\n     * 'undefined' if the document doesn't exist.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(documentSnapshot => {\n     *   let data = documentSnapshot.data();\n     *   console.log(`Retrieved data: ${JSON.stringify(data)}`);\n     * });\n     */\n    data() {\n        const fields = this._fieldsProto;\n        if (fields === undefined) {\n            return undefined;\n        }\n        const obj = {};\n        for (const prop of Object.keys(fields)) {\n            obj[prop] = this._serializer.decodeValue(fields[prop]);\n        }\n        return this.ref._converter.fromFirestore(obj);\n    }\n    /**\n     * Retrieves the field specified by `field`.\n     *\n     * @param {string|FieldPath} field The field path\n     * (e.g. 'foo' or 'foo.bar') to a specific field.\n     * @returns {*} The data at the specified field location or undefined if no\n     * such field exists.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.set({ a: { b: 'c' }}).then(() => {\n     *   return documentRef.get();\n     * }).then(documentSnapshot => {\n     *   let field = documentSnapshot.get('a.b');\n     *   console.log(`Retrieved field value: ${field}`);\n     * });\n     */\n    // We deliberately use `any` in the external API to not impose type-checking\n    // on end users.\n    // tslint:disable-next-line no-any\n    get(field) {\n        // tslint:disable-line no-any\n        path_1.validateFieldPath('field', field);\n        const protoField = this.protoField(field);\n        if (protoField === undefined) {\n            return undefined;\n        }\n        return this._serializer.decodeValue(protoField);\n    }\n    /**\n     * Retrieves the field specified by 'fieldPath' in its Protobuf JS\n     * representation.\n     *\n     * @private\n     * @param field The path (e.g. 'foo' or 'foo.bar') to a specific field.\n     * @returns The Protobuf-encoded data at the specified field location or\n     * undefined if no such field exists.\n     */\n    protoField(field) {\n        let fields = this._fieldsProto;\n        if (fields === undefined) {\n            return undefined;\n        }\n        const components = path_1.FieldPath.fromArgument(field).toArray();\n        while (components.length > 1) {\n            fields = fields[components.shift()];\n            if (!fields || !fields.mapValue) {\n                return undefined;\n            }\n            fields = fields.mapValue.fields;\n        }\n        return fields[components[0]];\n    }\n    /**\n     * Convert a document snapshot to the Firestore 'Document' Protobuf.\n     *\n     * @private\n     * @returns The document in the format the API expects.\n     */\n    toProto() {\n        return {\n            update: {\n                name: this._ref.formattedName,\n                fields: this._fieldsProto,\n            },\n        };\n    }\n    /**\n     * Returns true if the document's data and path in this `DocumentSnapshot` is\n     * equal to the provided value.\n     *\n     * @param {*} other The value to compare against.\n     * @return {boolean} true if this `DocumentSnapshot` is equal to the provided\n     * value.\n     */\n    isEqual(other) {\n        // Since the read time is different on every document read, we explicitly\n        // ignore all document metadata in this comparison.\n        return (this === other ||\n            (other instanceof DocumentSnapshot &&\n                this._ref.isEqual(other._ref) &&\n                deepEqual(this._fieldsProto, other._fieldsProto, { strict: true })));\n    }\n}\nexports.DocumentSnapshot = DocumentSnapshot;\n/**\n * A QueryDocumentSnapshot contains data read from a document in your\n * Firestore database as part of a query. The document is guaranteed to exist\n * and its data can be extracted with [data()]{@link QueryDocumentSnapshot#data}\n * or [get()]{@link DocumentSnapshot#get} to get a specific field.\n *\n * A QueryDocumentSnapshot offers the same API surface as a\n * {@link DocumentSnapshot}. Since query results contain only existing\n * documents, the [exists]{@link DocumentSnapshot#exists} property will\n * always be true and [data()]{@link QueryDocumentSnapshot#data} will never\n * return 'undefined'.\n *\n * @class\n * @extends DocumentSnapshot\n */\nclass QueryDocumentSnapshot extends DocumentSnapshot {\n    /**\n     * The time the document was created.\n     *\n     * @type {Timestamp}\n     * @name QueryDocumentSnapshot#createTime\n     * @readonly\n     * @override\n     *\n     * @example\n     * let query = firestore.collection('col');\n     *\n     * query.get().forEach(snapshot => {\n     *   console.log(`Document created at '${snapshot.createTime.toDate()}'`);\n     * });\n     */\n    get createTime() {\n        return super.createTime;\n    }\n    /**\n     * The time the document was last updated (at the time the snapshot was\n     * generated).\n     *\n     * @type {Timestamp}\n     * @name QueryDocumentSnapshot#updateTime\n     * @readonly\n     * @override\n     *\n     * @example\n     * let query = firestore.collection('col');\n     *\n     * query.get().forEach(snapshot => {\n     *   console.log(`Document updated at '${snapshot.updateTime.toDate()}'`);\n     * });\n     */\n    get updateTime() {\n        return super.updateTime;\n    }\n    /**\n     * Retrieves all fields in the document as an object.\n     *\n     * @override\n     *\n     * @returns {T} An object containing all fields in the document.\n     *\n     * @example\n     * let query = firestore.collection('col');\n     *\n     * query.get().forEach(documentSnapshot => {\n     *   let data = documentSnapshot.data();\n     *   console.log(`Retrieved data: ${JSON.stringify(data)}`);\n     * });\n     */\n    data() {\n        const data = super.data();\n        if (!data) {\n            throw new Error('The data in a QueryDocumentSnapshot should always exist.');\n        }\n        return data;\n    }\n}\nexports.QueryDocumentSnapshot = QueryDocumentSnapshot;\n/**\n * A Firestore Document Mask contains the field paths affected by an update.\n *\n * @class\n * @private\n */\nclass DocumentMask {\n    /**\n     * @private\n     * @hideconstructor\n     *\n     * @param fieldPaths The field paths in this mask.\n     */\n    constructor(fieldPaths) {\n        this._sortedPaths = fieldPaths;\n        this._sortedPaths.sort((a, b) => a.compareTo(b));\n    }\n    /**\n     * Creates a document mask with the field paths of a document.\n     *\n     * @private\n     * @param data A map with fields to modify. Only the keys are used to extract\n     * the document mask.\n     */\n    static fromUpdateMap(data) {\n        const fieldPaths = [];\n        data.forEach((value, key) => {\n            if (!(value instanceof field_value_1.FieldTransform) || value.includeInDocumentMask) {\n                fieldPaths.push(path_1.FieldPath.fromArgument(key));\n            }\n        });\n        return new DocumentMask(fieldPaths);\n    }\n    /**\n     * Creates a document mask from an array of field paths.\n     *\n     * @private\n     * @param fieldMask A list of field paths.\n     */\n    static fromFieldMask(fieldMask) {\n        const fieldPaths = [];\n        for (const fieldPath of fieldMask) {\n            fieldPaths.push(path_1.FieldPath.fromArgument(fieldPath));\n        }\n        return new DocumentMask(fieldPaths);\n    }\n    /**\n     * Creates a document mask with the field names of a document.\n     *\n     * @private\n     * @param data An object with fields to modify. Only the keys are used to\n     * extract the document mask.\n     */\n    static fromObject(data) {\n        const fieldPaths = [];\n        function extractFieldPaths(currentData, currentPath) {\n            let isEmpty = true;\n            for (const key of Object.keys(currentData)) {\n                isEmpty = false;\n                // We don't split on dots since fromObject is called with\n                // DocumentData.\n                const childSegment = new path_1.FieldPath(key);\n                const childPath = currentPath\n                    ? currentPath.append(childSegment)\n                    : childSegment;\n                const value = currentData[key];\n                if (value instanceof field_value_1.FieldTransform) {\n                    if (value.includeInDocumentMask) {\n                        fieldPaths.push(childPath);\n                    }\n                }\n                else if (util_1.isPlainObject(value)) {\n                    extractFieldPaths(value, childPath);\n                }\n                else {\n                    fieldPaths.push(childPath);\n                }\n            }\n            // Add a field path for an explicitly updated empty map.\n            if (currentPath && isEmpty) {\n                fieldPaths.push(currentPath);\n            }\n        }\n        extractFieldPaths(data);\n        return new DocumentMask(fieldPaths);\n    }\n    /**\n     * Returns true if this document mask contains no fields.\n     *\n     * @private\n     * @return {boolean} Whether this document mask is empty.\n     */\n    get isEmpty() {\n        return this._sortedPaths.length === 0;\n    }\n    /**\n     * Removes the specified values from a sorted field path array.\n     *\n     * @private\n     * @param input A sorted array of FieldPaths.\n     * @param values An array of FieldPaths to remove.\n     */\n    static removeFromSortedArray(input, values) {\n        for (let i = 0; i < input.length;) {\n            let removed = false;\n            for (const fieldPath of values) {\n                if (input[i].isEqual(fieldPath)) {\n                    input.splice(i, 1);\n                    removed = true;\n                    break;\n                }\n            }\n            if (!removed) {\n                ++i;\n            }\n        }\n    }\n    /**\n     * Removes the field path specified in 'fieldPaths' from this document mask.\n     *\n     * @private\n     * @param fieldPaths An array of FieldPaths.\n     */\n    removeFields(fieldPaths) {\n        DocumentMask.removeFromSortedArray(this._sortedPaths, fieldPaths);\n    }\n    /**\n     * Returns whether this document mask contains 'fieldPath'.\n     *\n     * @private\n     * @param fieldPath The field path to test.\n     * @return Whether this document mask contains 'fieldPath'.\n     */\n    contains(fieldPath) {\n        for (const sortedPath of this._sortedPaths) {\n            const cmp = sortedPath.compareTo(fieldPath);\n            if (cmp === 0) {\n                return true;\n            }\n            else if (cmp > 0) {\n                return false;\n            }\n        }\n        return false;\n    }\n    /**\n     * Removes all properties from 'data' that are not contained in this document\n     * mask.\n     *\n     * @private\n     * @param data An object to filter.\n     * @return A shallow copy of the object filtered by this document mask.\n     */\n    applyTo(data) {\n        /*!\n         * Applies this DocumentMask to 'data' and computes the list of field paths\n         * that were specified in the mask but are not present in 'data'.\n         */\n        const applyDocumentMask = (data) => {\n            const remainingPaths = this._sortedPaths.slice(0);\n            const processObject = (currentData, currentPath) => {\n                let result = null;\n                Object.keys(currentData).forEach(key => {\n                    const childPath = currentPath\n                        ? currentPath.append(key)\n                        : new path_1.FieldPath(key);\n                    if (this.contains(childPath)) {\n                        DocumentMask.removeFromSortedArray(remainingPaths, [childPath]);\n                        result = result || {};\n                        result[key] = currentData[key];\n                    }\n                    else if (util_1.isObject(currentData[key])) {\n                        const childObject = processObject(currentData[key], childPath);\n                        if (childObject) {\n                            result = result || {};\n                            result[key] = childObject;\n                        }\n                    }\n                });\n                return result;\n            };\n            // processObject() returns 'null' if the DocumentMask is empty.\n            const filteredData = processObject(data) || {};\n            return {\n                filteredData,\n                remainingPaths,\n            };\n        };\n        const result = applyDocumentMask(data);\n        if (result.remainingPaths.length !== 0) {\n            throw new Error(`Input data is missing for field \"${result.remainingPaths[0]}\".`);\n        }\n        return result.filteredData;\n    }\n    /**\n     * Converts a document mask to the Firestore 'DocumentMask' Proto.\n     *\n     * @private\n     * @returns A Firestore 'DocumentMask' Proto.\n     */\n    toProto() {\n        if (this.isEmpty) {\n            return {};\n        }\n        const encodedPaths = [];\n        for (const fieldPath of this._sortedPaths) {\n            encodedPaths.push(fieldPath.formattedName);\n        }\n        return {\n            fieldPaths: encodedPaths,\n        };\n    }\n}\nexports.DocumentMask = DocumentMask;\n/**\n * A Firestore Document Transform.\n *\n * A DocumentTransform contains pending server-side transforms and their\n * corresponding field paths.\n *\n * @private\n * @class\n */\nclass DocumentTransform {\n    /**\n     * @private\n     * @hideconstructor\n     *\n     * @param ref The DocumentReference for this transform.\n     * @param transforms A Map of FieldPaths to FieldTransforms.\n     */\n    constructor(ref, transforms) {\n        this.ref = ref;\n        this.transforms = transforms;\n    }\n    /**\n     * Generates a DocumentTransform from a JavaScript object.\n     *\n     * @private\n     * @param ref The `DocumentReference` to use for the DocumentTransform.\n     * @param obj The object to extract the transformations from.\n     * @returns The Document Transform.\n     */\n    static fromObject(ref, obj) {\n        const updateMap = new Map();\n        for (const prop of Object.keys(obj)) {\n            updateMap.set(new path_1.FieldPath(prop), obj[prop]);\n        }\n        return DocumentTransform.fromUpdateMap(ref, updateMap);\n    }\n    /**\n     * Generates a DocumentTransform from an Update Map.\n     *\n     * @private\n     * @param ref The `DocumentReference` to use for the DocumentTransform.\n     * @param data The update data to extract the transformations from.\n     * @returns The Document Transform.\n     */\n    static fromUpdateMap(ref, data) {\n        const transforms = new Map();\n        function encode_(val, path, allowTransforms) {\n            if (val instanceof field_value_1.FieldTransform && val.includeInDocumentTransform) {\n                if (allowTransforms) {\n                    transforms.set(path, val);\n                }\n                else {\n                    throw new Error(`${val.methodName}() is not supported inside of array values.`);\n                }\n            }\n            else if (Array.isArray(val)) {\n                for (let i = 0; i < val.length; ++i) {\n                    // We need to verify that no array value contains a document transform\n                    encode_(val[i], path.append(String(i)), false);\n                }\n            }\n            else if (util_1.isPlainObject(val)) {\n                for (const prop of Object.keys(val)) {\n                    encode_(val[prop], path.append(new path_1.FieldPath(prop)), allowTransforms);\n                }\n            }\n        }\n        data.forEach((value, key) => {\n            encode_(value, path_1.FieldPath.fromArgument(key), true);\n        });\n        return new DocumentTransform(ref, transforms);\n    }\n    /**\n     * Whether this DocumentTransform contains any actionable transformations.\n     *\n     * @private\n     */\n    get isEmpty() {\n        return this.transforms.size === 0;\n    }\n    /**\n     * Returns the array of fields in this DocumentTransform.\n     *\n     * @private\n     */\n    get fields() {\n        return Array.from(this.transforms.keys());\n    }\n    /**\n     * Validates the user provided field values in this document transform.\n     * @private\n     */\n    validate() {\n        const allowUndefined = !!this.ref.firestore._settings\n            .ignoreUndefinedProperties;\n        this.transforms.forEach(transform => transform.validate(allowUndefined));\n    }\n    /**\n     * Converts a document transform to the Firestore 'FieldTransform' Proto.\n     *\n     * @private\n     * @param serializer The Firestore serializer\n     * @returns A list of Firestore 'FieldTransform' Protos\n     */\n    toProto(serializer) {\n        return Array.from(this.transforms, ([path, transform]) => transform.toProto(serializer, path));\n    }\n}\nexports.DocumentTransform = DocumentTransform;\n/**\n * A Firestore Precondition encapsulates options for database writes.\n *\n * @private\n * @class\n */\nclass Precondition {\n    /**\n     * @private\n     * @hideconstructor\n     *\n     * @param options.exists - Whether the referenced document should exist in\n     * Firestore,\n     * @param options.lastUpdateTime - The last update time of the referenced\n     * document in Firestore.\n     * @param options\n     */\n    constructor(options) {\n        if (options !== undefined) {\n            this._exists = options.exists;\n            this._lastUpdateTime = options.lastUpdateTime;\n        }\n    }\n    /**\n     * Generates the Protobuf `Preconditon` object for this precondition.\n     *\n     * @private\n     * @returns The `Preconditon` Protobuf object or 'null' if there are no\n     * preconditions.\n     */\n    toProto() {\n        if (this.isEmpty) {\n            return null;\n        }\n        const proto = {};\n        if (this._lastUpdateTime !== undefined) {\n            proto.updateTime = this._lastUpdateTime.toProto().timestampValue;\n        }\n        else {\n            proto.exists = this._exists;\n        }\n        return proto;\n    }\n    /**\n     * Whether this DocumentTransform contains any enforcement.\n     *\n     * @private\n     */\n    get isEmpty() {\n        return this._exists === undefined && !this._lastUpdateTime;\n    }\n}\nexports.Precondition = Precondition;\n//# sourceMappingURL=document.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/firestore/build/src/document.js?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/firestore/build/src/field-value.js":
/*!***************************************************************************!*\
  !*** ./src/node_modules/@google-cloud/firestore/build/src/field-value.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst deepEqual = __webpack_require__(/*! deep-equal */ \"./src/node_modules/deep-equal/index.js\");\nconst serializer_1 = __webpack_require__(/*! ./serializer */ \"./src/node_modules/@google-cloud/firestore/build/src/serializer.js\");\nconst validate_1 = __webpack_require__(/*! ./validate */ \"./src/node_modules/@google-cloud/firestore/build/src/validate.js\");\n/**\n * Sentinel values that can be used when writing documents with set(), create()\n * or update().\n *\n * @class\n */\nclass FieldValue {\n    /**\n     * @hideconstructor\n     */\n    constructor() { }\n    /**\n     * Returns a sentinel for use with update() or set() with {merge:true} to mark\n     * a field for deletion.\n     *\n     * @returns {FieldValue} The sentinel value to use in your objects.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     * let data = { a: 'b', c: 'd' };\n     *\n     * documentRef.set(data).then(() => {\n     *   return documentRef.update({a: Firestore.FieldValue.delete()});\n     * }).then(() => {\n     *   // Document now only contains { c: 'd' }\n     * });\n     */\n    static delete() {\n        return DeleteTransform.DELETE_SENTINEL;\n    }\n    /**\n     * Returns a sentinel used with set(), create() or update() to include a\n     * server-generated timestamp in the written data.\n     *\n     * @return {FieldValue} The FieldValue sentinel for use in a call to set(),\n     * create() or update().\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.set({\n     *   time: Firestore.FieldValue.serverTimestamp()\n     * }).then(() => {\n     *   return documentRef.get();\n     * }).then(doc => {\n     *   console.log(`Server time set to ${doc.get('time')}`);\n     * });\n     */\n    static serverTimestamp() {\n        return ServerTimestampTransform.SERVER_TIMESTAMP_SENTINEL;\n    }\n    /**\n     * Returns a special value that can be used with set(), create() or update()\n     * that tells the server to increment the the field's current value by the\n     * given value.\n     *\n     * If either current field value or the operand uses floating point\n     * precision, both values will be interpreted as floating point numbers and\n     * all arithmetic will follow IEEE 754 semantics. Otherwise, integer\n     * precision is kept and the result is capped between -2^63 and 2^63-1.\n     *\n     * If the current field value is not of type 'number', or if the field does\n     * not yet exist, the transformation will set the field to the given value.\n     *\n     * @param {number} n The value to increment by.\n     * @return {FieldValue} The FieldValue sentinel for use in a call to set(),\n     * create() or update().\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.update(\n     *   'counter', Firestore.FieldValue.increment(1)\n     * ).then(() => {\n     *   return documentRef.get();\n     * }).then(doc => {\n     *   // doc.get('counter') was incremented\n     * });\n     */\n    static increment(n) {\n        validate_1.validateMinNumberOfArguments('FieldValue.increment', arguments, 1);\n        return new NumericIncrementTransform(n);\n    }\n    /**\n     * Returns a special value that can be used with set(), create() or update()\n     * that tells the server to union the given elements with any array value that\n     * already exists on the server. Each specified element that doesn't already\n     * exist in the array will be added to the end. If the field being modified is\n     * not already an array it will be overwritten with an array containing\n     * exactly the specified elements.\n     *\n     * @param {...*} elements The elements to union into the array.\n     * @return {FieldValue} The FieldValue sentinel for use in a call to set(),\n     * create() or update().\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.update(\n     *   'array', Firestore.FieldValue.arrayUnion('foo')\n     * ).then(() => {\n     *   return documentRef.get();\n     * }).then(doc => {\n     *   // doc.get('array') contains field 'foo'\n     * });\n     */\n    static arrayUnion(...elements) {\n        validate_1.validateMinNumberOfArguments('FieldValue.arrayUnion', arguments, 1);\n        return new ArrayUnionTransform(elements);\n    }\n    /**\n     * Returns a special value that can be used with set(), create() or update()\n     * that tells the server to remove the given elements from any array value\n     * that already exists on the server. All instances of each element specified\n     * will be removed from the array. If the field being modified is not already\n     * an array it will be overwritten with an empty array.\n     *\n     * @param {...*} elements The elements to remove from the array.\n     * @return {FieldValue} The FieldValue sentinel for use in a call to set(),\n     * create() or update().\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.update(\n     *   'array', Firestore.FieldValue.arrayRemove('foo')\n     * ).then(() => {\n     *   return documentRef.get();\n     * }).then(doc => {\n     *   // doc.get('array') no longer contains field 'foo'\n     * });\n     */\n    static arrayRemove(...elements) {\n        validate_1.validateMinNumberOfArguments('FieldValue.arrayRemove', arguments, 1);\n        return new ArrayRemoveTransform(elements);\n    }\n    /**\n     * Returns true if this `FieldValue` is equal to the provided value.\n     *\n     * @param {*} other The value to compare against.\n     * @return {boolean} true if this `FieldValue` is equal to the provided value.\n     *\n     * @example\n     * let fieldValues = [\n     *   Firestore.FieldValue.increment(-1.0),\n     *   Firestore.FieldValue.increment(-1),\n     *   Firestore.FieldValue.increment(-0.0),\n     *   Firestore.FieldValue.increment(-0),\n     *   Firestore.FieldValue.increment(0),\n     *   Firestore.FieldValue.increment(0.0),\n     *   Firestore.FieldValue.increment(1),\n     *   Firestore.FieldValue.increment(1.0)\n     * ];\n     *\n     * let equal = 0;\n     * for (let i = 0; i < fieldValues.length; ++i) {\n     *   for (let j = i + 1; j < fieldValues.length; ++j) {\n     *     if (fieldValues[i].isEqual(fieldValues[j])) {\n     *       ++equal;\n     *     }\n     *   }\n     * }\n     * console.log(`Found ${equal} equalities.`);\n     */\n    isEqual(other) {\n        return this === other;\n    }\n}\nexports.FieldValue = FieldValue;\n/**\n * An internal interface shared by all field transforms.\n *\n * A 'FieldTransform` subclass should implement '.includeInDocumentMask',\n * '.includeInDocumentTransform' and 'toProto' (if '.includeInDocumentTransform'\n * is 'true').\n *\n * @private\n * @abstract\n */\nclass FieldTransform extends FieldValue {\n}\nexports.FieldTransform = FieldTransform;\n/**\n * A transform that deletes a field from a Firestore document.\n *\n * @private\n */\nclass DeleteTransform extends FieldTransform {\n    constructor() {\n        super();\n    }\n    /**\n     * Deletes are included in document masks.\n     * @private\n     */\n    get includeInDocumentMask() {\n        return true;\n    }\n    /**\n     * Deletes are are omitted from document transforms.\n     * @private\n     */\n    get includeInDocumentTransform() {\n        return false;\n    }\n    get methodName() {\n        return 'FieldValue.delete';\n    }\n    validate() { }\n    toProto(serializer, fieldPath) {\n        throw new Error('FieldValue.delete() should not be included in a FieldTransform');\n    }\n}\nexports.DeleteTransform = DeleteTransform;\n/**\n * Sentinel value for a field delete.\n * @private\n */\nDeleteTransform.DELETE_SENTINEL = new DeleteTransform();\n/**\n * A transform that sets a field to the Firestore server time.\n *\n * @private\n */\nclass ServerTimestampTransform extends FieldTransform {\n    constructor() {\n        super();\n    }\n    /**\n     * Server timestamps are omitted from document masks.\n     *\n     * @private\n     */\n    get includeInDocumentMask() {\n        return false;\n    }\n    /**\n     * Server timestamps are included in document transforms.\n     *\n     * @private\n     */\n    get includeInDocumentTransform() {\n        return true;\n    }\n    get methodName() {\n        return 'FieldValue.serverTimestamp';\n    }\n    validate() { }\n    toProto(serializer, fieldPath) {\n        return {\n            fieldPath: fieldPath.formattedName,\n            setToServerValue: 'REQUEST_TIME',\n        };\n    }\n}\n/**\n * Sentinel value for a server timestamp.\n *\n * @private\n */\nServerTimestampTransform.SERVER_TIMESTAMP_SENTINEL = new ServerTimestampTransform();\n/**\n * Increments a field value on the backend.\n *\n * @private\n */\nclass NumericIncrementTransform extends FieldTransform {\n    constructor(operand) {\n        super();\n        this.operand = operand;\n    }\n    /**\n     * Numeric transforms are omitted from document masks.\n     *\n     * @private\n     */\n    get includeInDocumentMask() {\n        return false;\n    }\n    /**\n     * Numeric transforms are included in document transforms.\n     *\n     * @private\n     */\n    get includeInDocumentTransform() {\n        return true;\n    }\n    get methodName() {\n        return 'FieldValue.increment';\n    }\n    validate() {\n        validate_1.validateNumber('FieldValue.increment()', this.operand);\n    }\n    toProto(serializer, fieldPath) {\n        const encodedOperand = serializer.encodeValue(this.operand);\n        return { fieldPath: fieldPath.formattedName, increment: encodedOperand };\n    }\n    isEqual(other) {\n        return (this === other ||\n            (other instanceof NumericIncrementTransform &&\n                this.operand === other.operand));\n    }\n}\n/**\n * Transforms an array value via a union operation.\n *\n * @private\n */\nclass ArrayUnionTransform extends FieldTransform {\n    constructor(elements) {\n        super();\n        this.elements = elements;\n    }\n    /**\n     * Array transforms are omitted from document masks.\n     * @private\n     */\n    get includeInDocumentMask() {\n        return false;\n    }\n    /**\n     * Array transforms are included in document transforms.\n     * @private\n     */\n    get includeInDocumentTransform() {\n        return true;\n    }\n    get methodName() {\n        return 'FieldValue.arrayUnion';\n    }\n    validate(allowUndefined) {\n        for (let i = 0; i < this.elements.length; ++i) {\n            validateArrayElement(i, this.elements[i], allowUndefined);\n        }\n    }\n    toProto(serializer, fieldPath) {\n        const encodedElements = serializer.encodeValue(this.elements).arrayValue;\n        return {\n            fieldPath: fieldPath.formattedName,\n            appendMissingElements: encodedElements,\n        };\n    }\n    isEqual(other) {\n        return (this === other ||\n            (other instanceof ArrayUnionTransform &&\n                deepEqual(this.elements, other.elements, { strict: true })));\n    }\n}\n/**\n * Transforms an array value via a remove operation.\n *\n * @private\n */\nclass ArrayRemoveTransform extends FieldTransform {\n    constructor(elements) {\n        super();\n        this.elements = elements;\n    }\n    /**\n     * Array transforms are omitted from document masks.\n     * @private\n     */\n    get includeInDocumentMask() {\n        return false;\n    }\n    /**\n     * Array transforms are included in document transforms.\n     * @private\n     */\n    get includeInDocumentTransform() {\n        return true;\n    }\n    get methodName() {\n        return 'FieldValue.arrayRemove';\n    }\n    validate(allowUndefined) {\n        for (let i = 0; i < this.elements.length; ++i) {\n            validateArrayElement(i, this.elements[i], allowUndefined);\n        }\n    }\n    toProto(serializer, fieldPath) {\n        const encodedElements = serializer.encodeValue(this.elements).arrayValue;\n        return {\n            fieldPath: fieldPath.formattedName,\n            removeAllFromArray: encodedElements,\n        };\n    }\n    isEqual(other) {\n        return (this === other ||\n            (other instanceof ArrayRemoveTransform &&\n                deepEqual(this.elements, other.elements, { strict: true })));\n    }\n}\n/**\n * Validates that `value` can be used as an element inside of an array. Certain\n * field values (such as ServerTimestamps) are rejected. Nested arrays are also\n * rejected.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The value to validate.\n * @param allowUndefined Whether to allow nested properties that are `undefined`.\n */\nfunction validateArrayElement(arg, value, allowUndefined) {\n    if (Array.isArray(value)) {\n        throw new Error(`${validate_1.invalidArgumentMessage(arg, 'array element')} Nested arrays are not supported.`);\n    }\n    serializer_1.validateUserInput(arg, value, 'array element', \n    /*path=*/ { allowDeletes: 'none', allowTransforms: false, allowUndefined }, \n    /*path=*/ undefined, \n    /*level=*/ 0, \n    /*inArray=*/ true);\n}\n//# sourceMappingURL=field-value.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/firestore/build/src/field-value.js?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/firestore/build/src/geo-point.js":
/*!*************************************************************************!*\
  !*** ./src/node_modules/@google-cloud/firestore/build/src/geo-point.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst validate_1 = __webpack_require__(/*! ./validate */ \"./src/node_modules/@google-cloud/firestore/build/src/validate.js\");\n/**\n * An immutable object representing a geographic location in Firestore. The\n * location is represented as a latitude/longitude pair.\n *\n * @class\n */\nclass GeoPoint {\n    /**\n     * Creates a [GeoPoint]{@link GeoPoint}.\n     *\n     * @param {number} latitude The latitude as a number between -90 and 90.\n     * @param {number} longitude The longitude as a number between -180 and 180.\n     *\n     * @example\n     * let data = {\n     *   google: new Firestore.GeoPoint(37.422, 122.084)\n     * };\n     *\n     * firestore.doc('col/doc').set(data).then(() => {\n     *   console.log(`Location is ${data.google.latitude}, ` +\n     *     `${data.google.longitude}`);\n     * });\n     */\n    constructor(latitude, longitude) {\n        validate_1.validateNumber('latitude', latitude, { minValue: -90, maxValue: 90 });\n        validate_1.validateNumber('longitude', longitude, { minValue: -180, maxValue: 180 });\n        this._latitude = latitude;\n        this._longitude = longitude;\n    }\n    /**\n     * The latitude as a number between -90 and 90.\n     *\n     * @type {number}\n     * @name GeoPoint#latitude\n     * @readonly\n     */\n    get latitude() {\n        return this._latitude;\n    }\n    /**\n     * The longitude as a number between -180 and 180.\n     *\n     * @type {number}\n     * @name GeoPoint#longitude\n     * @readonly\n     */\n    get longitude() {\n        return this._longitude;\n    }\n    /**\n     * Returns true if this `GeoPoint` is equal to the provided value.\n     *\n     * @param {*} other The value to compare against.\n     * @return {boolean} true if this `GeoPoint` is equal to the provided value.\n     */\n    isEqual(other) {\n        return (this === other ||\n            (other instanceof GeoPoint &&\n                this.latitude === other.latitude &&\n                this.longitude === other.longitude));\n    }\n    /**\n     * Converts the GeoPoint to a google.type.LatLng proto.\n     * @private\n     */\n    toProto() {\n        return {\n            geoPointValue: {\n                latitude: this.latitude,\n                longitude: this.longitude,\n            },\n        };\n    }\n    /**\n     * Converts a google.type.LatLng proto to its GeoPoint representation.\n     * @private\n     */\n    static fromProto(proto) {\n        return new GeoPoint(proto.latitude || 0, proto.longitude || 0);\n    }\n}\nexports.GeoPoint = GeoPoint;\n//# sourceMappingURL=geo-point.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/firestore/build/src/geo-point.js?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/firestore/build/src/index.js":
/*!*********************************************************************!*\
  !*** ./src/node_modules/@google-cloud/firestore/build/src/index.js ***!
  \*********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst google_gax_1 = __webpack_require__(/*! google-gax */ \"google-gax\");\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst through2 = __webpack_require__(/*! through2 */ \"through2\");\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nconst backoff_1 = __webpack_require__(/*! ./backoff */ \"./src/node_modules/@google-cloud/firestore/build/src/backoff.js\");\nconst bulk_writer_1 = __webpack_require__(/*! ./bulk-writer */ \"./src/node_modules/@google-cloud/firestore/build/src/bulk-writer.js\");\nconst convert_1 = __webpack_require__(/*! ./convert */ \"./src/node_modules/@google-cloud/firestore/build/src/convert.js\");\nconst document_1 = __webpack_require__(/*! ./document */ \"./src/node_modules/@google-cloud/firestore/build/src/document.js\");\nconst logger_1 = __webpack_require__(/*! ./logger */ \"./src/node_modules/@google-cloud/firestore/build/src/logger.js\");\nconst path_1 = __webpack_require__(/*! ./path */ \"./src/node_modules/@google-cloud/firestore/build/src/path.js\");\nconst pool_1 = __webpack_require__(/*! ./pool */ \"./src/node_modules/@google-cloud/firestore/build/src/pool.js\");\nconst reference_1 = __webpack_require__(/*! ./reference */ \"./src/node_modules/@google-cloud/firestore/build/src/reference.js\");\nconst reference_2 = __webpack_require__(/*! ./reference */ \"./src/node_modules/@google-cloud/firestore/build/src/reference.js\");\nconst serializer_1 = __webpack_require__(/*! ./serializer */ \"./src/node_modules/@google-cloud/firestore/build/src/serializer.js\");\nconst timestamp_1 = __webpack_require__(/*! ./timestamp */ \"./src/node_modules/@google-cloud/firestore/build/src/timestamp.js\");\nconst transaction_1 = __webpack_require__(/*! ./transaction */ \"./src/node_modules/@google-cloud/firestore/build/src/transaction.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"./src/node_modules/@google-cloud/firestore/build/src/util.js\");\nconst validate_1 = __webpack_require__(/*! ./validate */ \"./src/node_modules/@google-cloud/firestore/build/src/validate.js\");\nconst write_batch_1 = __webpack_require__(/*! ./write-batch */ \"./src/node_modules/@google-cloud/firestore/build/src/write-batch.js\");\nconst firestore_client_config_json_1 = __webpack_require__(/*! ./v1/firestore_client_config.json */ \"./src/node_modules/@google-cloud/firestore/build/src/v1/firestore_client_config.json\");\nconst serviceConfig = firestore_client_config_json_1.interfaces['google.firestore.v1.Firestore'];\nvar reference_3 = __webpack_require__(/*! ./reference */ \"./src/node_modules/@google-cloud/firestore/build/src/reference.js\");\nexports.CollectionReference = reference_3.CollectionReference;\nexports.DocumentReference = reference_3.DocumentReference;\nexports.QuerySnapshot = reference_3.QuerySnapshot;\nexports.Query = reference_3.Query;\nvar document_2 = __webpack_require__(/*! ./document */ \"./src/node_modules/@google-cloud/firestore/build/src/document.js\");\nexports.DocumentSnapshot = document_2.DocumentSnapshot;\nexports.QueryDocumentSnapshot = document_2.QueryDocumentSnapshot;\nvar field_value_1 = __webpack_require__(/*! ./field-value */ \"./src/node_modules/@google-cloud/firestore/build/src/field-value.js\");\nexports.FieldValue = field_value_1.FieldValue;\nvar write_batch_2 = __webpack_require__(/*! ./write-batch */ \"./src/node_modules/@google-cloud/firestore/build/src/write-batch.js\");\nexports.WriteBatch = write_batch_2.WriteBatch;\nexports.WriteResult = write_batch_2.WriteResult;\nvar transaction_2 = __webpack_require__(/*! ./transaction */ \"./src/node_modules/@google-cloud/firestore/build/src/transaction.js\");\nexports.Transaction = transaction_2.Transaction;\nvar timestamp_2 = __webpack_require__(/*! ./timestamp */ \"./src/node_modules/@google-cloud/firestore/build/src/timestamp.js\");\nexports.Timestamp = timestamp_2.Timestamp;\nvar document_change_1 = __webpack_require__(/*! ./document-change */ \"./src/node_modules/@google-cloud/firestore/build/src/document-change.js\");\nexports.DocumentChange = document_change_1.DocumentChange;\nvar path_2 = __webpack_require__(/*! ./path */ \"./src/node_modules/@google-cloud/firestore/build/src/path.js\");\nexports.FieldPath = path_2.FieldPath;\nvar geo_point_1 = __webpack_require__(/*! ./geo-point */ \"./src/node_modules/@google-cloud/firestore/build/src/geo-point.js\");\nexports.GeoPoint = geo_point_1.GeoPoint;\nvar logger_2 = __webpack_require__(/*! ./logger */ \"./src/node_modules/@google-cloud/firestore/build/src/logger.js\");\nexports.setLogFunction = logger_2.setLogFunction;\nvar google_gax_2 = __webpack_require__(/*! google-gax */ \"google-gax\");\nexports.GrpcStatus = google_gax_2.Status;\nconst libVersion = __webpack_require__(/*! ../../package.json */ \"./src/node_modules/@google-cloud/firestore/package.json\").version;\nlogger_1.setLibVersion(libVersion);\n/*!\n * DO NOT REMOVE THE FOLLOWING NAMESPACE DEFINITIONS\n */\n/**\n * @namespace google.protobuf\n */\n/**\n * @namespace google.rpc\n */\n/**\n * @namespace google.longrunning\n */\n/**\n * @namespace google.firestore.v1\n */\n/**\n * @namespace google.firestore.v1beta1\n */\n/**\n * @namespace google.firestore.admin.v1\n */\n/*!\n * @see v1\n */\nlet v1; // Lazy-loaded in `_runRequest()`\n/*!\n * @see v1beta1\n */\nlet v1beta1; // Lazy-loaded upon access.\n/*!\n * HTTP header for the resource prefix to improve routing and project isolation\n * by the backend.\n */\nconst CLOUD_RESOURCE_HEADER = 'google-cloud-resource-prefix';\n/*!\n * The maximum number of times to retry idempotent requests.\n */\nconst MAX_REQUEST_RETRIES = 5;\n/*!\n * The default number of idle GRPC channel to keep.\n */\nconst DEFAULT_MAX_IDLE_CHANNELS = 1;\n/*!\n * The maximum number of concurrent requests supported by a single GRPC channel,\n * as enforced by Google's Frontend. If the SDK issues more than 100 concurrent\n * operations, we need to use more than one GAPIC client since these clients\n * multiplex all requests over a single channel.\n */\nconst MAX_CONCURRENT_REQUESTS_PER_CLIENT = 100;\n/**\n * Document data (e.g. for use with\n * [set()]{@link DocumentReference#set}) consisting of fields mapped\n * to values.\n *\n * @typedef {Object.<string, *>} DocumentData\n */\n/**\n * Update data (for use with [update]{@link DocumentReference#update})\n * that contains paths (e.g. 'foo' or 'foo.baz') mapped to values. Fields that\n * contain dots reference nested fields within the document.\n *\n * @typedef {Object.<string, *>} UpdateData\n */\n/**\n * An options object that configures conditional behavior of\n * [update()]{@link DocumentReference#update} and\n * [delete()]{@link DocumentReference#delete} calls in\n * [DocumentReference]{@link DocumentReference},\n * [WriteBatch]{@link WriteBatch}, and\n * [Transaction]{@link Transaction}. Using Preconditions, these calls\n * can be restricted to only apply to documents that match the specified\n * conditions.\n *\n * @example\n * const documentRef = firestore.doc('coll/doc');\n *\n * documentRef.get().then(snapshot => {\n *   const updateTime = snapshot.updateTime;\n *\n *   console.log(`Deleting document at update time: ${updateTime.toDate()}`);\n *   return documentRef.delete({ lastUpdateTime: updateTime });\n * });\n *\n * @property {Timestamp} lastUpdateTime The update time to enforce. If set,\n *  enforces that the document was last updated at lastUpdateTime. Fails the\n *  operation if the document was last updated at a different time.\n * @typedef {Object} Precondition\n */\n/**\n * An options object that configures the behavior of\n * [set()]{@link DocumentReference#set} calls in\n * [DocumentReference]{@link DocumentReference},\n * [WriteBatch]{@link WriteBatch}, and\n * [Transaction]{@link Transaction}. These calls can be\n * configured to perform granular merges instead of overwriting the target\n * documents in their entirety by providing a SetOptions object with\n * { merge : true }.\n *\n * @property {boolean} merge Changes the behavior of a set() call to only\n * replace the values specified in its data argument. Fields omitted from the\n * set() call remain untouched.\n * @property {Array<(string|FieldPath)>} mergeFields Changes the behavior of\n * set() calls to only replace the specified field paths. Any field path that is\n * not specified is ignored and remains untouched.\n * It is an error to pass a SetOptions object to a set() call that is missing a\n * value for any of the fields specified here.\n * @typedef {Object} SetOptions\n */\n/**\n * An options object that can be used to configure the behavior of\n * [getAll()]{@link Firestore#getAll} calls. By providing a `fieldMask`, these\n * calls can be configured to only return a subset of fields.\n *\n * @property {Array<(string|FieldPath)>} fieldMask Specifies the set of fields\n * to return and reduces the amount of data transmitted by the backend.\n * Adding a field mask does not filter results. Documents do not need to\n * contain values for all the fields in the mask to be part of the result set.\n * @typedef {Object} ReadOptions\n */\n/**\n * The Firestore client represents a Firestore Database and is the entry point\n * for all Firestore operations.\n *\n * @see [Firestore Documentation]{@link https://firebase.google.com/docs/firestore/}\n *\n * @class\n *\n * @example <caption>Install the client library with <a\n * href=\"https://www.npmjs.com/\">npm</a>:</caption> npm install --save\n * @google-cloud/firestore\n *\n * @example <caption>Import the client library</caption>\n * var Firestore = require('@google-cloud/firestore');\n *\n * @example <caption>Create a client that uses <a\n * href=\"https://cloud.google.com/docs/authentication/production#providing_credentials_to_your_application\">Application\n * Default Credentials (ADC)</a>:</caption> var firestore = new Firestore();\n *\n * @example <caption>Create a client with <a\n * href=\"https://cloud.google.com/docs/authentication/production#obtaining_and_providing_service_account_credentials_manually\">explicit\n * credentials</a>:</caption> var firestore = new Firestore({ projectId:\n * 'your-project-id', keyFilename: '/path/to/keyfile.json'\n * });\n *\n * @example <caption>include:samples/quickstart.js</caption>\n * region_tag:firestore_quickstart\n * Full quickstart example:\n */\nclass Firestore {\n    /**\n     * @param {Object=} settings [Configuration object](#/docs).\n     * @param {string=} settings.projectId The project ID from the Google\n     * Developer's Console, e.g. 'grape-spaceship-123'. We will also check the\n     * environment variable GCLOUD_PROJECT for your project ID.  Can be omitted in\n     * environments that support\n     * {@link https://cloud.google.com/docs/authentication Application Default\n     * Credentials}\n     * @param {string=} settings.keyFilename Local file containing the Service\n     * Account credentials as downloaded from the Google Developers Console. Can\n     * be omitted in environments that support\n     * {@link https://cloud.google.com/docs/authentication Application Default\n     * Credentials}. To configure Firestore with custom credentials, use\n     * `settings.credentials` and provide the `client_email` and `private_key` of\n     * your service account.\n     * @param {{client_email:string=, private_key:string=}=} settings.credentials\n     * The `client_email` and `private_key` properties of the service account\n     * to use with your Firestore project. Can be omitted in environments that\n     * support {@link https://cloud.google.com/docs/authentication Application\n     * Default Credentials}. If your credentials are stored in a JSON file, you\n     * can specify a `keyFilename` instead.\n     * @param {string=} settings.host The host to connect to.\n     * @param {boolean=} settings.ssl Whether to use SSL when connecting.\n     * @param {number=} settings.maxIdleChannels  The maximum number of idle GRPC\n     * channels to keep. A smaller number of idle channels reduces memory usage\n     * but increases request latency for clients with fluctuating request rates.\n     * If set to 0, shuts down all GRPC channels when the client becomes idle.\n     * Defaults to 1.\n     */\n    constructor(settings) {\n        /**\n         * The configuration options for the GAPIC client.\n         * @private\n         */\n        this._settings = {};\n        /**\n         * Whether the initialization settings can still be changed by invoking\n         * `settings()`.\n         * @private\n         */\n        this._settingsFrozen = false;\n        /**\n         * The serializer to use for the Protobuf transformation.\n         * @private\n         */\n        this._serializer = null;\n        /**\n         * The project ID for this client.\n         *\n         * The project ID is auto-detected during the first request unless a project\n         * ID is passed to the constructor (or provided via `.settings()`).\n         * @private\n         */\n        this._projectId = undefined;\n        /**\n         * Count of listeners that have been registered on the client.\n         *\n         * The client can only be terminated when there are no registered listeners.\n         * @private\n         */\n        this.registeredListenersCount = 0;\n        /** @private */\n        this._lastSuccessfulRequest = 0;\n        const libraryHeader = {\n            libName: 'gccl',\n            libVersion,\n        };\n        if (settings && settings.firebaseVersion) {\n            libraryHeader.libVersion += ' fire/' + settings.firebaseVersion;\n        }\n        if (process.env.FIRESTORE_EMULATOR_HOST) {\n            validate_1.validateHost('FIRESTORE_EMULATOR_HOST', process.env.FIRESTORE_EMULATOR_HOST);\n            const emulatorSettings = Object.assign(Object.assign(Object.assign({}, settings), libraryHeader), { host: process.env.FIRESTORE_EMULATOR_HOST, ssl: false });\n            // If FIRESTORE_EMULATOR_HOST is set, we unset `servicePath` and `apiEndpoint` to\n            // ensure that only one endpoint setting is provided.\n            delete emulatorSettings.servicePath;\n            delete emulatorSettings.apiEndpoint;\n            this.validateAndApplySettings(emulatorSettings);\n        }\n        else {\n            this.validateAndApplySettings(Object.assign(Object.assign({}, settings), libraryHeader));\n        }\n        const retryConfig = serviceConfig.retry_params.default;\n        this._backoffSettings = {\n            initialDelayMs: retryConfig.initial_retry_delay_millis,\n            maxDelayMs: retryConfig.max_retry_delay_millis,\n            backoffFactor: retryConfig.retry_delay_multiplier,\n        };\n        // GCF currently tears down idle connections after two minutes. Requests\n        // that are issued after this period may fail. On GCF, we therefore issue\n        // these requests as part of a transaction so that we can safely retry until\n        // the network link is reestablished.\n        //\n        // The environment variable FUNCTION_TRIGGER_TYPE is used to detect the GCF\n        // environment.\n        this._preferTransactions = process.env.FUNCTION_TRIGGER_TYPE !== undefined;\n        this._lastSuccessfulRequest = 0;\n        if (this._preferTransactions) {\n            logger_1.logger('Firestore', null, 'Detected GCF environment');\n        }\n        const maxIdleChannels = this._settings.maxIdleChannels === undefined\n            ? DEFAULT_MAX_IDLE_CHANNELS\n            : this._settings.maxIdleChannels;\n        this._clientPool = new pool_1.ClientPool(MAX_CONCURRENT_REQUESTS_PER_CLIENT, maxIdleChannels, \n        /* clientFactory= */ () => {\n            let client;\n            if (this._settings.ssl === false) {\n                const grpc = __webpack_require__(/*! @grpc/grpc-js */ \"@grpc/grpc-js\");\n                const sslCreds = grpc.credentials.createInsecure();\n                client = new module.exports.v1(Object.assign({ sslCreds }, this._settings));\n            }\n            else {\n                client = new module.exports.v1(this._settings);\n            }\n            logger_1.logger('Firestore', null, 'Initialized Firestore GAPIC Client');\n            return client;\n        }, \n        /* clientDestructor= */ client => client.close());\n        logger_1.logger('Firestore', null, 'Initialized Firestore');\n    }\n    /**\n     * Specifies custom settings to be used to configure the `Firestore`\n     * instance. Can only be invoked once and before any other Firestore method.\n     *\n     * If settings are provided via both `settings()` and the `Firestore`\n     * constructor, both settings objects are merged and any settings provided via\n     * `settings()` take precedence.\n     *\n     * @param {object} settings The settings to use for all Firestore operations.\n     */\n    settings(settings) {\n        validate_1.validateObject('settings', settings);\n        validate_1.validateString('settings.projectId', settings.projectId, { optional: true });\n        if (this._settingsFrozen) {\n            throw new Error('Firestore has already been initialized. You can only call ' +\n                'settings() once, and only before calling any other methods on a ' +\n                'Firestore object.');\n        }\n        const mergedSettings = Object.assign(Object.assign({}, this._settings), settings);\n        this.validateAndApplySettings(mergedSettings);\n        this._settingsFrozen = true;\n    }\n    validateAndApplySettings(settings) {\n        if (settings.projectId !== undefined) {\n            validate_1.validateString('settings.projectId', settings.projectId);\n            this._projectId = settings.projectId;\n        }\n        if (settings.host !== undefined) {\n            validate_1.validateHost('settings.host', settings.host);\n            if (settings.servicePath !== undefined) {\n                throw new Error('Cannot set both \"settings.host\" and \"settings.servicePath\".');\n            }\n            if (settings.apiEndpoint !== undefined) {\n                throw new Error('Cannot set both \"settings.host\" and \"settings.apiEndpoint\".');\n            }\n            const url = new url_1.URL(`http://${settings.host}`);\n            settings.servicePath = url.hostname;\n            if (url.port !== '' && settings.port === undefined) {\n                settings.port = Number(url.port);\n            }\n            // We need to remove the `host` setting, in case a user calls `settings()`,\n            // which will again enforce that `host` and `servicePath` are not both\n            // specified.\n            delete settings.host;\n        }\n        if (settings.ssl !== undefined) {\n            validate_1.validateBoolean('settings.ssl', settings.ssl);\n        }\n        if (settings.maxIdleChannels !== undefined) {\n            validate_1.validateInteger('settings.maxIdleChannels', settings.maxIdleChannels, {\n                minValue: 0,\n            });\n        }\n        this._settings = settings;\n        this._serializer = new serializer_1.Serializer(this);\n    }\n    /**\n     * Returns the Project ID for this Firestore instance. Validates that\n     * `initializeIfNeeded()` was called before.\n     *\n     * @private\n     */\n    get projectId() {\n        if (this._projectId === undefined) {\n            throw new Error('INTERNAL ERROR: Client is not yet ready to issue requests.');\n        }\n        return this._projectId;\n    }\n    /**\n     * Returns the root path of the database. Validates that\n     * `initializeIfNeeded()` was called before.\n     *\n     * @private\n     */\n    get formattedName() {\n        return `projects/${this.projectId}/databases/${path_1.DEFAULT_DATABASE_ID}`;\n    }\n    /**\n     * Gets a [DocumentReference]{@link DocumentReference} instance that\n     * refers to the document at the specified path.\n     *\n     * @param {string} documentPath A slash-separated path to a document.\n     * @returns {DocumentReference} The\n     * [DocumentReference]{@link DocumentReference} instance.\n     *\n     * @example\n     * let documentRef = firestore.doc('collection/document');\n     * console.log(`Path of document is ${documentRef.path}`);\n     */\n    doc(documentPath) {\n        path_1.validateResourcePath('documentPath', documentPath);\n        const path = path_1.ResourcePath.EMPTY.append(documentPath);\n        if (!path.isDocument) {\n            throw new Error(`Value for argument \"documentPath\" must point to a document, but was \"${documentPath}\". Your path does not contain an even number of components.`);\n        }\n        return new reference_2.DocumentReference(this, path);\n    }\n    /**\n     * Gets a [CollectionReference]{@link CollectionReference} instance\n     * that refers to the collection at the specified path.\n     *\n     * @param {string} collectionPath A slash-separated path to a collection.\n     * @returns {CollectionReference} The\n     * [CollectionReference]{@link CollectionReference} instance.\n     *\n     * @example\n     * let collectionRef = firestore.collection('collection');\n     *\n     * // Add a document with an auto-generated ID.\n     * collectionRef.add({foo: 'bar'}).then((documentRef) => {\n     *   console.log(`Added document at ${documentRef.path})`);\n     * });\n     */\n    collection(collectionPath) {\n        path_1.validateResourcePath('collectionPath', collectionPath);\n        const path = path_1.ResourcePath.EMPTY.append(collectionPath);\n        if (!path.isCollection) {\n            throw new Error(`Value for argument \"collectionPath\" must point to a collection, but was \"${collectionPath}\". Your path does not contain an odd number of components.`);\n        }\n        return new reference_1.CollectionReference(this, path);\n    }\n    /**\n     * Creates and returns a new Query that includes all documents in the\n     * database that are contained in a collection or subcollection with the\n     * given collectionId.\n     *\n     * @param {string} collectionId Identifies the collections to query over.\n     * Every collection or subcollection with this ID as the last segment of its\n     * path will be included. Cannot contain a slash.\n     * @returns {Query} The created Query.\n     *\n     * @example\n     * let docA = firestore.doc('mygroup/docA').set({foo: 'bar'});\n     * let docB = firestore.doc('abc/def/mygroup/docB').set({foo: 'bar'});\n     *\n     * Promise.all([docA, docB]).then(() => {\n     *    let query = firestore.collectionGroup('mygroup');\n     *    query = query.where('foo', '==', 'bar');\n     *    return query.get().then(snapshot => {\n     *       console.log(`Found ${snapshot.size} documents.`);\n     *    });\n     * });\n     */\n    collectionGroup(collectionId) {\n        if (collectionId.indexOf('/') !== -1) {\n            throw new Error(`Invalid collectionId '${collectionId}'. Collection IDs must not contain '/'.`);\n        }\n        return new reference_1.Query(this, reference_1.QueryOptions.forCollectionGroupQuery(collectionId));\n    }\n    /**\n     * Creates a [WriteBatch]{@link WriteBatch}, used for performing\n     * multiple writes as a single atomic operation.\n     *\n     * @returns {WriteBatch} A WriteBatch that operates on this Firestore\n     * client.\n     *\n     * @example\n     * let writeBatch = firestore.batch();\n     *\n     * // Add two documents in an atomic batch.\n     * let data = { foo: 'bar' };\n     * writeBatch.set(firestore.doc('col/doc1'), data);\n     * writeBatch.set(firestore.doc('col/doc2'), data);\n     *\n     * writeBatch.commit().then(res => {\n     *   console.log('Successfully executed batch.');\n     * });\n     */\n    batch() {\n        return new write_batch_1.WriteBatch(this);\n    }\n    /**\n     * Creates a [BulkWriter]{@link BulkWriter}, used for performing\n     * multiple writes in parallel. Gradually ramps up writes as specified\n     * by the 500/50/5 rule.\n     *\n     * @see [500/50/5 Documentation]{@link https://cloud.google.com/datastore/docs/best-practices#ramping_up_traffic}\n     *\n     * @private\n     * @param {object=} options BulkWriter options.\n     * @param {boolean=} options.disableThrottling Whether to disable throttling\n     * as specified by the 500/50/5 rule.\n     * @returns {WriteBatch} A BulkWriter that operates on this Firestore\n     * client.\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     *\n     * bulkWriter.create(firestore.doc('col/doc1'), {foo: 'bar'})\n     *   .then(res => {\n     *     console.log(`Added document at ${res.writeTime}`);\n     *   });\n     * bulkWriter.update(firestore.doc('col/doc2'), {foo: 'bar'})\n     *   .then(res => {\n     *     console.log(`Updated document at ${res.writeTime}`);\n     *   });\n     * bulkWriter.delete(firestore.doc('col/doc3'))\n     *   .then(res => {\n     *     console.log(`Deleted document at ${res.writeTime}`);\n     *   });\n     * await bulkWriter.close().then(() => {\n     *   console.log('Executed all writes');\n     * });\n     */\n    _bulkWriter(options) {\n        return new bulk_writer_1.BulkWriter(this, !(options === null || options === void 0 ? void 0 : options.disableThrottling));\n    }\n    snapshot_(documentOrName, readTime, encoding) {\n        // TODO: Assert that Firestore Project ID is valid.\n        let convertTimestamp;\n        let convertFields;\n        if (encoding === undefined || encoding === 'protobufJS') {\n            convertTimestamp = data => data;\n            convertFields = data => data;\n        }\n        else if (encoding === 'json') {\n            // Google Cloud Functions calls us with Proto3 JSON format data, which we\n            // must convert to Protobuf JS.\n            convertTimestamp = convert_1.timestampFromJson;\n            convertFields = convert_1.fieldsFromJson;\n        }\n        else {\n            throw new Error(`Unsupported encoding format. Expected \"json\" or \"protobufJS\", ` +\n                `but was \"${encoding}\".`);\n        }\n        let ref;\n        let document;\n        if (typeof documentOrName === 'string') {\n            ref = new reference_2.DocumentReference(this, path_1.QualifiedResourcePath.fromSlashSeparatedString(documentOrName));\n            document = new document_1.DocumentSnapshotBuilder(ref);\n        }\n        else {\n            ref = new reference_2.DocumentReference(this, path_1.QualifiedResourcePath.fromSlashSeparatedString(documentOrName.name));\n            document = new document_1.DocumentSnapshotBuilder(ref);\n            document.fieldsProto = documentOrName.fields\n                ? convertFields(documentOrName.fields)\n                : {};\n            document.createTime = timestamp_1.Timestamp.fromProto(convertTimestamp(documentOrName.createTime, 'documentOrName.createTime'));\n            document.updateTime = timestamp_1.Timestamp.fromProto(convertTimestamp(documentOrName.updateTime, 'documentOrName.updateTime'));\n        }\n        if (readTime) {\n            document.readTime = timestamp_1.Timestamp.fromProto(convertTimestamp(readTime, 'readTime'));\n        }\n        return document.build();\n    }\n    /**\n     * Executes the given updateFunction and commits the changes applied within\n     * the transaction.\n     *\n     * You can use the transaction object passed to 'updateFunction' to read and\n     * modify Firestore documents under lock. Transactions are committed once\n     * 'updateFunction' resolves and attempted up to five times on failure.\n     *\n     * @param {function(Transaction)} updateFunction The function to execute\n     * within the transaction context.\n     * @param {object=} transactionOptions Transaction options.\n     * @param {number=} transactionOptions.maxAttempts - The maximum number of\n     * attempts for this transaction.\n     * @returns {Promise} If the transaction completed successfully or was\n     * explicitly aborted (by the updateFunction returning a failed Promise), the\n     * Promise returned by the updateFunction will be returned here. Else if the\n     * transaction failed, a rejected Promise with the corresponding failure\n     * error will be returned.\n     *\n     * @example\n     * let counterTransaction = firestore.runTransaction(transaction => {\n     *   let documentRef = firestore.doc('col/doc');\n     *   return transaction.get(documentRef).then(doc => {\n     *     if (doc.exists) {\n     *       let count =  doc.get('count') || 0;\n     *       if (count > 10) {\n     *         return Promise.reject('Reached maximum count');\n     *       }\n     *       transaction.update(documentRef, { count: ++count });\n     *       return Promise.resolve(count);\n     *     }\n     *\n     *     transaction.create(documentRef, { count: 1 });\n     *     return Promise.resolve(1);\n     *   });\n     * });\n     *\n     * counterTransaction.then(res => {\n     *   console.log(`Count updated to ${res}`);\n     * });\n     */\n    runTransaction(updateFunction, transactionOptions) {\n        validate_1.validateFunction('updateFunction', updateFunction);\n        const defaultAttempts = 5;\n        const tag = util_1.requestTag();\n        let maxAttempts;\n        if (transactionOptions) {\n            validate_1.validateObject('transactionOptions', transactionOptions);\n            validate_1.validateInteger('transactionOptions.maxAttempts', transactionOptions.maxAttempts, { optional: true, minValue: 1 });\n            maxAttempts = transactionOptions.maxAttempts || defaultAttempts;\n        }\n        else {\n            maxAttempts = defaultAttempts;\n        }\n        const transaction = new transaction_1.Transaction(this, tag);\n        return this.initializeIfNeeded(tag).then(() => transaction.runTransaction(updateFunction, maxAttempts));\n    }\n    /**\n     * Fetches the root collections that are associated with this Firestore\n     * database.\n     *\n     * @returns {Promise.<Array.<CollectionReference>>} A Promise that resolves\n     * with an array of CollectionReferences.\n     *\n     * @example\n     * firestore.listCollections().then(collections => {\n     *   for (let collection of collections) {\n     *     console.log(`Found collection with id: ${collection.id}`);\n     *   }\n     * });\n     */\n    listCollections() {\n        const rootDocument = new reference_2.DocumentReference(this, path_1.ResourcePath.EMPTY);\n        return rootDocument.listCollections();\n    }\n    /**\n     * Retrieves multiple documents from Firestore.\n     *\n     * The first argument is required and must be of type `DocumentReference`\n     * followed by any additional `DocumentReference` documents. If used, the\n     * optional `ReadOptions` must be the last argument.\n     *\n     * @param {...DocumentReference|ReadOptions} documentRefsOrReadOptions The\n     * `DocumentReferences` to receive, followed by an optional field mask.\n     * @returns {Promise<Array.<DocumentSnapshot>>} A Promise that\n     * contains an array with the resulting document snapshots.\n     *\n     * @example\n     * let docRef1 = firestore.doc('col/doc1');\n     * let docRef2 = firestore.doc('col/doc2');\n     *\n     * firestore.getAll(docRef1, docRef2, { fieldMask: ['user'] }).then(docs => {\n     *   console.log(`First document: ${JSON.stringify(docs[0])}`);\n     *   console.log(`Second document: ${JSON.stringify(docs[1])}`);\n     * });\n     */\n    getAll(...documentRefsOrReadOptions) {\n        validate_1.validateMinNumberOfArguments('Firestore.getAll', arguments, 1);\n        const { documents, fieldMask } = transaction_1.parseGetAllArguments(documentRefsOrReadOptions);\n        const tag = util_1.requestTag();\n        // Capture the error stack to preserve stack tracing across async calls.\n        const stack = Error().stack;\n        return this.initializeIfNeeded(tag)\n            .then(() => this.getAll_(documents, fieldMask, tag))\n            .catch(err => {\n            throw util_1.wrapError(err, stack);\n        });\n    }\n    /**\n     * Internal method to retrieve multiple documents from Firestore, optionally\n     * as part of a transaction.\n     *\n     * @private\n     * @param docRefs The documents to receive.\n     * @param fieldMask An optional field mask to apply to this read.\n     * @param requestTag A unique client-assigned identifier for this request.\n     * @param transactionId The transaction ID to use for this read.\n     * @returns A Promise that contains an array with the resulting documents.\n     */\n    getAll_(docRefs, fieldMask, requestTag, transactionId) {\n        const requestedDocuments = new Set();\n        const retrievedDocuments = new Map();\n        for (const docRef of docRefs) {\n            requestedDocuments.add(docRef.formattedName);\n        }\n        const request = {\n            database: this.formattedName,\n            transaction: transactionId,\n            documents: Array.from(requestedDocuments),\n        };\n        if (fieldMask) {\n            const fieldPaths = fieldMask.map(fieldPath => fieldPath.formattedName);\n            request.mask = { fieldPaths };\n        }\n        return this.requestStream('batchGetDocuments', request, requestTag).then(stream => {\n            return new Promise((resolve, reject) => {\n                stream\n                    .on('error', err => {\n                    logger_1.logger('Firestore.getAll_', requestTag, 'GetAll failed with error:', err);\n                    reject(err);\n                })\n                    .on('data', (response) => {\n                    try {\n                        let document;\n                        if (response.found) {\n                            logger_1.logger('Firestore.getAll_', requestTag, 'Received document: %s', response.found.name);\n                            document = this.snapshot_(response.found, response.readTime);\n                        }\n                        else {\n                            logger_1.logger('Firestore.getAll_', requestTag, 'Document missing: %s', response.missing);\n                            document = this.snapshot_(response.missing, response.readTime);\n                        }\n                        const path = document.ref.path;\n                        retrievedDocuments.set(path, document);\n                    }\n                    catch (err) {\n                        logger_1.logger('Firestore.getAll_', requestTag, 'GetAll failed with exception:', err);\n                        reject(err);\n                    }\n                })\n                    .on('end', () => {\n                    logger_1.logger('Firestore.getAll_', requestTag, 'Received %d results', retrievedDocuments.size);\n                    // BatchGetDocuments doesn't preserve document order. We use\n                    // the request order to sort the resulting documents.\n                    const orderedDocuments = [];\n                    for (const docRef of docRefs) {\n                        const document = retrievedDocuments.get(docRef.path);\n                        if (document !== undefined) {\n                            // Recreate the DocumentSnapshot with the DocumentReference\n                            // containing the original converter.\n                            const finalDoc = new document_1.DocumentSnapshotBuilder(docRef);\n                            finalDoc.fieldsProto = document._fieldsProto;\n                            finalDoc.readTime = document.readTime;\n                            finalDoc.createTime = document.createTime;\n                            finalDoc.updateTime = document.updateTime;\n                            orderedDocuments.push(finalDoc.build());\n                        }\n                        else {\n                            reject(new Error(`Did not receive document for \"${docRef.path}\".`));\n                        }\n                    }\n                    resolve(orderedDocuments);\n                });\n                stream.resume();\n            });\n        });\n    }\n    /**\n     * Registers a listener on this client, incrementing the listener count. This\n     * is used to verify that all listeners are unsubscribed when terminate() is\n     * called.\n     *\n     * @private\n     */\n    registerListener() {\n        this.registeredListenersCount += 1;\n    }\n    /**\n     * Unregisters a listener on this client, decrementing the listener count.\n     * This is used to verify that all listeners are unsubscribed when terminate()\n     * is called.\n     *\n     * @private\n     */\n    unregisterListener() {\n        this.registeredListenersCount -= 1;\n    }\n    /**\n     * Terminates the Firestore client and closes all open streams.\n     *\n     * @return A Promise that resolves when the client is terminated.\n     */\n    terminate() {\n        if (this.registeredListenersCount > 0) {\n            return Promise.reject('All onSnapshot() listeners must be unsubscribed before terminating the client.');\n        }\n        return this._clientPool.terminate();\n    }\n    /**\n     * Initializes the client if it is not already initialized. All methods in the\n     * SDK can be used after this method completes.\n     *\n     * @private\n     * @param requestTag A unique client-assigned identifier that caused this\n     * initialization.\n     * @return A Promise that resolves when the client is initialized.\n     */\n    async initializeIfNeeded(requestTag) {\n        this._settingsFrozen = true;\n        if (this._settings.ssl === false) {\n            // If SSL is false, we assume that we are talking to the emulator. We\n            // provide an Authorization header by default so that the connection is\n            // recognized as admin in Firestore Emulator. (If for some reason we're\n            // not connecting to the emulator, then this will result in denials with\n            // invalid token, rather than behave like clients not logged in. The user\n            // can then provide their own Authorization header, which will take\n            // precedence).\n            this._settings.customHeaders = Object.assign({ Authorization: 'Bearer owner' }, this._settings.customHeaders);\n        }\n        if (this._projectId === undefined) {\n            try {\n                this._projectId = await this._clientPool.run(requestTag, gapicClient => gapicClient.getProjectId());\n                logger_1.logger('Firestore.initializeIfNeeded', null, 'Detected project ID: %s', this._projectId);\n            }\n            catch (err) {\n                logger_1.logger('Firestore.initializeIfNeeded', null, 'Failed to detect project ID: %s', err);\n                return Promise.reject(err);\n            }\n        }\n    }\n    /**\n     * Returns GAX call options that set the cloud resource header.\n     * @private\n     */\n    createCallOptions(methodName, retryCodes) {\n        const callOptions = {\n            otherArgs: {\n                headers: Object.assign({ [CLOUD_RESOURCE_HEADER]: this.formattedName }, this._settings.customHeaders),\n            },\n        };\n        if (retryCodes) {\n            const retryParams = util_1.getRetryParams(methodName);\n            callOptions.retry = new google_gax_1.RetryOptions(retryCodes, retryParams);\n        }\n        return callOptions;\n    }\n    /**\n     * A function returning a Promise that can be retried.\n     *\n     * @private\n     * @callback retryFunction\n     * @returns {Promise} A Promise indicating the function's success.\n     */\n    /**\n     * Helper method that retries failed Promises.\n     *\n     * If 'delayMs' is specified, waits 'delayMs' between invocations. Otherwise,\n     * schedules the first attempt immediately, and then waits 100 milliseconds\n     * for further attempts.\n     *\n     * @private\n     * @param methodName Name of the Veneer API endpoint that takes a request\n     * and GAX options.\n     * @param requestTag A unique client-assigned identifier for this request.\n     * @param func Method returning a Promise than can be retried.\n     * @returns A Promise with the function's result if successful within\n     * `attemptsRemaining`. Otherwise, returns the last rejected Promise.\n     */\n    async _retry(methodName, requestTag, func) {\n        const backoff = new backoff_1.ExponentialBackoff();\n        let lastError = undefined;\n        for (let attempt = 0; attempt < MAX_REQUEST_RETRIES; ++attempt) {\n            if (lastError) {\n                logger_1.logger('Firestore._retry', requestTag, 'Retrying request that failed with error:', lastError);\n            }\n            try {\n                await backoff.backoffAndWait();\n                const result = await func();\n                this._lastSuccessfulRequest = new Date().getTime();\n                return result;\n            }\n            catch (err) {\n                lastError = err;\n                if (util_1.isPermanentRpcError(err, methodName)) {\n                    break;\n                }\n            }\n        }\n        logger_1.logger('Firestore._retry', requestTag, 'Request failed with error:', lastError);\n        return Promise.reject(lastError);\n    }\n    /**\n     * Waits for the provided stream to become active and returns a paused but\n     * healthy stream. If an error occurs before the first byte is read, the\n     * method rejects the returned Promise.\n     *\n     * @private\n     * @param backendStream The Node stream to monitor.\n     * @param lifetime A Promise that resolves when the stream receives an 'end',\n     * 'close' or 'finish' message.\n     * @param requestTag A unique client-assigned identifier for this request.\n     * @param request If specified, the request that should be written to the\n     * stream after opening.\n     * @returns A guaranteed healthy stream that should be used instead of\n     * `backendStream`.\n     */\n    _initializeStream(backendStream, lifetime, requestTag, request) {\n        const resultStream = new stream_1.PassThrough({ objectMode: true });\n        resultStream.pause();\n        /**\n         * Whether we have resolved the Promise and returned the stream to the\n         * caller.\n         */\n        let streamInitialized = false;\n        return new Promise((resolve, reject) => {\n            function streamReady() {\n                if (!streamInitialized) {\n                    streamInitialized = true;\n                    logger_1.logger('Firestore._initializeStream', requestTag, 'Releasing stream');\n                    resolve(resultStream);\n                }\n            }\n            function streamEnded() {\n                logger_1.logger('Firestore._initializeStream', requestTag, 'Received stream end');\n                resultStream.unpipe(backendStream);\n                resolve(resultStream);\n                lifetime.resolve();\n            }\n            function streamFailed(err) {\n                if (!streamInitialized) {\n                    // If we receive an error before we were able to receive any data,\n                    // reject this stream.\n                    logger_1.logger('Firestore._initializeStream', requestTag, 'Received initial error:', err);\n                    reject(err);\n                }\n                else {\n                    logger_1.logger('Firestore._initializeStream', requestTag, 'Received stream error:', err);\n                    // We execute the forwarding of the 'error' event via setImmediate() as\n                    // V8 guarantees that the Promise chain returned from this method\n                    // is resolved before any code executed via setImmediate(). This\n                    // allows the caller to attach an error handler.\n                    setImmediate(() => {\n                        resultStream.emit('error', err);\n                    });\n                }\n            }\n            backendStream.on('data', () => streamReady());\n            backendStream.on('error', err => streamFailed(err));\n            backendStream.on('end', () => streamEnded());\n            backendStream.on('close', () => streamEnded());\n            backendStream.on('finish', () => streamEnded());\n            backendStream.pipe(resultStream);\n            if (request) {\n                logger_1.logger('Firestore._initializeStream', requestTag, 'Sending request: %j', request);\n                backendStream.write(request, 'utf-8', err => {\n                    if (err) {\n                        streamFailed(err);\n                    }\n                    else {\n                        logger_1.logger('Firestore._initializeStream', requestTag, 'Marking stream as healthy');\n                        streamReady();\n                    }\n                });\n            }\n        });\n    }\n    /**\n     * A funnel for all non-streaming API requests, assigning a project ID where\n     * necessary within the request options.\n     *\n     * @private\n     * @param methodName Name of the Veneer API endpoint that takes a request\n     * and GAX options.\n     * @param request The Protobuf request to send.\n     * @param requestTag A unique client-assigned identifier for this request.\n     * @param retryCodes If provided, a custom list of retry codes. If not\n     * provided, retry is based on the behavior as defined in the ServiceConfig.\n     * @returns A Promise with the request result.\n     */\n    request(methodName, request, requestTag, retryCodes) {\n        const callOptions = this.createCallOptions(methodName, retryCodes);\n        return this._clientPool.run(requestTag, async (gapicClient) => {\n            try {\n                logger_1.logger('Firestore.request', requestTag, 'Sending request: %j', request);\n                const [result] = await gapicClient[methodName](request, callOptions);\n                logger_1.logger('Firestore.request', requestTag, 'Received response: %j', result);\n                this._lastSuccessfulRequest = new Date().getTime();\n                return result;\n            }\n            catch (err) {\n                logger_1.logger('Firestore.request', requestTag, 'Received error:', err);\n                return Promise.reject(err);\n            }\n        });\n    }\n    /**\n     * A funnel for streaming API requests, assigning a project ID where necessary\n     * within the request options.\n     *\n     * The stream is returned in paused state and needs to be resumed once all\n     * listeners are attached.\n     *\n     * @private\n     * @param methodName Name of the streaming Veneer API endpoint that\n     * takes a request and GAX options.\n     * @param request The Protobuf request to send.\n     * @param requestTag A unique client-assigned identifier for this request.\n     * @returns A Promise with the resulting read-only stream.\n     */\n    requestStream(methodName, request, requestTag) {\n        const callOptions = this.createCallOptions(methodName);\n        const bidirectional = methodName === 'listen';\n        return this._retry(methodName, requestTag, () => {\n            const result = new util_1.Deferred();\n            this._clientPool.run(requestTag, async (gapicClient) => {\n                logger_1.logger('Firestore.requestStream', requestTag, 'Sending request: %j', request);\n                try {\n                    const stream = bidirectional\n                        ? gapicClient[methodName](callOptions)\n                        : gapicClient[methodName](request, callOptions);\n                    const logStream = through2.obj(function (chunk, enc, callback) {\n                        logger_1.logger('Firestore.requestStream', requestTag, 'Received response: %j', chunk);\n                        callback();\n                    });\n                    stream.pipe(logStream);\n                    const lifetime = new util_1.Deferred();\n                    const resultStream = await this._initializeStream(stream, lifetime, requestTag, bidirectional ? request : undefined);\n                    resultStream.on('end', () => stream.end());\n                    result.resolve(resultStream);\n                    // While we return the stream to the callee early, we don't want to\n                    // release the GAPIC client until the callee has finished processing the\n                    // stream.\n                    return lifetime.promise;\n                }\n                catch (e) {\n                    result.reject(e);\n                }\n            });\n            return result.promise;\n        });\n    }\n}\nexports.Firestore = Firestore;\n/**\n * A logging function that takes a single string.\n *\n * @callback Firestore~logFunction\n * @param {string} Log message\n */\n// tslint:disable-next-line:no-default-export\n/**\n * The default export of the `@google-cloud/firestore` package is the\n * {@link Firestore} class.\n *\n * See {@link Firestore} and {@link ClientConfig} for client methods and\n * configuration options.\n *\n * @module {Firestore} @google-cloud/firestore\n * @alias nodejs-firestore\n *\n * @example <caption>Install the client library with <a\n * href=\"https://www.npmjs.com/\">npm</a>:</caption> npm install --save\n * @google-cloud/firestore\n *\n * @example <caption>Import the client library</caption>\n * var Firestore = require('@google-cloud/firestore');\n *\n * @example <caption>Create a client that uses <a\n * href=\"https://cloud.google.com/docs/authentication/production#providing_credentials_to_your_application\">Application\n * Default Credentials (ADC)</a>:</caption> var firestore = new Firestore();\n *\n * @example <caption>Create a client with <a\n * href=\"https://cloud.google.com/docs/authentication/production#obtaining_and_providing_service_account_credentials_manually\">explicit\n * credentials</a>:</caption> var firestore = new Firestore({ projectId:\n * 'your-project-id', keyFilename: '/path/to/keyfile.json'\n * });\n *\n * @example <caption>include:samples/quickstart.js</caption>\n * region_tag:firestore_quickstart\n * Full quickstart example:\n */\n// tslint:disable-next-line:no-default-export\nexports.default = Firestore;\n// Horrible hack to ensure backwards compatibility with <= 17.0, which allows\n// users to call the default constructor via\n// `const Fs = require(`@google-cloud/firestore`); new Fs()`;\nconst existingExports = module.exports;\nmodule.exports = Firestore;\nmodule.exports = Object.assign(module.exports, existingExports);\n/**\n * {@link v1beta1} factory function.\n *\n * @private\n * @name Firestore.v1beta1\n * @see v1beta1\n * @type {function}\n */\nObject.defineProperty(module.exports, \"v1beta1\", ({\n    // The v1beta1 module is very large. To avoid pulling it in from static\n    // scope, we lazy-load and cache the module.\n    get: () => {\n        if (!v1beta1) {\n            v1beta1 = __webpack_require__(/*! ./v1beta1 */ \"./src/node_modules/@google-cloud/firestore/build/src/v1beta1/index.js\");\n        }\n        return v1beta1;\n    },\n}));\n/**\n * {@link v1} factory function.\n *\n * @private\n * @name Firestore.v1\n * @see v1\n * @type {function}\n */\nObject.defineProperty(module.exports, \"v1\", ({\n    // The v1 module is very large. To avoid pulling it in from static\n    // scope, we lazy-load and cache the module.\n    get: () => {\n        if (!v1) {\n            v1 = __webpack_require__(/*! ./v1 */ \"./src/node_modules/@google-cloud/firestore/build/src/v1/index.js\");\n        }\n        return v1;\n    },\n}));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/firestore/build/src/index.js?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/firestore/build/src/logger.js":
/*!**********************************************************************!*\
  !*** ./src/node_modules/@google-cloud/firestore/build/src/logger.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst util = __webpack_require__(/*! util */ \"util\");\nconst validate_1 = __webpack_require__(/*! ./validate */ \"./src/node_modules/@google-cloud/firestore/build/src/validate.js\");\n/*! The Firestore library version */\nlet libVersion;\n/*! The external function used to emit logs. */\nlet logFunction = null;\n/**\n * Log function to use for debug output. By default, we don't perform any\n * logging.\n *\n * @private\n */\nfunction logger(methodName, requestTag, logMessage, ...additionalArgs) {\n    requestTag = requestTag || '#####';\n    if (logFunction) {\n        const formattedMessage = util.format(logMessage, ...additionalArgs);\n        const time = new Date().toISOString();\n        logFunction(`Firestore (${libVersion}) ${time} ${requestTag} [${methodName}]: ` +\n            formattedMessage);\n    }\n}\nexports.logger = logger;\n/**\n * Sets or disables the log function for all active Firestore instances.\n *\n * @param logger A log function that takes a message (such as `console.log`) or\n * `null` to turn off logging.\n */\nfunction setLogFunction(logger) {\n    validate_1.validateFunction('logger', logger);\n    logFunction = logger;\n}\nexports.setLogFunction = setLogFunction;\n/**\n * Sets the library version to be used in log messages.\n *\n * @private\n */\nfunction setLibVersion(version) {\n    libVersion = version;\n}\nexports.setLibVersion = setLibVersion;\n//# sourceMappingURL=logger.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/firestore/build/src/logger.js?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/firestore/build/src/order.js":
/*!*********************************************************************!*\
  !*** ./src/node_modules/@google-cloud/firestore/build/src/order.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst convert_1 = __webpack_require__(/*! ./convert */ \"./src/node_modules/@google-cloud/firestore/build/src/convert.js\");\nconst path_1 = __webpack_require__(/*! ./path */ \"./src/node_modules/@google-cloud/firestore/build/src/path.js\");\n/*!\n * The type order as defined by the backend.\n */\nvar TypeOrder;\n(function (TypeOrder) {\n    TypeOrder[TypeOrder[\"NULL\"] = 0] = \"NULL\";\n    TypeOrder[TypeOrder[\"BOOLEAN\"] = 1] = \"BOOLEAN\";\n    TypeOrder[TypeOrder[\"NUMBER\"] = 2] = \"NUMBER\";\n    TypeOrder[TypeOrder[\"TIMESTAMP\"] = 3] = \"TIMESTAMP\";\n    TypeOrder[TypeOrder[\"STRING\"] = 4] = \"STRING\";\n    TypeOrder[TypeOrder[\"BLOB\"] = 5] = \"BLOB\";\n    TypeOrder[TypeOrder[\"REF\"] = 6] = \"REF\";\n    TypeOrder[TypeOrder[\"GEO_POINT\"] = 7] = \"GEO_POINT\";\n    TypeOrder[TypeOrder[\"ARRAY\"] = 8] = \"ARRAY\";\n    TypeOrder[TypeOrder[\"OBJECT\"] = 9] = \"OBJECT\";\n})(TypeOrder || (TypeOrder = {}));\n/*!\n * @private\n */\nfunction typeOrder(val) {\n    const valueType = convert_1.detectValueType(val);\n    switch (valueType) {\n        case 'nullValue':\n            return TypeOrder.NULL;\n        case 'integerValue':\n            return TypeOrder.NUMBER;\n        case 'doubleValue':\n            return TypeOrder.NUMBER;\n        case 'stringValue':\n            return TypeOrder.STRING;\n        case 'booleanValue':\n            return TypeOrder.BOOLEAN;\n        case 'arrayValue':\n            return TypeOrder.ARRAY;\n        case 'timestampValue':\n            return TypeOrder.TIMESTAMP;\n        case 'geoPointValue':\n            return TypeOrder.GEO_POINT;\n        case 'bytesValue':\n            return TypeOrder.BLOB;\n        case 'referenceValue':\n            return TypeOrder.REF;\n        case 'mapValue':\n            return TypeOrder.OBJECT;\n        default:\n            throw new Error('Unexpected value type: ' + valueType);\n    }\n}\n/*!\n * @private\n */\nfunction primitiveComparator(left, right) {\n    if (left < right) {\n        return -1;\n    }\n    if (left > right) {\n        return 1;\n    }\n    return 0;\n}\nexports.primitiveComparator = primitiveComparator;\n/*!\n * Utility function to compare doubles (using Firestore semantics for NaN).\n * @private\n */\nfunction compareNumbers(left, right) {\n    if (left < right) {\n        return -1;\n    }\n    if (left > right) {\n        return 1;\n    }\n    if (left === right) {\n        return 0;\n    }\n    // one or both are NaN.\n    if (isNaN(left)) {\n        return isNaN(right) ? 0 : -1;\n    }\n    return 1;\n}\n/*!\n * @private\n */\nfunction compareNumberProtos(left, right) {\n    let leftValue, rightValue;\n    if (left.integerValue !== undefined) {\n        leftValue = Number(left.integerValue);\n    }\n    else {\n        leftValue = Number(left.doubleValue);\n    }\n    if (right.integerValue !== undefined) {\n        rightValue = Number(right.integerValue);\n    }\n    else {\n        rightValue = Number(right.doubleValue);\n    }\n    return compareNumbers(leftValue, rightValue);\n}\n/*!\n * @private\n */\nfunction compareTimestamps(left, right) {\n    const seconds = primitiveComparator(left.seconds || 0, right.seconds || 0);\n    if (seconds !== 0) {\n        return seconds;\n    }\n    return primitiveComparator(left.nanos || 0, right.nanos || 0);\n}\n/*!\n * @private\n */\nfunction compareBlobs(left, right) {\n    if (!(left instanceof Buffer) || !(right instanceof Buffer)) {\n        throw new Error('Blobs can only be compared if they are Buffers.');\n    }\n    return Buffer.compare(left, right);\n}\n/*!\n * @private\n */\nfunction compareReferenceProtos(left, right) {\n    const leftPath = path_1.QualifiedResourcePath.fromSlashSeparatedString(left.referenceValue);\n    const rightPath = path_1.QualifiedResourcePath.fromSlashSeparatedString(right.referenceValue);\n    return leftPath.compareTo(rightPath);\n}\n/*!\n * @private\n */\nfunction compareGeoPoints(left, right) {\n    return (primitiveComparator(left.latitude || 0, right.latitude || 0) ||\n        primitiveComparator(left.longitude || 0, right.longitude || 0));\n}\n/*!\n * @private\n */\nfunction compareArrays(left, right) {\n    for (let i = 0; i < left.length && i < right.length; i++) {\n        const valueComparison = compare(left[i], right[i]);\n        if (valueComparison !== 0) {\n            return valueComparison;\n        }\n    }\n    // If all the values matched so far, just check the length.\n    return primitiveComparator(left.length, right.length);\n}\n/*!\n * @private\n */\nfunction compareObjects(left, right) {\n    // This requires iterating over the keys in the object in order and doing a\n    // deep comparison.\n    const leftKeys = Object.keys(left);\n    const rightKeys = Object.keys(right);\n    leftKeys.sort();\n    rightKeys.sort();\n    for (let i = 0; i < leftKeys.length && i < rightKeys.length; i++) {\n        const keyComparison = primitiveComparator(leftKeys[i], rightKeys[i]);\n        if (keyComparison !== 0) {\n            return keyComparison;\n        }\n        const key = leftKeys[i];\n        const valueComparison = compare(left[key], right[key]);\n        if (valueComparison !== 0) {\n            return valueComparison;\n        }\n    }\n    // If all the keys matched so far, just check the length.\n    return primitiveComparator(leftKeys.length, rightKeys.length);\n}\n/*!\n * @private\n */\nfunction compare(left, right) {\n    // First compare the types.\n    const leftType = typeOrder(left);\n    const rightType = typeOrder(right);\n    const typeComparison = primitiveComparator(leftType, rightType);\n    if (typeComparison !== 0) {\n        return typeComparison;\n    }\n    // So they are the same type.\n    switch (leftType) {\n        case TypeOrder.NULL:\n            // Nulls are all equal.\n            return 0;\n        case TypeOrder.BOOLEAN:\n            return primitiveComparator(left.booleanValue, right.booleanValue);\n        case TypeOrder.STRING:\n            return primitiveComparator(left.stringValue, right.stringValue);\n        case TypeOrder.NUMBER:\n            return compareNumberProtos(left, right);\n        case TypeOrder.TIMESTAMP:\n            return compareTimestamps(left.timestampValue, right.timestampValue);\n        case TypeOrder.BLOB:\n            return compareBlobs(left.bytesValue, right.bytesValue);\n        case TypeOrder.REF:\n            return compareReferenceProtos(left, right);\n        case TypeOrder.GEO_POINT:\n            return compareGeoPoints(left.geoPointValue, right.geoPointValue);\n        case TypeOrder.ARRAY:\n            return compareArrays(left.arrayValue.values || [], right.arrayValue.values || []);\n        case TypeOrder.OBJECT:\n            return compareObjects(left.mapValue.fields || {}, right.mapValue.fields || {});\n        default:\n            throw new Error(`Encountered unknown type order: ${leftType}`);\n    }\n}\nexports.compare = compare;\n//# sourceMappingURL=order.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/firestore/build/src/order.js?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/firestore/build/src/path.js":
/*!********************************************************************!*\
  !*** ./src/node_modules/@google-cloud/firestore/build/src/path.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst util_1 = __webpack_require__(/*! ./util */ \"./src/node_modules/@google-cloud/firestore/build/src/util.js\");\nconst validate_1 = __webpack_require__(/*! ./validate */ \"./src/node_modules/@google-cloud/firestore/build/src/validate.js\");\n/*!\n * The default database ID for this Firestore client. We do not yet expose the\n * ability to use different databases.\n */\nexports.DEFAULT_DATABASE_ID = '(default)';\n/*!\n * A regular expression to verify an absolute Resource Path in Firestore. It\n * extracts the project ID, the database name and the relative resource path\n * if available.\n *\n * @type {RegExp}\n */\nconst RESOURCE_PATH_RE = \n// Note: [\\s\\S] matches all characters including newlines.\n/^projects\\/([^/]*)\\/databases\\/([^/]*)(?:\\/documents\\/)?([\\s\\S]*)$/;\n/*!\n * A regular expression to verify whether a field name can be passed to the\n * backend without escaping.\n *\n * @type {RegExp}\n */\nconst UNESCAPED_FIELD_NAME_RE = /^[_a-zA-Z][_a-zA-Z0-9]*$/;\n/*!\n * A regular expression to verify field paths that are passed to the API as\n * strings. Field paths that do not match this expression have to be provided\n * as a [FieldPath]{@link FieldPath} object.\n *\n * @type {RegExp}\n */\nconst FIELD_PATH_RE = /^[^*~/[\\]]+$/;\n/**\n * An abstract class representing a Firestore path.\n *\n * Subclasses have to implement `split()` and `canonicalString()`.\n *\n * @private\n * @class\n */\nclass Path {\n    /**\n     * Creates a new Path with the given segments.\n     *\n     * @private\n     * @hideconstructor\n     * @param segments Sequence of parts of a path.\n     */\n    constructor(segments) {\n        this.segments = segments;\n    }\n    /**\n     * Returns the number of segments of this field path.\n     *\n     * @private\n     */\n    get size() {\n        return this.segments.length;\n    }\n    /**\n     * Create a child path beneath the current level.\n     *\n     * @private\n     * @param relativePath Relative path to append to the current path.\n     * @returns The new path.\n     */\n    append(relativePath) {\n        if (relativePath instanceof Path) {\n            return this.construct(this.segments.concat(relativePath.segments));\n        }\n        return this.construct(this.segments.concat(this.split(relativePath)));\n    }\n    /**\n     * Returns the path of the parent node.\n     *\n     * @private\n     * @returns The new path or null if we are already at the root.\n     */\n    parent() {\n        if (this.segments.length === 0) {\n            return null;\n        }\n        return this.construct(this.segments.slice(0, this.segments.length - 1));\n    }\n    /**\n     * Checks whether the current path is a prefix of the specified path.\n     *\n     * @private\n     * @param other The path to check against.\n     * @returns 'true' iff the current path is a prefix match with 'other'.\n     */\n    isPrefixOf(other) {\n        if (other.segments.length < this.segments.length) {\n            return false;\n        }\n        for (let i = 0; i < this.segments.length; i++) {\n            if (this.segments[i] !== other.segments[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Compare the current path against another Path object.\n     *\n     * @private\n     * @param other The path to compare to.\n     * @returns -1 if current < other, 1 if current > other, 0 if equal\n     */\n    compareTo(other) {\n        const len = Math.min(this.segments.length, other.segments.length);\n        for (let i = 0; i < len; i++) {\n            if (this.segments[i] < other.segments[i]) {\n                return -1;\n            }\n            if (this.segments[i] > other.segments[i]) {\n                return 1;\n            }\n        }\n        if (this.segments.length < other.segments.length) {\n            return -1;\n        }\n        if (this.segments.length > other.segments.length) {\n            return 1;\n        }\n        return 0;\n    }\n    /**\n     * Returns a copy of the underlying segments.\n     *\n     * @private\n     * @returns A copy of the segments that make up this path.\n     */\n    toArray() {\n        return this.segments.slice();\n    }\n    /**\n     * Returns true if this `Path` is equal to the provided value.\n     *\n     * @private\n     * @param other The value to compare against.\n     * @return true if this `Path` is equal to the provided value.\n     */\n    isEqual(other) {\n        return this === other || this.compareTo(other) === 0;\n    }\n}\n/**\n * A slash-separated path for navigating resources within the current Firestore\n * instance.\n *\n * @private\n */\nclass ResourcePath extends Path {\n    /**\n     * Constructs a ResourcePath.\n     *\n     * @private\n     * @param segments Sequence of names of the parts of the path.\n     */\n    constructor(...segments) {\n        super(segments);\n    }\n    /**\n     * Indicates whether this path points to a document.\n     * @private\n     */\n    get isDocument() {\n        return this.segments.length > 0 && this.segments.length % 2 === 0;\n    }\n    /**\n     * Indicates whether this path points to a collection.\n     * @private\n     */\n    get isCollection() {\n        return this.segments.length % 2 === 1;\n    }\n    /**\n     * The last component of the path.\n     * @private\n     */\n    get id() {\n        if (this.segments.length > 0) {\n            return this.segments[this.segments.length - 1];\n        }\n        return null;\n    }\n    /**\n     * Returns the location of this path relative to the root of the project's\n     * database.\n     * @private\n     */\n    get relativeName() {\n        return this.segments.join('/');\n    }\n    /**\n     * Constructs a new instance of ResourcePath.\n     *\n     * @private\n     * @param segments Sequence of parts of the path.\n     * @returns The newly created ResourcePath.\n     */\n    construct(segments) {\n        return new ResourcePath(...segments);\n    }\n    /**\n     * Splits a string into path segments, using slashes as separators.\n     *\n     * @private\n     * @param relativePath The path to split.\n     * @returns The split path segments.\n     */\n    split(relativePath) {\n        // We may have an empty segment at the beginning or end if they had a\n        // leading or trailing slash (which we allow).\n        return relativePath.split('/').filter(segment => segment.length > 0);\n    }\n    /**\n     * Converts this path to a fully qualified ResourcePath.\n     *\n     * @private\n     * @param projectIdIfMissing The project ID of the current Firestore project.\n     * The project ID is only used if it's not provided as part of this\n     * ResourcePath.\n     * @return A fully-qualified resource path pointing to the same element.\n     */\n    toQualifiedResourcePath(projectIdIfMissing) {\n        return new QualifiedResourcePath(projectIdIfMissing, exports.DEFAULT_DATABASE_ID, ...this.segments);\n    }\n}\nexports.ResourcePath = ResourcePath;\n/**\n * A default instance pointing to the root collection.\n * @private\n */\nResourcePath.EMPTY = new ResourcePath();\n/**\n * A slash-separated path that includes a project and database ID for referring\n * to resources in any Firestore project.\n *\n * @private\n */\nclass QualifiedResourcePath extends ResourcePath {\n    /**\n     * Constructs a Firestore Resource Path.\n     *\n     * @private\n     * @param projectId The Firestore project id.\n     * @param databaseId The Firestore database id.\n     * @param segments Sequence of names of the parts of the path.\n     */\n    constructor(projectId, databaseId, ...segments) {\n        super(...segments);\n        this.projectId = projectId;\n        this.databaseId = databaseId;\n    }\n    /**\n     * String representation of the path relative to the database root.\n     * @private\n     */\n    get relativeName() {\n        return this.segments.join('/');\n    }\n    /**\n     * Creates a resource path from an absolute Firestore path.\n     *\n     * @private\n     * @param absolutePath A string representation of a Resource Path.\n     * @returns The new ResourcePath.\n     */\n    static fromSlashSeparatedString(absolutePath) {\n        const elements = RESOURCE_PATH_RE.exec(absolutePath);\n        if (elements) {\n            const project = elements[1];\n            const database = elements[2];\n            const path = elements[3];\n            return new QualifiedResourcePath(project, database).append(path);\n        }\n        throw new Error(`Resource name '${absolutePath}' is not valid.`);\n    }\n    /**\n     * Create a child path beneath the current level.\n     *\n     * @private\n     * @param relativePath Relative path to append to the current path.\n     * @returns The new path.\n     */\n    append(relativePath) {\n        // `super.append()` calls `QualifiedResourcePath.construct()` when invoked\n        // from here and returns a QualifiedResourcePath.\n        return super.append(relativePath);\n    }\n    /**\n     * Create a child path beneath the current level.\n     *\n     * @private\n     * @returns The new path.\n     */\n    parent() {\n        return super.parent();\n    }\n    /**\n     * String representation of a ResourcePath as expected by the API.\n     *\n     * @private\n     * @returns The representation as expected by the API.\n     */\n    get formattedName() {\n        const components = [\n            'projects',\n            this.projectId,\n            'databases',\n            this.databaseId,\n            'documents',\n            ...this.segments,\n        ];\n        return components.join('/');\n    }\n    /**\n     * Constructs a new instance of ResourcePath. We need this instead of using\n     * the normal constructor because polymorphic 'this' doesn't work on static\n     * methods.\n     *\n     * @private\n     * @param segments Sequence of names of the parts of the path.\n     * @returns The newly created QualifiedResourcePath.\n     */\n    construct(segments) {\n        return new QualifiedResourcePath(this.projectId, this.databaseId, ...segments);\n    }\n    /**\n     * Convenience method to match the ResourcePath API. This method always\n     * returns the current instance. The arguments is ignored.\n     *\n     * @param projectIdIfMissing The project ID of the current Firestore project.\n     * The project ID is only used if it's not provided as part of this\n     * ResourcePath.\n     * @private\n     */\n    toQualifiedResourcePath(projectIdIfMissing) {\n        return this;\n    }\n    /**\n     * Compare the current path against another ResourcePath object.\n     *\n     * @private\n     * @param other The path to compare to.\n     * @returns -1 if current < other, 1 if current > other, 0 if equal\n     */\n    compareTo(other) {\n        if (other instanceof QualifiedResourcePath) {\n            if (this.projectId < other.projectId) {\n                return -1;\n            }\n            if (this.projectId > other.projectId) {\n                return 1;\n            }\n            if (this.databaseId < other.databaseId) {\n                return -1;\n            }\n            if (this.databaseId > other.databaseId) {\n                return 1;\n            }\n        }\n        return super.compareTo(other);\n    }\n    /**\n     * Converts this ResourcePath to the Firestore Proto representation.\n     * @private\n     */\n    toProto() {\n        return {\n            referenceValue: this.formattedName,\n        };\n    }\n}\nexports.QualifiedResourcePath = QualifiedResourcePath;\n/**\n * Validates that the given string can be used as a relative or absolute\n * resource path.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param resourcePath The path to validate.\n * @throws if the string can't be used as a resource path.\n */\nfunction validateResourcePath(arg, resourcePath) {\n    if (typeof resourcePath !== 'string' || resourcePath === '') {\n        throw new Error(`${validate_1.invalidArgumentMessage(arg, 'resource path')} Path must be a non-empty string.`);\n    }\n    if (resourcePath.indexOf('//') >= 0) {\n        throw new Error(`${validate_1.invalidArgumentMessage(arg, 'resource path')} Paths must not contain //.`);\n    }\n}\nexports.validateResourcePath = validateResourcePath;\n/**\n * A dot-separated path for navigating sub-objects within a document.\n *\n * @class\n */\nclass FieldPath extends Path {\n    /**\n     * Constructs a Firestore Field Path.\n     *\n     * @param {...string} segments Sequence of field names that form this path.\n     *\n     * @example\n     * let query = firestore.collection('col');\n     * let fieldPath = new FieldPath('f.o.o', 'bar');\n     *\n     * query.where(fieldPath, '==', 42).get().then(snapshot => {\n     *   snapshot.forEach(document => {\n     *     console.log(`Document contains {'f.o.o' : {'bar' : 42}}`);\n     *   });\n     * });\n     */\n    constructor(...segments) {\n        if (Array.isArray(segments[0])) {\n            throw new Error('The FieldPath constructor no longer supports an array as its first argument. ' +\n                'Please unpack your array and call FieldPath() with individual arguments.');\n        }\n        validate_1.validateMinNumberOfArguments('FieldPath', segments, 1);\n        for (let i = 0; i < segments.length; ++i) {\n            validate_1.validateString(i, segments[i]);\n            if (segments[i].length === 0) {\n                throw new Error(`Element at index ${i} should not be an empty string.`);\n            }\n        }\n        super(segments);\n    }\n    /**\n     * A special FieldPath value to refer to the ID of a document. It can be used\n     * in queries to sort or filter by the document ID.\n     *\n     * @returns {FieldPath}\n     */\n    static documentId() {\n        return FieldPath._DOCUMENT_ID;\n    }\n    /**\n     * Turns a field path argument into a [FieldPath]{@link FieldPath}.\n     * Supports FieldPaths as input (which are passed through) and dot-separated\n     * strings.\n     *\n     * @private\n     * @param {string|FieldPath} fieldPath The FieldPath to create.\n     * @returns {FieldPath} A field path representation.\n     */\n    static fromArgument(fieldPath) {\n        // validateFieldPath() is used in all public API entry points to validate\n        // that fromArgument() is only called with a Field Path or a string.\n        return fieldPath instanceof FieldPath\n            ? fieldPath\n            : new FieldPath(...fieldPath.split('.'));\n    }\n    /**\n     * String representation of a FieldPath as expected by the API.\n     *\n     * @private\n     * @override\n     * @returns {string} The representation as expected by the API.\n     */\n    get formattedName() {\n        return this.segments\n            .map(str => {\n            return UNESCAPED_FIELD_NAME_RE.test(str)\n                ? str\n                : '`' + str.replace('\\\\', '\\\\\\\\').replace('`', '\\\\`') + '`';\n        })\n            .join('.');\n    }\n    /**\n     * Returns a string representation of this path.\n     *\n     * @private\n     * @returns A string representing this path.\n     */\n    toString() {\n        return this.formattedName;\n    }\n    /**\n     * Splits a string into path segments, using dots as separators.\n     *\n     * @private\n     * @override\n     * @param {string} fieldPath The path to split.\n     * @returns {Array.<string>} - The split path segments.\n     */\n    split(fieldPath) {\n        return fieldPath.split('.');\n    }\n    /**\n     * Constructs a new instance of FieldPath. We need this instead of using\n     * the normal constructor because polymorphic 'this' doesn't work on static\n     * methods.\n     *\n     * @private\n     * @override\n     * @param segments Sequence of field names.\n     * @returns The newly created FieldPath.\n     */\n    construct(segments) {\n        return new FieldPath(...segments);\n    }\n    /**\n     * Returns true if this `FieldPath` is equal to the provided value.\n     *\n     * @param {*} other The value to compare against.\n     * @return {boolean} true if this `FieldPath` is equal to the provided value.\n     */\n    isEqual(other) {\n        return super.isEqual(other);\n    }\n}\nexports.FieldPath = FieldPath;\n/**\n * A special sentinel value to refer to the ID of a document.\n *\n * @private\n */\nFieldPath._DOCUMENT_ID = new FieldPath('__name__');\n/**\n * Validates that the provided value can be used as a field path argument.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param fieldPath The value to verify.\n * @throws if the string can't be used as a field path.\n */\nfunction validateFieldPath(arg, fieldPath) {\n    if (fieldPath instanceof FieldPath) {\n        return;\n    }\n    if (fieldPath === undefined) {\n        throw new Error(validate_1.invalidArgumentMessage(arg, 'field path') + ' The path cannot be omitted.');\n    }\n    if (util_1.isObject(fieldPath) && fieldPath.constructor.name === 'FieldPath') {\n        throw new Error(validate_1.customObjectMessage(arg, fieldPath));\n    }\n    if (typeof fieldPath !== 'string') {\n        throw new Error(`${validate_1.invalidArgumentMessage(arg, 'field path')} Paths can only be specified as strings or via a FieldPath object.`);\n    }\n    if (fieldPath.indexOf('..') >= 0) {\n        throw new Error(`${validate_1.invalidArgumentMessage(arg, 'field path')} Paths must not contain \"..\" in them.`);\n    }\n    if (fieldPath.startsWith('.') || fieldPath.endsWith('.')) {\n        throw new Error(`${validate_1.invalidArgumentMessage(arg, 'field path')} Paths must not start or end with \".\".`);\n    }\n    if (!FIELD_PATH_RE.test(fieldPath)) {\n        throw new Error(`${validate_1.invalidArgumentMessage(arg, 'field path')} Paths can't be empty and must not contain\n    \"*~/[]\".`);\n    }\n}\nexports.validateFieldPath = validateFieldPath;\n//# sourceMappingURL=path.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/firestore/build/src/path.js?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/firestore/build/src/pool.js":
/*!********************************************************************!*\
  !*** ./src/node_modules/@google-cloud/firestore/build/src/pool.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst logger_1 = __webpack_require__(/*! ./logger */ \"./src/node_modules/@google-cloud/firestore/build/src/logger.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"./src/node_modules/@google-cloud/firestore/build/src/util.js\");\n/**\n * An auto-resizing pool that distributes concurrent operations over multiple\n * clients of type `T`.\n *\n * ClientPool is used within Firestore to manage a pool of GAPIC clients and\n * automatically initializes multiple clients if we issue more than 100\n * concurrent operations.\n *\n * @private\n */\nclass ClientPool {\n    /**\n     * @param concurrentOperationLimit The number of operations that each client\n     * can handle.\n     * @param maxIdleClients The maximum number of idle clients to keep before\n     * garbage collecting.\n     * @param clientFactory A factory function called as needed when new clients\n     * are required.\n     * @param clientDestructor A cleanup function that is called when a client is\n     * disposed of.\n     */\n    constructor(concurrentOperationLimit, maxIdleClients, clientFactory, clientDestructor = () => Promise.resolve()) {\n        this.concurrentOperationLimit = concurrentOperationLimit;\n        this.maxIdleClients = maxIdleClients;\n        this.clientFactory = clientFactory;\n        this.clientDestructor = clientDestructor;\n        /**\n         * Stores each active clients and how many operations it has outstanding.\n         * @private\n         */\n        this.activeClients = new Map();\n        /**\n         * Whether the Firestore instance has been terminated. Once terminated, the\n         * ClientPool can longer schedule new operations.\n         */\n        this.terminated = false;\n        /**\n         * Deferred promise that is resolved when there are no active operations on\n         * the client pool after terminate() has been called.\n         */\n        this.terminateDeferred = new util_1.Deferred();\n    }\n    /**\n     * Returns an already existing client if it has less than the maximum number\n     * of concurrent operations or initializes and returns a new client.\n     *\n     * @private\n     */\n    acquire(requestTag) {\n        let selectedClient = null;\n        let selectedClientRequestCount = -1;\n        for (const [client, requestCount] of this.activeClients) {\n            // Use the \"most-full\" client that can still accommodate the request\n            // in order to maximize the number of idle clients as operations start to\n            // complete.\n            if (requestCount > selectedClientRequestCount &&\n                requestCount < this.concurrentOperationLimit) {\n                selectedClient = client;\n                selectedClientRequestCount = requestCount;\n            }\n        }\n        if (selectedClient) {\n            logger_1.logger('ClientPool.acquire', requestTag, 'Re-using existing client with %s remaining operations', this.concurrentOperationLimit - selectedClientRequestCount);\n        }\n        else {\n            logger_1.logger('ClientPool.acquire', requestTag, 'Creating a new client');\n            selectedClient = this.clientFactory();\n            selectedClientRequestCount = 0;\n            assert(!this.activeClients.has(selectedClient), 'The provided client factory returned an existing instance');\n        }\n        this.activeClients.set(selectedClient, selectedClientRequestCount + 1);\n        return selectedClient;\n    }\n    /**\n     * Reduces the number of operations for the provided client, potentially\n     * removing it from the pool of active clients.\n     * @private\n     */\n    async release(requestTag, client) {\n        const requestCount = this.activeClients.get(client) || 0;\n        assert(requestCount > 0, 'No active requests');\n        this.activeClients.set(client, requestCount - 1);\n        if (this.terminated && this.opCount === 0) {\n            this.terminateDeferred.resolve();\n        }\n        if (this.shouldGarbageCollectClient(client)) {\n            this.activeClients.delete(client);\n            await this.clientDestructor(client);\n            logger_1.logger('ClientPool.release', requestTag, 'Garbage collected 1 client');\n        }\n    }\n    /**\n     * Given the current operation counts, determines if the given client should\n     * be garbage collected.\n     * @private\n     */\n    shouldGarbageCollectClient(client) {\n        if (this.activeClients.get(client) !== 0) {\n            return false;\n        }\n        let idleCapacityCount = 0;\n        for (const [_, count] of this.activeClients) {\n            idleCapacityCount += this.concurrentOperationLimit - count;\n        }\n        return (idleCapacityCount > this.maxIdleClients * this.concurrentOperationLimit);\n    }\n    /**\n     * The number of currently registered clients.\n     *\n     * @return Number of currently registered clients.\n     * @private\n     */\n    // Visible for testing.\n    get size() {\n        return this.activeClients.size;\n    }\n    /**\n     * The number of currently active operations.\n     *\n     * @return Number of currently active operations.\n     * @private\n     */\n    // Visible for testing.\n    get opCount() {\n        let activeOperationCount = 0;\n        this.activeClients.forEach(count => (activeOperationCount += count));\n        return activeOperationCount;\n    }\n    /**\n     * Runs the provided operation in this pool. This function may create an\n     * additional client if all existing clients already operate at the concurrent\n     * operation limit.\n     *\n     * @param requestTag A unique client-assigned identifier for this operation.\n     * @param op A callback function that returns a Promise. The client T will\n     * be returned to the pool when callback finishes.\n     * @return A Promise that resolves with the result of `op`.\n     * @private\n     */\n    run(requestTag, op) {\n        if (this.terminated) {\n            return Promise.reject(new Error('The client has already been terminated'));\n        }\n        const client = this.acquire(requestTag);\n        return op(client)\n            .catch(async (err) => {\n            await this.release(requestTag, client);\n            return Promise.reject(err);\n        })\n            .then(async (res) => {\n            await this.release(requestTag, client);\n            return res;\n        });\n    }\n    async terminate() {\n        this.terminated = true;\n        // Wait for all pending operations to complete before terminating.\n        if (this.opCount > 0) {\n            logger_1.logger('ClientPool.terminate', \n            /* requestTag= */ null, 'Waiting for %s pending operations to complete before terminating', this.opCount);\n            await this.terminateDeferred.promise;\n        }\n        for (const [client, _requestCount] of this.activeClients) {\n            this.activeClients.delete(client);\n            await this.clientDestructor(client);\n        }\n    }\n}\nexports.ClientPool = ClientPool;\n//# sourceMappingURL=pool.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/firestore/build/src/pool.js?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/firestore/build/src/rate-limiter.js":
/*!****************************************************************************!*\
  !*** ./src/node_modules/@google-cloud/firestore/build/src/rate-limiter.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*!\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst assert = __webpack_require__(/*! assert */ \"assert\");\n/**\n * A helper that uses the Token Bucket algorithm to rate limit the number of\n * operations that can be made in a second.\n *\n * Before a given request containing a number of operations can proceed,\n * RateLimiter determines doing so stays under the provided rate limits. It can\n * also determine how much time is required before a request can be made.\n *\n * RateLimiter can also implement a gradually increasing rate limit. This is\n * used to enforce the 500/50/5 rule\n * (https://cloud.google.com/datastore/docs/best-practices#ramping_up_traffic).\n *\n * @private\n */\nclass RateLimiter {\n    /**\n     * @param initialCapacity Initial maximum number of operations per second.\n     * @param multiplier Rate by which to increase the capacity.\n     * @param multiplierMillis How often the capacity should increase in\n     * milliseconds.\n     * @param startTimeMillis The starting time in epoch milliseconds that the\n     * rate limit is based on. Used for testing the limiter.\n     */\n    constructor(initialCapacity, multiplier, multiplierMillis, startTimeMillis = Date.now()) {\n        this.initialCapacity = initialCapacity;\n        this.multiplier = multiplier;\n        this.multiplierMillis = multiplierMillis;\n        this.startTimeMillis = startTimeMillis;\n        this.availableTokens = initialCapacity;\n        this.lastRefillTimeMillis = startTimeMillis;\n    }\n    /**\n     * Tries to make the number of operations. Returns true if the request\n     * succeeded and false otherwise.\n     *\n     * @param requestTimeMillis The date used to calculate the number of available\n     * tokens. Used for testing the limiter.\n     * @private\n     */\n    tryMakeRequest(numOperations, requestTimeMillis = Date.now()) {\n        this.refillTokens(requestTimeMillis);\n        if (numOperations <= this.availableTokens) {\n            this.availableTokens -= numOperations;\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Returns the number of ms needed to make a request with the provided number\n     * of operations. Returns 0 if the request can be made with the existing\n     * capacity. Returns -1 if the request is not possible with the current\n     * capacity.\n     *\n     * @param requestTimeMillis The date used to calculate the number of available\n     * tokens. Used for testing the limiter.\n     * @private\n     */\n    getNextRequestDelayMs(numOperations, requestTimeMillis = Date.now()) {\n        this.refillTokens(requestTimeMillis);\n        if (numOperations < this.availableTokens) {\n            return 0;\n        }\n        const capacity = this.calculateCapacity(requestTimeMillis);\n        if (capacity < numOperations) {\n            return -1;\n        }\n        const requiredTokens = numOperations - this.availableTokens;\n        return Math.ceil((requiredTokens * 1000) / capacity);\n    }\n    /**\n     * Refills the number of available tokens based on how much time has elapsed\n     * since the last time the tokens were refilled.\n     *\n     * @param requestTimeMillis The date used to calculate the number of available\n     * tokens. Used for testing the limiter.\n     * @private\n     */\n    refillTokens(requestTimeMillis = Date.now()) {\n        if (requestTimeMillis >= this.lastRefillTimeMillis) {\n            const elapsedTime = requestTimeMillis - this.lastRefillTimeMillis;\n            const capacity = this.calculateCapacity(requestTimeMillis);\n            const tokensToAdd = Math.floor((elapsedTime * capacity) / 1000);\n            if (tokensToAdd > 0) {\n                this.availableTokens = Math.min(capacity, this.availableTokens + tokensToAdd);\n                this.lastRefillTimeMillis = requestTimeMillis;\n            }\n        }\n        else {\n            throw new Error('Request time should not be before the last token refill time.');\n        }\n    }\n    /**\n     * Calculates the maximum capacity based on the provided date.\n     *\n     * @private\n     */\n    // Visible for testing.\n    calculateCapacity(requestTimeMillis) {\n        assert(requestTimeMillis >= this.startTimeMillis, 'startTime cannot be after currentTime');\n        const millisElapsed = requestTimeMillis - this.startTimeMillis;\n        const operationsPerSecond = Math.floor(Math.pow(this.multiplier, Math.floor(millisElapsed / this.multiplierMillis)) * this.initialCapacity);\n        return operationsPerSecond;\n    }\n}\nexports.RateLimiter = RateLimiter;\n//# sourceMappingURL=rate-limiter.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/firestore/build/src/rate-limiter.js?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/firestore/build/src/reference.js":
/*!*************************************************************************!*\
  !*** ./src/node_modules/@google-cloud/firestore/build/src/reference.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst deepEqual = __webpack_require__(/*! deep-equal */ \"./src/node_modules/deep-equal/index.js\");\nconst through2 = __webpack_require__(/*! through2 */ \"through2\");\nconst document_1 = __webpack_require__(/*! ./document */ \"./src/node_modules/@google-cloud/firestore/build/src/document.js\");\nconst document_change_1 = __webpack_require__(/*! ./document-change */ \"./src/node_modules/@google-cloud/firestore/build/src/document-change.js\");\nconst logger_1 = __webpack_require__(/*! ./logger */ \"./src/node_modules/@google-cloud/firestore/build/src/logger.js\");\nconst order_1 = __webpack_require__(/*! ./order */ \"./src/node_modules/@google-cloud/firestore/build/src/order.js\");\nconst path_1 = __webpack_require__(/*! ./path */ \"./src/node_modules/@google-cloud/firestore/build/src/path.js\");\nconst serializer_1 = __webpack_require__(/*! ./serializer */ \"./src/node_modules/@google-cloud/firestore/build/src/serializer.js\");\nconst timestamp_1 = __webpack_require__(/*! ./timestamp */ \"./src/node_modules/@google-cloud/firestore/build/src/timestamp.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"./src/node_modules/@google-cloud/firestore/build/src/types.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"./src/node_modules/@google-cloud/firestore/build/src/util.js\");\nconst validate_1 = __webpack_require__(/*! ./validate */ \"./src/node_modules/@google-cloud/firestore/build/src/validate.js\");\nconst watch_1 = __webpack_require__(/*! ./watch */ \"./src/node_modules/@google-cloud/firestore/build/src/watch.js\");\nconst write_batch_1 = __webpack_require__(/*! ./write-batch */ \"./src/node_modules/@google-cloud/firestore/build/src/write-batch.js\");\n/**\n * The direction of a `Query.orderBy()` clause is specified as 'desc' or 'asc'\n * (descending or ascending).\n *\n * @private\n */\nconst directionOperators = {\n    asc: 'ASCENDING',\n    desc: 'DESCENDING',\n};\n/**\n * Filter conditions in a `Query.where()` clause are specified using the\n * strings '<', '<=', '==', '>=', '>', 'array-contains', 'in', and\n * 'array-contains-any'.\n *\n * @private\n */\nconst comparisonOperators = {\n    '<': 'LESS_THAN',\n    '<=': 'LESS_THAN_OR_EQUAL',\n    '==': 'EQUAL',\n    '>': 'GREATER_THAN',\n    '>=': 'GREATER_THAN_OR_EQUAL',\n    'array-contains': 'ARRAY_CONTAINS',\n    in: 'IN',\n    'array-contains-any': 'ARRAY_CONTAINS_ANY',\n};\n/**\n * onSnapshot() callback that receives a QuerySnapshot.\n *\n * @callback querySnapshotCallback\n * @param {QuerySnapshot} snapshot A query snapshot.\n */\n/**\n * onSnapshot() callback that receives a DocumentSnapshot.\n *\n * @callback documentSnapshotCallback\n * @param {DocumentSnapshot} snapshot A document snapshot.\n */\n/**\n * onSnapshot() callback that receives an error.\n *\n * @callback errorCallback\n * @param {Error} err An error from a listen.\n */\n/**\n * A DocumentReference refers to a document location in a Firestore database\n * and can be used to write, read, or listen to the location. The document at\n * the referenced location may or may not exist. A DocumentReference can\n * also be used to create a\n * [CollectionReference]{@link CollectionReference} to a\n * subcollection.\n *\n * @class\n */\nclass DocumentReference {\n    /**\n     * @hideconstructor\n     *\n     * @param _firestore The Firestore Database client.\n     * @param _path The Path of this reference.\n     */\n    constructor(_firestore, _path, _converter = types_1.defaultConverter) {\n        this._firestore = _firestore;\n        this._path = _path;\n        this._converter = _converter;\n    }\n    /**\n     * The string representation of the DocumentReference's location.\n     * @private\n     * @type {string}\n     * @name DocumentReference#formattedName\n     */\n    get formattedName() {\n        const projectId = this.firestore.projectId;\n        return this._path.toQualifiedResourcePath(projectId).formattedName;\n    }\n    /**\n     * The [Firestore]{@link Firestore} instance for the Firestore\n     * database (useful for performing transactions, etc.).\n     *\n     * @type {Firestore}\n     * @name DocumentReference#firestore\n     * @readonly\n     *\n     * @example\n     * let collectionRef = firestore.collection('col');\n     *\n     * collectionRef.add({foo: 'bar'}).then(documentReference => {\n     *   let firestore = documentReference.firestore;\n     *   console.log(`Root location for document is ${firestore.formattedName}`);\n     * });\n     */\n    get firestore() {\n        return this._firestore;\n    }\n    /**\n     * A string representing the path of the referenced document (relative\n     * to the root of the database).\n     *\n     * @type {string}\n     * @name DocumentReference#path\n     * @readonly\n     *\n     * @example\n     * let collectionRef = firestore.collection('col');\n     *\n     * collectionRef.add({foo: 'bar'}).then(documentReference => {\n     *   console.log(`Added document at '${documentReference.path}'`);\n     * });\n     */\n    get path() {\n        return this._path.relativeName;\n    }\n    /**\n     * The last path element of the referenced document.\n     *\n     * @type {string}\n     * @name DocumentReference#id\n     * @readonly\n     *\n     * @example\n     * let collectionRef = firestore.collection('col');\n     *\n     * collectionRef.add({foo: 'bar'}).then(documentReference => {\n     *   console.log(`Added document with name '${documentReference.id}'`);\n     * });\n     */\n    get id() {\n        return this._path.id;\n    }\n    /**\n     * A reference to the collection to which this DocumentReference belongs.\n     *\n     * @name DocumentReference#parent\n     * @type {CollectionReference}\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     * let collectionRef = documentRef.parent;\n     *\n     * collectionRef.where('foo', '==', 'bar').get().then(results => {\n     *   console.log(`Found ${results.size} matches in parent collection`);\n     * }):\n     */\n    get parent() {\n        return new CollectionReference(this._firestore, this._path.parent(), this._converter);\n    }\n    /**\n     * Reads the document referred to by this DocumentReference.\n     *\n     * @returns {Promise.<DocumentSnapshot>} A Promise resolved with a\n     * DocumentSnapshot for the retrieved document on success. For missing\n     * documents, DocumentSnapshot.exists will be false. If the get() fails for\n     * other reasons, the Promise will be rejected.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(documentSnapshot => {\n     *   if (documentSnapshot.exists) {\n     *     console.log('Document retrieved successfully.');\n     *   }\n     * });\n     */\n    get() {\n        return this._firestore.getAll(this).then(([result]) => result);\n    }\n    /**\n     * Gets a [CollectionReference]{@link CollectionReference} instance\n     * that refers to the collection at the specified path.\n     *\n     * @param {string} collectionPath A slash-separated path to a collection.\n     * @returns {CollectionReference} A reference to the new\n     * subcollection.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     * let subcollection = documentRef.collection('subcollection');\n     * console.log(`Path to subcollection: ${subcollection.path}`);\n     */\n    collection(collectionPath) {\n        path_1.validateResourcePath('collectionPath', collectionPath);\n        const path = this._path.append(collectionPath);\n        if (!path.isCollection) {\n            throw new Error(`Value for argument \"collectionPath\" must point to a collection, but was \"${collectionPath}\". Your path does not contain an odd number of components.`);\n        }\n        return new CollectionReference(this._firestore, path);\n    }\n    /**\n     * Fetches the subcollections that are direct children of this document.\n     *\n     * @returns {Promise.<Array.<CollectionReference>>} A Promise that resolves\n     * with an array of CollectionReferences.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.listCollections().then(collections => {\n     *   for (let collection of collections) {\n     *     console.log(`Found subcollection with id: ${collection.id}`);\n     *   }\n     * });\n     */\n    listCollections() {\n        const tag = util_1.requestTag();\n        return this.firestore.initializeIfNeeded(tag).then(() => {\n            const request = {\n                parent: this.formattedName,\n                // Setting `pageSize` to an arbitrarily large value lets the backend cap\n                // the page size (currently to 300). Note that the backend rejects\n                // MAX_INT32 (b/146883794).\n                pageSize: Math.pow(2, 16) - 1,\n            };\n            return this._firestore\n                .request('listCollectionIds', request, tag)\n                .then(collectionIds => {\n                const collections = [];\n                // We can just sort this list using the default comparator since it\n                // will only contain collection ids.\n                collectionIds.sort();\n                for (const collectionId of collectionIds) {\n                    collections.push(this.collection(collectionId));\n                }\n                return collections;\n            });\n        });\n    }\n    /**\n     * Create a document with the provided object values. This will fail the write\n     * if a document exists at its location.\n     *\n     * @param {DocumentData} data An object that contains the fields and data to\n     * serialize as the document.\n     * @returns {Promise.<WriteResult>} A Promise that resolves with the\n     * write time of this create.\n     *\n     * @example\n     * let documentRef = firestore.collection('col').doc();\n     *\n     * documentRef.create({foo: 'bar'}).then((res) => {\n     *   console.log(`Document created at ${res.updateTime}`);\n     * }).catch((err) => {\n     *   console.log(`Failed to create document: ${err}`);\n     * });\n     */\n    create(data) {\n        const writeBatch = new write_batch_1.WriteBatch(this._firestore);\n        return writeBatch\n            .create(this, data)\n            .commit()\n            .then(([writeResult]) => writeResult);\n    }\n    /**\n     * Deletes the document referred to by this `DocumentReference`.\n     *\n     * A delete for a non-existing document is treated as a success (unless\n     * lastUptimeTime is provided).\n     *\n     * @param {Precondition=} precondition A precondition to enforce for this\n     * delete.\n     * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\n     * document was last updated at lastUpdateTime. Fails the delete if the\n     * document was last updated at a different time.\n     * @returns {Promise.<WriteResult>} A Promise that resolves with the\n     * delete time.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.delete().then(() => {\n     *   console.log('Document successfully deleted.');\n     * });\n     */\n    delete(precondition) {\n        const writeBatch = new write_batch_1.WriteBatch(this._firestore);\n        return writeBatch\n            .delete(this, precondition)\n            .commit()\n            .then(([writeResult]) => writeResult);\n    }\n    /**\n     * Writes to the document referred to by this DocumentReference. If the\n     * document does not yet exist, it will be created. If you pass\n     * [SetOptions]{@link SetOptions}, the provided data can be merged into an\n     * existing document.\n     *\n     * @param {T} data A map of the fields and values for the document.\n     * @param {SetOptions=} options An object to configure the set behavior.\n     * @param {boolean=} options.merge If true, set() merges the values specified\n     * in its data argument. Fields omitted from this set() call remain untouched.\n     * @param {Array.<string|FieldPath>=} options.mergeFields If provided,\n     * set() only replaces the specified field paths. Any field path that is not\n     * specified is ignored and remains untouched.\n     * @returns {Promise.<WriteResult>} A Promise that resolves with the\n     * write time of this set.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.set({foo: 'bar'}).then(res => {\n     *   console.log(`Document written at ${res.updateTime}`);\n     * });\n     */\n    set(data, options) {\n        const writeBatch = new write_batch_1.WriteBatch(this._firestore);\n        return writeBatch\n            .set(this, data, options)\n            .commit()\n            .then(([writeResult]) => writeResult);\n    }\n    /**\n     * Updates fields in the document referred to by this DocumentReference.\n     * If the document doesn't yet exist, the update fails and the returned\n     * Promise will be rejected.\n     *\n     * The update() method accepts either an object with field paths encoded as\n     * keys and field values encoded as values, or a variable number of arguments\n     * that alternate between field paths and field values.\n     *\n     * A Precondition restricting this update can be specified as the last\n     * argument.\n     *\n     * @param {UpdateData|string|FieldPath} dataOrField An object containing the\n     * fields and values with which to update the document or the path of the\n     * first field to update.\n     * @param {\n     * ...(*|string|FieldPath|Precondition)} preconditionOrValues An alternating\n     * list of field paths and values to update or a Precondition to restrict\n     * this update.\n     * @returns {Promise.<WriteResult>} A Promise that resolves once the\n     * data has been successfully written to the backend.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.update({foo: 'bar'}).then(res => {\n     *   console.log(`Document updated at ${res.updateTime}`);\n     * });\n     */\n    update(dataOrField, ...preconditionOrValues) {\n        validate_1.validateMinNumberOfArguments('DocumentReference.update', arguments, 1);\n        const writeBatch = new write_batch_1.WriteBatch(this._firestore);\n        return writeBatch\n            .update(this, dataOrField, ...preconditionOrValues)\n            .commit()\n            .then(([writeResult]) => writeResult);\n    }\n    /**\n     * Attaches a listener for DocumentSnapshot events.\n     *\n     * @param {documentSnapshotCallback} onNext A callback to be called every\n     * time a new `DocumentSnapshot` is available.\n     * @param {errorCallback=} onError A callback to be called if the listen fails\n     * or is cancelled. No further callbacks will occur. If unset, errors will be\n     * logged to the console.\n     *\n     * @returns {function()} An unsubscribe function that can be called to cancel\n     * the snapshot listener.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * let unsubscribe = documentRef.onSnapshot(documentSnapshot => {\n     *   if (documentSnapshot.exists) {\n     *     console.log(documentSnapshot.data());\n     *   }\n     * }, err => {\n     *   console.log(`Encountered error: ${err}`);\n     * });\n     *\n     * // Remove this listener.\n     * unsubscribe();\n     */\n    onSnapshot(onNext, onError) {\n        validate_1.validateFunction('onNext', onNext);\n        validate_1.validateFunction('onError', onError, { optional: true });\n        const watch = new watch_1.DocumentWatch(this.firestore, this);\n        return watch.onSnapshot((readTime, size, docs) => {\n            for (const document of docs()) {\n                if (document.ref.path === this.path) {\n                    onNext(document);\n                    return;\n                }\n            }\n            // The document is missing.\n            const ref = new DocumentReference(this._firestore, this._path, this._converter);\n            const document = new document_1.DocumentSnapshotBuilder(ref);\n            document.readTime = readTime;\n            onNext(document.build());\n        }, onError || console.error);\n    }\n    /**\n     * Returns true if this `DocumentReference` is equal to the provided value.\n     *\n     * @param {*} other The value to compare against.\n     * @return {boolean} true if this `DocumentReference` is equal to the provided\n     * value.\n     */\n    isEqual(other) {\n        return (this === other ||\n            (other instanceof DocumentReference &&\n                this._firestore === other._firestore &&\n                this._path.isEqual(other._path) &&\n                this._converter === other._converter));\n    }\n    /**\n     * Converts this DocumentReference to the Firestore Proto representation.\n     *\n     * @private\n     */\n    toProto() {\n        return { referenceValue: this.formattedName };\n    }\n    /**\n     * Applies a custom data converter to this DocumentReference, allowing you\n     * to use your own custom model objects with Firestore. When you call\n     * set(), get(), etc. on the returned DocumentReference instance, the\n     * provided converter will convert between Firestore data and your custom\n     * type U.\n     *\n     * Using the converter allows you to specify generic type arguments when\n     * storing and retrieving objects from Firestore.\n     *\n     * @example\n     * class Post {\n     *   constructor(readonly title: string, readonly author: string) {}\n     *\n     *   toString(): string {\n     *     return this.title + ', by ' + this.author;\n     *   }\n     * }\n     *\n     * const postConverter = {\n     *   toFirestore(post: Post): FirebaseFirestore.DocumentData {\n     *     return {title: post.title, author: post.author};\n     *   },\n     *   fromFirestore(\n     *     data: FirebaseFirestore.DocumentData\n     *   ): Post {\n     *     return new Post(data.title, data.author);\n     *   }\n     * };\n     *\n     * const postSnap = await Firestore()\n     *   .collection('posts')\n     *   .withConverter(postConverter)\n     *   .doc().get();\n     * const post = postSnap.data();\n     * if (post !== undefined) {\n     *   post.title; // string\n     *   post.toString(); // Should be defined\n     *   post.someNonExistentProperty; // TS error\n     * }\n     *\n     * @param converter Converts objects to and from Firestore.\n     * @return A DocumentReference<U> that uses the provided converter.\n     */\n    withConverter(converter) {\n        return new DocumentReference(this.firestore, this._path, converter);\n    }\n}\nexports.DocumentReference = DocumentReference;\n/**\n * A Query order-by field.\n *\n * @private\n * @class\n */\nclass FieldOrder {\n    /**\n     * @param field The name of a document field (member) on which to order query\n     * results.\n     * @param direction One of 'ASCENDING' (default) or 'DESCENDING' to\n     * set the ordering direction to ascending or descending, respectively.\n     */\n    constructor(field, direction = 'ASCENDING') {\n        this.field = field;\n        this.direction = direction;\n    }\n    /**\n     * Generates the proto representation for this field order.\n     * @private\n     */\n    toProto() {\n        return {\n            field: {\n                fieldPath: this.field.formattedName,\n            },\n            direction: this.direction,\n        };\n    }\n}\n/**\n * A field constraint for a Query where clause.\n *\n * @private\n * @class\n */\nclass FieldFilter {\n    /**\n     * @param serializer The Firestore serializer\n     * @param field The path of the property value to compare.\n     * @param op A comparison operation.\n     * @param value The value to which to compare the field for inclusion in a\n     * query.\n     */\n    constructor(serializer, field, op, value) {\n        this.serializer = serializer;\n        this.field = field;\n        this.op = op;\n        this.value = value;\n    }\n    /**\n     * Returns whether this FieldFilter uses an equals comparison.\n     *\n     * @private\n     */\n    isInequalityFilter() {\n        switch (this.op) {\n            case 'GREATER_THAN':\n            case 'GREATER_THAN_OR_EQUAL':\n            case 'LESS_THAN':\n            case 'LESS_THAN_OR_EQUAL':\n                return true;\n            default:\n                return false;\n        }\n    }\n    /**\n     * Generates the proto representation for this field filter.\n     *\n     * @private\n     */\n    toProto() {\n        if (typeof this.value === 'number' && isNaN(this.value)) {\n            return {\n                unaryFilter: {\n                    field: {\n                        fieldPath: this.field.formattedName,\n                    },\n                    op: 'IS_NAN',\n                },\n            };\n        }\n        if (this.value === null) {\n            return {\n                unaryFilter: {\n                    field: {\n                        fieldPath: this.field.formattedName,\n                    },\n                    op: 'IS_NULL',\n                },\n            };\n        }\n        return {\n            fieldFilter: {\n                field: {\n                    fieldPath: this.field.formattedName,\n                },\n                op: this.op,\n                value: this.serializer.encodeValue(this.value),\n            },\n        };\n    }\n}\n/**\n * A QuerySnapshot contains zero or more\n * [QueryDocumentSnapshot]{@link QueryDocumentSnapshot} objects\n * representing the results of a query. The documents can be accessed as an\n * array via the [documents]{@link QuerySnapshot#documents} property\n * or enumerated using the [forEach]{@link QuerySnapshot#forEach}\n * method. The number of documents can be determined via the\n * [empty]{@link QuerySnapshot#empty} and\n * [size]{@link QuerySnapshot#size} properties.\n *\n * @class QuerySnapshot\n */\nclass QuerySnapshot {\n    /**\n     * @hideconstructor\n     *\n     * @param _query The originating query.\n     * @param _readTime The time when this query snapshot was obtained.\n     * @param _size The number of documents in the result set.\n     * @param docs A callback returning a sorted array of documents matching\n     * this query\n     * @param changes A callback returning a sorted array of document change\n     * events for this snapshot.\n     */\n    constructor(_query, _readTime, _size, docs, changes) {\n        this._query = _query;\n        this._readTime = _readTime;\n        this._size = _size;\n        this._materializedDocs = null;\n        this._materializedChanges = null;\n        this._docs = null;\n        this._changes = null;\n        this._docs = docs;\n        this._changes = changes;\n    }\n    /**\n     * The query on which you called get() or onSnapshot() in order to get this\n     * QuerySnapshot.\n     *\n     * @type {Query}\n     * @name QuerySnapshot#query\n     * @readonly\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.limit(10).get().then(querySnapshot => {\n     *   console.log(`Returned first batch of results`);\n     *   let query = querySnapshot.query;\n     *   return query.offset(10).get();\n     * }).then(() => {\n     *   console.log(`Returned second batch of results`);\n     * });\n     */\n    get query() {\n        return this._query;\n    }\n    /**\n     * An array of all the documents in this QuerySnapshot.\n     *\n     * @type {Array.<QueryDocumentSnapshot>}\n     * @name QuerySnapshot#docs\n     * @readonly\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.get().then(querySnapshot => {\n     *   let docs = querySnapshot.docs;\n     *   for (let doc of docs) {\n     *     console.log(`Document found at path: ${doc.ref.path}`);\n     *   }\n     * });\n     */\n    get docs() {\n        if (this._materializedDocs) {\n            return this._materializedDocs;\n        }\n        this._materializedDocs = this._docs();\n        this._docs = null;\n        return this._materializedDocs;\n    }\n    /**\n     * True if there are no documents in the QuerySnapshot.\n     *\n     * @type {boolean}\n     * @name QuerySnapshot#empty\n     * @readonly\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.get().then(querySnapshot => {\n     *   if (querySnapshot.empty) {\n     *     console.log('No documents found.');\n     *   }\n     * });\n     */\n    get empty() {\n        return this._size === 0;\n    }\n    /**\n     * The number of documents in the QuerySnapshot.\n     *\n     * @type {number}\n     * @name QuerySnapshot#size\n     * @readonly\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.get().then(querySnapshot => {\n     *   console.log(`Found ${querySnapshot.size} documents.`);\n     * });\n     */\n    get size() {\n        return this._size;\n    }\n    /**\n     * The time this query snapshot was obtained.\n     *\n     * @type {Timestamp}\n     * @name QuerySnapshot#readTime\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.get().then((querySnapshot) => {\n     *   let readTime = querySnapshot.readTime;\n     *   console.log(`Query results returned at '${readTime.toDate()}'`);\n     * });\n     */\n    get readTime() {\n        return this._readTime;\n    }\n    /**\n     * Returns an array of the documents changes since the last snapshot. If\n     * this is the first snapshot, all documents will be in the list as added\n     * changes.\n     *\n     * @return {Array.<DocumentChange>}\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.onSnapshot(querySnapshot => {\n     *   let changes = querySnapshot.docChanges();\n     *   for (let change of changes) {\n     *     console.log(`A document was ${change.type}.`);\n     *   }\n     * });\n     */\n    docChanges() {\n        if (this._materializedChanges) {\n            return this._materializedChanges;\n        }\n        this._materializedChanges = this._changes();\n        this._changes = null;\n        return this._materializedChanges;\n    }\n    /**\n     * Enumerates all of the documents in the QuerySnapshot. This is a convenience\n     * method for running the same callback on each {@link QueryDocumentSnapshot}\n     * that is returned.\n     *\n     * @param {function} callback A callback to be called with a\n     * [QueryDocumentSnapshot]{@link QueryDocumentSnapshot} for each document in\n     * the snapshot.\n     * @param {*=} thisArg The `this` binding for the callback..\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Document found at path: ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     */\n    forEach(callback, thisArg) {\n        validate_1.validateFunction('callback', callback);\n        for (const doc of this.docs) {\n            callback.call(thisArg, doc);\n        }\n    }\n    /**\n     * Returns true if the document data in this `QuerySnapshot` is equal to the\n     * provided value.\n     *\n     * @param {*} other The value to compare against.\n     * @return {boolean} true if this `QuerySnapshot` is equal to the provided\n     * value.\n     */\n    isEqual(other) {\n        // Since the read time is different on every query read, we explicitly\n        // ignore all metadata in this comparison.\n        if (this === other) {\n            return true;\n        }\n        if (!(other instanceof QuerySnapshot)) {\n            return false;\n        }\n        if (this._size !== other._size) {\n            return false;\n        }\n        if (!this._query.isEqual(other._query)) {\n            return false;\n        }\n        if (this._materializedDocs && !this._materializedChanges) {\n            // If we have only materialized the documents, we compare them first.\n            return (isArrayEqual(this.docs, other.docs) &&\n                isArrayEqual(this.docChanges(), other.docChanges()));\n        }\n        // Otherwise, we compare the changes first as we expect there to be fewer.\n        return (isArrayEqual(this.docChanges(), other.docChanges()) &&\n            isArrayEqual(this.docs, other.docs));\n    }\n}\nexports.QuerySnapshot = QuerySnapshot;\n// TODO: As of v0.17.0, we're changing docChanges from an array into a method.\n// Because this is a runtime breaking change and somewhat subtle (both Array and\n// Function have a .length, etc.), we'll replace commonly-used properties\n// (including Symbol.iterator) to throw a custom error message. By our v1.0\n// release, we should remove this code.\nfunction throwDocChangesMethodError() {\n    throw new Error('QuerySnapshot.docChanges has been changed from a property into a ' +\n        'method, so usages like \"querySnapshot.docChanges\" should become ' +\n        '\"querySnapshot.docChanges()\"');\n}\nconst docChangesPropertiesToOverride = [\n    'length',\n    'forEach',\n    'map',\n    ...(typeof Symbol !== 'undefined' ? [Symbol.iterator] : []),\n];\ndocChangesPropertiesToOverride.forEach(property => {\n    Object.defineProperty(QuerySnapshot.prototype.docChanges, property, {\n        get: () => throwDocChangesMethodError(),\n    });\n});\n/*!\n * Denotes whether a provided limit is applied to the beginning or the end of\n * the result set.\n */\nvar LimitType;\n(function (LimitType) {\n    LimitType[LimitType[\"First\"] = 0] = \"First\";\n    LimitType[LimitType[\"Last\"] = 1] = \"Last\";\n})(LimitType || (LimitType = {}));\n/**\n * Internal class representing custom Query options.\n *\n * These options are immutable. Modified options can be created using `with()`.\n * @private\n */\nclass QueryOptions {\n    constructor(parentPath, collectionId, converter, allDescendants, fieldFilters, fieldOrders, startAt, endAt, limit, limitType, offset, projection) {\n        this.parentPath = parentPath;\n        this.collectionId = collectionId;\n        this.converter = converter;\n        this.allDescendants = allDescendants;\n        this.fieldFilters = fieldFilters;\n        this.fieldOrders = fieldOrders;\n        this.startAt = startAt;\n        this.endAt = endAt;\n        this.limit = limit;\n        this.limitType = limitType;\n        this.offset = offset;\n        this.projection = projection;\n    }\n    /**\n     * Returns query options for a collection group query.\n     * @private\n     */\n    static forCollectionGroupQuery(collectionId, converter = types_1.defaultConverter) {\n        return new QueryOptions(\n        /*parentPath=*/ path_1.ResourcePath.EMPTY, collectionId, converter, \n        /*allDescendants=*/ true, \n        /*fieldFilters=*/ [], \n        /*fieldOrders=*/ []);\n    }\n    /**\n     * Returns query options for a single-collection query.\n     * @private\n     */\n    static forCollectionQuery(collectionRef, converter = types_1.defaultConverter) {\n        return new QueryOptions(collectionRef.parent(), collectionRef.id, converter, \n        /*allDescendants=*/ false, \n        /*fieldFilters=*/ [], \n        /*fieldOrders=*/ []);\n    }\n    /**\n     * Returns the union of the current and the provided options.\n     * @private\n     */\n    with(settings) {\n        return new QueryOptions(coalesce(settings.parentPath, this.parentPath), coalesce(settings.collectionId, this.collectionId), this.converter, coalesce(settings.allDescendants, this.allDescendants), coalesce(settings.fieldFilters, this.fieldFilters), coalesce(settings.fieldOrders, this.fieldOrders), coalesce(settings.startAt, this.startAt), coalesce(settings.endAt, this.endAt), coalesce(settings.limit, this.limit), coalesce(settings.limitType, this.limitType), coalesce(settings.offset, this.offset), coalesce(settings.projection, this.projection));\n    }\n    withConverter(converter) {\n        return new QueryOptions(this.parentPath, this.collectionId, converter, this.allDescendants, this.fieldFilters, this.fieldOrders, this.startAt, this.endAt, this.limit, this.limitType, this.offset, this.projection);\n    }\n    hasFieldOrders() {\n        return this.fieldOrders.length > 0;\n    }\n    isEqual(other) {\n        if (this === other) {\n            return true;\n        }\n        return (other instanceof QueryOptions &&\n            this.parentPath.isEqual(other.parentPath) &&\n            this.collectionId === other.collectionId &&\n            this.converter === other.converter &&\n            this.allDescendants === other.allDescendants &&\n            this.limit === other.limit &&\n            this.offset === other.offset &&\n            deepEqual(this.fieldFilters, other.fieldFilters, { strict: true }) &&\n            deepEqual(this.fieldOrders, other.fieldOrders, { strict: true }) &&\n            deepEqual(this.startAt, other.startAt, { strict: true }) &&\n            deepEqual(this.endAt, other.endAt, { strict: true }) &&\n            deepEqual(this.projection, other.projection, { strict: true }));\n    }\n}\nexports.QueryOptions = QueryOptions;\n/**\n * A Query refers to a query which you can read or stream from. You can also\n * construct refined Query objects by adding filters and ordering.\n *\n * @class Query\n */\nclass Query {\n    /**\n     * @hideconstructor\n     *\n     * @param _firestore The Firestore Database client.\n     * @param _queryOptions Options that define the query.\n     */\n    constructor(_firestore, _queryOptions) {\n        this._firestore = _firestore;\n        this._queryOptions = _queryOptions;\n        this._serializer = new serializer_1.Serializer(_firestore);\n        this._allowUndefined = !!this._firestore._settings\n            .ignoreUndefinedProperties;\n    }\n    /**\n     * Detects the argument type for Firestore cursors.\n     *\n     * @private\n     * @param fieldValuesOrDocumentSnapshot A snapshot of the document or a set\n     * of field values.\n     * @returns 'true' if the input is a single DocumentSnapshot..\n     */\n    static _isDocumentSnapshot(fieldValuesOrDocumentSnapshot) {\n        return (fieldValuesOrDocumentSnapshot.length === 1 &&\n            fieldValuesOrDocumentSnapshot[0] instanceof document_1.DocumentSnapshot);\n    }\n    /**\n     * Extracts field values from the DocumentSnapshot based on the provided\n     * field order.\n     *\n     * @private\n     * @param documentSnapshot The document to extract the fields from.\n     * @param fieldOrders The field order that defines what fields we should\n     * extract.\n     * @return {Array.<*>} The field values to use.\n     * @private\n     */\n    static _extractFieldValues(documentSnapshot, fieldOrders) {\n        const fieldValues = [];\n        for (const fieldOrder of fieldOrders) {\n            if (path_1.FieldPath.documentId().isEqual(fieldOrder.field)) {\n                fieldValues.push(documentSnapshot.ref);\n            }\n            else {\n                const fieldValue = documentSnapshot.get(fieldOrder.field);\n                if (fieldValue === undefined) {\n                    throw new Error(`Field \"${fieldOrder.field}\" is missing in the provided DocumentSnapshot. ` +\n                        'Please provide a document that contains values for all specified ' +\n                        'orderBy() and where() constraints.');\n                }\n                else {\n                    fieldValues.push(fieldValue);\n                }\n            }\n        }\n        return fieldValues;\n    }\n    /**\n     * The [Firestore]{@link Firestore} instance for the Firestore\n     * database (useful for performing transactions, etc.).\n     *\n     * @type {Firestore}\n     * @name Query#firestore\n     * @readonly\n     *\n     * @example\n     * let collectionRef = firestore.collection('col');\n     *\n     * collectionRef.add({foo: 'bar'}).then(documentReference => {\n     *   let firestore = documentReference.firestore;\n     *   console.log(`Root location for document is ${firestore.formattedName}`);\n     * });\n     */\n    get firestore() {\n        return this._firestore;\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} with the additional filter\n     * that documents must contain the specified field and that its value should\n     * satisfy the relation constraint provided.\n     *\n     * Returns a new Query that constrains the value of a Document property.\n     *\n     * This function returns a new (immutable) instance of the Query (rather than\n     * modify the existing instance) to impose the filter.\n     *\n     * @param {string|FieldPath} fieldPath The name of a property value to compare.\n     * @param {string} opStr A comparison operation in the form of a string\n     * (e.g., \"<\").\n     * @param {*} value The value to which to compare the field for inclusion in\n     * a query.\n     * @returns {Query} The created Query.\n     *\n     * @example\n     * let collectionRef = firestore.collection('col');\n     *\n     * collectionRef.where('foo', '==', 'bar').get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     */\n    where(fieldPath, opStr, value) {\n        path_1.validateFieldPath('fieldPath', fieldPath);\n        opStr = validateQueryOperator('opStr', opStr, value);\n        validateQueryValue('value', value, this._allowUndefined);\n        if (this._queryOptions.startAt || this._queryOptions.endAt) {\n            throw new Error('Cannot specify a where() filter after calling startAt(), ' +\n                'startAfter(), endBefore() or endAt().');\n        }\n        const path = path_1.FieldPath.fromArgument(fieldPath);\n        if (path_1.FieldPath.documentId().isEqual(path)) {\n            if (opStr === 'array-contains' || opStr === 'array-contains-any') {\n                throw new Error(`Invalid Query. You can't perform '${opStr}' ` +\n                    'queries on FieldPath.documentId().');\n            }\n            if (opStr === 'in') {\n                if (!Array.isArray(value) || value.length === 0) {\n                    throw new Error(`Invalid Query. A non-empty array is required for '${opStr}' filters.`);\n                }\n                value = value.map(el => this.validateReference(el));\n            }\n            else {\n                value = this.validateReference(value);\n            }\n        }\n        const fieldFilter = new FieldFilter(this._serializer, path, comparisonOperators[opStr], value);\n        const options = this._queryOptions.with({\n            fieldFilters: this._queryOptions.fieldFilters.concat(fieldFilter),\n        });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} instance that applies a\n     * field mask to the result and returns only the specified subset of fields.\n     * You can specify a list of field paths to return, or use an empty list to\n     * only return the references of matching documents.\n     *\n     * Queries that contain field masks cannot be listened to via `onSnapshot()`\n     * listeners.\n     *\n     * This function returns a new (immutable) instance of the Query (rather than\n     * modify the existing instance) to impose the field mask.\n     *\n     * @param {...(string|FieldPath)} fieldPaths The field paths to return.\n     * @returns {Query} The created Query.\n     *\n     * @example\n     * let collectionRef = firestore.collection('col');\n     * let documentRef = collectionRef.doc('doc');\n     *\n     * return documentRef.set({x:10, y:5}).then(() => {\n     *   return collectionRef.where('x', '>', 5).select('y').get();\n     * }).then((res) => {\n     *   console.log(`y is ${res.docs[0].get('y')}.`);\n     * });\n     */\n    select(...fieldPaths) {\n        const fields = [];\n        if (fieldPaths.length === 0) {\n            fields.push({ fieldPath: path_1.FieldPath.documentId().formattedName });\n        }\n        else {\n            for (let i = 0; i < fieldPaths.length; ++i) {\n                path_1.validateFieldPath(i, fieldPaths[i]);\n                fields.push({\n                    fieldPath: path_1.FieldPath.fromArgument(fieldPaths[i]).formattedName,\n                });\n            }\n        }\n        const options = this._queryOptions.with({ projection: { fields } });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} that's additionally sorted\n     * by the specified field, optionally in descending order instead of\n     * ascending.\n     *\n     * This function returns a new (immutable) instance of the Query (rather than\n     * modify the existing instance) to impose the field mask.\n     *\n     * @param {string|FieldPath} fieldPath The field to sort by.\n     * @param {string=} directionStr Optional direction to sort by ('asc' or\n     * 'desc'). If not specified, order will be ascending.\n     * @returns {Query} The created Query.\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '>', 42);\n     *\n     * query.orderBy('foo', 'desc').get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     */\n    orderBy(fieldPath, directionStr) {\n        path_1.validateFieldPath('fieldPath', fieldPath);\n        directionStr = validateQueryOrder('directionStr', directionStr);\n        if (this._queryOptions.startAt || this._queryOptions.endAt) {\n            throw new Error('Cannot specify an orderBy() constraint after calling ' +\n                'startAt(), startAfter(), endBefore() or endAt().');\n        }\n        const newOrder = new FieldOrder(path_1.FieldPath.fromArgument(fieldPath), directionOperators[directionStr || 'asc']);\n        const options = this._queryOptions.with({\n            fieldOrders: this._queryOptions.fieldOrders.concat(newOrder),\n        });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} that only returns the\n     * first matching documents.\n     *\n     * This function returns a new (immutable) instance of the Query (rather than\n     * modify the existing instance) to impose the limit.\n     *\n     * @param {number} limit The maximum number of items to return.\n     * @returns {Query} The created Query.\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '>', 42);\n     *\n     * query.limit(1).get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     */\n    limit(limit) {\n        validate_1.validateInteger('limit', limit);\n        const options = this._queryOptions.with({\n            limit,\n            limitType: LimitType.First,\n        });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} that only returns the\n     * last matching documents.\n     *\n     * You must specify at least one orderBy clause for limitToLast queries,\n     * otherwise an exception will be thrown during execution.\n     *\n     * Results for limitToLast queries cannot be streamed via the `stream()` API.\n     *\n     * @param limit The maximum number of items to return.\n     * @return The created Query.\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '>', 42);\n     *\n     * query.limitToLast(1).get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Last matching document is ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     */\n    limitToLast(limit) {\n        validate_1.validateInteger('limitToLast', limit);\n        const options = this._queryOptions.with({ limit, limitType: LimitType.Last });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Specifies the offset of the returned results.\n     *\n     * This function returns a new (immutable) instance of the\n     * [Query]{@link Query} (rather than modify the existing instance)\n     * to impose the offset.\n     *\n     * @param {number} offset The offset to apply to the Query results\n     * @returns {Query} The created Query.\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '>', 42);\n     *\n     * query.limit(10).offset(20).get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     */\n    offset(offset) {\n        validate_1.validateInteger('offset', offset);\n        const options = this._queryOptions.with({ offset });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Returns true if this `Query` is equal to the provided value.\n     *\n     * @param {*} other The value to compare against.\n     * @return {boolean} true if this `Query` is equal to the provided value.\n     */\n    isEqual(other) {\n        if (this === other) {\n            return true;\n        }\n        return (other instanceof Query && this._queryOptions.isEqual(other._queryOptions));\n    }\n    /**\n     * Computes the backend ordering semantics for DocumentSnapshot cursors.\n     *\n     * @private\n     * @param cursorValuesOrDocumentSnapshot The snapshot of the document or the\n     * set of field values to use as the boundary.\n     * @returns The implicit ordering semantics.\n     */\n    createImplicitOrderBy(cursorValuesOrDocumentSnapshot) {\n        if (!Query._isDocumentSnapshot(cursorValuesOrDocumentSnapshot)) {\n            return this._queryOptions.fieldOrders;\n        }\n        const fieldOrders = this._queryOptions.fieldOrders.slice();\n        let hasDocumentId = false;\n        if (fieldOrders.length === 0) {\n            // If no explicit ordering is specified, use the first inequality to\n            // define an implicit order.\n            for (const fieldFilter of this._queryOptions.fieldFilters) {\n                if (fieldFilter.isInequalityFilter()) {\n                    fieldOrders.push(new FieldOrder(fieldFilter.field));\n                    break;\n                }\n            }\n        }\n        else {\n            for (const fieldOrder of fieldOrders) {\n                if (path_1.FieldPath.documentId().isEqual(fieldOrder.field)) {\n                    hasDocumentId = true;\n                }\n            }\n        }\n        if (!hasDocumentId) {\n            // Add implicit sorting by name, using the last specified direction.\n            const lastDirection = fieldOrders.length === 0\n                ? directionOperators.ASC\n                : fieldOrders[fieldOrders.length - 1].direction;\n            fieldOrders.push(new FieldOrder(path_1.FieldPath.documentId(), lastDirection));\n        }\n        return fieldOrders;\n    }\n    /**\n     * Builds a Firestore 'Position' proto message.\n     *\n     * @private\n     * @param {Array.<FieldOrder>} fieldOrders The field orders to use for this\n     * cursor.\n     * @param {Array.<DocumentSnapshot|*>} cursorValuesOrDocumentSnapshot The\n     * snapshot of the document or the set of field values to use as the boundary.\n     * @param before Whether the query boundary lies just before or after the\n     * provided data.\n     * @returns {Object} The proto message.\n     */\n    createCursor(fieldOrders, cursorValuesOrDocumentSnapshot, before) {\n        let fieldValues;\n        if (Query._isDocumentSnapshot(cursorValuesOrDocumentSnapshot)) {\n            fieldValues = Query._extractFieldValues(cursorValuesOrDocumentSnapshot[0], fieldOrders);\n        }\n        else {\n            fieldValues = cursorValuesOrDocumentSnapshot;\n        }\n        if (fieldValues.length > fieldOrders.length) {\n            throw new Error('Too many cursor values specified. The specified ' +\n                'values must match the orderBy() constraints of the query.');\n        }\n        const options = { values: [], before };\n        for (let i = 0; i < fieldValues.length; ++i) {\n            let fieldValue = fieldValues[i];\n            if (path_1.FieldPath.documentId().isEqual(fieldOrders[i].field)) {\n                fieldValue = this.validateReference(fieldValue);\n            }\n            validateQueryValue(i, fieldValue, this._allowUndefined);\n            options.values.push(fieldValue);\n        }\n        return options;\n    }\n    /**\n     * Validates that a value used with FieldValue.documentId() is either a\n     * string or a DocumentReference that is part of the query`s result set.\n     * Throws a validation error or returns a DocumentReference that can\n     * directly be used in the Query.\n     *\n     * @param val The value to validate.\n     * @throws If the value cannot be used for this query.\n     * @return If valid, returns a DocumentReference that can be used with the\n     * query.\n     * @private\n     */\n    validateReference(val) {\n        const basePath = this._queryOptions.allDescendants\n            ? this._queryOptions.parentPath\n            : this._queryOptions.parentPath.append(this._queryOptions.collectionId);\n        let reference;\n        if (typeof val === 'string') {\n            const path = basePath.append(val);\n            if (this._queryOptions.allDescendants) {\n                if (!path.isDocument) {\n                    throw new Error('When querying a collection group and ordering by ' +\n                        'FieldPath.documentId(), the corresponding value must result in ' +\n                        `a valid document path, but '${val}' is not because it ` +\n                        'contains an odd number of segments.');\n                }\n            }\n            else if (val.indexOf('/') !== -1) {\n                throw new Error('When querying a collection and ordering by FieldPath.documentId(), ' +\n                    `the corresponding value must be a plain document ID, but '${val}' ` +\n                    'contains a slash.');\n            }\n            reference = new DocumentReference(this._firestore, basePath.append(val), this._queryOptions.converter);\n        }\n        else if (val instanceof DocumentReference) {\n            reference = val;\n            if (!basePath.isPrefixOf(reference._path)) {\n                throw new Error(`\"${reference.path}\" is not part of the query result set and ` +\n                    'cannot be used as a query boundary.');\n            }\n        }\n        else {\n            throw new Error('The corresponding value for FieldPath.documentId() must be a ' +\n                `string or a DocumentReference, but was \"${val}\".`);\n        }\n        if (!this._queryOptions.allDescendants &&\n            reference._path.parent().compareTo(basePath) !== 0) {\n            throw new Error('Only a direct child can be used as a query boundary. ' +\n                `Found: \"${reference.path}\".`);\n        }\n        return reference;\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} that starts at the provided\n     * set of field values relative to the order of the query. The order of the\n     * provided values must match the order of the order by clauses of the query.\n     *\n     * @param {...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot\n     * of the document the query results should start at or the field values to\n     * start this query at, in order of the query's order by.\n     * @returns {Query} A query with the new starting point.\n     *\n     * @example\n     * let query = firestore.collection('col');\n     *\n     * query.orderBy('foo').startAt(42).get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     */\n    startAt(...fieldValuesOrDocumentSnapshot) {\n        validate_1.validateMinNumberOfArguments('Query.startAt', arguments, 1);\n        const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);\n        const startAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, true);\n        const options = this._queryOptions.with({ fieldOrders, startAt });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} that starts after the\n     * provided set of field values relative to the order of the query. The order\n     * of the provided values must match the order of the order by clauses of the\n     * query.\n     *\n     * @param {...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot\n     * of the document the query results should start after or the field values to\n     * start this query after, in order of the query's order by.\n     * @returns {Query} A query with the new starting point.\n     *\n     * @example\n     * let query = firestore.collection('col');\n     *\n     * query.orderBy('foo').startAfter(42).get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     */\n    startAfter(...fieldValuesOrDocumentSnapshot) {\n        validate_1.validateMinNumberOfArguments('Query.startAfter', arguments, 1);\n        const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);\n        const startAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, false);\n        const options = this._queryOptions.with({ fieldOrders, startAt });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} that ends before the set of\n     * field values relative to the order of the query. The order of the provided\n     * values must match the order of the order by clauses of the query.\n     *\n     * @param {...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot\n     * of the document the query results should end before or the field values to\n     * end this query before, in order of the query's order by.\n     * @returns {Query} A query with the new ending point.\n     *\n     * @example\n     * let query = firestore.collection('col');\n     *\n     * query.orderBy('foo').endBefore(42).get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     */\n    endBefore(...fieldValuesOrDocumentSnapshot) {\n        validate_1.validateMinNumberOfArguments('Query.endBefore', arguments, 1);\n        const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);\n        const endAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, true);\n        const options = this._queryOptions.with({ fieldOrders, endAt });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} that ends at the provided\n     * set of field values relative to the order of the query. The order of the\n     * provided values must match the order of the order by clauses of the query.\n     *\n     * @param {...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot\n     * of the document the query results should end at or the field values to end\n     * this query at, in order of the query's order by.\n     * @returns {Query} A query with the new ending point.\n     *\n     * @example\n     * let query = firestore.collection('col');\n     *\n     * query.orderBy('foo').endAt(42).get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     */\n    endAt(...fieldValuesOrDocumentSnapshot) {\n        validate_1.validateMinNumberOfArguments('Query.endAt', arguments, 1);\n        const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);\n        const endAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, false);\n        const options = this._queryOptions.with({ fieldOrders, endAt });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Executes the query and returns the results as a\n     * [QuerySnapshot]{@link QuerySnapshot}.\n     *\n     * @returns {Promise.<QuerySnapshot>} A Promise that resolves with the results\n     * of the Query.\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     */\n    get() {\n        return this._get();\n    }\n    /**\n     * Internal get() method that accepts an optional transaction id.\n     *\n     * @private\n     * @param {bytes=} transactionId A transaction ID.\n     */\n    _get(transactionId) {\n        const docs = [];\n        // Capture the error stack to preserve stack tracing across async calls.\n        const stack = Error().stack;\n        return new Promise((resolve, reject) => {\n            let readTime;\n            this._stream(transactionId)\n                .on('error', err => {\n                reject(util_1.wrapError(err, stack));\n            })\n                .on('data', result => {\n                readTime = result.readTime;\n                if (result.document) {\n                    docs.push(result.document);\n                }\n            })\n                .on('end', () => {\n                if (this._queryOptions.limitType === LimitType.Last) {\n                    // The results for limitToLast queries need to be flipped since\n                    // we reversed the ordering constraints before sending the query\n                    // to the backend.\n                    docs.reverse();\n                }\n                resolve(new QuerySnapshot(this, readTime, docs.length, () => docs, () => {\n                    const changes = [];\n                    for (let i = 0; i < docs.length; ++i) {\n                        changes.push(new document_change_1.DocumentChange('added', docs[i], -1, i));\n                    }\n                    return changes;\n                }));\n            });\n        });\n    }\n    /**\n     * Executes the query and streams the results as\n     * [QueryDocumentSnapshots]{@link QueryDocumentSnapshot}.\n     *\n     * @returns {Stream.<QueryDocumentSnapshot>} A stream of\n     * QueryDocumentSnapshots.\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * let count = 0;\n     *\n     * query.stream().on('data', (documentSnapshot) => {\n     *   console.log(`Found document with name '${documentSnapshot.id}'`);\n     *   ++count;\n     * }).on('end', () => {\n     *   console.log(`Total count is ${count}`);\n     * });\n     */\n    stream() {\n        if (this._queryOptions.limitType === LimitType.Last) {\n            throw new Error('Query results for queries that include limitToLast() ' +\n                'constraints cannot be streamed. Use Query.get() instead.');\n        }\n        const responseStream = this._stream();\n        const transform = through2.obj(function (chunk, encoding, callback) {\n            // Only send chunks with documents.\n            if (chunk.document) {\n                this.push(chunk.document);\n            }\n            callback();\n        });\n        responseStream.pipe(transform);\n        responseStream.on('error', e => transform.destroy(e));\n        return transform;\n    }\n    /**\n     * Converts a QueryCursor to its proto representation.\n     *\n     * @param cursor The original cursor value\n     * @private\n     */\n    toCursor(cursor) {\n        if (cursor) {\n            const values = cursor.values.map(val => this._serializer.encodeValue(val));\n            return cursor.before ? { before: true, values } : { values };\n        }\n        return undefined;\n    }\n    /**\n     * Internal method for serializing a query to its RunQuery proto\n     * representation with an optional transaction id or read time.\n     *\n     * @param transactionIdOrReadTime A transaction ID or the read time at which\n     * to execute the query.\n     * @private\n     * @returns Serialized JSON for the query.\n     */\n    toProto(transactionIdOrReadTime) {\n        const projectId = this.firestore.projectId;\n        const parentPath = this._queryOptions.parentPath.toQualifiedResourcePath(projectId);\n        const reqOpts = {\n            parent: parentPath.formattedName,\n            structuredQuery: {\n                from: [\n                    {\n                        collectionId: this._queryOptions.collectionId,\n                    },\n                ],\n            },\n        };\n        if (this._queryOptions.allDescendants) {\n            reqOpts.structuredQuery.from[0].allDescendants = true;\n        }\n        const structuredQuery = reqOpts.structuredQuery;\n        if (this._queryOptions.fieldFilters.length === 1) {\n            structuredQuery.where = this._queryOptions.fieldFilters[0].toProto();\n        }\n        else if (this._queryOptions.fieldFilters.length > 1) {\n            const filters = [];\n            for (const fieldFilter of this._queryOptions.fieldFilters) {\n                filters.push(fieldFilter.toProto());\n            }\n            structuredQuery.where = {\n                compositeFilter: {\n                    op: 'AND',\n                    filters,\n                },\n            };\n        }\n        if (this._queryOptions.limitType === LimitType.Last) {\n            if (!this._queryOptions.hasFieldOrders()) {\n                throw new Error('limitToLast() queries require specifying at least one orderBy() clause.');\n            }\n            structuredQuery.orderBy = this._queryOptions.fieldOrders.map(order => {\n                // Flip the orderBy directions since we want the last results\n                const dir = order.direction === 'DESCENDING' ? 'ASCENDING' : 'DESCENDING';\n                return new FieldOrder(order.field, dir).toProto();\n            });\n            // Swap the cursors to match the now-flipped query ordering.\n            structuredQuery.startAt = this._queryOptions.endAt\n                ? this.toCursor({\n                    values: this._queryOptions.endAt.values,\n                    before: !this._queryOptions.endAt.before,\n                })\n                : undefined;\n            structuredQuery.endAt = this._queryOptions.startAt\n                ? this.toCursor({\n                    values: this._queryOptions.startAt.values,\n                    before: !this._queryOptions.startAt.before,\n                })\n                : undefined;\n        }\n        else {\n            if (this._queryOptions.hasFieldOrders()) {\n                structuredQuery.orderBy = this._queryOptions.fieldOrders.map(o => o.toProto());\n            }\n            structuredQuery.startAt = this.toCursor(this._queryOptions.startAt);\n            structuredQuery.endAt = this.toCursor(this._queryOptions.endAt);\n        }\n        if (this._queryOptions.limit) {\n            structuredQuery.limit = { value: this._queryOptions.limit };\n        }\n        structuredQuery.offset = this._queryOptions.offset;\n        structuredQuery.select = this._queryOptions.projection;\n        if (transactionIdOrReadTime instanceof Uint8Array) {\n            reqOpts.transaction = transactionIdOrReadTime;\n        }\n        else if (transactionIdOrReadTime instanceof timestamp_1.Timestamp) {\n            reqOpts.readTime = transactionIdOrReadTime.toProto().timestampValue;\n        }\n        return reqOpts;\n    }\n    /**\n     * Internal streaming method that accepts an optional transaction ID.\n     *\n     * @param transactionId A transaction ID.\n     * @private\n     * @returns A stream of document results.\n     */\n    _stream(transactionId) {\n        const tag = util_1.requestTag();\n        const self = this;\n        let lastReceivedDocument = null;\n        const stream = through2.obj(function (proto, enc, callback) {\n            const readTime = timestamp_1.Timestamp.fromProto(proto.readTime);\n            if (proto.document) {\n                const document = self.firestore.snapshot_(proto.document, proto.readTime);\n                const finalDoc = new document_1.DocumentSnapshotBuilder(document.ref.withConverter(self._queryOptions.converter));\n                // Recreate the QueryDocumentSnapshot with the DocumentReference\n                // containing the original converter.\n                finalDoc.fieldsProto = document._fieldsProto;\n                finalDoc.readTime = document.readTime;\n                finalDoc.createTime = document.createTime;\n                finalDoc.updateTime = document.updateTime;\n                lastReceivedDocument = finalDoc.build();\n                this.push({ document: lastReceivedDocument, readTime });\n            }\n            else {\n                this.push({ readTime });\n            }\n            callback();\n        });\n        this.firestore\n            .initializeIfNeeded(tag)\n            .then(async () => {\n            // `toProto()` might throw an exception. We rely on the behavior of an\n            // async function to convert this exception into the rejected Promise we\n            // catch below.\n            let request = this.toProto(transactionId);\n            let streamActive;\n            do {\n                streamActive = new util_1.Deferred();\n                const backendStream = await this._firestore.requestStream('runQuery', request, tag);\n                backendStream.on('error', err => {\n                    backendStream.unpipe(stream);\n                    // If a non-transactional query failed, attempt to restart.\n                    // Transactional queries are retried via the transaction runner.\n                    if (!transactionId && !util_1.isPermanentRpcError(err, 'runQuery')) {\n                        logger_1.logger('Query._stream', tag, 'Query failed with retryable stream error:', err);\n                        if (lastReceivedDocument) {\n                            // Restart the query but use the last document we received as the\n                            // query cursor. Note that we do not use backoff here. The call to\n                            // `requestStream()` will backoff should the restart fail before\n                            // delivering any results.\n                            request = this.startAfter(lastReceivedDocument).toProto(lastReceivedDocument.readTime);\n                        }\n                        streamActive.resolve(/* active= */ true);\n                    }\n                    else {\n                        logger_1.logger('Query._stream', tag, 'Query failed with stream error:', err);\n                        stream.destroy(err);\n                        streamActive.resolve(/* active= */ false);\n                    }\n                });\n                backendStream.on('end', () => {\n                    streamActive.resolve(/* active= */ false);\n                });\n                backendStream.resume();\n                backendStream.pipe(stream);\n            } while (await streamActive.promise);\n        })\n            .catch(e => stream.destroy(e));\n        return stream;\n    }\n    /**\n     * Attaches a listener for QuerySnapshot events.\n     *\n     * @param {querySnapshotCallback} onNext A callback to be called every time\n     * a new [QuerySnapshot]{@link QuerySnapshot} is available.\n     * @param {errorCallback=} onError A callback to be called if the listen\n     * fails or is cancelled. No further callbacks will occur.\n     *\n     * @returns {function()} An unsubscribe function that can be called to cancel\n     * the snapshot listener.\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * let unsubscribe = query.onSnapshot(querySnapshot => {\n     *   console.log(`Received query snapshot of size ${querySnapshot.size}`);\n     * }, err => {\n     *   console.log(`Encountered error: ${err}`);\n     * });\n     *\n     * // Remove this listener.\n     * unsubscribe();\n     */\n    onSnapshot(onNext, onError) {\n        validate_1.validateFunction('onNext', onNext);\n        validate_1.validateFunction('onError', onError, { optional: true });\n        const watch = new watch_1.QueryWatch(this.firestore, this, this._queryOptions.converter);\n        return watch.onSnapshot((readTime, size, docs, changes) => {\n            onNext(new QuerySnapshot(this, readTime, size, docs, changes));\n        }, onError || console.error);\n    }\n    /**\n     * Returns a function that can be used to sort QueryDocumentSnapshots\n     * according to the sort criteria of this query.\n     *\n     * @private\n     */\n    comparator() {\n        return (doc1, doc2) => {\n            // Add implicit sorting by name, using the last specified direction.\n            const lastDirection = this._queryOptions.hasFieldOrders()\n                ? this._queryOptions.fieldOrders[this._queryOptions.fieldOrders.length - 1].direction\n                : 'ASCENDING';\n            const orderBys = this._queryOptions.fieldOrders.concat(new FieldOrder(path_1.FieldPath.documentId(), lastDirection));\n            for (const orderBy of orderBys) {\n                let comp;\n                if (path_1.FieldPath.documentId().isEqual(orderBy.field)) {\n                    comp = doc1.ref._path.compareTo(doc2.ref._path);\n                }\n                else {\n                    const v1 = doc1.protoField(orderBy.field);\n                    const v2 = doc2.protoField(orderBy.field);\n                    if (v1 === undefined || v2 === undefined) {\n                        throw new Error('Trying to compare documents on fields that ' +\n                            \"don't exist. Please include the fields you are ordering on \" +\n                            'in your select() call.');\n                    }\n                    comp = order_1.compare(v1, v2);\n                }\n                if (comp !== 0) {\n                    const direction = orderBy.direction === 'ASCENDING' ? 1 : -1;\n                    return direction * comp;\n                }\n            }\n            return 0;\n        };\n    }\n    /**\n     * Applies a custom data converter to this Query, allowing you to use your\n     * own custom model objects with Firestore. When you call get() on the\n     * returned Query, the provided converter will convert between Firestore\n     * data and your custom type U.\n     *\n     * Using the converter allows you to specify generic type arguments when\n     * storing and retrieving objects from Firestore.\n     *\n     * @example\n     * class Post {\n     *   constructor(readonly title: string, readonly author: string) {}\n     *\n     *   toString(): string {\n     *     return this.title + ', by ' + this.author;\n     *   }\n     * }\n     *\n     * const postConverter = {\n     *   toFirestore(post: Post): FirebaseFirestore.DocumentData {\n     *     return {title: post.title, author: post.author};\n     *   },\n     *   fromFirestore(\n     *     data: FirebaseFirestore.DocumentData\n     *   ): Post {\n     *     return new Post(data.title, data.author);\n     *   }\n     * };\n     *\n     * const postSnap = await Firestore()\n     *   .collection('posts')\n     *   .withConverter(postConverter)\n     *   .doc().get();\n     * const post = postSnap.data();\n     * if (post !== undefined) {\n     *   post.title; // string\n     *   post.toString(); // Should be defined\n     *   post.someNonExistentProperty; // TS error\n     * }\n     *\n     * @param converter Converts objects to and from Firestore.\n     * @return A Query<U> that uses the provided converter.\n     */\n    withConverter(converter) {\n        return new Query(this.firestore, this._queryOptions.withConverter(converter));\n    }\n}\nexports.Query = Query;\n/**\n * A CollectionReference object can be used for adding documents, getting\n * document references, and querying for documents (using the methods\n * inherited from [Query]{@link Query}).\n *\n * @class\n * @extends Query\n */\nclass CollectionReference extends Query {\n    /**\n     * @hideconstructor\n     *\n     * @param firestore The Firestore Database client.\n     * @param path The Path of this collection.\n     */\n    constructor(firestore, path, converter) {\n        super(firestore, QueryOptions.forCollectionQuery(path, converter));\n    }\n    /**\n     * Returns a resource path for this collection.\n     * @private\n     */\n    get resourcePath() {\n        return this._queryOptions.parentPath.append(this._queryOptions.collectionId);\n    }\n    /**\n     * The last path element of the referenced collection.\n     *\n     * @type {string}\n     * @name CollectionReference#id\n     * @readonly\n     *\n     * @example\n     * let collectionRef = firestore.collection('col/doc/subcollection');\n     * console.log(`ID of the subcollection: ${collectionRef.id}`);\n     */\n    get id() {\n        return this._queryOptions.collectionId;\n    }\n    /**\n     * A reference to the containing Document if this is a subcollection, else\n     * null.\n     *\n     * @type {DocumentReference|null}\n     * @name CollectionReference#parent\n     * @readonly\n     *\n     * @example\n     * let collectionRef = firestore.collection('col/doc/subcollection');\n     * let documentRef = collectionRef.parent;\n     * console.log(`Parent name: ${documentRef.path}`);\n     */\n    get parent() {\n        if (this._queryOptions.parentPath.isDocument) {\n            return new DocumentReference(this.firestore, this._queryOptions.parentPath);\n        }\n        return null;\n    }\n    /**\n     * A string representing the path of the referenced collection (relative\n     * to the root of the database).\n     *\n     * @type {string}\n     * @name CollectionReference#path\n     * @readonly\n     *\n     * @example\n     * let collectionRef = firestore.collection('col/doc/subcollection');\n     * console.log(`Path of the subcollection: ${collectionRef.path}`);\n     */\n    get path() {\n        return this.resourcePath.relativeName;\n    }\n    /**\n     * Retrieves the list of documents in this collection.\n     *\n     * The document references returned may include references to \"missing\n     * documents\", i.e. document locations that have no document present but\n     * which contain subcollections with documents. Attempting to read such a\n     * document reference (e.g. via `.get()` or `.onSnapshot()`) will return a\n     * `DocumentSnapshot` whose `.exists` property is false.\n     *\n     * @return {Promise<DocumentReference[]>} The list of documents in this\n     * collection.\n     *\n     * @example\n     * let collectionRef = firestore.collection('col');\n     *\n     * return collectionRef.listDocuments().then(documentRefs => {\n     *    return firestore.getAll(documentRefs);\n     * }).then(documentSnapshots => {\n     *    for (let documentSnapshot of documentSnapshots) {\n     *       if (documentSnapshot.exists) {\n     *         console.log(`Found document with data: ${documentSnapshot.id}`);\n     *       } else {\n     *         console.log(`Found missing document: ${documentSnapshot.id}`);\n     *       }\n     *    }\n     * });\n     */\n    listDocuments() {\n        const tag = util_1.requestTag();\n        return this.firestore.initializeIfNeeded(tag).then(() => {\n            const parentPath = this._queryOptions.parentPath.toQualifiedResourcePath(this.firestore.projectId);\n            const request = {\n                parent: parentPath.formattedName,\n                collectionId: this.id,\n                showMissing: true,\n                // Setting `pageSize` to the maximum allowed value lets the backend cap\n                // the page size (currently to 300).\n                pageSize: Math.pow(2, 32) - 1,\n                mask: { fieldPaths: [] },\n            };\n            return this.firestore\n                .request('listDocuments', request, tag)\n                .then(documents => {\n                // Note that the backend already orders these documents by name,\n                // so we do not need to manually sort them.\n                return documents.map(doc => {\n                    const path = path_1.QualifiedResourcePath.fromSlashSeparatedString(doc.name);\n                    return this.doc(path.id);\n                });\n            });\n        });\n    }\n    /**\n     * Gets a [DocumentReference]{@link DocumentReference} instance that\n     * refers to the document at the specified path. If no path is specified, an\n     * automatically-generated unique ID will be used for the returned\n     * DocumentReference.\n     *\n     * @param {string=} documentPath A slash-separated path to a document.\n     * @returns {DocumentReference} The `DocumentReference`\n     * instance.\n     *\n     * @example\n     * let collectionRef = firestore.collection('col');\n     * let documentRefWithName = collectionRef.doc('doc');\n     * let documentRefWithAutoId = collectionRef.doc();\n     * console.log(`Reference with name: ${documentRefWithName.path}`);\n     * console.log(`Reference with auto-id: ${documentRefWithAutoId.path}`);\n     */\n    doc(documentPath) {\n        if (arguments.length === 0) {\n            documentPath = util_1.autoId();\n        }\n        else {\n            path_1.validateResourcePath('documentPath', documentPath);\n        }\n        const path = this.resourcePath.append(documentPath);\n        if (!path.isDocument) {\n            throw new Error(`Value for argument \"documentPath\" must point to a document, but was \"${documentPath}\". Your path does not contain an even number of components.`);\n        }\n        return new DocumentReference(this.firestore, path, this._queryOptions.converter);\n    }\n    /**\n     * Add a new document to this collection with the specified data, assigning\n     * it a document ID automatically.\n     *\n     * @param {DocumentData} data An Object containing the data for the new\n     * document.\n     * @returns {Promise.<DocumentReference>} A Promise resolved with a\n     * [DocumentReference]{@link DocumentReference} pointing to the\n     * newly created document.\n     *\n     * @example\n     * let collectionRef = firestore.collection('col');\n     * collectionRef.add({foo: 'bar'}).then(documentReference => {\n     *   console.log(`Added document with name: ${documentReference.id}`);\n     * });\n     */\n    add(data) {\n        const firestoreData = this._queryOptions.converter.toFirestore(data);\n        write_batch_1.validateDocumentData('data', firestoreData, \n        /*allowDeletes=*/ false, this._allowUndefined);\n        const documentRef = this.doc();\n        return documentRef.create(data).then(() => documentRef);\n    }\n    /**\n     * Returns true if this `CollectionReference` is equal to the provided value.\n     *\n     * @param {*} other The value to compare against.\n     * @return {boolean} true if this `CollectionReference` is equal to the\n     * provided value.\n     */\n    isEqual(other) {\n        return (this === other ||\n            (other instanceof CollectionReference && super.isEqual(other)));\n    }\n    /**\n     * Applies a custom data converter to this CollectionReference, allowing you\n     * to use your own custom model objects with Firestore. When you call add()\n     * on the returned CollectionReference instance, the provided converter will\n     * convert between Firestore data and your custom type U.\n     *\n     * Using the converter allows you to specify generic type arguments when\n     * storing and retrieving objects from Firestore.\n     *\n     * @example\n     * class Post {\n     *   constructor(readonly title: string, readonly author: string) {}\n     *\n     *   toString(): string {\n     *     return this.title + ', by ' + this.author;\n     *   }\n     * }\n     *\n     * const postConverter = {\n     *   toFirestore(post: Post): FirebaseFirestore.DocumentData {\n     *     return {title: post.title, author: post.author};\n     *   },\n     *   fromFirestore(\n     *     data: FirebaseFirestore.DocumentData\n     *   ): Post {\n     *     return new Post(data.title, data.author);\n     *   }\n     * };\n     *\n     * const postSnap = await Firestore()\n     *   .collection('posts')\n     *   .withConverter(postConverter)\n     *   .doc().get();\n     * const post = postSnap.data();\n     * if (post !== undefined) {\n     *   post.title; // string\n     *   post.toString(); // Should be defined\n     *   post.someNonExistentProperty; // TS error\n     * }\n     *\n     * @param converter Converts objects to and from Firestore.\n     * @return A CollectionReference<U> that uses the provided converter.\n     */\n    withConverter(converter) {\n        return new CollectionReference(this.firestore, this.resourcePath, converter);\n    }\n}\nexports.CollectionReference = CollectionReference;\n/**\n * Validates the input string as a field order direction.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param op Order direction to validate.\n * @throws when the direction is invalid\n * @return a validated input value, which may be different from the provided\n * value.\n */\nfunction validateQueryOrder(arg, op) {\n    // For backwards compatibility, we support both lower and uppercase values.\n    op = typeof op === 'string' ? op.toLowerCase() : op;\n    validate_1.validateEnumValue(arg, op, Object.keys(directionOperators), { optional: true });\n    return op;\n}\nexports.validateQueryOrder = validateQueryOrder;\n/**\n * Validates the input string as a field comparison operator.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param op Field comparison operator to validate.\n * @param fieldValue Value that is used in the filter.\n * @throws when the comparison operation is invalid\n * @return a validated input value, which may be different from the provided\n * value.\n */\nfunction validateQueryOperator(arg, op, fieldValue) {\n    // For backwards compatibility, we support both `=` and `==` for \"equals\".\n    op = op === '=' ? '==' : op;\n    validate_1.validateEnumValue(arg, op, Object.keys(comparisonOperators));\n    if (typeof fieldValue === 'number' && isNaN(fieldValue) && op !== '==') {\n        throw new Error('Invalid query. You can only perform equals comparisons on NaN.');\n    }\n    if (fieldValue === null && op !== '==') {\n        throw new Error('Invalid query. You can only perform equals comparisons on Null.');\n    }\n    return op;\n}\nexports.validateQueryOperator = validateQueryOperator;\n/**\n * Validates that 'value' is a DocumentReference.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The argument to validate.\n */\nfunction validateDocumentReference(arg, value) {\n    if (!(value instanceof DocumentReference)) {\n        throw new Error(validate_1.invalidArgumentMessage(arg, 'DocumentReference'));\n    }\n}\nexports.validateDocumentReference = validateDocumentReference;\n/**\n * Validates that 'value' can be used as a query value.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The argument to validate.\n * @param allowUndefined Whether to allow nested properties that are `undefined`.\n */\nfunction validateQueryValue(arg, value, allowUndefined) {\n    serializer_1.validateUserInput(arg, value, 'query constraint', {\n        allowDeletes: 'none',\n        allowTransforms: false,\n        allowUndefined,\n    });\n}\n/**\n * Verifies equality for an array of objects using the `isEqual` interface.\n *\n * @private\n * @param left Array of objects supporting `isEqual`.\n * @param right Array of objects supporting `isEqual`.\n * @return True if arrays are equal.\n */\nfunction isArrayEqual(left, right) {\n    if (left.length !== right.length) {\n        return false;\n    }\n    for (let i = 0; i < left.length; ++i) {\n        if (!left[i].isEqual(right[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Returns the first non-undefined value or `undefined` if no such value exists.\n * @private\n */\nfunction coalesce(...values) {\n    return values.find(value => value !== undefined);\n}\n//# sourceMappingURL=reference.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/firestore/build/src/reference.js?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/firestore/build/src/serializer.js":
/*!**************************************************************************!*\
  !*** ./src/node_modules/@google-cloud/firestore/build/src/serializer.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Copyright 2019 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst convert_1 = __webpack_require__(/*! ./convert */ \"./src/node_modules/@google-cloud/firestore/build/src/convert.js\");\nconst field_value_1 = __webpack_require__(/*! ./field-value */ \"./src/node_modules/@google-cloud/firestore/build/src/field-value.js\");\nconst field_value_2 = __webpack_require__(/*! ./field-value */ \"./src/node_modules/@google-cloud/firestore/build/src/field-value.js\");\nconst geo_point_1 = __webpack_require__(/*! ./geo-point */ \"./src/node_modules/@google-cloud/firestore/build/src/geo-point.js\");\nconst index_1 = __webpack_require__(/*! ./index */ \"./src/node_modules/@google-cloud/firestore/build/src/index.js\");\nconst path_1 = __webpack_require__(/*! ./path */ \"./src/node_modules/@google-cloud/firestore/build/src/path.js\");\nconst timestamp_1 = __webpack_require__(/*! ./timestamp */ \"./src/node_modules/@google-cloud/firestore/build/src/timestamp.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"./src/node_modules/@google-cloud/firestore/build/src/util.js\");\nconst validate_1 = __webpack_require__(/*! ./validate */ \"./src/node_modules/@google-cloud/firestore/build/src/validate.js\");\n/**\n * The maximum depth of a Firestore object.\n *\n * @private\n */\nconst MAX_DEPTH = 20;\n/**\n * Serializer that is used to convert between JavaScript types and their\n * Firestore Protobuf representation.\n *\n * @private\n */\nclass Serializer {\n    constructor(firestore) {\n        // Instead of storing the `firestore` object, we store just a reference to\n        // its `.doc()` method. This avoid a circular reference, which breaks\n        // JSON.stringify().\n        this.createReference = path => firestore.doc(path);\n        this.allowUndefined = !!firestore._settings.ignoreUndefinedProperties;\n    }\n    /**\n     * Encodes a JavaScript object into the Firestore 'Fields' representation.\n     *\n     * @private\n     * @param obj The object to encode.\n     * @returns The Firestore 'Fields' representation\n     */\n    encodeFields(obj) {\n        const fields = {};\n        for (const prop of Object.keys(obj)) {\n            const val = this.encodeValue(obj[prop]);\n            if (val) {\n                fields[prop] = val;\n            }\n        }\n        return fields;\n    }\n    /**\n     * Encodes a JavaScript value into the Firestore 'Value' representation.\n     *\n     * @private\n     * @param val The object to encode\n     * @returns The Firestore Proto or null if we are deleting a field.\n     */\n    encodeValue(val) {\n        if (val instanceof field_value_1.FieldTransform) {\n            return null;\n        }\n        if (typeof val === 'string') {\n            return {\n                stringValue: val,\n            };\n        }\n        if (typeof val === 'boolean') {\n            return {\n                booleanValue: val,\n            };\n        }\n        if (typeof val === 'number') {\n            if (Number.isSafeInteger(val)) {\n                return {\n                    integerValue: val,\n                };\n            }\n            else {\n                return {\n                    doubleValue: val,\n                };\n            }\n        }\n        if (val instanceof Date) {\n            const timestamp = timestamp_1.Timestamp.fromDate(val);\n            return {\n                timestampValue: {\n                    seconds: timestamp.seconds,\n                    nanos: timestamp.nanoseconds,\n                },\n            };\n        }\n        if (isMomentJsType(val)) {\n            const timestamp = timestamp_1.Timestamp.fromDate(val.toDate());\n            return {\n                timestampValue: {\n                    seconds: timestamp.seconds,\n                    nanos: timestamp.nanoseconds,\n                },\n            };\n        }\n        if (val === null) {\n            return {\n                nullValue: 'NULL_VALUE',\n            };\n        }\n        if (val instanceof Buffer || val instanceof Uint8Array) {\n            return {\n                bytesValue: val,\n            };\n        }\n        if (util_1.isObject(val)) {\n            const toProto = val['toProto'];\n            if (typeof toProto === 'function') {\n                return toProto.bind(val)();\n            }\n        }\n        if (val instanceof Array) {\n            const array = {\n                arrayValue: {},\n            };\n            if (val.length > 0) {\n                array.arrayValue.values = [];\n                for (let i = 0; i < val.length; ++i) {\n                    const enc = this.encodeValue(val[i]);\n                    if (enc) {\n                        array.arrayValue.values.push(enc);\n                    }\n                }\n            }\n            return array;\n        }\n        if (typeof val === 'object' && util_1.isPlainObject(val)) {\n            const map = {\n                mapValue: {},\n            };\n            // If we encounter an empty object, we always need to send it to make sure\n            // the server creates a map entry.\n            if (!util_1.isEmpty(val)) {\n                map.mapValue.fields = this.encodeFields(val);\n                if (util_1.isEmpty(map.mapValue.fields)) {\n                    return null;\n                }\n            }\n            return map;\n        }\n        if (val === undefined && this.allowUndefined) {\n            return null;\n        }\n        throw new Error(`Cannot encode value: ${val}`);\n    }\n    /**\n     * Decodes a single Firestore 'Value' Protobuf.\n     *\n     * @private\n     * @param proto A Firestore 'Value' Protobuf.\n     * @returns The converted JS type.\n     */\n    decodeValue(proto) {\n        const valueType = convert_1.detectValueType(proto);\n        switch (valueType) {\n            case 'stringValue': {\n                return proto.stringValue;\n            }\n            case 'booleanValue': {\n                return proto.booleanValue;\n            }\n            case 'integerValue': {\n                return Number(proto.integerValue);\n            }\n            case 'doubleValue': {\n                return Number(proto.doubleValue);\n            }\n            case 'timestampValue': {\n                const timestamp = timestamp_1.Timestamp.fromProto(proto.timestampValue);\n                return timestamp;\n            }\n            case 'referenceValue': {\n                const resourcePath = path_1.QualifiedResourcePath.fromSlashSeparatedString(proto.referenceValue);\n                return this.createReference(resourcePath.relativeName);\n            }\n            case 'arrayValue': {\n                const array = [];\n                if (Array.isArray(proto.arrayValue.values)) {\n                    for (const value of proto.arrayValue.values) {\n                        array.push(this.decodeValue(value));\n                    }\n                }\n                return array;\n            }\n            case 'nullValue': {\n                return null;\n            }\n            case 'mapValue': {\n                const obj = {};\n                const fields = proto.mapValue.fields;\n                if (fields) {\n                    for (const prop of Object.keys(fields)) {\n                        obj[prop] = this.decodeValue(fields[prop]);\n                    }\n                }\n                return obj;\n            }\n            case 'geoPointValue': {\n                return geo_point_1.GeoPoint.fromProto(proto.geoPointValue);\n            }\n            case 'bytesValue': {\n                return proto.bytesValue;\n            }\n            default: {\n                throw new Error('Cannot decode type from Firestore Value: ' + JSON.stringify(proto));\n            }\n        }\n    }\n}\nexports.Serializer = Serializer;\n/**\n * Validates a JavaScript value for usage as a Firestore value.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value JavaScript value to validate.\n * @param desc A description of the expected type.\n * @param path The field path to validate.\n * @param options Validation options\n * @param level The current depth of the traversal. This is used to decide\n * whether undefined values or deletes are allowed.\n * @param inArray Whether we are inside an array.\n * @throws when the object is invalid.\n */\nfunction validateUserInput(arg, value, desc, options, path, level, inArray) {\n    if (path && path.size > MAX_DEPTH) {\n        throw new Error(`${validate_1.invalidArgumentMessage(arg, desc)} Input object is deeper than ${MAX_DEPTH} levels or contains a cycle.`);\n    }\n    options = options || {};\n    level = level || 0;\n    inArray = inArray || false;\n    const fieldPathMessage = path ? ` (found in field \"${path}\")` : '';\n    if (Array.isArray(value)) {\n        for (let i = 0; i < value.length; ++i) {\n            validateUserInput(arg, value[i], desc, options, path ? path.append(String(i)) : new path_1.FieldPath(String(i)), level + 1, \n            /* inArray= */ true);\n        }\n    }\n    else if (util_1.isPlainObject(value)) {\n        for (const prop of Object.keys(value)) {\n            validateUserInput(arg, value[prop], desc, options, path ? path.append(new path_1.FieldPath(prop)) : new path_1.FieldPath(prop), level + 1, inArray);\n        }\n    }\n    else if (value === undefined) {\n        if (options.allowUndefined && level === 0) {\n            throw new Error(`${validate_1.invalidArgumentMessage(arg, desc)} \"undefined\" values are only ignored in object properties.`);\n        }\n        else if (!options.allowUndefined) {\n            throw new Error(`${validate_1.invalidArgumentMessage(arg, desc)} Cannot use \"undefined\" as a Firestore value${fieldPathMessage}. ` +\n                'If you want to ignore undefined values, enable `ignoreUndefinedProperties`.');\n        }\n    }\n    else if (value instanceof field_value_2.DeleteTransform) {\n        if (inArray) {\n            throw new Error(`${validate_1.invalidArgumentMessage(arg, desc)} ${value.methodName}() cannot be used inside of an array${fieldPathMessage}.`);\n        }\n        else if ((options.allowDeletes === 'root' && level !== 0) ||\n            options.allowDeletes === 'none') {\n            throw new Error(`${validate_1.invalidArgumentMessage(arg, desc)} ${value.methodName}() must appear at the top-level and can only be used in update() or set() with {merge:true}${fieldPathMessage}.`);\n        }\n    }\n    else if (value instanceof field_value_1.FieldTransform) {\n        if (inArray) {\n            throw new Error(`${validate_1.invalidArgumentMessage(arg, desc)} ${value.methodName}() cannot be used inside of an array${fieldPathMessage}.`);\n        }\n        else if (!options.allowTransforms) {\n            throw new Error(`${validate_1.invalidArgumentMessage(arg, desc)} ${value.methodName}() can only be used in set(), create() or update()${fieldPathMessage}.`);\n        }\n    }\n    else if (value instanceof path_1.FieldPath) {\n        throw new Error(`${validate_1.invalidArgumentMessage(arg, desc)} Cannot use object of type \"FieldPath\" as a Firestore value${fieldPathMessage}.`);\n    }\n    else if (value instanceof index_1.DocumentReference) {\n        // Ok.\n    }\n    else if (value instanceof geo_point_1.GeoPoint) {\n        // Ok.\n    }\n    else if (value instanceof timestamp_1.Timestamp || value instanceof Date) {\n        // Ok.\n    }\n    else if (isMomentJsType(value)) {\n        // Ok.\n    }\n    else if (value instanceof Buffer || value instanceof Uint8Array) {\n        // Ok.\n    }\n    else if (value === null) {\n        // Ok.\n    }\n    else if (typeof value === 'object') {\n        throw new Error(validate_1.customObjectMessage(arg, value, path));\n    }\n}\nexports.validateUserInput = validateUserInput;\n/**\n * Returns true if value is a MomentJs date object.\n * @private\n */\nfunction isMomentJsType(value) {\n    return (typeof value === 'object' &&\n        value !== null &&\n        value.constructor &&\n        value.constructor.name === 'Moment' &&\n        // tslint:disable-next-line:no-any\n        typeof value.toDate === 'function');\n}\n//# sourceMappingURL=serializer.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/firestore/build/src/serializer.js?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/firestore/build/src/timestamp.js":
/*!*************************************************************************!*\
  !*** ./src/node_modules/@google-cloud/firestore/build/src/timestamp.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst validate_1 = __webpack_require__(/*! ./validate */ \"./src/node_modules/@google-cloud/firestore/build/src/validate.js\");\n/*!\n * Number of nanoseconds in a millisecond.\n *\n * @type {number}\n */\nconst MS_TO_NANOS = 1000000;\n/*!\n * The minimum legal value for the \"seconds\" property of a Timestamp object.\n *\n * This value corresponds to 0001-01-01T00:00:00Z.\n *\n * @type {number}\n */\nconst MIN_SECONDS = -62135596800;\n/*!\n * The maximum legal value for the \"seconds\" property of a Timestamp object.\n *\n * This value corresponds to 9999-12-31T23:59:59.999999999Z.\n *\n * @type {number}\n */\nconst MAX_SECONDS = 253402300799;\n/**\n * A Timestamp represents a point in time independent of any time zone or\n * calendar, represented as seconds and fractions of seconds at nanosecond\n * resolution in UTC Epoch time. It is encoded using the Proleptic Gregorian\n * Calendar which extends the Gregorian calendar backwards to year one. It is\n * encoded assuming all minutes are 60 seconds long, i.e. leap seconds are\n * \"smeared\" so that no leap second table is needed for interpretation. Range is\n * from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z.\n *\n * @see https://github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto\n */\nclass Timestamp {\n    /**\n     * Creates a new timestamp.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.set({ startTime:new Firestore.Timestamp(42, 0) });\n     *\n     * @param {number} seconds The number of seconds of UTC time since Unix epoch\n     * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n     * 9999-12-31T23:59:59Z inclusive.\n     * @param {number} nanoseconds The non-negative fractions of a second at\n     * nanosecond resolution. Negative second values with fractions must still\n     * have non-negative nanoseconds values that count forward in time. Must be\n     * from 0 to 999,999,999 inclusive.\n     */\n    constructor(seconds, nanoseconds) {\n        validate_1.validateInteger('seconds', seconds, {\n            minValue: MIN_SECONDS,\n            maxValue: MAX_SECONDS,\n        });\n        validate_1.validateInteger('nanoseconds', nanoseconds, {\n            minValue: 0,\n            maxValue: 999999999,\n        });\n        this._seconds = seconds;\n        this._nanoseconds = nanoseconds;\n    }\n    /**\n     * Creates a new timestamp with the current date, with millisecond precision.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.set({ updateTime:Firestore.Timestamp.now() });\n     *\n     * @return {Timestamp} A new `Timestamp` representing the current date.\n     */\n    static now() {\n        return Timestamp.fromMillis(Date.now());\n    }\n    /**\n     * Creates a new timestamp from the given date.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * let date = Date.parse('01 Jan 2000 00:00:00 GMT');\n     * documentRef.set({ startTime:Firestore.Timestamp.fromDate(date) });\n     *\n     * @param {Date} date The date to initialize the `Timestamp` from.\n     * @return {Timestamp} A new `Timestamp` representing the same point in time\n     * as the given date.\n     */\n    static fromDate(date) {\n        return Timestamp.fromMillis(date.getTime());\n    }\n    /**\n     * Creates a new timestamp from the given number of milliseconds.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.set({ startTime:Firestore.Timestamp.fromMillis(42) });\n     *\n     * @param {number} milliseconds Number of milliseconds since Unix epoch\n     * 1970-01-01T00:00:00Z.\n     * @return {Timestamp}  A new `Timestamp` representing the same point in time\n     * as the given number of milliseconds.\n     */\n    static fromMillis(milliseconds) {\n        const seconds = Math.floor(milliseconds / 1000);\n        const nanos = (milliseconds - seconds * 1000) * MS_TO_NANOS;\n        return new Timestamp(seconds, nanos);\n    }\n    /**\n     * Generates a `Timestamp` object from a Timestamp proto.\n     *\n     * @private\n     * @param {Object} timestamp The `Timestamp` Protobuf object.\n     */\n    static fromProto(timestamp) {\n        return new Timestamp(Number(timestamp.seconds || 0), Number(timestamp.nanos || 0));\n    }\n    /**\n     * The number of seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(snap => {\n     *   let updated = snap.updateTime;\n     *   console.log(`Updated at ${updated.seconds}s ${updated.nanoseconds}ns`);\n     * });\n     *\n     * @type {number}\n     */\n    get seconds() {\n        return this._seconds;\n    }\n    /**\n     * The non-negative fractions of a second at nanosecond resolution.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(snap => {\n     *   let updated = snap.updateTime;\n     *   console.log(`Updated at ${updated.seconds}s ${updated.nanoseconds}ns`);\n     * });\n     *\n     * @type {number}\n     */\n    get nanoseconds() {\n        return this._nanoseconds;\n    }\n    /**\n     * Returns a new `Date` corresponding to this timestamp. This may lose\n     * precision.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(snap => {\n     *   console.log(`Document updated at: ${snap.updateTime.toDate()}`);\n     * });\n     *\n     * @return {Date} JavaScript `Date` object representing the same point in time\n     * as this `Timestamp`, with millisecond precision.\n     */\n    toDate() {\n        return new Date(this._seconds * 1000 + Math.round(this._nanoseconds / MS_TO_NANOS));\n    }\n    /**\n     * Returns the number of milliseconds since Unix epoch 1970-01-01T00:00:00Z.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(snap => {\n     *   let startTime = snap.get('startTime');\n     *   let endTime = snap.get('endTime');\n     *   console.log(`Duration: ${endTime - startTime}`);\n     * });\n     *\n     * @return {number} The point in time corresponding to this timestamp,\n     * represented as the number of milliseconds since Unix epoch\n     * 1970-01-01T00:00:00Z.\n     */\n    toMillis() {\n        return this._seconds * 1000 + Math.floor(this._nanoseconds / MS_TO_NANOS);\n    }\n    /**\n     * Returns 'true' if this `Timestamp` is equal to the provided one.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(snap => {\n     *   if (snap.createTime.isEqual(snap.updateTime)) {\n     *     console.log('Document is in its initial state.');\n     *   }\n     * });\n     *\n     * @param {any} other The `Timestamp` to compare against.\n     * @return {boolean} 'true' if this `Timestamp` is equal to the provided one.\n     */\n    isEqual(other) {\n        return (this === other ||\n            (other instanceof Timestamp &&\n                this._seconds === other.seconds &&\n                this._nanoseconds === other.nanoseconds));\n    }\n    /**\n     * Generates the Protobuf `Timestamp` object for this timestamp.\n     *\n     * @private\n     * @returns {Object} The `Timestamp` Protobuf object.\n     */\n    toProto() {\n        const timestamp = {};\n        if (this.seconds) {\n            timestamp.seconds = this.seconds;\n        }\n        if (this.nanoseconds) {\n            timestamp.nanos = this.nanoseconds;\n        }\n        return { timestampValue: timestamp };\n    }\n    /**\n     * Converts this object to a primitive `string`, which allows `Timestamp` objects to be compared\n     * using the `>`, `<=`, `>=` and `>` operators.\n     *\n     * @return {string} a string encoding of this object.\n     */\n    valueOf() {\n        // This method returns a string of the form <seconds>.<nanoseconds> where <seconds> is\n        // translated to have a non-negative value and both <seconds> and <nanoseconds> are left-padded\n        // with zeroes to be a consistent length. Strings with this format then have a lexiographical\n        // ordering that matches the expected ordering. The <seconds> translation is done to avoid\n        // having a leading negative sign (i.e. a leading '-' character) in its string representation,\n        // which would affect its lexiographical ordering.\n        const adjustedSeconds = this.seconds - MIN_SECONDS;\n        // Note: Up to 12 decimal digits are required to represent all valid 'seconds' values.\n        const formattedSeconds = String(adjustedSeconds).padStart(12, '0');\n        const formattedNanoseconds = String(this.nanoseconds).padStart(9, '0');\n        return formattedSeconds + '.' + formattedNanoseconds;\n    }\n}\nexports.Timestamp = Timestamp;\n//# sourceMappingURL=timestamp.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/firestore/build/src/timestamp.js?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/firestore/build/src/transaction.js":
/*!***************************************************************************!*\
  !*** ./src/node_modules/@google-cloud/firestore/build/src/transaction.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst google_gax_1 = __webpack_require__(/*! google-gax */ \"google-gax\");\nconst backoff_1 = __webpack_require__(/*! ./backoff */ \"./src/node_modules/@google-cloud/firestore/build/src/backoff.js\");\nconst logger_1 = __webpack_require__(/*! ./logger */ \"./src/node_modules/@google-cloud/firestore/build/src/logger.js\");\nconst path_1 = __webpack_require__(/*! ./path */ \"./src/node_modules/@google-cloud/firestore/build/src/path.js\");\nconst reference_1 = __webpack_require__(/*! ./reference */ \"./src/node_modules/@google-cloud/firestore/build/src/reference.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"./src/node_modules/@google-cloud/firestore/build/src/util.js\");\nconst validate_1 = __webpack_require__(/*! ./validate */ \"./src/node_modules/@google-cloud/firestore/build/src/validate.js\");\n/*!\n * Error message for transactional reads that were executed after performing\n * writes.\n */\nconst READ_AFTER_WRITE_ERROR_MSG = 'Firestore transactions require all reads to be executed before all writes.';\n/**\n * A reference to a transaction.\n *\n * The Transaction object passed to a transaction's updateFunction provides\n * the methods to read and write data within the transaction context. See\n * [runTransaction()]{@link Firestore#runTransaction}.\n *\n * @class\n */\nclass Transaction {\n    /**\n     * @hideconstructor\n     *\n     * @param firestore The Firestore Database client.\n     * @param requestTag A unique client-assigned identifier for the scope of\n     * this transaction.\n     */\n    constructor(firestore, requestTag) {\n        this._firestore = firestore;\n        this._writeBatch = firestore.batch();\n        this._requestTag = requestTag;\n        this._backoff = new backoff_1.ExponentialBackoff();\n    }\n    /**\n     * Retrieve a document or a query result from the database. Holds a\n     * pessimistic lock on all returned documents.\n     *\n     * @param {DocumentReference|Query} refOrQuery The document or query to\n     * return.\n     * @returns {Promise} A Promise that resolves with a DocumentSnapshot or\n     * QuerySnapshot for the returned documents.\n     *\n     * @example\n     * firestore.runTransaction(transaction => {\n     *   let documentRef = firestore.doc('col/doc');\n     *   return transaction.get(documentRef).then(doc => {\n     *     if (doc.exists) {\n     *       transaction.update(documentRef, { count: doc.get('count') + 1 });\n     *     } else {\n     *       transaction.create(documentRef, { count: 1 });\n     *     }\n     *   });\n     * });\n     */\n    get(refOrQuery) {\n        if (!this._writeBatch.isEmpty) {\n            throw new Error(READ_AFTER_WRITE_ERROR_MSG);\n        }\n        if (refOrQuery instanceof reference_1.DocumentReference) {\n            return this._firestore\n                .getAll_([refOrQuery], \n            /* fieldMask= */ null, this._requestTag, this._transactionId)\n                .then(res => {\n                return Promise.resolve(res[0]);\n            });\n        }\n        if (refOrQuery instanceof reference_1.Query) {\n            return refOrQuery._get(this._transactionId);\n        }\n        throw new Error('Value for argument \"refOrQuery\" must be a DocumentReference or a Query.');\n    }\n    /**\n     * Retrieves multiple documents from Firestore. Holds a pessimistic lock on\n     * all returned documents.\n     *\n     * The first argument is required and must be of type `DocumentReference`\n     * followed by any additional `DocumentReference` documents. If used, the\n     * optional `ReadOptions` must be the last argument.\n     *\n     * @param {...DocumentReference|ReadOptions} documentRefsOrReadOptions The\n     * `DocumentReferences` to receive, followed by an optional field mask.\n     * @returns {Promise<Array.<DocumentSnapshot>>} A Promise that\n     * contains an array with the resulting document snapshots.\n     *\n     * @example\n     * let firstDoc = firestore.doc('col/doc1');\n     * let secondDoc = firestore.doc('col/doc2');\n     * let resultDoc = firestore.doc('col/doc3');\n     *\n     * firestore.runTransaction(transaction => {\n     *   return transaction.getAll(firstDoc, secondDoc).then(docs => {\n     *     transaction.set(resultDoc, {\n     *       sum: docs[0].get('count') + docs[1].get('count')\n     *     });\n     *   });\n     * });\n     */\n    getAll(...documentRefsOrReadOptions) {\n        if (!this._writeBatch.isEmpty) {\n            throw new Error(READ_AFTER_WRITE_ERROR_MSG);\n        }\n        validate_1.validateMinNumberOfArguments('Transaction.getAll', arguments, 1);\n        const { documents, fieldMask } = parseGetAllArguments(documentRefsOrReadOptions);\n        return this._firestore.getAll_(documents, fieldMask, this._requestTag, this._transactionId);\n    }\n    /**\n     * Create the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. The operation will\n     * fail the transaction if a document exists at the specified location.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * created.\n     * @param {DocumentData} data The object data to serialize as the document.\n     * @returns {Transaction} This Transaction instance. Used for\n     * chaining method calls.\n     *\n     * @example\n     * firestore.runTransaction(transaction => {\n     *   let documentRef = firestore.doc('col/doc');\n     *   return transaction.get(documentRef).then(doc => {\n     *     if (!doc.exists) {\n     *       transaction.create(documentRef, { foo: 'bar' });\n     *     }\n     *   });\n     * });\n     */\n    create(documentRef, data) {\n        this._writeBatch.create(documentRef, data);\n        return this;\n    }\n    /**\n     * Writes to the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. If the document\n     * does not exist yet, it will be created. If you pass\n     * [SetOptions]{@link SetOptions}, the provided data can be merged into the\n     * existing document.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * set.\n     * @param {T} data The object to serialize as the document.\n     * @param {SetOptions=} options An object to configure the set behavior.\n     * @param {boolean=} options.merge - If true, set() merges the values\n     * specified in its data argument. Fields omitted from this set() call\n     * remain untouched.\n     * @param {Array.<string|FieldPath>=} options.mergeFields - If provided,\n     * set() only replaces the specified field paths. Any field path that is not\n     * specified is ignored and remains untouched.\n     * @returns {Transaction} This Transaction instance. Used for\n     * chaining method calls.\n     *\n     * @example\n     * firestore.runTransaction(transaction => {\n     *   let documentRef = firestore.doc('col/doc');\n     *   transaction.set(documentRef, { foo: 'bar' });\n     *   return Promise.resolve();\n     * });\n     */\n    set(documentRef, data, options) {\n        this._writeBatch.set(documentRef, data, options);\n        return this;\n    }\n    /**\n     * Updates fields in the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. The update will\n     * fail if applied to a document that does not exist.\n     *\n     * The update() method accepts either an object with field paths encoded as\n     * keys and field values encoded as values, or a variable number of arguments\n     * that alternate between field paths and field values. Nested fields can be\n     * updated by providing dot-separated field path strings or by providing\n     * FieldPath objects.\n     *\n     * A Precondition restricting this update can be specified as the last\n     * argument.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * updated.\n     * @param {UpdateData|string|FieldPath} dataOrField An object\n     * containing the fields and values with which to update the document\n     * or the path of the first field to update.\n     * @param {\n     * ...(Precondition|*|string|FieldPath)} preconditionOrValues -\n     * An alternating list of field paths and values to update or a Precondition\n     * to to enforce on this update.\n     * @returns {Transaction} This Transaction instance. Used for\n     * chaining method calls.\n     *\n     * @example\n     * firestore.runTransaction(transaction => {\n     *   let documentRef = firestore.doc('col/doc');\n     *   return transaction.get(documentRef).then(doc => {\n     *     if (doc.exists) {\n     *       transaction.update(documentRef, { count: doc.get('count') + 1 });\n     *     } else {\n     *       transaction.create(documentRef, { count: 1 });\n     *     }\n     *   });\n     * });\n     */\n    update(documentRef, dataOrField, ...preconditionOrValues) {\n        validate_1.validateMinNumberOfArguments('Transaction.update', arguments, 2);\n        this._writeBatch.update(documentRef, dataOrField, ...preconditionOrValues);\n        return this;\n    }\n    /**\n     * Deletes the document referred to by the provided [DocumentReference]\n     * {@link DocumentReference}.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * deleted.\n     * @param {Precondition=} precondition A precondition to enforce for this\n     * delete.\n     * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\n     * document was last updated at lastUpdateTime. Fails the transaction if the\n     * document doesn't exist or was last updated at a different time.\n     * @returns {Transaction} This Transaction instance. Used for\n     * chaining method calls.\n     *\n     * @example\n     * firestore.runTransaction(transaction => {\n     *   let documentRef = firestore.doc('col/doc');\n     *   transaction.delete(documentRef);\n     *   return Promise.resolve();\n     * });\n     */\n    delete(documentRef, precondition) {\n        this._writeBatch.delete(documentRef, precondition);\n        return this;\n    }\n    /**\n     * Starts a transaction and obtains the transaction id from the server.\n     *\n     * @private\n     */\n    begin() {\n        const request = {\n            database: this._firestore.formattedName,\n        };\n        if (this._transactionId) {\n            request.options = {\n                readWrite: {\n                    retryTransaction: this._transactionId,\n                },\n            };\n        }\n        return this._firestore\n            .request('beginTransaction', request, this._requestTag)\n            .then(resp => {\n            this._transactionId = resp.transaction;\n        });\n    }\n    /**\n     * Commits all queued-up changes in this transaction and releases all locks.\n     *\n     * @private\n     */\n    commit() {\n        return this._writeBatch\n            .commit_({\n            transactionId: this._transactionId,\n            requestTag: this._requestTag,\n        })\n            .then(() => { });\n    }\n    /**\n     * Releases all locks and rolls back this transaction.\n     *\n     * @private\n     */\n    rollback() {\n        const request = {\n            database: this._firestore.formattedName,\n            transaction: this._transactionId,\n        };\n        return this._firestore.request('rollback', request, this._requestTag);\n    }\n    /**\n     * Executes `updateFunction()` and commits the transaction with retry.\n     *\n     * @private\n     * @param updateFunction The user function to execute within the transaction\n     * context.\n     * @param requestTag A unique client-assigned identifier for the scope of\n     * this transaction.\n     * @param maxAttempts The maximum number of attempts for this transaction.\n     */\n    async runTransaction(updateFunction, maxAttempts) {\n        let result;\n        let lastError = undefined;\n        for (let attempt = 0; attempt < maxAttempts; ++attempt) {\n            if (lastError) {\n                logger_1.logger('Firestore.runTransaction', this._requestTag, `Retrying transaction after error:`, lastError);\n            }\n            this._writeBatch._reset();\n            await this.maybeBackoff(lastError);\n            await this.begin();\n            try {\n                const promise = updateFunction(this);\n                if (!(promise instanceof Promise)) {\n                    throw new Error('You must return a Promise in your transaction()-callback.');\n                }\n                result = await promise;\n                await this.commit();\n                return result;\n            }\n            catch (err) {\n                logger_1.logger('Firestore.runTransaction', this._requestTag, 'Rolling back transaction after callback error:', err);\n                await this.rollback();\n                if (isRetryableTransactionError(err)) {\n                    lastError = err;\n                }\n                else {\n                    return Promise.reject(err); // Callback failed w/ non-retryable error\n                }\n            }\n        }\n        logger_1.logger('Firestore.runTransaction', this._requestTag, 'Transaction not eligible for retry, returning error: %s', lastError);\n        return Promise.reject(lastError);\n    }\n    /**\n     * Delays further operations based on the provided error.\n     *\n     * @private\n     * @return A Promise that resolves after the delay expired.\n     */\n    async maybeBackoff(error) {\n        if (error && error.code === google_gax_1.Status.RESOURCE_EXHAUSTED) {\n            this._backoff.resetToMax();\n        }\n        await this._backoff.backoffAndWait();\n    }\n}\nexports.Transaction = Transaction;\n/**\n * Parses the arguments for the `getAll()` call supported by both the Firestore\n * and Transaction class.\n *\n * @private\n * @param documentRefsOrReadOptions An array of document references followed by\n * an optional ReadOptions object.\n */\nfunction parseGetAllArguments(documentRefsOrReadOptions) {\n    let documents;\n    let readOptions = undefined;\n    if (Array.isArray(documentRefsOrReadOptions[0])) {\n        throw new Error('getAll() no longer accepts an array as its first argument. ' +\n            'Please unpack your array and call getAll() with individual arguments.');\n    }\n    if (documentRefsOrReadOptions.length > 0 &&\n        util_1.isPlainObject(documentRefsOrReadOptions[documentRefsOrReadOptions.length - 1])) {\n        readOptions = documentRefsOrReadOptions.pop();\n        documents = documentRefsOrReadOptions;\n    }\n    else {\n        documents = documentRefsOrReadOptions;\n    }\n    for (let i = 0; i < documents.length; ++i) {\n        reference_1.validateDocumentReference(i, documents[i]);\n    }\n    validateReadOptions('options', readOptions, { optional: true });\n    const fieldMask = readOptions && readOptions.fieldMask\n        ? readOptions.fieldMask.map(fieldPath => path_1.FieldPath.fromArgument(fieldPath))\n        : null;\n    return { fieldMask, documents };\n}\nexports.parseGetAllArguments = parseGetAllArguments;\n/**\n * Validates the use of 'options' as ReadOptions and enforces that 'fieldMask'\n * is an array of strings or field paths.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n * @param options Options that specify whether the ReadOptions can be omitted.\n */\nfunction validateReadOptions(arg, value, options) {\n    if (!validate_1.validateOptional(value, options)) {\n        if (!util_1.isObject(value)) {\n            throw new Error(`${validate_1.invalidArgumentMessage(arg, 'read option')} Input is not an object.'`);\n        }\n        const options = value;\n        if (options.fieldMask !== undefined) {\n            if (!Array.isArray(options.fieldMask)) {\n                throw new Error(`${validate_1.invalidArgumentMessage(arg, 'read option')} \"fieldMask\" is not an array.`);\n            }\n            for (let i = 0; i < options.fieldMask.length; ++i) {\n                try {\n                    path_1.validateFieldPath(i, options.fieldMask[i]);\n                }\n                catch (err) {\n                    throw new Error(`${validate_1.invalidArgumentMessage(arg, 'read option')} \"fieldMask\" is not valid: ${err.message}`);\n                }\n            }\n        }\n    }\n}\nfunction isRetryableTransactionError(error) {\n    if (error.code !== undefined) {\n        // This list is based on https://github.com/firebase/firebase-js-sdk/blob/master/packages/firestore/src/core/transaction_runner.ts#L112\n        switch (error.code) {\n            case google_gax_1.Status.ABORTED:\n            case google_gax_1.Status.CANCELLED:\n            case google_gax_1.Status.UNKNOWN:\n            case google_gax_1.Status.DEADLINE_EXCEEDED:\n            case google_gax_1.Status.INTERNAL:\n            case google_gax_1.Status.UNAVAILABLE:\n            case google_gax_1.Status.UNAUTHENTICATED:\n            case google_gax_1.Status.RESOURCE_EXHAUSTED:\n                return true;\n            default:\n                return false;\n        }\n    }\n    return false;\n}\n//# sourceMappingURL=transaction.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/firestore/build/src/transaction.js?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/firestore/build/src/types.js":
/*!*********************************************************************!*\
  !*** ./src/node_modules/@google-cloud/firestore/build/src/types.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/*!\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * A default converter to use when none is provided.\n * @private\n */\nexports.defaultConverter = {\n    toFirestore(modelObject) {\n        return modelObject;\n    },\n    fromFirestore(data) {\n        return data;\n    },\n};\n//# sourceMappingURL=types.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/firestore/build/src/types.js?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/firestore/build/src/util.js":
/*!********************************************************************!*\
  !*** ./src/node_modules/@google-cloud/firestore/build/src/util.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst crypto_1 = __webpack_require__(/*! crypto */ \"crypto\");\nconst google_gax_1 = __webpack_require__(/*! google-gax */ \"google-gax\");\nconst gapicConfig = __webpack_require__(/*! ./v1/firestore_client_config.json */ \"./src/node_modules/@google-cloud/firestore/build/src/v1/firestore_client_config.json\");\nconst serviceConfig = google_gax_1.constructSettings('google.firestore.v1.Firestore', gapicConfig, {}, google_gax_1.Status);\n/**\n * A Promise implementation that supports deferred resolution.\n * @private\n */\nclass Deferred {\n    constructor() {\n        this.resolve = () => { };\n        this.reject = () => { };\n        this.promise = new Promise((resolve, reject) => {\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n}\nexports.Deferred = Deferred;\n/**\n * Generate a unique client-side identifier.\n *\n * Used for the creation of new documents.\n *\n * @private\n * @returns {string} A unique 20-character wide identifier.\n */\nfunction autoId() {\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    let autoId = '';\n    while (autoId.length < 20) {\n        const bytes = crypto_1.randomBytes(40);\n        bytes.forEach(b => {\n            // Length of `chars` is 62. We only take bytes between 0 and 62*4-1\n            // (both inclusive). The value is then evenly mapped to indices of `char`\n            // via a modulo operation.\n            const maxValue = 62 * 4 - 1;\n            if (autoId.length < 20 && b <= maxValue) {\n                autoId += chars.charAt(b % 62);\n            }\n        });\n    }\n    return autoId;\n}\nexports.autoId = autoId;\n/**\n * Generate a short and semi-random client-side identifier.\n *\n * Used for the creation of request tags.\n *\n * @private\n * @returns {string} A random 5-character wide identifier.\n */\nfunction requestTag() {\n    return autoId().substr(0, 5);\n}\nexports.requestTag = requestTag;\n/**\n * Determines whether `value` is a JavaScript object.\n *\n * @private\n */\nfunction isObject(value) {\n    return Object.prototype.toString.call(value) === '[object Object]';\n}\nexports.isObject = isObject;\n/**\n * Verifies that 'obj' is a plain JavaScript object that can be encoded as a\n * 'Map' in Firestore.\n *\n * @private\n * @param input The argument to verify.\n * @returns 'true' if the input can be a treated as a plain object.\n */\nfunction isPlainObject(input) {\n    return (isObject(input) &&\n        (Object.getPrototypeOf(input) === Object.prototype ||\n            Object.getPrototypeOf(input) === null ||\n            input.constructor.name === 'Object'));\n}\nexports.isPlainObject = isPlainObject;\n/**\n * Returns whether `value` has no custom properties.\n *\n * @private\n */\nfunction isEmpty(value) {\n    return Object.keys(value).length === 0;\n}\nexports.isEmpty = isEmpty;\n/**\n * Determines whether `value` is a JavaScript function.\n *\n * @private\n */\nfunction isFunction(value) {\n    return typeof value === 'function';\n}\nexports.isFunction = isFunction;\n/**\n * Determines whether the provided error is considered permanent for the given\n * RPC.\n *\n * @private\n */\nfunction isPermanentRpcError(err, methodName) {\n    if (err.code !== undefined) {\n        const retryCodes = getRetryCodes(methodName);\n        return retryCodes.indexOf(err.code) === -1;\n    }\n    else {\n        return false;\n    }\n}\nexports.isPermanentRpcError = isPermanentRpcError;\n/**\n * Returns the list of retryable error codes specified in the service\n * configuration.\n */\nfunction getRetryCodes(methodName) {\n    var _a, _b, _c;\n    return (_c = (_b = (_a = serviceConfig[methodName]) === null || _a === void 0 ? void 0 : _a.retry) === null || _b === void 0 ? void 0 : _b.retryCodes) !== null && _c !== void 0 ? _c : [];\n}\nexports.getRetryCodes = getRetryCodes;\n/** Returns the backoff setting from the service configuration. */\nfunction getRetryParams(methodName) {\n    var _a, _b, _c;\n    return ((_c = (_b = (_a = serviceConfig[methodName]) === null || _a === void 0 ? void 0 : _a.retry) === null || _b === void 0 ? void 0 : _b.backoffSettings) !== null && _c !== void 0 ? _c : google_gax_1.createDefaultBackoffSettings());\n}\nexports.getRetryParams = getRetryParams;\n/**\n * Wraps the provided error in a new error that includes the provided stack.\n *\n * Used to preserve stack traces across async calls.\n * @private\n */\nfunction wrapError(err, stack) {\n    err.stack += '\\nCaused by: ' + stack;\n    return err;\n}\nexports.wrapError = wrapError;\n//# sourceMappingURL=util.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/firestore/build/src/util.js?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/firestore/build/src/v1/firestore_admin_client.js":
/*!*****************************************************************************************!*\
  !*** ./src/node_modules/@google-cloud/firestore/build/src/v1/firestore_admin_client.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// Copyright 2020 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ** This file is automatically generated by gapic-generator-typescript. **\n// ** https://github.com/googleapis/gapic-generator-typescript **\n// ** All changes to this file may be overwritten. **\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst gax = __webpack_require__(/*! google-gax */ \"google-gax\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst gapicConfig = __webpack_require__(/*! ./firestore_admin_client_config.json */ \"./src/node_modules/@google-cloud/firestore/build/src/v1/firestore_admin_client_config.json\");\nconst version = __webpack_require__(/*! ../../../package.json */ \"./src/node_modules/@google-cloud/firestore/package.json\").version;\n/**\n *  Operations are created by service `FirestoreAdmin`, but are accessed via\n *  service `google.longrunning.Operations`.\n * @class\n * @memberof v1\n */\nclass FirestoreAdminClient {\n    /**\n     * Construct an instance of FirestoreAdminClient.\n     *\n     * @param {object} [options] - The configuration object. See the subsequent\n     *   parameters for more details.\n     * @param {object} [options.credentials] - Credentials object.\n     * @param {string} [options.credentials.client_email]\n     * @param {string} [options.credentials.private_key]\n     * @param {string} [options.email] - Account email address. Required when\n     *     using a .pem or .p12 keyFilename.\n     * @param {string} [options.keyFilename] - Full path to the a .json, .pem, or\n     *     .p12 key downloaded from the Google Developers Console. If you provide\n     *     a path to a JSON file, the projectId option below is not necessary.\n     *     NOTE: .pem and .p12 require you to specify options.email as well.\n     * @param {number} [options.port] - The port on which to connect to\n     *     the remote host.\n     * @param {string} [options.projectId] - The project ID from the Google\n     *     Developer's Console, e.g. 'grape-spaceship-123'. We will also check\n     *     the environment variable GCLOUD_PROJECT for your project ID. If your\n     *     app is running in an environment which supports\n     *     {@link https://developers.google.com/identity/protocols/application-default-credentials Application Default Credentials},\n     *     your project ID will be detected automatically.\n     * @param {string} [options.apiEndpoint] - The domain name of the\n     *     API remote host.\n     */\n    constructor(opts) {\n        this._descriptors = {\n            page: {},\n            stream: {},\n            longrunning: {},\n            batching: {},\n        };\n        this._terminated = false;\n        // Ensure that options include the service address and port.\n        const staticMembers = this.constructor;\n        const servicePath = opts && opts.servicePath\n            ? opts.servicePath\n            : opts && opts.apiEndpoint\n                ? opts.apiEndpoint\n                : staticMembers.servicePath;\n        const port = opts && opts.port ? opts.port : staticMembers.port;\n        if (!opts) {\n            opts = { servicePath, port };\n        }\n        opts.servicePath = opts.servicePath || servicePath;\n        opts.port = opts.port || port;\n        opts.clientConfig = opts.clientConfig || {};\n        const isBrowser = typeof window !== 'undefined';\n        if (isBrowser) {\n            opts.fallback = true;\n        }\n        // If we are in browser, we are already using fallback because of the\n        // \"browser\" field in package.json.\n        // But if we were explicitly requested to use fallback, let's do it now.\n        this._gaxModule = !isBrowser && opts.fallback ? gax.fallback : gax;\n        // Create a `gaxGrpc` object, with any grpc-specific options\n        // sent to the client.\n        opts.scopes = this.constructor.scopes;\n        this._gaxGrpc = new this._gaxModule.GrpcClient(opts);\n        // Save options to use in initialize() method.\n        this._opts = opts;\n        // Save the auth object to the client, for use by other methods.\n        this.auth = this._gaxGrpc.auth;\n        // Determine the client header string.\n        const clientHeader = [`gax/${this._gaxModule.version}`, `gapic/${version}`];\n        if (typeof process !== 'undefined' && 'versions' in process) {\n            clientHeader.push(`gl-node/${process.versions.node}`);\n        }\n        else {\n            clientHeader.push(`gl-web/${this._gaxModule.version}`);\n        }\n        if (!opts.fallback) {\n            clientHeader.push(`grpc/${this._gaxGrpc.grpcVersion}`);\n        }\n        if (opts.libName && opts.libVersion) {\n            clientHeader.push(`${opts.libName}/${opts.libVersion}`);\n        }\n        // Load the applicable protos.\n        // For Node.js, pass the path to JSON proto file.\n        // For browsers, pass the JSON content.\n        const nodejsProtoPath = path.join(__dirname, '..', '..', 'protos', 'protos.json');\n        this._protos = this._gaxGrpc.loadProto(opts.fallback ? __webpack_require__(/*! ../../protos/protos.json */ \"./src/node_modules/@google-cloud/firestore/build/protos/protos.json\") : nodejsProtoPath);\n        // This API contains \"path templates\"; forward-slash-separated\n        // identifiers to uniquely identify resources within the API.\n        // Create useful helper objects for these.\n        this._pathTemplates = {\n            collectionGroupPathTemplate: new this._gaxModule.PathTemplate('projects/{project}/databases/{database}/collectionGroups/{collection}'),\n            databasePathTemplate: new this._gaxModule.PathTemplate('projects/{project}/databases/{database}'),\n            fieldPathTemplate: new this._gaxModule.PathTemplate('projects/{project}/databases/{database}/collectionGroups/{collection}/fields/{field}'),\n            indexPathTemplate: new this._gaxModule.PathTemplate('projects/{project}/databases/{database}/collectionGroups/{collection}/indexes/{index}'),\n        };\n        // Some of the methods on this service return \"paged\" results,\n        // (e.g. 50 results at a time, with tokens to get subsequent\n        // pages). Denote the keys used for pagination and results.\n        this._descriptors.page = {\n            listIndexes: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'indexes'),\n            listFields: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'fields'),\n        };\n        // This API contains \"long-running operations\", which return a\n        // an Operation object that allows for tracking of the operation,\n        // rather than holding a request open.\n        const protoFilesRoot = opts.fallback\n            ? this._gaxModule.protobuf.Root.fromJSON(__webpack_require__(/*! ../../protos/protos.json */ \"./src/node_modules/@google-cloud/firestore/build/protos/protos.json\"))\n            : this._gaxModule.protobuf.loadSync(nodejsProtoPath);\n        this.operationsClient = this._gaxModule\n            .lro({\n            auth: this.auth,\n            grpc: 'grpc' in this._gaxGrpc ? this._gaxGrpc.grpc : undefined,\n        })\n            .operationsClient(opts);\n        const createIndexResponse = protoFilesRoot.lookup('.google.firestore.admin.v1.Index');\n        const createIndexMetadata = protoFilesRoot.lookup('.google.firestore.admin.v1.IndexOperationMetadata');\n        const updateFieldResponse = protoFilesRoot.lookup('.google.firestore.admin.v1.Field');\n        const updateFieldMetadata = protoFilesRoot.lookup('.google.firestore.admin.v1.FieldOperationMetadata');\n        const exportDocumentsResponse = protoFilesRoot.lookup('.google.firestore.admin.v1.ExportDocumentsResponse');\n        const exportDocumentsMetadata = protoFilesRoot.lookup('.google.firestore.admin.v1.ExportDocumentsMetadata');\n        const importDocumentsResponse = protoFilesRoot.lookup('.google.protobuf.Empty');\n        const importDocumentsMetadata = protoFilesRoot.lookup('.google.firestore.admin.v1.ImportDocumentsMetadata');\n        this._descriptors.longrunning = {\n            createIndex: new this._gaxModule.LongrunningDescriptor(this.operationsClient, createIndexResponse.decode.bind(createIndexResponse), createIndexMetadata.decode.bind(createIndexMetadata)),\n            updateField: new this._gaxModule.LongrunningDescriptor(this.operationsClient, updateFieldResponse.decode.bind(updateFieldResponse), updateFieldMetadata.decode.bind(updateFieldMetadata)),\n            exportDocuments: new this._gaxModule.LongrunningDescriptor(this.operationsClient, exportDocumentsResponse.decode.bind(exportDocumentsResponse), exportDocumentsMetadata.decode.bind(exportDocumentsMetadata)),\n            importDocuments: new this._gaxModule.LongrunningDescriptor(this.operationsClient, importDocumentsResponse.decode.bind(importDocumentsResponse), importDocumentsMetadata.decode.bind(importDocumentsMetadata)),\n        };\n        // Put together the default options sent with requests.\n        this._defaults = this._gaxGrpc.constructSettings('google.firestore.admin.v1.FirestoreAdmin', gapicConfig, opts.clientConfig || {}, { 'x-goog-api-client': clientHeader.join(' ') });\n        // Set up a dictionary of \"inner API calls\"; the core implementation\n        // of calling the API is handled in `google-gax`, with this code\n        // merely providing the destination and request information.\n        this._innerApiCalls = {};\n    }\n    /**\n     * Initialize the client.\n     * Performs asynchronous operations (such as authentication) and prepares the client.\n     * This function will be called automatically when any class method is called for the\n     * first time, but if you need to initialize it before calling an actual method,\n     * feel free to call initialize() directly.\n     *\n     * You can await on this method if you want to make sure the client is initialized.\n     *\n     * @returns {Promise} A promise that resolves to an authenticated service stub.\n     */\n    initialize() {\n        // If the client stub promise is already initialized, return immediately.\n        if (this.firestoreAdminStub) {\n            return this.firestoreAdminStub;\n        }\n        // Put together the \"service stub\" for\n        // google.firestore.admin.v1.FirestoreAdmin.\n        this.firestoreAdminStub = this._gaxGrpc.createStub(this._opts.fallback\n            ? this._protos.lookupService('google.firestore.admin.v1.FirestoreAdmin')\n            : // tslint:disable-next-line no-any\n                this._protos.google.firestore.admin.v1.FirestoreAdmin, this._opts);\n        // Iterate over each of the methods that the service provides\n        // and create an API call method for each.\n        const firestoreAdminStubMethods = [\n            'createIndex',\n            'listIndexes',\n            'getIndex',\n            'deleteIndex',\n            'getField',\n            'updateField',\n            'listFields',\n            'exportDocuments',\n            'importDocuments',\n        ];\n        for (const methodName of firestoreAdminStubMethods) {\n            const innerCallPromise = this.firestoreAdminStub.then(stub => (...args) => {\n                if (this._terminated) {\n                    return Promise.reject(new Error('The client has already been closed.'));\n                }\n                const func = stub[methodName];\n                return func.apply(stub, args);\n            }, (err) => () => {\n                throw err;\n            });\n            const apiCall = this._gaxModule.createApiCall(innerCallPromise, this._defaults[methodName], this._descriptors.page[methodName] ||\n                this._descriptors.stream[methodName] ||\n                this._descriptors.longrunning[methodName]);\n            this._innerApiCalls[methodName] = (argument, callOptions, callback) => {\n                return apiCall(argument, callOptions, callback);\n            };\n        }\n        return this.firestoreAdminStub;\n    }\n    /**\n     * The DNS address for this API service.\n     */\n    static get servicePath() {\n        return 'firestore.googleapis.com';\n    }\n    /**\n     * The DNS address for this API service - same as servicePath(),\n     * exists for compatibility reasons.\n     */\n    static get apiEndpoint() {\n        return 'firestore.googleapis.com';\n    }\n    /**\n     * The port for this API service.\n     */\n    static get port() {\n        return 443;\n    }\n    /**\n     * The scopes needed to make gRPC calls for every method defined\n     * in this service.\n     */\n    static get scopes() {\n        return [\n            'https://www.googleapis.com/auth/cloud-platform',\n            'https://www.googleapis.com/auth/datastore',\n        ];\n    }\n    /**\n     * Return the project ID used by this class.\n     * @param {function(Error, string)} callback - the callback to\n     *   be called with the current project Id.\n     */\n    getProjectId(callback) {\n        if (callback) {\n            this.auth.getProjectId(callback);\n            return;\n        }\n        return this.auth.getProjectId();\n    }\n    /**\n     * Gets a composite index.\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.name\n     *   Required. A name of the form\n     *   `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}/indexes/{index_id}`\n     * @param {object} [options]\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\n     * @returns {Promise} - The promise which resolves to an array.\n     *   The first element of the array is an object representing [Index]{@link google.firestore.admin.v1.Index}.\n     *   The promise has a method named \"cancel\" which cancels the ongoing API call.\n     */\n    getIndex(request, optionsOrCallback, callback) {\n        request = request || {};\n        let options;\n        if (typeof optionsOrCallback === 'function' && callback === undefined) {\n            callback = optionsOrCallback;\n            options = {};\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        options = options || {};\n        options.otherArgs = options.otherArgs || {};\n        options.otherArgs.headers = options.otherArgs.headers || {};\n        options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n            name: request.name || '',\n        });\n        this.initialize();\n        return this._innerApiCalls.getIndex(request, options, callback);\n    }\n    /**\n     * Deletes a composite index.\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.name\n     *   Required. A name of the form\n     *   `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}/indexes/{index_id}`\n     * @param {object} [options]\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\n     * @returns {Promise} - The promise which resolves to an array.\n     *   The first element of the array is an object representing [Empty]{@link google.protobuf.Empty}.\n     *   The promise has a method named \"cancel\" which cancels the ongoing API call.\n     */\n    deleteIndex(request, optionsOrCallback, callback) {\n        request = request || {};\n        let options;\n        if (typeof optionsOrCallback === 'function' && callback === undefined) {\n            callback = optionsOrCallback;\n            options = {};\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        options = options || {};\n        options.otherArgs = options.otherArgs || {};\n        options.otherArgs.headers = options.otherArgs.headers || {};\n        options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n            name: request.name || '',\n        });\n        this.initialize();\n        return this._innerApiCalls.deleteIndex(request, options, callback);\n    }\n    /**\n     * Gets the metadata and configuration for a Field.\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.name\n     *   Required. A name of the form\n     *   `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}/fields/{field_id}`\n     * @param {object} [options]\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\n     * @returns {Promise} - The promise which resolves to an array.\n     *   The first element of the array is an object representing [Field]{@link google.firestore.admin.v1.Field}.\n     *   The promise has a method named \"cancel\" which cancels the ongoing API call.\n     */\n    getField(request, optionsOrCallback, callback) {\n        request = request || {};\n        let options;\n        if (typeof optionsOrCallback === 'function' && callback === undefined) {\n            callback = optionsOrCallback;\n            options = {};\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        options = options || {};\n        options.otherArgs = options.otherArgs || {};\n        options.otherArgs.headers = options.otherArgs.headers || {};\n        options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n            name: request.name || '',\n        });\n        this.initialize();\n        return this._innerApiCalls.getField(request, options, callback);\n    }\n    /**\n     * Creates a composite index. This returns a {@link google.longrunning.Operation|google.longrunning.Operation}\n     * which may be used to track the status of the creation. The metadata for\n     * the operation will be the type {@link google.firestore.admin.v1.IndexOperationMetadata|IndexOperationMetadata}.\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.parent\n     *   Required. A parent name of the form\n     *   `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}`\n     * @param {google.firestore.admin.v1.Index} request.index\n     *   Required. The composite index to create.\n     * @param {object} [options]\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\n     * @returns {Promise} - The promise which resolves to an array.\n     *   The first element of the array is an object representing [Operation]{@link google.longrunning.Operation}.\n     *   The promise has a method named \"cancel\" which cancels the ongoing API call.\n     */\n    createIndex(request, optionsOrCallback, callback) {\n        request = request || {};\n        let options;\n        if (typeof optionsOrCallback === 'function' && callback === undefined) {\n            callback = optionsOrCallback;\n            options = {};\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        options = options || {};\n        options.otherArgs = options.otherArgs || {};\n        options.otherArgs.headers = options.otherArgs.headers || {};\n        options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n            parent: request.parent || '',\n        });\n        this.initialize();\n        return this._innerApiCalls.createIndex(request, options, callback);\n    }\n    /**\n     * Updates a field configuration. Currently, field updates apply only to\n     * single field index configuration. However, calls to\n     * {@link google.firestore.admin.v1.FirestoreAdmin.UpdateField|FirestoreAdmin.UpdateField} should provide a field mask to avoid\n     * changing any configuration that the caller isn't aware of. The field mask\n     * should be specified as: `{ paths: \"index_config\" }`.\n     *\n     * This call returns a {@link google.longrunning.Operation|google.longrunning.Operation} which may be used to\n     * track the status of the field update. The metadata for\n     * the operation will be the type {@link google.firestore.admin.v1.FieldOperationMetadata|FieldOperationMetadata}.\n     *\n     * To configure the default field settings for the database, use\n     * the special `Field` with resource name:\n     * `projects/{project_id}/databases/{database_id}/collectionGroups/__default__/fields/*`.\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {google.firestore.admin.v1.Field} request.field\n     *   Required. The field to be updated.\n     * @param {google.protobuf.FieldMask} request.updateMask\n     *   A mask, relative to the field. If specified, only configuration specified\n     *   by this field_mask will be updated in the field.\n     * @param {object} [options]\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\n     * @returns {Promise} - The promise which resolves to an array.\n     *   The first element of the array is an object representing [Operation]{@link google.longrunning.Operation}.\n     *   The promise has a method named \"cancel\" which cancels the ongoing API call.\n     */\n    updateField(request, optionsOrCallback, callback) {\n        request = request || {};\n        let options;\n        if (typeof optionsOrCallback === 'function' && callback === undefined) {\n            callback = optionsOrCallback;\n            options = {};\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        options = options || {};\n        options.otherArgs = options.otherArgs || {};\n        options.otherArgs.headers = options.otherArgs.headers || {};\n        options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n            'field.name': request.field.name || '',\n        });\n        this.initialize();\n        return this._innerApiCalls.updateField(request, options, callback);\n    }\n    /**\n     * Exports a copy of all or a subset of documents from Google Cloud Firestore\n     * to another storage system, such as Google Cloud Storage. Recent updates to\n     * documents may not be reflected in the export. The export occurs in the\n     * background and its progress can be monitored and managed via the\n     * Operation resource that is created. The output of an export may only be\n     * used once the associated operation is done. If an export operation is\n     * cancelled before completion it may leave partial data behind in Google\n     * Cloud Storage.\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.name\n     *   Required. Database to export. Should be of the form:\n     *   `projects/{project_id}/databases/{database_id}`.\n     * @param {string[]} request.collectionIds\n     *   Which collection ids to export. Unspecified means all collections.\n     * @param {string} request.outputUriPrefix\n     *   The output URI. Currently only supports Google Cloud Storage URIs of the\n     *   form: `gs://BUCKET_NAME[/NAMESPACE_PATH]`, where `BUCKET_NAME` is the name\n     *   of the Google Cloud Storage bucket and `NAMESPACE_PATH` is an optional\n     *   Google Cloud Storage namespace path. When\n     *   choosing a name, be sure to consider Google Cloud Storage naming\n     *   guidelines: https://cloud.google.com/storage/docs/naming.\n     *   If the URI is a bucket (without a namespace path), a prefix will be\n     *   generated based on the start time.\n     * @param {object} [options]\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\n     * @returns {Promise} - The promise which resolves to an array.\n     *   The first element of the array is an object representing [Operation]{@link google.longrunning.Operation}.\n     *   The promise has a method named \"cancel\" which cancels the ongoing API call.\n     */\n    exportDocuments(request, optionsOrCallback, callback) {\n        request = request || {};\n        let options;\n        if (typeof optionsOrCallback === 'function' && callback === undefined) {\n            callback = optionsOrCallback;\n            options = {};\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        options = options || {};\n        options.otherArgs = options.otherArgs || {};\n        options.otherArgs.headers = options.otherArgs.headers || {};\n        options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n            name: request.name || '',\n        });\n        this.initialize();\n        return this._innerApiCalls.exportDocuments(request, options, callback);\n    }\n    /**\n     * Imports documents into Google Cloud Firestore. Existing documents with the\n     * same name are overwritten. The import occurs in the background and its\n     * progress can be monitored and managed via the Operation resource that is\n     * created. If an ImportDocuments operation is cancelled, it is possible\n     * that a subset of the data has already been imported to Cloud Firestore.\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.name\n     *   Required. Database to import into. Should be of the form:\n     *   `projects/{project_id}/databases/{database_id}`.\n     * @param {string[]} request.collectionIds\n     *   Which collection ids to import. Unspecified means all collections included\n     *   in the import.\n     * @param {string} request.inputUriPrefix\n     *   Location of the exported files.\n     *   This must match the output_uri_prefix of an ExportDocumentsResponse from\n     *   an export that has completed successfully.\n     *   See:\n     *   {@link google.firestore.admin.v1.ExportDocumentsResponse.output_uri_prefix|google.firestore.admin.v1.ExportDocumentsResponse.output_uri_prefix}.\n     * @param {object} [options]\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\n     * @returns {Promise} - The promise which resolves to an array.\n     *   The first element of the array is an object representing [Operation]{@link google.longrunning.Operation}.\n     *   The promise has a method named \"cancel\" which cancels the ongoing API call.\n     */\n    importDocuments(request, optionsOrCallback, callback) {\n        request = request || {};\n        let options;\n        if (typeof optionsOrCallback === 'function' && callback === undefined) {\n            callback = optionsOrCallback;\n            options = {};\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        options = options || {};\n        options.otherArgs = options.otherArgs || {};\n        options.otherArgs.headers = options.otherArgs.headers || {};\n        options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n            name: request.name || '',\n        });\n        this.initialize();\n        return this._innerApiCalls.importDocuments(request, options, callback);\n    }\n    /**\n     * Lists composite indexes.\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.parent\n     *   Required. A parent name of the form\n     *   `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}`\n     * @param {string} request.filter\n     *   The filter to apply to list results.\n     * @param {number} request.pageSize\n     *   The number of results to return.\n     * @param {string} request.pageToken\n     *   A page token, returned from a previous call to\n     *   {@link google.firestore.admin.v1.FirestoreAdmin.ListIndexes|FirestoreAdmin.ListIndexes}, that may be used to get the next\n     *   page of results.\n     * @param {object} [options]\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\n     * @returns {Promise} - The promise which resolves to an array.\n     *   The first element of the array is Array of [Index]{@link google.firestore.admin.v1.Index}.\n     *   The client library support auto-pagination by default: it will call the API as many\n     *   times as needed and will merge results from all the pages into this array.\n     *\n     *   When autoPaginate: false is specified through options, the array has three elements.\n     *   The first element is Array of [Index]{@link google.firestore.admin.v1.Index} that corresponds to\n     *   the one page received from the API server.\n     *   If the second element is not null it contains the request object of type [ListIndexesRequest]{@link google.firestore.admin.v1.ListIndexesRequest}\n     *   that can be used to obtain the next page of the results.\n     *   If it is null, the next page does not exist.\n     *   The third element contains the raw response received from the API server. Its type is\n     *   [ListIndexesResponse]{@link google.firestore.admin.v1.ListIndexesResponse}.\n     *\n     *   The promise has a method named \"cancel\" which cancels the ongoing API call.\n     */\n    listIndexes(request, optionsOrCallback, callback) {\n        request = request || {};\n        let options;\n        if (typeof optionsOrCallback === 'function' && callback === undefined) {\n            callback = optionsOrCallback;\n            options = {};\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        options = options || {};\n        options.otherArgs = options.otherArgs || {};\n        options.otherArgs.headers = options.otherArgs.headers || {};\n        options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n            parent: request.parent || '',\n        });\n        this.initialize();\n        return this._innerApiCalls.listIndexes(request, options, callback);\n    }\n    /**\n     * Equivalent to {@link listIndexes}, but returns a NodeJS Stream object.\n     *\n     * This fetches the paged responses for {@link listIndexes} continuously\n     * and invokes the callback registered for 'data' event for each element in the\n     * responses.\n     *\n     * The returned object has 'end' method when no more elements are required.\n     *\n     * autoPaginate option will be ignored.\n     *\n     * @see {@link https://nodejs.org/api/stream.html}\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.parent\n     *   Required. A parent name of the form\n     *   `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}`\n     * @param {string} request.filter\n     *   The filter to apply to list results.\n     * @param {number} request.pageSize\n     *   The number of results to return.\n     * @param {string} request.pageToken\n     *   A page token, returned from a previous call to\n     *   {@link google.firestore.admin.v1.FirestoreAdmin.ListIndexes|FirestoreAdmin.ListIndexes}, that may be used to get the next\n     *   page of results.\n     * @param {object} [options]\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\n     * @returns {Stream}\n     *   An object stream which emits an object representing [Index]{@link google.firestore.admin.v1.Index} on 'data' event.\n     */\n    listIndexesStream(request, options) {\n        request = request || {};\n        options = options || {};\n        options.otherArgs = options.otherArgs || {};\n        options.otherArgs.headers = options.otherArgs.headers || {};\n        options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n            parent: request.parent || '',\n        });\n        const callSettings = new gax.CallSettings(options);\n        this.initialize();\n        return this._descriptors.page.listIndexes.createStream(this._innerApiCalls.listIndexes, request, callSettings);\n    }\n    /**\n     * Lists the field configuration and metadata for this database.\n     *\n     * Currently, {@link google.firestore.admin.v1.FirestoreAdmin.ListFields|FirestoreAdmin.ListFields} only supports listing fields\n     * that have been explicitly overridden. To issue this query, call\n     * {@link google.firestore.admin.v1.FirestoreAdmin.ListFields|FirestoreAdmin.ListFields} with the filter set to\n     * `indexConfig.usesAncestorConfig:false`.\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.parent\n     *   Required. A parent name of the form\n     *   `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}`\n     * @param {string} request.filter\n     *   The filter to apply to list results. Currently,\n     *   {@link google.firestore.admin.v1.FirestoreAdmin.ListFields|FirestoreAdmin.ListFields} only supports listing fields\n     *   that have been explicitly overridden. To issue this query, call\n     *   {@link google.firestore.admin.v1.FirestoreAdmin.ListFields|FirestoreAdmin.ListFields} with the filter set to\n     *   `indexConfig.usesAncestorConfig:false`.\n     * @param {number} request.pageSize\n     *   The number of results to return.\n     * @param {string} request.pageToken\n     *   A page token, returned from a previous call to\n     *   {@link google.firestore.admin.v1.FirestoreAdmin.ListFields|FirestoreAdmin.ListFields}, that may be used to get the next\n     *   page of results.\n     * @param {object} [options]\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\n     * @returns {Promise} - The promise which resolves to an array.\n     *   The first element of the array is Array of [Field]{@link google.firestore.admin.v1.Field}.\n     *   The client library support auto-pagination by default: it will call the API as many\n     *   times as needed and will merge results from all the pages into this array.\n     *\n     *   When autoPaginate: false is specified through options, the array has three elements.\n     *   The first element is Array of [Field]{@link google.firestore.admin.v1.Field} that corresponds to\n     *   the one page received from the API server.\n     *   If the second element is not null it contains the request object of type [ListFieldsRequest]{@link google.firestore.admin.v1.ListFieldsRequest}\n     *   that can be used to obtain the next page of the results.\n     *   If it is null, the next page does not exist.\n     *   The third element contains the raw response received from the API server. Its type is\n     *   [ListFieldsResponse]{@link google.firestore.admin.v1.ListFieldsResponse}.\n     *\n     *   The promise has a method named \"cancel\" which cancels the ongoing API call.\n     */\n    listFields(request, optionsOrCallback, callback) {\n        request = request || {};\n        let options;\n        if (typeof optionsOrCallback === 'function' && callback === undefined) {\n            callback = optionsOrCallback;\n            options = {};\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        options = options || {};\n        options.otherArgs = options.otherArgs || {};\n        options.otherArgs.headers = options.otherArgs.headers || {};\n        options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n            parent: request.parent || '',\n        });\n        this.initialize();\n        return this._innerApiCalls.listFields(request, options, callback);\n    }\n    /**\n     * Equivalent to {@link listFields}, but returns a NodeJS Stream object.\n     *\n     * This fetches the paged responses for {@link listFields} continuously\n     * and invokes the callback registered for 'data' event for each element in the\n     * responses.\n     *\n     * The returned object has 'end' method when no more elements are required.\n     *\n     * autoPaginate option will be ignored.\n     *\n     * @see {@link https://nodejs.org/api/stream.html}\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.parent\n     *   Required. A parent name of the form\n     *   `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}`\n     * @param {string} request.filter\n     *   The filter to apply to list results. Currently,\n     *   {@link google.firestore.admin.v1.FirestoreAdmin.ListFields|FirestoreAdmin.ListFields} only supports listing fields\n     *   that have been explicitly overridden. To issue this query, call\n     *   {@link google.firestore.admin.v1.FirestoreAdmin.ListFields|FirestoreAdmin.ListFields} with the filter set to\n     *   `indexConfig.usesAncestorConfig:false`.\n     * @param {number} request.pageSize\n     *   The number of results to return.\n     * @param {string} request.pageToken\n     *   A page token, returned from a previous call to\n     *   {@link google.firestore.admin.v1.FirestoreAdmin.ListFields|FirestoreAdmin.ListFields}, that may be used to get the next\n     *   page of results.\n     * @param {object} [options]\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\n     * @returns {Stream}\n     *   An object stream which emits an object representing [Field]{@link google.firestore.admin.v1.Field} on 'data' event.\n     */\n    listFieldsStream(request, options) {\n        request = request || {};\n        options = options || {};\n        options.otherArgs = options.otherArgs || {};\n        options.otherArgs.headers = options.otherArgs.headers || {};\n        options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n            parent: request.parent || '',\n        });\n        const callSettings = new gax.CallSettings(options);\n        this.initialize();\n        return this._descriptors.page.listFields.createStream(this._innerApiCalls.listFields, request, callSettings);\n    }\n    // --------------------\n    // -- Path templates --\n    // --------------------\n    /**\n     * Return a fully-qualified collectionGroup resource name string.\n     *\n     * @param {string} project\n     * @param {string} database\n     * @param {string} collection\n     * @returns {string} Resource name string.\n     */\n    collectionGroupPath(project, database, collection) {\n        return this._pathTemplates.collectionGroupPathTemplate.render({\n            project,\n            database,\n            collection,\n        });\n    }\n    /**\n     * Parse the project from CollectionGroup resource.\n     *\n     * @param {string} collectionGroupName\n     *   A fully-qualified path representing CollectionGroup resource.\n     * @returns {string} A string representing the project.\n     */\n    matchProjectFromCollectionGroupName(collectionGroupName) {\n        return this._pathTemplates.collectionGroupPathTemplate.match(collectionGroupName).project;\n    }\n    /**\n     * Parse the database from CollectionGroup resource.\n     *\n     * @param {string} collectionGroupName\n     *   A fully-qualified path representing CollectionGroup resource.\n     * @returns {string} A string representing the database.\n     */\n    matchDatabaseFromCollectionGroupName(collectionGroupName) {\n        return this._pathTemplates.collectionGroupPathTemplate.match(collectionGroupName).database;\n    }\n    /**\n     * Parse the collection from CollectionGroup resource.\n     *\n     * @param {string} collectionGroupName\n     *   A fully-qualified path representing CollectionGroup resource.\n     * @returns {string} A string representing the collection.\n     */\n    matchCollectionFromCollectionGroupName(collectionGroupName) {\n        return this._pathTemplates.collectionGroupPathTemplate.match(collectionGroupName).collection;\n    }\n    /**\n     * Return a fully-qualified database resource name string.\n     *\n     * @param {string} project\n     * @param {string} database\n     * @returns {string} Resource name string.\n     */\n    databasePath(project, database) {\n        return this._pathTemplates.databasePathTemplate.render({\n            project,\n            database,\n        });\n    }\n    /**\n     * Parse the project from Database resource.\n     *\n     * @param {string} databaseName\n     *   A fully-qualified path representing Database resource.\n     * @returns {string} A string representing the project.\n     */\n    matchProjectFromDatabaseName(databaseName) {\n        return this._pathTemplates.databasePathTemplate.match(databaseName).project;\n    }\n    /**\n     * Parse the database from Database resource.\n     *\n     * @param {string} databaseName\n     *   A fully-qualified path representing Database resource.\n     * @returns {string} A string representing the database.\n     */\n    matchDatabaseFromDatabaseName(databaseName) {\n        return this._pathTemplates.databasePathTemplate.match(databaseName)\n            .database;\n    }\n    /**\n     * Return a fully-qualified field resource name string.\n     *\n     * @param {string} project\n     * @param {string} database\n     * @param {string} collection\n     * @param {string} field\n     * @returns {string} Resource name string.\n     */\n    fieldPath(project, database, collection, field) {\n        return this._pathTemplates.fieldPathTemplate.render({\n            project,\n            database,\n            collection,\n            field,\n        });\n    }\n    /**\n     * Parse the project from Field resource.\n     *\n     * @param {string} fieldName\n     *   A fully-qualified path representing Field resource.\n     * @returns {string} A string representing the project.\n     */\n    matchProjectFromFieldName(fieldName) {\n        return this._pathTemplates.fieldPathTemplate.match(fieldName).project;\n    }\n    /**\n     * Parse the database from Field resource.\n     *\n     * @param {string} fieldName\n     *   A fully-qualified path representing Field resource.\n     * @returns {string} A string representing the database.\n     */\n    matchDatabaseFromFieldName(fieldName) {\n        return this._pathTemplates.fieldPathTemplate.match(fieldName).database;\n    }\n    /**\n     * Parse the collection from Field resource.\n     *\n     * @param {string} fieldName\n     *   A fully-qualified path representing Field resource.\n     * @returns {string} A string representing the collection.\n     */\n    matchCollectionFromFieldName(fieldName) {\n        return this._pathTemplates.fieldPathTemplate.match(fieldName).collection;\n    }\n    /**\n     * Parse the field from Field resource.\n     *\n     * @param {string} fieldName\n     *   A fully-qualified path representing Field resource.\n     * @returns {string} A string representing the field.\n     */\n    matchFieldFromFieldName(fieldName) {\n        return this._pathTemplates.fieldPathTemplate.match(fieldName).field;\n    }\n    /**\n     * Return a fully-qualified index resource name string.\n     *\n     * @param {string} project\n     * @param {string} database\n     * @param {string} collection\n     * @param {string} index\n     * @returns {string} Resource name string.\n     */\n    indexPath(project, database, collection, index) {\n        return this._pathTemplates.indexPathTemplate.render({\n            project,\n            database,\n            collection,\n            index,\n        });\n    }\n    /**\n     * Parse the project from Index resource.\n     *\n     * @param {string} indexName\n     *   A fully-qualified path representing Index resource.\n     * @returns {string} A string representing the project.\n     */\n    matchProjectFromIndexName(indexName) {\n        return this._pathTemplates.indexPathTemplate.match(indexName).project;\n    }\n    /**\n     * Parse the database from Index resource.\n     *\n     * @param {string} indexName\n     *   A fully-qualified path representing Index resource.\n     * @returns {string} A string representing the database.\n     */\n    matchDatabaseFromIndexName(indexName) {\n        return this._pathTemplates.indexPathTemplate.match(indexName).database;\n    }\n    /**\n     * Parse the collection from Index resource.\n     *\n     * @param {string} indexName\n     *   A fully-qualified path representing Index resource.\n     * @returns {string} A string representing the collection.\n     */\n    matchCollectionFromIndexName(indexName) {\n        return this._pathTemplates.indexPathTemplate.match(indexName).collection;\n    }\n    /**\n     * Parse the index from Index resource.\n     *\n     * @param {string} indexName\n     *   A fully-qualified path representing Index resource.\n     * @returns {string} A string representing the index.\n     */\n    matchIndexFromIndexName(indexName) {\n        return this._pathTemplates.indexPathTemplate.match(indexName).index;\n    }\n    /**\n     * Terminate the GRPC channel and close the client.\n     *\n     * The client will no longer be usable and all future behavior is undefined.\n     */\n    close() {\n        this.initialize();\n        if (!this._terminated) {\n            return this.firestoreAdminStub.then(stub => {\n                this._terminated = true;\n                stub.close();\n            });\n        }\n        return Promise.resolve();\n    }\n}\nexports.FirestoreAdminClient = FirestoreAdminClient;\n//# sourceMappingURL=firestore_admin_client.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/firestore/build/src/v1/firestore_admin_client.js?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/firestore/build/src/v1/firestore_admin_client_config.json":
/*!**************************************************************************************************!*\
  !*** ./src/node_modules/@google-cloud/firestore/build/src/v1/firestore_admin_client_config.json ***!
  \**************************************************************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"interfaces\":{\"google.firestore.admin.v1.FirestoreAdmin\":{\"retry_codes\":{\"non_idempotent\":[],\"idempotent\":[\"DEADLINE_EXCEEDED\",\"UNAVAILABLE\"],\"deadline_exceeded_internal_unavailable\":[\"DEADLINE_EXCEEDED\",\"INTERNAL\",\"UNAVAILABLE\"]},\"retry_params\":{\"default\":{\"initial_retry_delay_millis\":100,\"retry_delay_multiplier\":1.3,\"max_retry_delay_millis\":60000,\"initial_rpc_timeout_millis\":60000,\"rpc_timeout_multiplier\":1,\"max_rpc_timeout_millis\":60000,\"total_timeout_millis\":600000}},\"methods\":{\"CreateIndex\":{\"timeout_millis\":60000,\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"ListIndexes\":{\"timeout_millis\":60000,\"retry_codes_name\":\"deadline_exceeded_internal_unavailable\",\"retry_params_name\":\"default\"},\"GetIndex\":{\"timeout_millis\":60000,\"retry_codes_name\":\"deadline_exceeded_internal_unavailable\",\"retry_params_name\":\"default\"},\"DeleteIndex\":{\"timeout_millis\":60000,\"retry_codes_name\":\"deadline_exceeded_internal_unavailable\",\"retry_params_name\":\"default\"},\"GetField\":{\"timeout_millis\":60000,\"retry_codes_name\":\"deadline_exceeded_internal_unavailable\",\"retry_params_name\":\"default\"},\"UpdateField\":{\"timeout_millis\":60000,\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"ListFields\":{\"timeout_millis\":60000,\"retry_codes_name\":\"deadline_exceeded_internal_unavailable\",\"retry_params_name\":\"default\"},\"ExportDocuments\":{\"timeout_millis\":60000,\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"ImportDocuments\":{\"timeout_millis\":60000,\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"}}}}}');\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/firestore/build/src/v1/firestore_admin_client_config.json?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/firestore/build/src/v1/firestore_client.js":
/*!***********************************************************************************!*\
  !*** ./src/node_modules/@google-cloud/firestore/build/src/v1/firestore_client.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// Copyright 2020 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ** This file is automatically generated by gapic-generator-typescript. **\n// ** https://github.com/googleapis/gapic-generator-typescript **\n// ** All changes to this file may be overwritten. **\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst gax = __webpack_require__(/*! google-gax */ \"google-gax\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst gapicConfig = __webpack_require__(/*! ./firestore_client_config.json */ \"./src/node_modules/@google-cloud/firestore/build/src/v1/firestore_client_config.json\");\nconst version = __webpack_require__(/*! ../../../package.json */ \"./src/node_modules/@google-cloud/firestore/package.json\").version;\n/**\n *  The Cloud Firestore service.\n *\n *  Cloud Firestore is a fast, fully managed, serverless, cloud-native NoSQL\n *  document database that simplifies storing, syncing, and querying data for\n *  your mobile, web, and IoT apps at global scale. Its client libraries provide\n *  live synchronization and offline support, while its security features and\n *  integrations with Firebase and Google Cloud Platform (GCP) accelerate\n *  building truly serverless apps.\n * @class\n * @memberof v1\n */\nclass FirestoreClient {\n    /**\n     * Construct an instance of FirestoreClient.\n     *\n     * @param {object} [options] - The configuration object. See the subsequent\n     *   parameters for more details.\n     * @param {object} [options.credentials] - Credentials object.\n     * @param {string} [options.credentials.client_email]\n     * @param {string} [options.credentials.private_key]\n     * @param {string} [options.email] - Account email address. Required when\n     *     using a .pem or .p12 keyFilename.\n     * @param {string} [options.keyFilename] - Full path to the a .json, .pem, or\n     *     .p12 key downloaded from the Google Developers Console. If you provide\n     *     a path to a JSON file, the projectId option below is not necessary.\n     *     NOTE: .pem and .p12 require you to specify options.email as well.\n     * @param {number} [options.port] - The port on which to connect to\n     *     the remote host.\n     * @param {string} [options.projectId] - The project ID from the Google\n     *     Developer's Console, e.g. 'grape-spaceship-123'. We will also check\n     *     the environment variable GCLOUD_PROJECT for your project ID. If your\n     *     app is running in an environment which supports\n     *     {@link https://developers.google.com/identity/protocols/application-default-credentials Application Default Credentials},\n     *     your project ID will be detected automatically.\n     * @param {string} [options.apiEndpoint] - The domain name of the\n     *     API remote host.\n     */\n    constructor(opts) {\n        this._descriptors = {\n            page: {},\n            stream: {},\n            longrunning: {},\n            batching: {},\n        };\n        this._terminated = false;\n        // Ensure that options include the service address and port.\n        const staticMembers = this.constructor;\n        const servicePath = opts && opts.servicePath\n            ? opts.servicePath\n            : opts && opts.apiEndpoint\n                ? opts.apiEndpoint\n                : staticMembers.servicePath;\n        const port = opts && opts.port ? opts.port : staticMembers.port;\n        if (!opts) {\n            opts = { servicePath, port };\n        }\n        opts.servicePath = opts.servicePath || servicePath;\n        opts.port = opts.port || port;\n        opts.clientConfig = opts.clientConfig || {};\n        const isBrowser = typeof window !== 'undefined';\n        if (isBrowser) {\n            opts.fallback = true;\n        }\n        // If we are in browser, we are already using fallback because of the\n        // \"browser\" field in package.json.\n        // But if we were explicitly requested to use fallback, let's do it now.\n        this._gaxModule = !isBrowser && opts.fallback ? gax.fallback : gax;\n        // Create a `gaxGrpc` object, with any grpc-specific options\n        // sent to the client.\n        opts.scopes = this.constructor.scopes;\n        this._gaxGrpc = new this._gaxModule.GrpcClient(opts);\n        // Save options to use in initialize() method.\n        this._opts = opts;\n        // Save the auth object to the client, for use by other methods.\n        this.auth = this._gaxGrpc.auth;\n        // Determine the client header string.\n        const clientHeader = [`gax/${this._gaxModule.version}`, `gapic/${version}`];\n        if (typeof process !== 'undefined' && 'versions' in process) {\n            clientHeader.push(`gl-node/${process.versions.node}`);\n        }\n        else {\n            clientHeader.push(`gl-web/${this._gaxModule.version}`);\n        }\n        if (!opts.fallback) {\n            clientHeader.push(`grpc/${this._gaxGrpc.grpcVersion}`);\n        }\n        if (opts.libName && opts.libVersion) {\n            clientHeader.push(`${opts.libName}/${opts.libVersion}`);\n        }\n        // Load the applicable protos.\n        // For Node.js, pass the path to JSON proto file.\n        // For browsers, pass the JSON content.\n        const nodejsProtoPath = path.join(__dirname, '..', '..', 'protos', 'protos.json');\n        this._protos = this._gaxGrpc.loadProto(opts.fallback ? __webpack_require__(/*! ../../protos/protos.json */ \"./src/node_modules/@google-cloud/firestore/build/protos/protos.json\") : nodejsProtoPath);\n        // Some of the methods on this service return \"paged\" results,\n        // (e.g. 50 results at a time, with tokens to get subsequent\n        // pages). Denote the keys used for pagination and results.\n        this._descriptors.page = {\n            listDocuments: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'documents'),\n            listCollectionIds: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'collectionIds'),\n        };\n        // Some of the methods on this service provide streaming responses.\n        // Provide descriptors for these.\n        this._descriptors.stream = {\n            batchGetDocuments: new this._gaxModule.StreamDescriptor(gax.StreamType.SERVER_STREAMING),\n            runQuery: new this._gaxModule.StreamDescriptor(gax.StreamType.SERVER_STREAMING),\n            write: new this._gaxModule.StreamDescriptor(gax.StreamType.BIDI_STREAMING),\n            listen: new this._gaxModule.StreamDescriptor(gax.StreamType.BIDI_STREAMING),\n        };\n        // Put together the default options sent with requests.\n        this._defaults = this._gaxGrpc.constructSettings('google.firestore.v1.Firestore', gapicConfig, opts.clientConfig || {}, { 'x-goog-api-client': clientHeader.join(' ') });\n        // Set up a dictionary of \"inner API calls\"; the core implementation\n        // of calling the API is handled in `google-gax`, with this code\n        // merely providing the destination and request information.\n        this._innerApiCalls = {};\n    }\n    /**\n     * Initialize the client.\n     * Performs asynchronous operations (such as authentication) and prepares the client.\n     * This function will be called automatically when any class method is called for the\n     * first time, but if you need to initialize it before calling an actual method,\n     * feel free to call initialize() directly.\n     *\n     * You can await on this method if you want to make sure the client is initialized.\n     *\n     * @returns {Promise} A promise that resolves to an authenticated service stub.\n     */\n    initialize() {\n        // If the client stub promise is already initialized, return immediately.\n        if (this.firestoreStub) {\n            return this.firestoreStub;\n        }\n        // Put together the \"service stub\" for\n        // google.firestore.v1.Firestore.\n        this.firestoreStub = this._gaxGrpc.createStub(this._opts.fallback\n            ? this._protos.lookupService('google.firestore.v1.Firestore')\n            : // tslint:disable-next-line no-any\n                this._protos.google.firestore.v1.Firestore, this._opts);\n        // Iterate over each of the methods that the service provides\n        // and create an API call method for each.\n        const firestoreStubMethods = [\n            'getDocument',\n            'listDocuments',\n            'updateDocument',\n            'deleteDocument',\n            'batchGetDocuments',\n            'beginTransaction',\n            'commit',\n            'rollback',\n            'runQuery',\n            'write',\n            'listen',\n            'listCollectionIds',\n            'createDocument',\n        ];\n        for (const methodName of firestoreStubMethods) {\n            const innerCallPromise = this.firestoreStub.then(stub => (...args) => {\n                if (this._terminated) {\n                    return Promise.reject(new Error('The client has already been closed.'));\n                }\n                const func = stub[methodName];\n                return func.apply(stub, args);\n            }, (err) => () => {\n                throw err;\n            });\n            const apiCall = this._gaxModule.createApiCall(innerCallPromise, this._defaults[methodName], this._descriptors.page[methodName] ||\n                this._descriptors.stream[methodName] ||\n                this._descriptors.longrunning[methodName]);\n            this._innerApiCalls[methodName] = (argument, callOptions, callback) => {\n                return apiCall(argument, callOptions, callback);\n            };\n        }\n        return this.firestoreStub;\n    }\n    /**\n     * The DNS address for this API service.\n     */\n    static get servicePath() {\n        return 'firestore.googleapis.com';\n    }\n    /**\n     * The DNS address for this API service - same as servicePath(),\n     * exists for compatibility reasons.\n     */\n    static get apiEndpoint() {\n        return 'firestore.googleapis.com';\n    }\n    /**\n     * The port for this API service.\n     */\n    static get port() {\n        return 443;\n    }\n    /**\n     * The scopes needed to make gRPC calls for every method defined\n     * in this service.\n     */\n    static get scopes() {\n        return [\n            'https://www.googleapis.com/auth/cloud-platform',\n            'https://www.googleapis.com/auth/datastore',\n        ];\n    }\n    /**\n     * Return the project ID used by this class.\n     * @param {function(Error, string)} callback - the callback to\n     *   be called with the current project Id.\n     */\n    getProjectId(callback) {\n        if (callback) {\n            this.auth.getProjectId(callback);\n            return;\n        }\n        return this.auth.getProjectId();\n    }\n    /**\n     * Gets a single document.\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.name\n     *   Required. The resource name of the Document to get. In the format:\n     *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.\n     * @param {google.firestore.v1.DocumentMask} request.mask\n     *   The fields to return. If not set, returns all fields.\n     *\n     *   If the document has a field that is not present in this mask, that field\n     *   will not be returned in the response.\n     * @param {Buffer} request.transaction\n     *   Reads the document in a transaction.\n     * @param {google.protobuf.Timestamp} request.readTime\n     *   Reads the version of the document at the given time.\n     *   This may not be older than 60 seconds.\n     * @param {object} [options]\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\n     * @returns {Promise} - The promise which resolves to an array.\n     *   The first element of the array is an object representing [Document]{@link google.firestore.v1.Document}.\n     *   The promise has a method named \"cancel\" which cancels the ongoing API call.\n     */\n    getDocument(request, optionsOrCallback, callback) {\n        request = request || {};\n        let options;\n        if (typeof optionsOrCallback === 'function' && callback === undefined) {\n            callback = optionsOrCallback;\n            options = {};\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        options = options || {};\n        options.otherArgs = options.otherArgs || {};\n        options.otherArgs.headers = options.otherArgs.headers || {};\n        options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n            name: request.name || '',\n        });\n        this.initialize();\n        return this._innerApiCalls.getDocument(request, options, callback);\n    }\n    /**\n     * Updates or inserts a document.\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {google.firestore.v1.Document} request.document\n     *   Required. The updated document.\n     *   Creates the document if it does not already exist.\n     * @param {google.firestore.v1.DocumentMask} request.updateMask\n     *   The fields to update.\n     *   None of the field paths in the mask may contain a reserved name.\n     *\n     *   If the document exists on the server and has fields not referenced in the\n     *   mask, they are left unchanged.\n     *   Fields referenced in the mask, but not present in the input document, are\n     *   deleted from the document on the server.\n     * @param {google.firestore.v1.DocumentMask} request.mask\n     *   The fields to return. If not set, returns all fields.\n     *\n     *   If the document has a field that is not present in this mask, that field\n     *   will not be returned in the response.\n     * @param {google.firestore.v1.Precondition} request.currentDocument\n     *   An optional precondition on the document.\n     *   The request will fail if this is set and not met by the target document.\n     * @param {object} [options]\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\n     * @returns {Promise} - The promise which resolves to an array.\n     *   The first element of the array is an object representing [Document]{@link google.firestore.v1.Document}.\n     *   The promise has a method named \"cancel\" which cancels the ongoing API call.\n     */\n    updateDocument(request, optionsOrCallback, callback) {\n        request = request || {};\n        let options;\n        if (typeof optionsOrCallback === 'function' && callback === undefined) {\n            callback = optionsOrCallback;\n            options = {};\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        options = options || {};\n        options.otherArgs = options.otherArgs || {};\n        options.otherArgs.headers = options.otherArgs.headers || {};\n        options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n            'document.name': request.document.name || '',\n        });\n        this.initialize();\n        return this._innerApiCalls.updateDocument(request, options, callback);\n    }\n    /**\n     * Deletes a document.\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.name\n     *   Required. The resource name of the Document to delete. In the format:\n     *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.\n     * @param {google.firestore.v1.Precondition} request.currentDocument\n     *   An optional precondition on the document.\n     *   The request will fail if this is set and not met by the target document.\n     * @param {object} [options]\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\n     * @returns {Promise} - The promise which resolves to an array.\n     *   The first element of the array is an object representing [Empty]{@link google.protobuf.Empty}.\n     *   The promise has a method named \"cancel\" which cancels the ongoing API call.\n     */\n    deleteDocument(request, optionsOrCallback, callback) {\n        request = request || {};\n        let options;\n        if (typeof optionsOrCallback === 'function' && callback === undefined) {\n            callback = optionsOrCallback;\n            options = {};\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        options = options || {};\n        options.otherArgs = options.otherArgs || {};\n        options.otherArgs.headers = options.otherArgs.headers || {};\n        options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n            name: request.name || '',\n        });\n        this.initialize();\n        return this._innerApiCalls.deleteDocument(request, options, callback);\n    }\n    /**\n     * Starts a new transaction.\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.database\n     *   Required. The database name. In the format:\n     *   `projects/{project_id}/databases/{database_id}`.\n     * @param {google.firestore.v1.TransactionOptions} request.options\n     *   The options for the transaction.\n     *   Defaults to a read-write transaction.\n     * @param {object} [options]\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\n     * @returns {Promise} - The promise which resolves to an array.\n     *   The first element of the array is an object representing [BeginTransactionResponse]{@link google.firestore.v1.BeginTransactionResponse}.\n     *   The promise has a method named \"cancel\" which cancels the ongoing API call.\n     */\n    beginTransaction(request, optionsOrCallback, callback) {\n        request = request || {};\n        let options;\n        if (typeof optionsOrCallback === 'function' && callback === undefined) {\n            callback = optionsOrCallback;\n            options = {};\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        options = options || {};\n        options.otherArgs = options.otherArgs || {};\n        options.otherArgs.headers = options.otherArgs.headers || {};\n        options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n            database: request.database || '',\n        });\n        this.initialize();\n        return this._innerApiCalls.beginTransaction(request, options, callback);\n    }\n    /**\n     * Commits a transaction, while optionally updating documents.\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.database\n     *   Required. The database name. In the format:\n     *   `projects/{project_id}/databases/{database_id}`.\n     * @param {number[]} request.writes\n     *   The writes to apply.\n     *\n     *   Always executed atomically and in order.\n     * @param {Buffer} request.transaction\n     *   If set, applies all writes in this transaction, and commits it.\n     * @param {object} [options]\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\n     * @returns {Promise} - The promise which resolves to an array.\n     *   The first element of the array is an object representing [CommitResponse]{@link google.firestore.v1.CommitResponse}.\n     *   The promise has a method named \"cancel\" which cancels the ongoing API call.\n     */\n    commit(request, optionsOrCallback, callback) {\n        request = request || {};\n        let options;\n        if (typeof optionsOrCallback === 'function' && callback === undefined) {\n            callback = optionsOrCallback;\n            options = {};\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        options = options || {};\n        options.otherArgs = options.otherArgs || {};\n        options.otherArgs.headers = options.otherArgs.headers || {};\n        options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n            database: request.database || '',\n        });\n        this.initialize();\n        return this._innerApiCalls.commit(request, options, callback);\n    }\n    /**\n     * Rolls back a transaction.\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.database\n     *   Required. The database name. In the format:\n     *   `projects/{project_id}/databases/{database_id}`.\n     * @param {Buffer} request.transaction\n     *   Required. The transaction to roll back.\n     * @param {object} [options]\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\n     * @returns {Promise} - The promise which resolves to an array.\n     *   The first element of the array is an object representing [Empty]{@link google.protobuf.Empty}.\n     *   The promise has a method named \"cancel\" which cancels the ongoing API call.\n     */\n    rollback(request, optionsOrCallback, callback) {\n        request = request || {};\n        let options;\n        if (typeof optionsOrCallback === 'function' && callback === undefined) {\n            callback = optionsOrCallback;\n            options = {};\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        options = options || {};\n        options.otherArgs = options.otherArgs || {};\n        options.otherArgs.headers = options.otherArgs.headers || {};\n        options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n            database: request.database || '',\n        });\n        this.initialize();\n        return this._innerApiCalls.rollback(request, options, callback);\n    }\n    /**\n     * Creates a new document.\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.parent\n     *   Required. The parent resource. For example:\n     *   `projects/{project_id}/databases/{database_id}/documents` or\n     *   `projects/{project_id}/databases/{database_id}/documents/chatrooms/{chatroom_id}`\n     * @param {string} request.collectionId\n     *   Required. The collection ID, relative to `parent`, to list. For example: `chatrooms`.\n     * @param {string} request.documentId\n     *   The client-assigned document ID to use for this document.\n     *\n     *   Optional. If not specified, an ID will be assigned by the service.\n     * @param {google.firestore.v1.Document} request.document\n     *   Required. The document to create. `name` must not be set.\n     * @param {google.firestore.v1.DocumentMask} request.mask\n     *   The fields to return. If not set, returns all fields.\n     *\n     *   If the document has a field that is not present in this mask, that field\n     *   will not be returned in the response.\n     * @param {object} [options]\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\n     * @returns {Promise} - The promise which resolves to an array.\n     *   The first element of the array is an object representing [Document]{@link google.firestore.v1.Document}.\n     *   The promise has a method named \"cancel\" which cancels the ongoing API call.\n     */\n    createDocument(request, optionsOrCallback, callback) {\n        request = request || {};\n        let options;\n        if (typeof optionsOrCallback === 'function' && callback === undefined) {\n            callback = optionsOrCallback;\n            options = {};\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        options = options || {};\n        options.otherArgs = options.otherArgs || {};\n        options.otherArgs.headers = options.otherArgs.headers || {};\n        options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n            parent: request.parent || '',\n        });\n        this.initialize();\n        return this._innerApiCalls.createDocument(request, options, callback);\n    }\n    /**\n     * Gets multiple documents.\n     *\n     * Documents returned by this method are not guaranteed to be returned in the\n     * same order that they were requested.\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.database\n     *   Required. The database name. In the format:\n     *   `projects/{project_id}/databases/{database_id}`.\n     * @param {string[]} request.documents\n     *   The names of the documents to retrieve. In the format:\n     *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.\n     *   The request will fail if any of the document is not a child resource of the\n     *   given `database`. Duplicate names will be elided.\n     * @param {google.firestore.v1.DocumentMask} request.mask\n     *   The fields to return. If not set, returns all fields.\n     *\n     *   If a document has a field that is not present in this mask, that field will\n     *   not be returned in the response.\n     * @param {Buffer} request.transaction\n     *   Reads documents in a transaction.\n     * @param {google.firestore.v1.TransactionOptions} request.newTransaction\n     *   Starts a new transaction and reads the documents.\n     *   Defaults to a read-only transaction.\n     *   The new transaction ID will be returned as the first response in the\n     *   stream.\n     * @param {google.protobuf.Timestamp} request.readTime\n     *   Reads documents as they were at the given time.\n     *   This may not be older than 60 seconds.\n     * @param {object} [options]\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\n     * @returns {Stream}\n     *   An object stream which emits [BatchGetDocumentsResponse]{@link google.firestore.v1.BatchGetDocumentsResponse} on 'data' event.\n     */\n    batchGetDocuments(request, options) {\n        request = request || {};\n        options = options || {};\n        options.otherArgs = options.otherArgs || {};\n        options.otherArgs.headers = options.otherArgs.headers || {};\n        options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n            database: request.database || '',\n        });\n        this.initialize();\n        return this._innerApiCalls.batchGetDocuments(request, options);\n    }\n    /**\n     * Runs a query.\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.parent\n     *   Required. The parent resource name. In the format:\n     *   `projects/{project_id}/databases/{database_id}/documents` or\n     *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.\n     *   For example:\n     *   `projects/my-project/databases/my-database/documents` or\n     *   `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`\n     * @param {google.firestore.v1.StructuredQuery} request.structuredQuery\n     *   A structured query.\n     * @param {Buffer} request.transaction\n     *   Reads documents in a transaction.\n     * @param {google.firestore.v1.TransactionOptions} request.newTransaction\n     *   Starts a new transaction and reads the documents.\n     *   Defaults to a read-only transaction.\n     *   The new transaction ID will be returned as the first response in the\n     *   stream.\n     * @param {google.protobuf.Timestamp} request.readTime\n     *   Reads documents as they were at the given time.\n     *   This may not be older than 60 seconds.\n     * @param {object} [options]\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\n     * @returns {Stream}\n     *   An object stream which emits [RunQueryResponse]{@link google.firestore.v1.RunQueryResponse} on 'data' event.\n     */\n    runQuery(request, options) {\n        request = request || {};\n        options = options || {};\n        options.otherArgs = options.otherArgs || {};\n        options.otherArgs.headers = options.otherArgs.headers || {};\n        options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n            parent: request.parent || '',\n        });\n        this.initialize();\n        return this._innerApiCalls.runQuery(request, options);\n    }\n    /**\n     * Streams batches of document updates and deletes, in order.\n     *\n     * @param {object} [options]\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\n     * @returns {Stream}\n     *   An object stream which is both readable and writable. It accepts objects\n     *   representing [WriteRequest]{@link google.firestore.v1.WriteRequest} for write() method, and\n     *   will emit objects representing [WriteResponse]{@link google.firestore.v1.WriteResponse} on 'data' event asynchronously.\n     */\n    write(options) {\n        this.initialize();\n        return this._innerApiCalls.write(options);\n    }\n    /**\n     * Listens to changes.\n     *\n     * @param {object} [options]\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\n     * @returns {Stream}\n     *   An object stream which is both readable and writable. It accepts objects\n     *   representing [ListenRequest]{@link google.firestore.v1.ListenRequest} for write() method, and\n     *   will emit objects representing [ListenResponse]{@link google.firestore.v1.ListenResponse} on 'data' event asynchronously.\n     */\n    listen(options) {\n        this.initialize();\n        return this._innerApiCalls.listen({}, options);\n    }\n    /**\n     * Lists documents.\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.parent\n     *   Required. The parent resource name. In the format:\n     *   `projects/{project_id}/databases/{database_id}/documents` or\n     *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.\n     *   For example:\n     *   `projects/my-project/databases/my-database/documents` or\n     *   `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`\n     * @param {string} request.collectionId\n     *   Required. The collection ID, relative to `parent`, to list. For example: `chatrooms`\n     *   or `messages`.\n     * @param {number} request.pageSize\n     *   The maximum number of documents to return.\n     * @param {string} request.pageToken\n     *   The `next_page_token` value returned from a previous List request, if any.\n     * @param {string} request.orderBy\n     *   The order to sort results by. For example: `priority desc, name`.\n     * @param {google.firestore.v1.DocumentMask} request.mask\n     *   The fields to return. If not set, returns all fields.\n     *\n     *   If a document has a field that is not present in this mask, that field\n     *   will not be returned in the response.\n     * @param {Buffer} request.transaction\n     *   Reads documents in a transaction.\n     * @param {google.protobuf.Timestamp} request.readTime\n     *   Reads documents as they were at the given time.\n     *   This may not be older than 60 seconds.\n     * @param {boolean} request.showMissing\n     *   If the list should show missing documents. A missing document is a\n     *   document that does not exist but has sub-documents. These documents will\n     *   be returned with a key but will not have fields, {@link google.firestore.v1.Document.create_time|Document.create_time},\n     *   or {@link google.firestore.v1.Document.update_time|Document.update_time} set.\n     *\n     *   Requests with `show_missing` may not specify `where` or\n     *   `order_by`.\n     * @param {object} [options]\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\n     * @returns {Promise} - The promise which resolves to an array.\n     *   The first element of the array is Array of [Document]{@link google.firestore.v1.Document}.\n     *   The client library support auto-pagination by default: it will call the API as many\n     *   times as needed and will merge results from all the pages into this array.\n     *\n     *   When autoPaginate: false is specified through options, the array has three elements.\n     *   The first element is Array of [Document]{@link google.firestore.v1.Document} that corresponds to\n     *   the one page received from the API server.\n     *   If the second element is not null it contains the request object of type [ListDocumentsRequest]{@link google.firestore.v1.ListDocumentsRequest}\n     *   that can be used to obtain the next page of the results.\n     *   If it is null, the next page does not exist.\n     *   The third element contains the raw response received from the API server. Its type is\n     *   [ListDocumentsResponse]{@link google.firestore.v1.ListDocumentsResponse}.\n     *\n     *   The promise has a method named \"cancel\" which cancels the ongoing API call.\n     */\n    listDocuments(request, optionsOrCallback, callback) {\n        request = request || {};\n        let options;\n        if (typeof optionsOrCallback === 'function' && callback === undefined) {\n            callback = optionsOrCallback;\n            options = {};\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        options = options || {};\n        options.otherArgs = options.otherArgs || {};\n        options.otherArgs.headers = options.otherArgs.headers || {};\n        options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n            parent: request.parent || '',\n        });\n        this.initialize();\n        return this._innerApiCalls.listDocuments(request, options, callback);\n    }\n    /**\n     * Equivalent to {@link listDocuments}, but returns a NodeJS Stream object.\n     *\n     * This fetches the paged responses for {@link listDocuments} continuously\n     * and invokes the callback registered for 'data' event for each element in the\n     * responses.\n     *\n     * The returned object has 'end' method when no more elements are required.\n     *\n     * autoPaginate option will be ignored.\n     *\n     * @see {@link https://nodejs.org/api/stream.html}\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.parent\n     *   Required. The parent resource name. In the format:\n     *   `projects/{project_id}/databases/{database_id}/documents` or\n     *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.\n     *   For example:\n     *   `projects/my-project/databases/my-database/documents` or\n     *   `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`\n     * @param {string} request.collectionId\n     *   Required. The collection ID, relative to `parent`, to list. For example: `chatrooms`\n     *   or `messages`.\n     * @param {number} request.pageSize\n     *   The maximum number of documents to return.\n     * @param {string} request.pageToken\n     *   The `next_page_token` value returned from a previous List request, if any.\n     * @param {string} request.orderBy\n     *   The order to sort results by. For example: `priority desc, name`.\n     * @param {google.firestore.v1.DocumentMask} request.mask\n     *   The fields to return. If not set, returns all fields.\n     *\n     *   If a document has a field that is not present in this mask, that field\n     *   will not be returned in the response.\n     * @param {Buffer} request.transaction\n     *   Reads documents in a transaction.\n     * @param {google.protobuf.Timestamp} request.readTime\n     *   Reads documents as they were at the given time.\n     *   This may not be older than 60 seconds.\n     * @param {boolean} request.showMissing\n     *   If the list should show missing documents. A missing document is a\n     *   document that does not exist but has sub-documents. These documents will\n     *   be returned with a key but will not have fields, {@link google.firestore.v1.Document.create_time|Document.create_time},\n     *   or {@link google.firestore.v1.Document.update_time|Document.update_time} set.\n     *\n     *   Requests with `show_missing` may not specify `where` or\n     *   `order_by`.\n     * @param {object} [options]\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\n     * @returns {Stream}\n     *   An object stream which emits an object representing [Document]{@link google.firestore.v1.Document} on 'data' event.\n     */\n    listDocumentsStream(request, options) {\n        request = request || {};\n        options = options || {};\n        options.otherArgs = options.otherArgs || {};\n        options.otherArgs.headers = options.otherArgs.headers || {};\n        options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n            parent: request.parent || '',\n        });\n        const callSettings = new gax.CallSettings(options);\n        this.initialize();\n        return this._descriptors.page.listDocuments.createStream(this._innerApiCalls.listDocuments, request, callSettings);\n    }\n    /**\n     * Lists all the collection IDs underneath a document.\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.parent\n     *   Required. The parent document. In the format:\n     *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.\n     *   For example:\n     *   `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`\n     * @param {number} request.pageSize\n     *   The maximum number of results to return.\n     * @param {string} request.pageToken\n     *   A page token. Must be a value from\n     *   {@link google.firestore.v1.ListCollectionIdsResponse|ListCollectionIdsResponse}.\n     * @param {object} [options]\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\n     * @returns {Promise} - The promise which resolves to an array.\n     *   The first element of the array is Array of string.\n     *   The client library support auto-pagination by default: it will call the API as many\n     *   times as needed and will merge results from all the pages into this array.\n     *\n     *   When autoPaginate: false is specified through options, the array has three elements.\n     *   The first element is Array of string that corresponds to\n     *   the one page received from the API server.\n     *   If the second element is not null it contains the request object of type [ListCollectionIdsRequest]{@link google.firestore.v1.ListCollectionIdsRequest}\n     *   that can be used to obtain the next page of the results.\n     *   If it is null, the next page does not exist.\n     *   The third element contains the raw response received from the API server. Its type is\n     *   [ListCollectionIdsResponse]{@link google.firestore.v1.ListCollectionIdsResponse}.\n     *\n     *   The promise has a method named \"cancel\" which cancels the ongoing API call.\n     */\n    listCollectionIds(request, optionsOrCallback, callback) {\n        request = request || {};\n        let options;\n        if (typeof optionsOrCallback === 'function' && callback === undefined) {\n            callback = optionsOrCallback;\n            options = {};\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        options = options || {};\n        options.otherArgs = options.otherArgs || {};\n        options.otherArgs.headers = options.otherArgs.headers || {};\n        options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n            parent: request.parent || '',\n        });\n        this.initialize();\n        return this._innerApiCalls.listCollectionIds(request, options, callback);\n    }\n    /**\n     * Equivalent to {@link listCollectionIds}, but returns a NodeJS Stream object.\n     *\n     * This fetches the paged responses for {@link listCollectionIds} continuously\n     * and invokes the callback registered for 'data' event for each element in the\n     * responses.\n     *\n     * The returned object has 'end' method when no more elements are required.\n     *\n     * autoPaginate option will be ignored.\n     *\n     * @see {@link https://nodejs.org/api/stream.html}\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.parent\n     *   Required. The parent document. In the format:\n     *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.\n     *   For example:\n     *   `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`\n     * @param {number} request.pageSize\n     *   The maximum number of results to return.\n     * @param {string} request.pageToken\n     *   A page token. Must be a value from\n     *   {@link google.firestore.v1.ListCollectionIdsResponse|ListCollectionIdsResponse}.\n     * @param {object} [options]\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\n     * @returns {Stream}\n     *   An object stream which emits an object representing string on 'data' event.\n     */\n    listCollectionIdsStream(request, options) {\n        request = request || {};\n        options = options || {};\n        options.otherArgs = options.otherArgs || {};\n        options.otherArgs.headers = options.otherArgs.headers || {};\n        options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n            parent: request.parent || '',\n        });\n        const callSettings = new gax.CallSettings(options);\n        this.initialize();\n        return this._descriptors.page.listCollectionIds.createStream(this._innerApiCalls.listCollectionIds, request, callSettings);\n    }\n    /**\n     * Terminate the GRPC channel and close the client.\n     *\n     * The client will no longer be usable and all future behavior is undefined.\n     */\n    close() {\n        this.initialize();\n        if (!this._terminated) {\n            return this.firestoreStub.then(stub => {\n                this._terminated = true;\n                stub.close();\n            });\n        }\n        return Promise.resolve();\n    }\n}\nexports.FirestoreClient = FirestoreClient;\n//# sourceMappingURL=firestore_client.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/firestore/build/src/v1/firestore_client.js?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/firestore/build/src/v1/firestore_client_config.json":
/*!********************************************************************************************!*\
  !*** ./src/node_modules/@google-cloud/firestore/build/src/v1/firestore_client_config.json ***!
  \********************************************************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"interfaces\":{\"google.firestore.v1.Firestore\":{\"retry_codes\":{\"non_idempotent\":[],\"idempotent\":[\"DEADLINE_EXCEEDED\",\"UNAVAILABLE\"],\"deadline_exceeded_internal_unavailable\":[\"DEADLINE_EXCEEDED\",\"INTERNAL\",\"UNAVAILABLE\"]},\"retry_params\":{\"default\":{\"initial_retry_delay_millis\":100,\"retry_delay_multiplier\":1.3,\"max_retry_delay_millis\":60000,\"initial_rpc_timeout_millis\":60000,\"rpc_timeout_multiplier\":1,\"max_rpc_timeout_millis\":60000,\"total_timeout_millis\":600000}},\"methods\":{\"GetDocument\":{\"timeout_millis\":60000,\"retry_codes_name\":\"deadline_exceeded_internal_unavailable\",\"retry_params_name\":\"default\"},\"ListDocuments\":{\"timeout_millis\":60000,\"retry_codes_name\":\"deadline_exceeded_internal_unavailable\",\"retry_params_name\":\"default\"},\"UpdateDocument\":{\"timeout_millis\":60000,\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"DeleteDocument\":{\"timeout_millis\":60000,\"retry_codes_name\":\"deadline_exceeded_internal_unavailable\",\"retry_params_name\":\"default\"},\"BatchGetDocuments\":{\"timeout_millis\":300000,\"retry_codes_name\":\"deadline_exceeded_internal_unavailable\",\"retry_params_name\":\"default\"},\"BeginTransaction\":{\"timeout_millis\":60000,\"retry_codes_name\":\"deadline_exceeded_internal_unavailable\",\"retry_params_name\":\"default\"},\"Commit\":{\"timeout_millis\":60000,\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"Rollback\":{\"timeout_millis\":60000,\"retry_codes_name\":\"deadline_exceeded_internal_unavailable\",\"retry_params_name\":\"default\"},\"RunQuery\":{\"timeout_millis\":300000,\"retry_codes_name\":\"deadline_exceeded_internal_unavailable\",\"retry_params_name\":\"default\"},\"Write\":{\"timeout_millis\":86400000,\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"Listen\":{\"timeout_millis\":86400000,\"retry_codes_name\":\"deadline_exceeded_internal_unavailable\",\"retry_params_name\":\"default\"},\"ListCollectionIds\":{\"timeout_millis\":60000,\"retry_codes_name\":\"deadline_exceeded_internal_unavailable\",\"retry_params_name\":\"default\"},\"CreateDocument\":{\"timeout_millis\":60000,\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"}}}}}');\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/firestore/build/src/v1/firestore_client_config.json?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/firestore/build/src/v1/index.js":
/*!************************************************************************!*\
  !*** ./src/node_modules/@google-cloud/firestore/build/src/v1/index.js ***!
  \************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst firestore_admin_client_1 = __webpack_require__(/*! ./firestore_admin_client */ \"./src/node_modules/@google-cloud/firestore/build/src/v1/firestore_admin_client.js\");\nexports.FirestoreAdminClient = firestore_admin_client_1.FirestoreAdminClient;\nconst firestore_client_1 = __webpack_require__(/*! ./firestore_client */ \"./src/node_modules/@google-cloud/firestore/build/src/v1/firestore_client.js\");\nexports.FirestoreClient = firestore_client_1.FirestoreClient;\n// Doing something really horrible for reverse compatibility with original JavaScript exports\nconst existingExports = module.exports;\nmodule.exports = firestore_client_1.FirestoreClient;\nmodule.exports = Object.assign(module.exports, existingExports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/firestore/build/src/v1/index.js?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/firestore/build/src/v1beta1/firestore_client.js":
/*!****************************************************************************************!*\
  !*** ./src/node_modules/@google-cloud/firestore/build/src/v1beta1/firestore_client.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// Copyright 2020 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ** This file is automatically generated by gapic-generator-typescript. **\n// ** https://github.com/googleapis/gapic-generator-typescript **\n// ** All changes to this file may be overwritten. **\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst gax = __webpack_require__(/*! google-gax */ \"google-gax\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst gapicConfig = __webpack_require__(/*! ./firestore_client_config.json */ \"./src/node_modules/@google-cloud/firestore/build/src/v1beta1/firestore_client_config.json\");\nconst version = __webpack_require__(/*! ../../../package.json */ \"./src/node_modules/@google-cloud/firestore/package.json\").version;\n/**\n *  The Cloud Firestore service.\n *\n *  This service exposes several types of comparable timestamps:\n *\n *  *    `create_time` - The time at which a document was created. Changes only\n *       when a document is deleted, then re-created. Increases in a strict\n *        monotonic fashion.\n *  *    `update_time` - The time at which a document was last updated. Changes\n *       every time a document is modified. Does not change when a write results\n *       in no modifications. Increases in a strict monotonic fashion.\n *  *    `read_time` - The time at which a particular state was observed. Used\n *       to denote a consistent snapshot of the database or the time at which a\n *       Document was observed to not exist.\n *  *    `commit_time` - The time at which the writes in a transaction were\n *       committed. Any read with an equal or greater `read_time` is guaranteed\n *       to see the effects of the transaction.\n * @class\n * @memberof v1beta1\n */\nclass FirestoreClient {\n    /**\n     * Construct an instance of FirestoreClient.\n     *\n     * @param {object} [options] - The configuration object. See the subsequent\n     *   parameters for more details.\n     * @param {object} [options.credentials] - Credentials object.\n     * @param {string} [options.credentials.client_email]\n     * @param {string} [options.credentials.private_key]\n     * @param {string} [options.email] - Account email address. Required when\n     *     using a .pem or .p12 keyFilename.\n     * @param {string} [options.keyFilename] - Full path to the a .json, .pem, or\n     *     .p12 key downloaded from the Google Developers Console. If you provide\n     *     a path to a JSON file, the projectId option below is not necessary.\n     *     NOTE: .pem and .p12 require you to specify options.email as well.\n     * @param {number} [options.port] - The port on which to connect to\n     *     the remote host.\n     * @param {string} [options.projectId] - The project ID from the Google\n     *     Developer's Console, e.g. 'grape-spaceship-123'. We will also check\n     *     the environment variable GCLOUD_PROJECT for your project ID. If your\n     *     app is running in an environment which supports\n     *     {@link https://developers.google.com/identity/protocols/application-default-credentials Application Default Credentials},\n     *     your project ID will be detected automatically.\n     * @param {string} [options.apiEndpoint] - The domain name of the\n     *     API remote host.\n     */\n    constructor(opts) {\n        this._descriptors = {\n            page: {},\n            stream: {},\n            longrunning: {},\n            batching: {},\n        };\n        this._terminated = false;\n        // Ensure that options include the service address and port.\n        const staticMembers = this.constructor;\n        const servicePath = opts && opts.servicePath\n            ? opts.servicePath\n            : opts && opts.apiEndpoint\n                ? opts.apiEndpoint\n                : staticMembers.servicePath;\n        const port = opts && opts.port ? opts.port : staticMembers.port;\n        if (!opts) {\n            opts = { servicePath, port };\n        }\n        opts.servicePath = opts.servicePath || servicePath;\n        opts.port = opts.port || port;\n        opts.clientConfig = opts.clientConfig || {};\n        const isBrowser = typeof window !== 'undefined';\n        if (isBrowser) {\n            opts.fallback = true;\n        }\n        // If we are in browser, we are already using fallback because of the\n        // \"browser\" field in package.json.\n        // But if we were explicitly requested to use fallback, let's do it now.\n        this._gaxModule = !isBrowser && opts.fallback ? gax.fallback : gax;\n        // Create a `gaxGrpc` object, with any grpc-specific options\n        // sent to the client.\n        opts.scopes = this.constructor.scopes;\n        this._gaxGrpc = new this._gaxModule.GrpcClient(opts);\n        // Save options to use in initialize() method.\n        this._opts = opts;\n        // Save the auth object to the client, for use by other methods.\n        this.auth = this._gaxGrpc.auth;\n        // Determine the client header string.\n        const clientHeader = [`gax/${this._gaxModule.version}`, `gapic/${version}`];\n        if (typeof process !== 'undefined' && 'versions' in process) {\n            clientHeader.push(`gl-node/${process.versions.node}`);\n        }\n        else {\n            clientHeader.push(`gl-web/${this._gaxModule.version}`);\n        }\n        if (!opts.fallback) {\n            clientHeader.push(`grpc/${this._gaxGrpc.grpcVersion}`);\n        }\n        if (opts.libName && opts.libVersion) {\n            clientHeader.push(`${opts.libName}/${opts.libVersion}`);\n        }\n        // Load the applicable protos.\n        // For Node.js, pass the path to JSON proto file.\n        // For browsers, pass the JSON content.\n        const nodejsProtoPath = path.join(__dirname, '..', '..', 'protos', 'protos.json');\n        this._protos = this._gaxGrpc.loadProto(opts.fallback ? __webpack_require__(/*! ../../protos/protos.json */ \"./src/node_modules/@google-cloud/firestore/build/protos/protos.json\") : nodejsProtoPath);\n        // Some of the methods on this service return \"paged\" results,\n        // (e.g. 50 results at a time, with tokens to get subsequent\n        // pages). Denote the keys used for pagination and results.\n        this._descriptors.page = {\n            listDocuments: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'documents'),\n            listCollectionIds: new this._gaxModule.PageDescriptor('pageToken', 'nextPageToken', 'collectionIds'),\n        };\n        // Some of the methods on this service provide streaming responses.\n        // Provide descriptors for these.\n        this._descriptors.stream = {\n            batchGetDocuments: new this._gaxModule.StreamDescriptor(gax.StreamType.SERVER_STREAMING),\n            runQuery: new this._gaxModule.StreamDescriptor(gax.StreamType.SERVER_STREAMING),\n            write: new this._gaxModule.StreamDescriptor(gax.StreamType.BIDI_STREAMING),\n            listen: new this._gaxModule.StreamDescriptor(gax.StreamType.BIDI_STREAMING),\n        };\n        // Put together the default options sent with requests.\n        this._defaults = this._gaxGrpc.constructSettings('google.firestore.v1beta1.Firestore', gapicConfig, opts.clientConfig || {}, { 'x-goog-api-client': clientHeader.join(' ') });\n        // Set up a dictionary of \"inner API calls\"; the core implementation\n        // of calling the API is handled in `google-gax`, with this code\n        // merely providing the destination and request information.\n        this._innerApiCalls = {};\n    }\n    /**\n     * Initialize the client.\n     * Performs asynchronous operations (such as authentication) and prepares the client.\n     * This function will be called automatically when any class method is called for the\n     * first time, but if you need to initialize it before calling an actual method,\n     * feel free to call initialize() directly.\n     *\n     * You can await on this method if you want to make sure the client is initialized.\n     *\n     * @returns {Promise} A promise that resolves to an authenticated service stub.\n     */\n    initialize() {\n        // If the client stub promise is already initialized, return immediately.\n        if (this.firestoreStub) {\n            return this.firestoreStub;\n        }\n        // Put together the \"service stub\" for\n        // google.firestore.v1beta1.Firestore.\n        this.firestoreStub = this._gaxGrpc.createStub(this._opts.fallback\n            ? this._protos.lookupService('google.firestore.v1beta1.Firestore')\n            : // tslint:disable-next-line no-any\n                this._protos.google.firestore.v1beta1.Firestore, this._opts);\n        // Iterate over each of the methods that the service provides\n        // and create an API call method for each.\n        const firestoreStubMethods = [\n            'getDocument',\n            'listDocuments',\n            'createDocument',\n            'updateDocument',\n            'deleteDocument',\n            'batchGetDocuments',\n            'beginTransaction',\n            'commit',\n            'rollback',\n            'runQuery',\n            'write',\n            'listen',\n            'listCollectionIds',\n        ];\n        for (const methodName of firestoreStubMethods) {\n            const innerCallPromise = this.firestoreStub.then(stub => (...args) => {\n                if (this._terminated) {\n                    return Promise.reject(new Error('The client has already been closed.'));\n                }\n                const func = stub[methodName];\n                return func.apply(stub, args);\n            }, (err) => () => {\n                throw err;\n            });\n            const apiCall = this._gaxModule.createApiCall(innerCallPromise, this._defaults[methodName], this._descriptors.page[methodName] ||\n                this._descriptors.stream[methodName] ||\n                this._descriptors.longrunning[methodName]);\n            this._innerApiCalls[methodName] = (argument, callOptions, callback) => {\n                return apiCall(argument, callOptions, callback);\n            };\n        }\n        return this.firestoreStub;\n    }\n    /**\n     * The DNS address for this API service.\n     */\n    static get servicePath() {\n        return 'firestore.googleapis.com';\n    }\n    /**\n     * The DNS address for this API service - same as servicePath(),\n     * exists for compatibility reasons.\n     */\n    static get apiEndpoint() {\n        return 'firestore.googleapis.com';\n    }\n    /**\n     * The port for this API service.\n     */\n    static get port() {\n        return 443;\n    }\n    /**\n     * The scopes needed to make gRPC calls for every method defined\n     * in this service.\n     */\n    static get scopes() {\n        return [\n            'https://www.googleapis.com/auth/cloud-platform',\n            'https://www.googleapis.com/auth/datastore',\n        ];\n    }\n    /**\n     * Return the project ID used by this class.\n     * @param {function(Error, string)} callback - the callback to\n     *   be called with the current project Id.\n     */\n    getProjectId(callback) {\n        if (callback) {\n            this.auth.getProjectId(callback);\n            return;\n        }\n        return this.auth.getProjectId();\n    }\n    /**\n     * Gets a single document.\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.name\n     *   Required. The resource name of the Document to get. In the format:\n     *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.\n     * @param {google.firestore.v1beta1.DocumentMask} request.mask\n     *   The fields to return. If not set, returns all fields.\n     *\n     *   If the document has a field that is not present in this mask, that field\n     *   will not be returned in the response.\n     * @param {Buffer} request.transaction\n     *   Reads the document in a transaction.\n     * @param {google.protobuf.Timestamp} request.readTime\n     *   Reads the version of the document at the given time.\n     *   This may not be older than 60 seconds.\n     * @param {object} [options]\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\n     * @returns {Promise} - The promise which resolves to an array.\n     *   The first element of the array is an object representing [Document]{@link google.firestore.v1beta1.Document}.\n     *   The promise has a method named \"cancel\" which cancels the ongoing API call.\n     */\n    getDocument(request, optionsOrCallback, callback) {\n        request = request || {};\n        let options;\n        if (typeof optionsOrCallback === 'function' && callback === undefined) {\n            callback = optionsOrCallback;\n            options = {};\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        options = options || {};\n        options.otherArgs = options.otherArgs || {};\n        options.otherArgs.headers = options.otherArgs.headers || {};\n        options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n            name: request.name || '',\n        });\n        this.initialize();\n        return this._innerApiCalls.getDocument(request, options, callback);\n    }\n    /**\n     * Creates a new document.\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.parent\n     *   Required. The parent resource. For example:\n     *   `projects/{project_id}/databases/{database_id}/documents` or\n     *   `projects/{project_id}/databases/{database_id}/documents/chatrooms/{chatroom_id}`\n     * @param {string} request.collectionId\n     *   Required. The collection ID, relative to `parent`, to list. For example: `chatrooms`.\n     * @param {string} request.documentId\n     *   The client-assigned document ID to use for this document.\n     *\n     *   Optional. If not specified, an ID will be assigned by the service.\n     * @param {google.firestore.v1beta1.Document} request.document\n     *   Required. The document to create. `name` must not be set.\n     * @param {google.firestore.v1beta1.DocumentMask} request.mask\n     *   The fields to return. If not set, returns all fields.\n     *\n     *   If the document has a field that is not present in this mask, that field\n     *   will not be returned in the response.\n     * @param {object} [options]\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\n     * @returns {Promise} - The promise which resolves to an array.\n     *   The first element of the array is an object representing [Document]{@link google.firestore.v1beta1.Document}.\n     *   The promise has a method named \"cancel\" which cancels the ongoing API call.\n     */\n    createDocument(request, optionsOrCallback, callback) {\n        request = request || {};\n        let options;\n        if (typeof optionsOrCallback === 'function' && callback === undefined) {\n            callback = optionsOrCallback;\n            options = {};\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        options = options || {};\n        options.otherArgs = options.otherArgs || {};\n        options.otherArgs.headers = options.otherArgs.headers || {};\n        options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n            parent: request.parent || '',\n        });\n        this.initialize();\n        return this._innerApiCalls.createDocument(request, options, callback);\n    }\n    /**\n     * Updates or inserts a document.\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {google.firestore.v1beta1.Document} request.document\n     *   Required. The updated document.\n     *   Creates the document if it does not already exist.\n     * @param {google.firestore.v1beta1.DocumentMask} request.updateMask\n     *   The fields to update.\n     *   None of the field paths in the mask may contain a reserved name.\n     *\n     *   If the document exists on the server and has fields not referenced in the\n     *   mask, they are left unchanged.\n     *   Fields referenced in the mask, but not present in the input document, are\n     *   deleted from the document on the server.\n     * @param {google.firestore.v1beta1.DocumentMask} request.mask\n     *   The fields to return. If not set, returns all fields.\n     *\n     *   If the document has a field that is not present in this mask, that field\n     *   will not be returned in the response.\n     * @param {google.firestore.v1beta1.Precondition} request.currentDocument\n     *   An optional precondition on the document.\n     *   The request will fail if this is set and not met by the target document.\n     * @param {object} [options]\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\n     * @returns {Promise} - The promise which resolves to an array.\n     *   The first element of the array is an object representing [Document]{@link google.firestore.v1beta1.Document}.\n     *   The promise has a method named \"cancel\" which cancels the ongoing API call.\n     */\n    updateDocument(request, optionsOrCallback, callback) {\n        request = request || {};\n        let options;\n        if (typeof optionsOrCallback === 'function' && callback === undefined) {\n            callback = optionsOrCallback;\n            options = {};\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        options = options || {};\n        options.otherArgs = options.otherArgs || {};\n        options.otherArgs.headers = options.otherArgs.headers || {};\n        options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n            'document.name': request.document.name || '',\n        });\n        this.initialize();\n        return this._innerApiCalls.updateDocument(request, options, callback);\n    }\n    /**\n     * Deletes a document.\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.name\n     *   Required. The resource name of the Document to delete. In the format:\n     *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.\n     * @param {google.firestore.v1beta1.Precondition} request.currentDocument\n     *   An optional precondition on the document.\n     *   The request will fail if this is set and not met by the target document.\n     * @param {object} [options]\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\n     * @returns {Promise} - The promise which resolves to an array.\n     *   The first element of the array is an object representing [Empty]{@link google.protobuf.Empty}.\n     *   The promise has a method named \"cancel\" which cancels the ongoing API call.\n     */\n    deleteDocument(request, optionsOrCallback, callback) {\n        request = request || {};\n        let options;\n        if (typeof optionsOrCallback === 'function' && callback === undefined) {\n            callback = optionsOrCallback;\n            options = {};\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        options = options || {};\n        options.otherArgs = options.otherArgs || {};\n        options.otherArgs.headers = options.otherArgs.headers || {};\n        options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n            name: request.name || '',\n        });\n        this.initialize();\n        return this._innerApiCalls.deleteDocument(request, options, callback);\n    }\n    /**\n     * Starts a new transaction.\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.database\n     *   Required. The database name. In the format:\n     *   `projects/{project_id}/databases/{database_id}`.\n     * @param {google.firestore.v1beta1.TransactionOptions} request.options\n     *   The options for the transaction.\n     *   Defaults to a read-write transaction.\n     * @param {object} [options]\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\n     * @returns {Promise} - The promise which resolves to an array.\n     *   The first element of the array is an object representing [BeginTransactionResponse]{@link google.firestore.v1beta1.BeginTransactionResponse}.\n     *   The promise has a method named \"cancel\" which cancels the ongoing API call.\n     */\n    beginTransaction(request, optionsOrCallback, callback) {\n        request = request || {};\n        let options;\n        if (typeof optionsOrCallback === 'function' && callback === undefined) {\n            callback = optionsOrCallback;\n            options = {};\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        options = options || {};\n        options.otherArgs = options.otherArgs || {};\n        options.otherArgs.headers = options.otherArgs.headers || {};\n        options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n            database: request.database || '',\n        });\n        this.initialize();\n        return this._innerApiCalls.beginTransaction(request, options, callback);\n    }\n    /**\n     * Commits a transaction, while optionally updating documents.\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.database\n     *   Required. The database name. In the format:\n     *   `projects/{project_id}/databases/{database_id}`.\n     * @param {number[]} request.writes\n     *   The writes to apply.\n     *\n     *   Always executed atomically and in order.\n     * @param {Buffer} request.transaction\n     *   If set, applies all writes in this transaction, and commits it.\n     * @param {object} [options]\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\n     * @returns {Promise} - The promise which resolves to an array.\n     *   The first element of the array is an object representing [CommitResponse]{@link google.firestore.v1beta1.CommitResponse}.\n     *   The promise has a method named \"cancel\" which cancels the ongoing API call.\n     */\n    commit(request, optionsOrCallback, callback) {\n        request = request || {};\n        let options;\n        if (typeof optionsOrCallback === 'function' && callback === undefined) {\n            callback = optionsOrCallback;\n            options = {};\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        options = options || {};\n        options.otherArgs = options.otherArgs || {};\n        options.otherArgs.headers = options.otherArgs.headers || {};\n        options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n            database: request.database || '',\n        });\n        this.initialize();\n        return this._innerApiCalls.commit(request, options, callback);\n    }\n    /**\n     * Rolls back a transaction.\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.database\n     *   Required. The database name. In the format:\n     *   `projects/{project_id}/databases/{database_id}`.\n     * @param {Buffer} request.transaction\n     *   Required. The transaction to roll back.\n     * @param {object} [options]\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\n     * @returns {Promise} - The promise which resolves to an array.\n     *   The first element of the array is an object representing [Empty]{@link google.protobuf.Empty}.\n     *   The promise has a method named \"cancel\" which cancels the ongoing API call.\n     */\n    rollback(request, optionsOrCallback, callback) {\n        request = request || {};\n        let options;\n        if (typeof optionsOrCallback === 'function' && callback === undefined) {\n            callback = optionsOrCallback;\n            options = {};\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        options = options || {};\n        options.otherArgs = options.otherArgs || {};\n        options.otherArgs.headers = options.otherArgs.headers || {};\n        options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n            database: request.database || '',\n        });\n        this.initialize();\n        return this._innerApiCalls.rollback(request, options, callback);\n    }\n    /**\n     * Gets multiple documents.\n     *\n     * Documents returned by this method are not guaranteed to be returned in the\n     * same order that they were requested.\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.database\n     *   Required. The database name. In the format:\n     *   `projects/{project_id}/databases/{database_id}`.\n     * @param {string[]} request.documents\n     *   The names of the documents to retrieve. In the format:\n     *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.\n     *   The request will fail if any of the document is not a child resource of the\n     *   given `database`. Duplicate names will be elided.\n     * @param {google.firestore.v1beta1.DocumentMask} request.mask\n     *   The fields to return. If not set, returns all fields.\n     *\n     *   If a document has a field that is not present in this mask, that field will\n     *   not be returned in the response.\n     * @param {Buffer} request.transaction\n     *   Reads documents in a transaction.\n     * @param {google.firestore.v1beta1.TransactionOptions} request.newTransaction\n     *   Starts a new transaction and reads the documents.\n     *   Defaults to a read-only transaction.\n     *   The new transaction ID will be returned as the first response in the\n     *   stream.\n     * @param {google.protobuf.Timestamp} request.readTime\n     *   Reads documents as they were at the given time.\n     *   This may not be older than 60 seconds.\n     * @param {object} [options]\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\n     * @returns {Stream}\n     *   An object stream which emits [BatchGetDocumentsResponse]{@link google.firestore.v1beta1.BatchGetDocumentsResponse} on 'data' event.\n     */\n    batchGetDocuments(request, options) {\n        request = request || {};\n        options = options || {};\n        options.otherArgs = options.otherArgs || {};\n        options.otherArgs.headers = options.otherArgs.headers || {};\n        options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n            database: request.database || '',\n        });\n        this.initialize();\n        return this._innerApiCalls.batchGetDocuments(request, options);\n    }\n    /**\n     * Runs a query.\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.parent\n     *   Required. The parent resource name. In the format:\n     *   `projects/{project_id}/databases/{database_id}/documents` or\n     *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.\n     *   For example:\n     *   `projects/my-project/databases/my-database/documents` or\n     *   `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`\n     * @param {google.firestore.v1beta1.StructuredQuery} request.structuredQuery\n     *   A structured query.\n     * @param {Buffer} request.transaction\n     *   Reads documents in a transaction.\n     * @param {google.firestore.v1beta1.TransactionOptions} request.newTransaction\n     *   Starts a new transaction and reads the documents.\n     *   Defaults to a read-only transaction.\n     *   The new transaction ID will be returned as the first response in the\n     *   stream.\n     * @param {google.protobuf.Timestamp} request.readTime\n     *   Reads documents as they were at the given time.\n     *   This may not be older than 60 seconds.\n     * @param {object} [options]\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\n     * @returns {Stream}\n     *   An object stream which emits [RunQueryResponse]{@link google.firestore.v1beta1.RunQueryResponse} on 'data' event.\n     */\n    runQuery(request, options) {\n        request = request || {};\n        options = options || {};\n        options.otherArgs = options.otherArgs || {};\n        options.otherArgs.headers = options.otherArgs.headers || {};\n        options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n            parent: request.parent || '',\n        });\n        this.initialize();\n        return this._innerApiCalls.runQuery(request, options);\n    }\n    /**\n     * Streams batches of document updates and deletes, in order.\n     *\n     * @param {object} [options]\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\n     * @returns {Stream}\n     *   An object stream which is both readable and writable. It accepts objects\n     *   representing [WriteRequest]{@link google.firestore.v1beta1.WriteRequest} for write() method, and\n     *   will emit objects representing [WriteResponse]{@link google.firestore.v1beta1.WriteResponse} on 'data' event asynchronously.\n     */\n    write(options) {\n        this.initialize();\n        return this._innerApiCalls.write(options);\n    }\n    /**\n     * Listens to changes.\n     *\n     * @param {object} [options]\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\n     * @returns {Stream}\n     *   An object stream which is both readable and writable. It accepts objects\n     *   representing [ListenRequest]{@link google.firestore.v1beta1.ListenRequest} for write() method, and\n     *   will emit objects representing [ListenResponse]{@link google.firestore.v1beta1.ListenResponse} on 'data' event asynchronously.\n     */\n    listen(options) {\n        this.initialize();\n        return this._innerApiCalls.listen({}, options);\n    }\n    /**\n     * Lists documents.\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.parent\n     *   Required. The parent resource name. In the format:\n     *   `projects/{project_id}/databases/{database_id}/documents` or\n     *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.\n     *   For example:\n     *   `projects/my-project/databases/my-database/documents` or\n     *   `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`\n     * @param {string} request.collectionId\n     *   Required. The collection ID, relative to `parent`, to list. For example: `chatrooms`\n     *   or `messages`.\n     * @param {number} request.pageSize\n     *   The maximum number of documents to return.\n     * @param {string} request.pageToken\n     *   The `next_page_token` value returned from a previous List request, if any.\n     * @param {string} request.orderBy\n     *   The order to sort results by. For example: `priority desc, name`.\n     * @param {google.firestore.v1beta1.DocumentMask} request.mask\n     *   The fields to return. If not set, returns all fields.\n     *\n     *   If a document has a field that is not present in this mask, that field\n     *   will not be returned in the response.\n     * @param {Buffer} request.transaction\n     *   Reads documents in a transaction.\n     * @param {google.protobuf.Timestamp} request.readTime\n     *   Reads documents as they were at the given time.\n     *   This may not be older than 60 seconds.\n     * @param {boolean} request.showMissing\n     *   If the list should show missing documents. A missing document is a\n     *   document that does not exist but has sub-documents. These documents will\n     *   be returned with a key but will not have fields, {@link google.firestore.v1beta1.Document.create_time|Document.create_time},\n     *   or {@link google.firestore.v1beta1.Document.update_time|Document.update_time} set.\n     *\n     *   Requests with `show_missing` may not specify `where` or\n     *   `order_by`.\n     * @param {object} [options]\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\n     * @returns {Promise} - The promise which resolves to an array.\n     *   The first element of the array is Array of [Document]{@link google.firestore.v1beta1.Document}.\n     *   The client library support auto-pagination by default: it will call the API as many\n     *   times as needed and will merge results from all the pages into this array.\n     *\n     *   When autoPaginate: false is specified through options, the array has three elements.\n     *   The first element is Array of [Document]{@link google.firestore.v1beta1.Document} that corresponds to\n     *   the one page received from the API server.\n     *   If the second element is not null it contains the request object of type [ListDocumentsRequest]{@link google.firestore.v1beta1.ListDocumentsRequest}\n     *   that can be used to obtain the next page of the results.\n     *   If it is null, the next page does not exist.\n     *   The third element contains the raw response received from the API server. Its type is\n     *   [ListDocumentsResponse]{@link google.firestore.v1beta1.ListDocumentsResponse}.\n     *\n     *   The promise has a method named \"cancel\" which cancels the ongoing API call.\n     */\n    listDocuments(request, optionsOrCallback, callback) {\n        request = request || {};\n        let options;\n        if (typeof optionsOrCallback === 'function' && callback === undefined) {\n            callback = optionsOrCallback;\n            options = {};\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        options = options || {};\n        options.otherArgs = options.otherArgs || {};\n        options.otherArgs.headers = options.otherArgs.headers || {};\n        options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n            parent: request.parent || '',\n        });\n        this.initialize();\n        return this._innerApiCalls.listDocuments(request, options, callback);\n    }\n    /**\n     * Equivalent to {@link listDocuments}, but returns a NodeJS Stream object.\n     *\n     * This fetches the paged responses for {@link listDocuments} continuously\n     * and invokes the callback registered for 'data' event for each element in the\n     * responses.\n     *\n     * The returned object has 'end' method when no more elements are required.\n     *\n     * autoPaginate option will be ignored.\n     *\n     * @see {@link https://nodejs.org/api/stream.html}\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.parent\n     *   Required. The parent resource name. In the format:\n     *   `projects/{project_id}/databases/{database_id}/documents` or\n     *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.\n     *   For example:\n     *   `projects/my-project/databases/my-database/documents` or\n     *   `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`\n     * @param {string} request.collectionId\n     *   Required. The collection ID, relative to `parent`, to list. For example: `chatrooms`\n     *   or `messages`.\n     * @param {number} request.pageSize\n     *   The maximum number of documents to return.\n     * @param {string} request.pageToken\n     *   The `next_page_token` value returned from a previous List request, if any.\n     * @param {string} request.orderBy\n     *   The order to sort results by. For example: `priority desc, name`.\n     * @param {google.firestore.v1beta1.DocumentMask} request.mask\n     *   The fields to return. If not set, returns all fields.\n     *\n     *   If a document has a field that is not present in this mask, that field\n     *   will not be returned in the response.\n     * @param {Buffer} request.transaction\n     *   Reads documents in a transaction.\n     * @param {google.protobuf.Timestamp} request.readTime\n     *   Reads documents as they were at the given time.\n     *   This may not be older than 60 seconds.\n     * @param {boolean} request.showMissing\n     *   If the list should show missing documents. A missing document is a\n     *   document that does not exist but has sub-documents. These documents will\n     *   be returned with a key but will not have fields, {@link google.firestore.v1beta1.Document.create_time|Document.create_time},\n     *   or {@link google.firestore.v1beta1.Document.update_time|Document.update_time} set.\n     *\n     *   Requests with `show_missing` may not specify `where` or\n     *   `order_by`.\n     * @param {object} [options]\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\n     * @returns {Stream}\n     *   An object stream which emits an object representing [Document]{@link google.firestore.v1beta1.Document} on 'data' event.\n     */\n    listDocumentsStream(request, options) {\n        request = request || {};\n        options = options || {};\n        options.otherArgs = options.otherArgs || {};\n        options.otherArgs.headers = options.otherArgs.headers || {};\n        options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n            parent: request.parent || '',\n        });\n        const callSettings = new gax.CallSettings(options);\n        this.initialize();\n        return this._descriptors.page.listDocuments.createStream(this._innerApiCalls.listDocuments, request, callSettings);\n    }\n    /**\n     * Lists all the collection IDs underneath a document.\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.parent\n     *   Required. The parent document. In the format:\n     *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.\n     *   For example:\n     *   `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`\n     * @param {number} request.pageSize\n     *   The maximum number of results to return.\n     * @param {string} request.pageToken\n     *   A page token. Must be a value from\n     *   {@link google.firestore.v1beta1.ListCollectionIdsResponse|ListCollectionIdsResponse}.\n     * @param {object} [options]\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\n     * @returns {Promise} - The promise which resolves to an array.\n     *   The first element of the array is Array of string.\n     *   The client library support auto-pagination by default: it will call the API as many\n     *   times as needed and will merge results from all the pages into this array.\n     *\n     *   When autoPaginate: false is specified through options, the array has three elements.\n     *   The first element is Array of string that corresponds to\n     *   the one page received from the API server.\n     *   If the second element is not null it contains the request object of type [ListCollectionIdsRequest]{@link google.firestore.v1beta1.ListCollectionIdsRequest}\n     *   that can be used to obtain the next page of the results.\n     *   If it is null, the next page does not exist.\n     *   The third element contains the raw response received from the API server. Its type is\n     *   [ListCollectionIdsResponse]{@link google.firestore.v1beta1.ListCollectionIdsResponse}.\n     *\n     *   The promise has a method named \"cancel\" which cancels the ongoing API call.\n     */\n    listCollectionIds(request, optionsOrCallback, callback) {\n        request = request || {};\n        let options;\n        if (typeof optionsOrCallback === 'function' && callback === undefined) {\n            callback = optionsOrCallback;\n            options = {};\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        options = options || {};\n        options.otherArgs = options.otherArgs || {};\n        options.otherArgs.headers = options.otherArgs.headers || {};\n        options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n            parent: request.parent || '',\n        });\n        this.initialize();\n        return this._innerApiCalls.listCollectionIds(request, options, callback);\n    }\n    /**\n     * Equivalent to {@link listCollectionIds}, but returns a NodeJS Stream object.\n     *\n     * This fetches the paged responses for {@link listCollectionIds} continuously\n     * and invokes the callback registered for 'data' event for each element in the\n     * responses.\n     *\n     * The returned object has 'end' method when no more elements are required.\n     *\n     * autoPaginate option will be ignored.\n     *\n     * @see {@link https://nodejs.org/api/stream.html}\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.parent\n     *   Required. The parent document. In the format:\n     *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.\n     *   For example:\n     *   `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`\n     * @param {number} request.pageSize\n     *   The maximum number of results to return.\n     * @param {string} request.pageToken\n     *   A page token. Must be a value from\n     *   {@link google.firestore.v1beta1.ListCollectionIdsResponse|ListCollectionIdsResponse}.\n     * @param {object} [options]\n     *   Call options. See {@link https://googleapis.dev/nodejs/google-gax/latest/interfaces/CallOptions.html|CallOptions} for more details.\n     * @returns {Stream}\n     *   An object stream which emits an object representing string on 'data' event.\n     */\n    listCollectionIdsStream(request, options) {\n        request = request || {};\n        options = options || {};\n        options.otherArgs = options.otherArgs || {};\n        options.otherArgs.headers = options.otherArgs.headers || {};\n        options.otherArgs.headers['x-goog-request-params'] = gax.routingHeader.fromParams({\n            parent: request.parent || '',\n        });\n        const callSettings = new gax.CallSettings(options);\n        this.initialize();\n        return this._descriptors.page.listCollectionIds.createStream(this._innerApiCalls.listCollectionIds, request, callSettings);\n    }\n    /**\n     * Terminate the GRPC channel and close the client.\n     *\n     * The client will no longer be usable and all future behavior is undefined.\n     */\n    close() {\n        this.initialize();\n        if (!this._terminated) {\n            return this.firestoreStub.then(stub => {\n                this._terminated = true;\n                stub.close();\n            });\n        }\n        return Promise.resolve();\n    }\n}\nexports.FirestoreClient = FirestoreClient;\n//# sourceMappingURL=firestore_client.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/firestore/build/src/v1beta1/firestore_client.js?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/firestore/build/src/v1beta1/firestore_client_config.json":
/*!*************************************************************************************************!*\
  !*** ./src/node_modules/@google-cloud/firestore/build/src/v1beta1/firestore_client_config.json ***!
  \*************************************************************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"interfaces\":{\"google.firestore.v1beta1.Firestore\":{\"retry_codes\":{\"non_idempotent\":[],\"idempotent\":[\"DEADLINE_EXCEEDED\",\"UNAVAILABLE\"]},\"retry_params\":{\"default\":{\"initial_retry_delay_millis\":100,\"retry_delay_multiplier\":1.3,\"max_retry_delay_millis\":60000,\"initial_rpc_timeout_millis\":60000,\"rpc_timeout_multiplier\":1,\"max_rpc_timeout_millis\":60000,\"total_timeout_millis\":600000}},\"methods\":{\"GetDocument\":{\"timeout_millis\":60000,\"retry_codes_name\":\"idempotent\",\"retry_params_name\":\"default\"},\"ListDocuments\":{\"timeout_millis\":60000,\"retry_codes_name\":\"idempotent\",\"retry_params_name\":\"default\"},\"CreateDocument\":{\"timeout_millis\":60000,\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"UpdateDocument\":{\"timeout_millis\":60000,\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"DeleteDocument\":{\"timeout_millis\":60000,\"retry_codes_name\":\"idempotent\",\"retry_params_name\":\"default\"},\"BatchGetDocuments\":{\"timeout_millis\":300000,\"retry_codes_name\":\"idempotent\",\"retry_params_name\":\"default\"},\"BeginTransaction\":{\"timeout_millis\":60000,\"retry_codes_name\":\"idempotent\",\"retry_params_name\":\"default\"},\"Commit\":{\"timeout_millis\":60000,\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"Rollback\":{\"timeout_millis\":60000,\"retry_codes_name\":\"idempotent\",\"retry_params_name\":\"default\"},\"RunQuery\":{\"timeout_millis\":300000,\"retry_codes_name\":\"idempotent\",\"retry_params_name\":\"default\"},\"Write\":{\"timeout_millis\":86400000,\"retry_codes_name\":\"non_idempotent\",\"retry_params_name\":\"default\"},\"Listen\":{\"timeout_millis\":86400000,\"retry_codes_name\":\"idempotent\",\"retry_params_name\":\"default\"},\"ListCollectionIds\":{\"timeout_millis\":60000,\"retry_codes_name\":\"idempotent\",\"retry_params_name\":\"default\"}}}}}');\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/firestore/build/src/v1beta1/firestore_client_config.json?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/firestore/build/src/v1beta1/index.js":
/*!*****************************************************************************!*\
  !*** ./src/node_modules/@google-cloud/firestore/build/src/v1beta1/index.js ***!
  \*****************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ** This file is automatically generated by gapic-generator-typescript. **\n// ** https://github.com/googleapis/gapic-generator-typescript **\n// ** All changes to this file may be overwritten. **\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst firestore_client_1 = __webpack_require__(/*! ./firestore_client */ \"./src/node_modules/@google-cloud/firestore/build/src/v1beta1/firestore_client.js\");\nexports.FirestoreClient = firestore_client_1.FirestoreClient;\n// Doing something really horrible for reverse compatibility with original JavaScript exports\nconst existingExports = module.exports;\nmodule.exports = firestore_client_1.FirestoreClient;\nmodule.exports = Object.assign(module.exports, existingExports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/firestore/build/src/v1beta1/index.js?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/firestore/build/src/validate.js":
/*!************************************************************************!*\
  !*** ./src/node_modules/@google-cloud/firestore/build/src/validate.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nconst util_1 = __webpack_require__(/*! ./util */ \"./src/node_modules/@google-cloud/firestore/build/src/util.js\");\n/**\n * Generates an error message to use with custom objects that cannot be\n * serialized.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The value that failed serialization.\n * @param path The field path that the object is assigned to.\n */\nfunction customObjectMessage(arg, value, path) {\n    const fieldPathMessage = path ? ` (found in field \"${path}\")` : '';\n    if (util_1.isObject(value)) {\n        // We use the base class name as the type name as the sentinel classes\n        // returned by the public FieldValue API are subclasses of FieldValue. By\n        // using the base name, we reduce the number of special cases below.\n        const typeName = value.constructor.name;\n        switch (typeName) {\n            case 'DocumentReference':\n            case 'FieldPath':\n            case 'FieldValue':\n            case 'GeoPoint':\n            case 'Timestamp':\n                return (`${invalidArgumentMessage(arg, 'Firestore document')} Detected an object of type \"${typeName}\" that doesn't match the ` +\n                    `expected instance${fieldPathMessage}. Please ensure that the ` +\n                    'Firestore types you are using are from the same NPM package.)');\n            case 'Object':\n                return `${invalidArgumentMessage(arg, 'Firestore document')} Invalid use of type \"${typeof value}\" as a Firestore argument${fieldPathMessage}.`;\n            default:\n                return (`${invalidArgumentMessage(arg, 'Firestore document')} Couldn't serialize object of type \"${typeName}\"${fieldPathMessage}. Firestore doesn't support JavaScript ` +\n                    'objects with custom prototypes (i.e. objects that were created ' +\n                    'via the \"new\" operator).');\n        }\n    }\n    else {\n        return `${invalidArgumentMessage(arg, 'Firestore document')} Input is not a plain JavaScript object${fieldPathMessage}.`;\n    }\n}\nexports.customObjectMessage = customObjectMessage;\n/**\n * Validates that 'value' is a function.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n * @param options Options that specify whether the function can be omitted.\n */\nfunction validateFunction(arg, value, options) {\n    if (!validateOptional(value, options)) {\n        if (!util_1.isFunction(value)) {\n            throw new Error(invalidArgumentMessage(arg, 'function'));\n        }\n    }\n}\nexports.validateFunction = validateFunction;\n/**\n * Validates that 'value' is an object.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n * @param options Options that specify whether the object can be omitted.\n */\nfunction validateObject(arg, value, options) {\n    if (!validateOptional(value, options)) {\n        if (!util_1.isObject(value)) {\n            throw new Error(invalidArgumentMessage(arg, 'object'));\n        }\n    }\n}\nexports.validateObject = validateObject;\n/**\n * Validates that 'value' is a string.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n * @param options Options that specify whether the string can be omitted.\n */\nfunction validateString(arg, value, options) {\n    if (!validateOptional(value, options)) {\n        if (typeof value !== 'string') {\n            throw new Error(invalidArgumentMessage(arg, 'string'));\n        }\n    }\n}\nexports.validateString = validateString;\n/**\n * Validates that 'value' is a host.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n * @param options Options that specify whether the host can be omitted.\n */\nfunction validateHost(arg, value, options) {\n    if (!validateOptional(value, options)) {\n        validateString(arg, value);\n        const urlString = `http://${value}/`;\n        let parsed;\n        try {\n            parsed = new url_1.URL(urlString);\n        }\n        catch (e) {\n            throw new Error(invalidArgumentMessage(arg, 'host'));\n        }\n        if (parsed.search !== '' ||\n            parsed.pathname !== '/' ||\n            parsed.username !== '') {\n            throw new Error(invalidArgumentMessage(arg, 'host'));\n        }\n    }\n}\nexports.validateHost = validateHost;\n/**\n * Validates that 'value' is a boolean.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n * @param options Options that specify whether the boolean can be omitted.\n */\nfunction validateBoolean(arg, value, options) {\n    if (!validateOptional(value, options)) {\n        if (typeof value !== 'boolean') {\n            throw new Error(invalidArgumentMessage(arg, 'boolean'));\n        }\n    }\n}\nexports.validateBoolean = validateBoolean;\n/**\n * Validates that 'value' is a number.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n * @param options Options that specify whether the number can be omitted.\n */\nfunction validateNumber(arg, value, options) {\n    const min = options !== undefined && options.minValue !== undefined\n        ? options.minValue\n        : -Infinity;\n    const max = options !== undefined && options.maxValue !== undefined\n        ? options.maxValue\n        : Infinity;\n    if (!validateOptional(value, options)) {\n        if (typeof value !== 'number' || isNaN(value)) {\n            throw new Error(invalidArgumentMessage(arg, 'number'));\n        }\n        else if (value < min || value > max) {\n            throw new Error(`${formatArgumentName(arg)} must be within [${min}, ${max}] inclusive, but was: ${value}`);\n        }\n    }\n}\nexports.validateNumber = validateNumber;\n/**\n * Validates that 'value' is a integer.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n * @param options Options that specify whether the integer can be omitted.\n */\nfunction validateInteger(arg, value, options) {\n    const min = options !== undefined && options.minValue !== undefined\n        ? options.minValue\n        : -Infinity;\n    const max = options !== undefined && options.maxValue !== undefined\n        ? options.maxValue\n        : Infinity;\n    if (!validateOptional(value, options)) {\n        if (typeof value !== 'number' || isNaN(value) || value % 1 !== 0) {\n            throw new Error(invalidArgumentMessage(arg, 'integer'));\n        }\n        else if (value < min || value > max) {\n            throw new Error(`${formatArgumentName(arg)} must be within [${min}, ${max}] inclusive, but was: ${value}`);\n        }\n    }\n}\nexports.validateInteger = validateInteger;\n/**\n * Generates an error message to use with invalid arguments.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param expectedType The expected input type.\n */\nfunction invalidArgumentMessage(arg, expectedType) {\n    return `${formatArgumentName(arg)} is not a valid ${expectedType}.`;\n}\nexports.invalidArgumentMessage = invalidArgumentMessage;\n/**\n * Enforces the 'options.optional' constraint for 'value'.\n *\n * @private\n * @param value The input to validate.\n * @param options Whether the function can be omitted.\n * @return Whether the object is omitted and is allowed to be omitted.\n */\nfunction validateOptional(value, options) {\n    return (value === undefined && options !== undefined && options.optional === true);\n}\nexports.validateOptional = validateOptional;\n/**\n * Formats the given word as plural conditionally given the preceding number.\n *\n * @private\n * @param num The number to use for formatting.\n * @param str The string to format.\n */\nfunction formatPlural(num, str) {\n    return `${num} ${str}` + (num === 1 ? '' : 's');\n}\n/**\n * Creates a descriptive name for the provided argument name or index.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @return Either the argument name or its index description.\n */\nfunction formatArgumentName(arg) {\n    return typeof arg === 'string'\n        ? `Value for argument \"${arg}\"`\n        : `Element at index ${arg}`;\n}\n/**\n * Verifies that 'args' has at least 'minSize' elements.\n *\n * @private\n * @param funcName The function name to use in the error message.\n * @param args The array (or array-like structure) to verify.\n * @param minSize The minimum number of elements to enforce.\n * @throws if the expectation is not met.\n */\nfunction validateMinNumberOfArguments(funcName, args, minSize) {\n    if (args.length < minSize) {\n        throw new Error(`Function \"${funcName}()\" requires at least ` +\n            `${formatPlural(minSize, 'argument')}.`);\n    }\n}\nexports.validateMinNumberOfArguments = validateMinNumberOfArguments;\n/**\n * Verifies that 'args' has at most 'maxSize' elements.\n *\n * @private\n * @param funcName The function name to use in the error message.\n * @param args The array (or array-like structure) to verify.\n * @param maxSize The maximum number of elements to enforce.\n * @throws if the expectation is not met.\n */\nfunction validateMaxNumberOfArguments(funcName, args, maxSize) {\n    if (args.length > maxSize) {\n        throw new Error(`Function \"${funcName}()\" accepts at most ` +\n            `${formatPlural(maxSize, 'argument')}.`);\n    }\n}\nexports.validateMaxNumberOfArguments = validateMaxNumberOfArguments;\n/**\n * Validates that the provided named option equals one of the expected values.\n *\n * @param arg The argument name or argument index (for varargs methods).).\n * @param value The input to validate.\n * @param allowedValues A list of expected values.\n * @param options Whether the input can be omitted.\n * @private\n */\nfunction validateEnumValue(arg, value, allowedValues, options) {\n    if (!validateOptional(value, options)) {\n        const expectedDescription = [];\n        for (const allowed of allowedValues) {\n            if (allowed === value) {\n                return;\n            }\n            expectedDescription.push(allowed);\n        }\n        throw new Error(`${formatArgumentName(arg)} is invalid. Acceptable values are: ${expectedDescription.join(', ')}`);\n    }\n}\nexports.validateEnumValue = validateEnumValue;\n//# sourceMappingURL=validate.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/firestore/build/src/validate.js?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/firestore/build/src/watch.js":
/*!*********************************************************************!*\
  !*** ./src/node_modules/@google-cloud/firestore/build/src/watch.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst rbtree = __webpack_require__(/*! functional-red-black-tree */ \"./src/node_modules/functional-red-black-tree/rbtree.js\");\nconst google_gax_1 = __webpack_require__(/*! google-gax */ \"google-gax\");\nconst backoff_1 = __webpack_require__(/*! ./backoff */ \"./src/node_modules/@google-cloud/firestore/build/src/backoff.js\");\nconst document_1 = __webpack_require__(/*! ./document */ \"./src/node_modules/@google-cloud/firestore/build/src/document.js\");\nconst document_change_1 = __webpack_require__(/*! ./document-change */ \"./src/node_modules/@google-cloud/firestore/build/src/document-change.js\");\nconst logger_1 = __webpack_require__(/*! ./logger */ \"./src/node_modules/@google-cloud/firestore/build/src/logger.js\");\nconst path_1 = __webpack_require__(/*! ./path */ \"./src/node_modules/@google-cloud/firestore/build/src/path.js\");\nconst timestamp_1 = __webpack_require__(/*! ./timestamp */ \"./src/node_modules/@google-cloud/firestore/build/src/timestamp.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"./src/node_modules/@google-cloud/firestore/build/src/types.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"./src/node_modules/@google-cloud/firestore/build/src/util.js\");\n/*!\n * Target ID used by watch. Watch uses a fixed target id since we only support\n * one target per stream.\n * @type {number}\n */\nconst WATCH_TARGET_ID = 0x1;\n/**\n * Idle timeout used to detect Watch streams that stall (see\n * https://github.com/googleapis/nodejs-firestore/issues/1057, b/156308554).\n * Under normal load, the Watch backend will send a TARGET_CHANGE message\n * roughly every 30 seconds. As discussed with the backend team, we reset the\n * Watch stream if we do not receive any message within 120 seconds.\n */\nexports.WATCH_IDLE_TIMEOUT_MS = 120 * 1000;\n/*!\n * Sentinel value for a document remove.\n */\n// tslint:disable-next-line:no-any\nconst REMOVED = {};\n/*!\n * The change type for document change events.\n */\n// tslint:disable-next-line:variable-name\nconst ChangeType = {\n    added: 'added',\n    modified: 'modified',\n    removed: 'removed',\n};\n/*!\n * The comparator used for document watches (which should always get called with\n * the same document).\n */\nconst DOCUMENT_WATCH_COMPARATOR = (doc1, doc2) => {\n    assert(doc1 === doc2, 'Document watches only support one document.');\n    return 0;\n};\nconst EMPTY_FUNCTION = () => { };\n/**\n * Watch provides listen functionality and exposes the 'onSnapshot' observer. It\n * can be used with a valid Firestore Listen target.\n *\n * @class\n * @private\n */\nclass Watch {\n    /**\n     * @private\n     * @hideconstructor\n     *\n     * @param firestore The Firestore Database client.\n     */\n    constructor(firestore, _converter = types_1.defaultConverter) {\n        this._converter = _converter;\n        /**\n         * Indicates whether we are interested in data from the stream. Set to false in the\n         * 'unsubscribe()' callback.\n         * @private\n         */\n        this.isActive = true;\n        /**\n         * The current stream to the backend.\n         * @private\n         */\n        this.currentStream = null;\n        /**\n         * The server assigns and updates the resume token.\n         * @private\n         */\n        this.resumeToken = undefined;\n        /**\n         * A map of document names to QueryDocumentSnapshots for the last sent snapshot.\n         * @private\n         */\n        this.docMap = new Map();\n        /**\n         * The accumulated map of document changes (keyed by document name) for the\n         * current snapshot.\n         * @private\n         */\n        this.changeMap = new Map();\n        /**\n         * The current state of the query results. *\n         * @private\n         */\n        this.current = false;\n        /**\n         * We need this to track whether we've pushed an initial set of changes,\n         * since we should push those even when there are no changes, if there\n         * aren't docs.\n         * @private\n         */\n        this.hasPushed = false;\n        this.firestore = firestore;\n        this.backoff = new backoff_1.ExponentialBackoff();\n        this.requestTag = util_1.requestTag();\n        this.onNext = EMPTY_FUNCTION;\n        this.onError = EMPTY_FUNCTION;\n    }\n    /**\n     * Starts a watch and attaches a listener for document change events.\n     *\n     * @private\n     * @param onNext A callback to be called every time a new snapshot is\n     * available.\n     * @param onError A callback to be called if the listen fails or is cancelled.\n     * No further callbacks will occur.\n     *\n     * @returns An unsubscribe function that can be called to cancel the snapshot\n     * listener.\n     */\n    onSnapshot(onNext, onError) {\n        assert(this.onNext === EMPTY_FUNCTION, 'onNext should not already be defined.');\n        assert(this.onError === EMPTY_FUNCTION, 'onError should not already be defined.');\n        assert(this.docTree === undefined, 'docTree should not already be defined.');\n        this.onNext = onNext;\n        this.onError = onError;\n        this.docTree = rbtree(this.getComparator());\n        this.initStream();\n        const unsubscribe = () => {\n            logger_1.logger('Watch.onSnapshot', this.requestTag, 'Unsubscribe called');\n            // Prevent further callbacks.\n            this.onNext = () => { };\n            this.onError = () => { };\n            this.shutdown();\n        };\n        this.firestore.registerListener();\n        return unsubscribe;\n    }\n    /**\n     * Returns the current count of all documents, including the changes from\n     * the current changeMap.\n     * @private\n     */\n    currentSize() {\n        const changes = this.extractCurrentChanges(timestamp_1.Timestamp.now());\n        return this.docMap.size + changes.adds.length - changes.deletes.length;\n    }\n    /**\n     * Splits up document changes into removals, additions, and updates.\n     * @private\n     */\n    extractCurrentChanges(readTime) {\n        const deletes = [];\n        const adds = [];\n        const updates = [];\n        this.changeMap.forEach((value, name) => {\n            if (value === REMOVED) {\n                if (this.docMap.has(name)) {\n                    deletes.push(name);\n                }\n            }\n            else if (this.docMap.has(name)) {\n                value.readTime = readTime;\n                updates.push(value.build());\n            }\n            else {\n                value.readTime = readTime;\n                adds.push(value.build());\n            }\n        });\n        return { deletes, adds, updates };\n    }\n    /**\n     * Helper to clear the docs on RESET or filter mismatch.\n     * @private\n     */\n    resetDocs() {\n        logger_1.logger('Watch.resetDocs', this.requestTag, 'Resetting documents');\n        this.changeMap.clear();\n        this.resumeToken = undefined;\n        this.docTree.forEach((snapshot) => {\n            // Mark each document as deleted. If documents are not deleted, they\n            // will be send again by the server.\n            this.changeMap.set(snapshot.ref.path, REMOVED);\n        });\n        this.current = false;\n    }\n    /**\n     * Closes the stream and calls onError() if the stream is still active.\n     * @private\n     */\n    closeStream(err) {\n        if (this.isActive) {\n            logger_1.logger('Watch.closeStream', this.requestTag, 'Invoking onError: ', err);\n            this.onError(err);\n        }\n        this.shutdown();\n    }\n    /**\n     * Re-opens the stream unless the specified error is considered permanent.\n     * Clears the change map.\n     * @private\n     */\n    maybeReopenStream(err) {\n        if (this.isActive && !this.isPermanentWatchError(err)) {\n            logger_1.logger('Watch.maybeReopenStream', this.requestTag, 'Stream ended, re-opening after retryable error:', err);\n            this.changeMap.clear();\n            if (this.isResourceExhaustedError(err)) {\n                this.backoff.resetToMax();\n            }\n            this.initStream();\n        }\n        else {\n            this.closeStream(err);\n        }\n    }\n    /**\n     * Cancels the current idle timeout and reschedules a new timer.\n     *\n     * @private\n     */\n    resetIdleTimeout() {\n        if (this.idleTimeoutHandle) {\n            clearTimeout(this.idleTimeoutHandle);\n        }\n        this.idleTimeoutHandle = backoff_1.delayExecution(() => {\n            var _a;\n            logger_1.logger('Watch.resetIdleTimeout', this.requestTag, 'Resetting stream after idle timeout');\n            (_a = this.currentStream) === null || _a === void 0 ? void 0 : _a.end();\n            this.currentStream = null;\n            const error = new google_gax_1.GoogleError('Watch stream idle timeout');\n            error.code = google_gax_1.Status.UNKNOWN;\n            this.maybeReopenStream(error);\n        }, exports.WATCH_IDLE_TIMEOUT_MS);\n    }\n    /**\n     * Helper to restart the outgoing stream to the backend.\n     * @private\n     */\n    resetStream() {\n        logger_1.logger('Watch.resetStream', this.requestTag, 'Restarting stream');\n        if (this.currentStream) {\n            this.currentStream.end();\n            this.currentStream = null;\n        }\n        this.initStream();\n    }\n    /**\n     * Initializes a new stream to the backend with backoff.\n     * @private\n     */\n    initStream() {\n        this.backoff\n            .backoffAndWait()\n            .then(async () => {\n            if (!this.isActive) {\n                logger_1.logger('Watch.initStream', this.requestTag, 'Not initializing inactive stream');\n                return;\n            }\n            await this.firestore.initializeIfNeeded(this.requestTag);\n            const request = {};\n            request.database = this.firestore.formattedName;\n            request.addTarget = this.getTarget(this.resumeToken);\n            // Note that we need to call the internal _listen API to pass additional\n            // header values in readWriteStream.\n            return this.firestore\n                .requestStream('listen', request, this.requestTag)\n                .then(backendStream => {\n                if (!this.isActive) {\n                    logger_1.logger('Watch.initStream', this.requestTag, 'Closing inactive stream');\n                    backendStream.emit('end');\n                    return;\n                }\n                logger_1.logger('Watch.initStream', this.requestTag, 'Opened new stream');\n                this.currentStream = backendStream;\n                this.resetIdleTimeout();\n                this.currentStream.on('data', (proto) => {\n                    this.resetIdleTimeout();\n                    this.onData(proto);\n                })\n                    .on('error', err => {\n                    if (this.currentStream === backendStream) {\n                        this.currentStream = null;\n                        this.maybeReopenStream(err);\n                    }\n                })\n                    .on('end', () => {\n                    if (this.currentStream === backendStream) {\n                        this.currentStream = null;\n                        const err = new google_gax_1.GoogleError('Stream ended unexpectedly');\n                        err.code = google_gax_1.Status.UNKNOWN;\n                        this.maybeReopenStream(err);\n                    }\n                });\n                this.currentStream.resume();\n            });\n        })\n            .catch(err => {\n            this.closeStream(err);\n        });\n    }\n    /**\n     * Handles 'data' events and closes the stream if the response type is\n     * invalid.\n     * @private\n     */\n    onData(proto) {\n        if (proto.targetChange) {\n            logger_1.logger('Watch.onData', this.requestTag, 'Processing target change');\n            const change = proto.targetChange;\n            const noTargetIds = !change.targetIds || change.targetIds.length === 0;\n            if (change.targetChangeType === 'NO_CHANGE') {\n                if (noTargetIds && change.readTime && this.current) {\n                    // This means everything is up-to-date, so emit the current\n                    // set of docs as a snapshot, if there were changes.\n                    this.pushSnapshot(timestamp_1.Timestamp.fromProto(change.readTime), change.resumeToken);\n                }\n            }\n            else if (change.targetChangeType === 'ADD') {\n                if (WATCH_TARGET_ID !== change.targetIds[0]) {\n                    this.closeStream(Error('Unexpected target ID sent by server'));\n                }\n            }\n            else if (change.targetChangeType === 'REMOVE') {\n                let code = google_gax_1.Status.INTERNAL;\n                let message = 'internal error';\n                if (change.cause) {\n                    code = change.cause.code;\n                    message = change.cause.message;\n                }\n                // @todo: Surface a .code property on the exception.\n                this.closeStream(new Error('Error ' + code + ': ' + message));\n            }\n            else if (change.targetChangeType === 'RESET') {\n                // Whatever changes have happened so far no longer matter.\n                this.resetDocs();\n            }\n            else if (change.targetChangeType === 'CURRENT') {\n                this.current = true;\n            }\n            else {\n                this.closeStream(new Error('Unknown target change type: ' + JSON.stringify(change)));\n            }\n            if (change.resumeToken &&\n                this.affectsTarget(change.targetIds, WATCH_TARGET_ID)) {\n                this.backoff.reset();\n            }\n        }\n        else if (proto.documentChange) {\n            logger_1.logger('Watch.onData', this.requestTag, 'Processing change event');\n            // No other targetIds can show up here, but we still need to see\n            // if the targetId was in the added list or removed list.\n            const targetIds = proto.documentChange.targetIds || [];\n            const removedTargetIds = proto.documentChange.removedTargetIds || [];\n            let changed = false;\n            let removed = false;\n            for (let i = 0; i < targetIds.length; i++) {\n                if (targetIds[i] === WATCH_TARGET_ID) {\n                    changed = true;\n                }\n            }\n            for (let i = 0; i < removedTargetIds.length; i++) {\n                if (removedTargetIds[i] === WATCH_TARGET_ID) {\n                    removed = true;\n                }\n            }\n            const document = proto.documentChange.document;\n            const name = document.name;\n            const relativeName = path_1.QualifiedResourcePath.fromSlashSeparatedString(name)\n                .relativeName;\n            if (changed) {\n                logger_1.logger('Watch.onData', this.requestTag, 'Received document change');\n                const ref = this.firestore.doc(relativeName);\n                const snapshot = new document_1.DocumentSnapshotBuilder(ref.withConverter(this._converter));\n                snapshot.fieldsProto = document.fields || {};\n                snapshot.createTime = timestamp_1.Timestamp.fromProto(document.createTime);\n                snapshot.updateTime = timestamp_1.Timestamp.fromProto(document.updateTime);\n                this.changeMap.set(relativeName, snapshot);\n            }\n            else if (removed) {\n                logger_1.logger('Watch.onData', this.requestTag, 'Received document remove');\n                this.changeMap.set(relativeName, REMOVED);\n            }\n        }\n        else if (proto.documentDelete || proto.documentRemove) {\n            logger_1.logger('Watch.onData', this.requestTag, 'Processing remove event');\n            const name = (proto.documentDelete || proto.documentRemove).document;\n            const relativeName = path_1.QualifiedResourcePath.fromSlashSeparatedString(name)\n                .relativeName;\n            this.changeMap.set(relativeName, REMOVED);\n        }\n        else if (proto.filter) {\n            logger_1.logger('Watch.onData', this.requestTag, 'Processing filter update');\n            if (proto.filter.count !== this.currentSize()) {\n                // We need to remove all the current results.\n                this.resetDocs();\n                // The filter didn't match, so re-issue the query.\n                this.resetStream();\n            }\n        }\n        else {\n            this.closeStream(new Error('Unknown listen response type: ' + JSON.stringify(proto)));\n        }\n    }\n    /**\n     * Checks if the current target id is included in the list of target ids.\n     * If no targetIds are provided, returns true.\n     * @private\n     */\n    affectsTarget(targetIds, currentId) {\n        if (targetIds === undefined || targetIds.length === 0) {\n            return true;\n        }\n        for (const targetId of targetIds) {\n            if (targetId === currentId) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Assembles a new snapshot from the current set of changes and invokes the\n     * user's callback. Clears the current changes on completion.\n     * @private\n     */\n    pushSnapshot(readTime, nextResumeToken) {\n        const appliedChanges = this.computeSnapshot(readTime);\n        if (!this.hasPushed || appliedChanges.length > 0) {\n            logger_1.logger('Watch.pushSnapshot', this.requestTag, 'Sending snapshot with %d changes and %d documents', String(appliedChanges.length), this.docTree.length);\n            // We pass the current set of changes, even if `docTree` is modified later.\n            const currentTree = this.docTree;\n            this.onNext(readTime, currentTree.length, () => currentTree.keys, () => appliedChanges);\n            this.hasPushed = true;\n        }\n        this.changeMap.clear();\n        this.resumeToken = nextResumeToken;\n    }\n    /**\n     * Applies a document delete to the document tree and the document map.\n     * Returns the corresponding DocumentChange event.\n     * @private\n     */\n    deleteDoc(name) {\n        assert(this.docMap.has(name), 'Document to delete does not exist');\n        const oldDocument = this.docMap.get(name);\n        const existing = this.docTree.find(oldDocument);\n        const oldIndex = existing.index;\n        this.docTree = existing.remove();\n        this.docMap.delete(name);\n        return new document_change_1.DocumentChange(ChangeType.removed, oldDocument, oldIndex, -1);\n    }\n    /**\n     * Applies a document add to the document tree and the document map. Returns\n     * the corresponding DocumentChange event.\n     * @private\n     */\n    addDoc(newDocument) {\n        const name = newDocument.ref.path;\n        assert(!this.docMap.has(name), 'Document to add already exists');\n        this.docTree = this.docTree.insert(newDocument, null);\n        const newIndex = this.docTree.find(newDocument).index;\n        this.docMap.set(name, newDocument);\n        return new document_change_1.DocumentChange(ChangeType.added, newDocument, -1, newIndex);\n    }\n    /**\n     * Applies a document modification to the document tree and the document map.\n     * Returns the DocumentChange event for successful modifications.\n     * @private\n     */\n    modifyDoc(newDocument) {\n        const name = newDocument.ref.path;\n        assert(this.docMap.has(name), 'Document to modify does not exist');\n        const oldDocument = this.docMap.get(name);\n        if (!oldDocument.updateTime.isEqual(newDocument.updateTime)) {\n            const removeChange = this.deleteDoc(name);\n            const addChange = this.addDoc(newDocument);\n            return new document_change_1.DocumentChange(ChangeType.modified, newDocument, removeChange.oldIndex, addChange.newIndex);\n        }\n        return null;\n    }\n    /**\n     * Applies the mutations in changeMap to both the document tree and the\n     * document lookup map. Modified docMap in-place and returns the updated\n     * state.\n     * @private\n     */\n    computeSnapshot(readTime) {\n        const changeSet = this.extractCurrentChanges(readTime);\n        const appliedChanges = [];\n        // Process the sorted changes in the order that is expected by our clients\n        // (removals, additions, and then modifications). We also need to sort the\n        // individual changes to assure that oldIndex/newIndex keep incrementing.\n        changeSet.deletes.sort((name1, name2) => {\n            // Deletes are sorted based on the order of the existing document.\n            return this.getComparator()(this.docMap.get(name1), this.docMap.get(name2));\n        });\n        changeSet.deletes.forEach(name => {\n            const change = this.deleteDoc(name);\n            appliedChanges.push(change);\n        });\n        changeSet.adds.sort(this.getComparator());\n        changeSet.adds.forEach(snapshot => {\n            const change = this.addDoc(snapshot);\n            appliedChanges.push(change);\n        });\n        changeSet.updates.sort(this.getComparator());\n        changeSet.updates.forEach(snapshot => {\n            const change = this.modifyDoc(snapshot);\n            if (change) {\n                appliedChanges.push(change);\n            }\n        });\n        assert(this.docTree.length === this.docMap.size, 'The update document ' +\n            'tree and document map should have the same number of entries.');\n        return appliedChanges;\n    }\n    /**\n     * Determines whether a watch error is considered permanent and should not be\n     * retried. Errors that don't provide a GRPC error code are always considered\n     * transient in this context.\n     *\n     * @private\n     * @param error An error object.\n     * @return Whether the error is permanent.\n     */\n    isPermanentWatchError(error) {\n        if (error.code === undefined) {\n            logger_1.logger('Watch.isPermanentError', this.requestTag, 'Unable to determine error code: ', error);\n            return false;\n        }\n        switch (error.code) {\n            case google_gax_1.Status.ABORTED:\n            case google_gax_1.Status.CANCELLED:\n            case google_gax_1.Status.UNKNOWN:\n            case google_gax_1.Status.DEADLINE_EXCEEDED:\n            case google_gax_1.Status.RESOURCE_EXHAUSTED:\n            case google_gax_1.Status.INTERNAL:\n            case google_gax_1.Status.UNAVAILABLE:\n            case google_gax_1.Status.UNAUTHENTICATED:\n                return false;\n            default:\n                return true;\n        }\n    }\n    /**\n     * Determines whether we need to initiate a longer backoff due to system\n     * overload.\n     *\n     * @private\n     * @param error A GRPC Error object that exposes an error code.\n     * @return Whether we need to back off our retries.\n     */\n    isResourceExhaustedError(error) {\n        return error.code === google_gax_1.Status.RESOURCE_EXHAUSTED;\n    }\n    /** Closes the stream and clears all timeouts. */\n    shutdown() {\n        var _a;\n        if (this.isActive) {\n            this.isActive = false;\n            if (this.idleTimeoutHandle) {\n                clearTimeout(this.idleTimeoutHandle);\n                this.idleTimeoutHandle = undefined;\n            }\n            this.firestore.unregisterListener();\n        }\n        (_a = this.currentStream) === null || _a === void 0 ? void 0 : _a.end();\n        this.currentStream = null;\n    }\n}\n/**\n * Creates a new Watch instance to listen on DocumentReferences.\n *\n * @private\n */\nclass DocumentWatch extends Watch {\n    constructor(firestore, ref) {\n        super(firestore, ref._converter);\n        this.ref = ref;\n    }\n    getComparator() {\n        return DOCUMENT_WATCH_COMPARATOR;\n    }\n    getTarget(resumeToken) {\n        const formattedName = this.ref.formattedName;\n        return {\n            documents: {\n                documents: [formattedName],\n            },\n            targetId: WATCH_TARGET_ID,\n            resumeToken,\n        };\n    }\n}\nexports.DocumentWatch = DocumentWatch;\n/**\n * Creates a new Watch instance to listen on Queries.\n *\n * @private\n */\nclass QueryWatch extends Watch {\n    constructor(firestore, query, converter) {\n        super(firestore, converter);\n        this.query = query;\n        this.comparator = query.comparator();\n    }\n    getComparator() {\n        return this.query.comparator();\n    }\n    getTarget(resumeToken) {\n        const query = this.query.toProto();\n        return { query, targetId: WATCH_TARGET_ID, resumeToken };\n    }\n}\nexports.QueryWatch = QueryWatch;\n//# sourceMappingURL=watch.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/firestore/build/src/watch.js?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/firestore/build/src/write-batch.js":
/*!***************************************************************************!*\
  !*** ./src/node_modules/@google-cloud/firestore/build/src/write-batch.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Copyright 2019 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst document_1 = __webpack_require__(/*! ./document */ \"./src/node_modules/@google-cloud/firestore/build/src/document.js\");\nconst logger_1 = __webpack_require__(/*! ./logger */ \"./src/node_modules/@google-cloud/firestore/build/src/logger.js\");\nconst path_1 = __webpack_require__(/*! ./path */ \"./src/node_modules/@google-cloud/firestore/build/src/path.js\");\nconst reference_1 = __webpack_require__(/*! ./reference */ \"./src/node_modules/@google-cloud/firestore/build/src/reference.js\");\nconst serializer_1 = __webpack_require__(/*! ./serializer */ \"./src/node_modules/@google-cloud/firestore/build/src/serializer.js\");\nconst timestamp_1 = __webpack_require__(/*! ./timestamp */ \"./src/node_modules/@google-cloud/firestore/build/src/timestamp.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"./src/node_modules/@google-cloud/firestore/build/src/util.js\");\nconst validate_1 = __webpack_require__(/*! ./validate */ \"./src/node_modules/@google-cloud/firestore/build/src/validate.js\");\nconst google_gax_1 = __webpack_require__(/*! google-gax */ \"google-gax\");\n/*!\n * Google Cloud Functions terminates idle connections after two minutes. After\n * longer periods of idleness, we issue transactional commits to allow for\n * retries.\n */\nconst GCF_IDLE_TIMEOUT_MS = 110 * 1000;\n/**\n * A WriteResult wraps the write time set by the Firestore servers on sets(),\n * updates(), and creates().\n *\n * @class\n */\nclass WriteResult {\n    /**\n     * @hideconstructor\n     *\n     * @param _writeTime The time of the corresponding document write.\n     */\n    constructor(_writeTime) {\n        this._writeTime = _writeTime;\n    }\n    /**\n     * The write time as set by the Firestore servers.\n     *\n     * @type {Timestamp}\n     * @name WriteResult#writeTime\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.set({foo: 'bar'}).then(writeResult => {\n     *   console.log(`Document written at: ${writeResult.writeTime.toDate()}`);\n     * });\n     */\n    get writeTime() {\n        return this._writeTime;\n    }\n    /**\n     * Returns true if this `WriteResult` is equal to the provided value.\n     *\n     * @param {*} other The value to compare against.\n     * @return true if this `WriteResult` is equal to the provided value.\n     */\n    isEqual(other) {\n        return (this === other ||\n            (other instanceof WriteResult &&\n                this._writeTime.isEqual(other._writeTime)));\n    }\n}\nexports.WriteResult = WriteResult;\n/**\n * A BatchWriteResult wraps the write time and status returned by Firestore\n * when making BatchWriteRequests.\n *\n * @private\n */\nclass BatchWriteResult {\n    constructor(writeTime, status) {\n        this.writeTime = writeTime;\n        this.status = status;\n    }\n}\nexports.BatchWriteResult = BatchWriteResult;\n/**\n * A Firestore WriteBatch that can be used to atomically commit multiple write\n * operations at once.\n *\n * @class\n */\nclass WriteBatch {\n    /**\n     * @hideconstructor\n     *\n     * @param firestore The Firestore Database client.\n     */\n    constructor(firestore) {\n        /**\n         * An array of write operations that are executed as part of the commit. The\n         * resulting `api.IWrite` will be sent to the backend.\n         * @private\n         */\n        this._ops = [];\n        this._committed = false;\n        this._firestore = firestore;\n        this._serializer = new serializer_1.Serializer(firestore);\n        this._allowUndefined = !!firestore._settings.ignoreUndefinedProperties;\n    }\n    /**\n     * Checks if this write batch has any pending operations.\n     *\n     * @private\n     */\n    get isEmpty() {\n        return this._ops.length === 0;\n    }\n    /**\n     * Throws an error if this batch has already been committed.\n     *\n     * @private\n     */\n    verifyNotCommitted() {\n        if (this._committed) {\n            throw new Error('Cannot modify a WriteBatch that has been committed.');\n        }\n    }\n    /**\n     * Create a document with the provided object values. This will fail the batch\n     * if a document exists at its location.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * created.\n     * @param {T} data The object to serialize as the document.\n     * @returns {WriteBatch} This WriteBatch instance. Used for chaining\n     * method calls.\n     *\n     * @example\n     * let writeBatch = firestore.batch();\n     * let documentRef = firestore.collection('col').doc();\n     *\n     * writeBatch.create(documentRef, {foo: 'bar'});\n     *\n     * writeBatch.commit().then(() => {\n     *   console.log('Successfully executed batch.');\n     * });\n     */\n    create(documentRef, data) {\n        reference_1.validateDocumentReference('documentRef', documentRef);\n        const firestoreData = documentRef._converter.toFirestore(data);\n        validateDocumentData('data', firestoreData, \n        /* allowDeletes= */ false, this._allowUndefined);\n        this.verifyNotCommitted();\n        const transform = document_1.DocumentTransform.fromObject(documentRef, firestoreData);\n        transform.validate();\n        const precondition = new document_1.Precondition({ exists: false });\n        const op = () => {\n            const document = document_1.DocumentSnapshot.fromObject(documentRef, firestoreData);\n            const write = document.toProto();\n            if (!transform.isEmpty) {\n                write.updateTransforms = transform.toProto(this._serializer);\n            }\n            return {\n                write,\n                precondition: precondition.toProto(),\n            };\n        };\n        this._ops.push(op);\n        return this;\n    }\n    /**\n     * Deletes a document from the database.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * deleted.\n     * @param {Precondition=} precondition A precondition to enforce for this\n     * delete.\n     * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\n     * document was last updated at lastUpdateTime. Fails the batch if the\n     * document doesn't exist or was last updated at a different time.\n     * @returns {WriteBatch} This WriteBatch instance. Used for chaining\n     * method calls.\n     *\n     * @example\n     * let writeBatch = firestore.batch();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * writeBatch.delete(documentRef);\n     *\n     * writeBatch.commit().then(() => {\n     *   console.log('Successfully executed batch.');\n     * });\n     */\n    delete(documentRef, precondition) {\n        reference_1.validateDocumentReference('documentRef', documentRef);\n        validateDeletePrecondition('precondition', precondition, { optional: true });\n        this.verifyNotCommitted();\n        const conditions = new document_1.Precondition(precondition);\n        const op = () => {\n            return {\n                write: {\n                    delete: documentRef.formattedName,\n                },\n                precondition: conditions.toProto(),\n            };\n        };\n        this._ops.push(op);\n        return this;\n    }\n    /**\n     * Write to the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}.\n     * If the document does not exist yet, it will be created. If you pass\n     * [SetOptions]{@link SetOptions}., the provided data can be merged\n     * into the existing document.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * set.\n     * @param {T} data The object to serialize as the document.\n     * @param {SetOptions=} options An object to configure the set behavior.\n     * @param {boolean=} options.merge - If true, set() merges the values\n     * specified in its data argument. Fields omitted from this set() call\n     * remain untouched.\n     * @param {Array.<string|FieldPath>=} options.mergeFields - If provided,\n     * set() only replaces the specified field paths. Any field path that is not\n     * specified is ignored and remains untouched.\n     * @returns {WriteBatch} This WriteBatch instance. Used for chaining\n     * method calls.\n     *\n     * @example\n     * let writeBatch = firestore.batch();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * writeBatch.set(documentRef, {foo: 'bar'});\n     *\n     * writeBatch.commit().then(() => {\n     *   console.log('Successfully executed batch.');\n     * });\n     */\n    set(documentRef, data, options) {\n        validateSetOptions('options', options, { optional: true });\n        const mergeLeaves = options && options.merge === true;\n        const mergePaths = options && options.mergeFields;\n        reference_1.validateDocumentReference('documentRef', documentRef);\n        let firestoreData = documentRef._converter.toFirestore(data);\n        validateDocumentData('data', firestoreData, \n        /* allowDeletes= */ !!(mergePaths || mergeLeaves), this._allowUndefined);\n        this.verifyNotCommitted();\n        let documentMask;\n        if (mergePaths) {\n            documentMask = document_1.DocumentMask.fromFieldMask(options.mergeFields);\n            firestoreData = documentMask.applyTo(firestoreData);\n        }\n        const transform = document_1.DocumentTransform.fromObject(documentRef, firestoreData);\n        transform.validate();\n        const op = () => {\n            const document = document_1.DocumentSnapshot.fromObject(documentRef, firestoreData);\n            if (mergePaths) {\n                documentMask.removeFields(transform.fields);\n            }\n            else if (mergeLeaves) {\n                documentMask = document_1.DocumentMask.fromObject(firestoreData);\n            }\n            const write = document.toProto();\n            if (!transform.isEmpty) {\n                write.updateTransforms = transform.toProto(this._serializer);\n            }\n            if (mergePaths || mergeLeaves) {\n                write.updateMask = documentMask.toProto();\n            }\n            return {\n                write,\n            };\n        };\n        this._ops.push(op);\n        return this;\n    }\n    /**\n     * Update fields of the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. If the document\n     * doesn't yet exist, the update fails and the entire batch will be rejected.\n     *\n     * The update() method accepts either an object with field paths encoded as\n     * keys and field values encoded as values, or a variable number of arguments\n     * that alternate between field paths and field values. Nested fields can be\n     * updated by providing dot-separated field path strings or by providing\n     * FieldPath objects.\n     *\n     * A Precondition restricting this update can be specified as the last\n     * argument.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * updated.\n     * @param {UpdateData|string|FieldPath} dataOrField An object\n     * containing the fields and values with which to update the document\n     * or the path of the first field to update.\n     * @param {\n     * ...(Precondition|*|string|FieldPath)} preconditionOrValues -\n     * An alternating list of field paths and values to update or a Precondition\n     * to restrict this update.\n     * @returns {WriteBatch} This WriteBatch instance. Used for chaining\n     * method calls.\n     *\n     * @example\n     * let writeBatch = firestore.batch();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * writeBatch.update(documentRef, {foo: 'bar'});\n     *\n     * writeBatch.commit().then(() => {\n     *   console.log('Successfully executed batch.');\n     * });\n     */\n    update(documentRef, dataOrField, ...preconditionOrValues) {\n        validate_1.validateMinNumberOfArguments('WriteBatch.update', arguments, 2);\n        reference_1.validateDocumentReference('documentRef', documentRef);\n        this.verifyNotCommitted();\n        const updateMap = new Map();\n        let precondition = new document_1.Precondition({ exists: true });\n        const argumentError = 'Update() requires either a single JavaScript ' +\n            'object or an alternating list of field/value pairs that can be ' +\n            'followed by an optional precondition.';\n        const usesVarargs = typeof dataOrField === 'string' || dataOrField instanceof path_1.FieldPath;\n        if (usesVarargs) {\n            try {\n                for (let i = 1; i < arguments.length; i += 2) {\n                    if (i === arguments.length - 1) {\n                        validateUpdatePrecondition(i, arguments[i]);\n                        precondition = new document_1.Precondition(arguments[i]);\n                    }\n                    else {\n                        path_1.validateFieldPath(i, arguments[i]);\n                        // Unlike the `validateMinNumberOfArguments` invocation above, this\n                        // validation can be triggered both from `WriteBatch.update()` and\n                        // `DocumentReference.update()`. Hence, we don't use the fully\n                        // qualified API name in the error message.\n                        validate_1.validateMinNumberOfArguments('update', arguments, i + 1);\n                        const fieldPath = path_1.FieldPath.fromArgument(arguments[i]);\n                        validateFieldValue(i, arguments[i + 1], this._allowUndefined, fieldPath);\n                        updateMap.set(fieldPath, arguments[i + 1]);\n                    }\n                }\n            }\n            catch (err) {\n                logger_1.logger('WriteBatch.update', null, 'Varargs validation failed:', err);\n                // We catch the validation error here and re-throw to provide a better\n                // error message.\n                throw new Error(`${argumentError} ${err.message}`);\n            }\n        }\n        else {\n            try {\n                validateUpdateMap('dataOrField', dataOrField, this._allowUndefined);\n                validate_1.validateMaxNumberOfArguments('update', arguments, 3);\n                const data = dataOrField;\n                Object.keys(data).forEach(key => {\n                    path_1.validateFieldPath(key, key);\n                    updateMap.set(path_1.FieldPath.fromArgument(key), data[key]);\n                });\n                if (preconditionOrValues.length > 0) {\n                    validateUpdatePrecondition('preconditionOrValues', preconditionOrValues[0]);\n                    precondition = new document_1.Precondition(preconditionOrValues[0]);\n                }\n            }\n            catch (err) {\n                logger_1.logger('WriteBatch.update', null, 'Non-varargs validation failed:', err);\n                // We catch the validation error here and prefix the error with a custom\n                // message to describe the usage of update() better.\n                throw new Error(`${argumentError} ${err.message}`);\n            }\n        }\n        validateNoConflictingFields('dataOrField', updateMap);\n        const transform = document_1.DocumentTransform.fromUpdateMap(documentRef, updateMap);\n        transform.validate();\n        const documentMask = document_1.DocumentMask.fromUpdateMap(updateMap);\n        const op = () => {\n            const document = document_1.DocumentSnapshot.fromUpdateMap(documentRef, updateMap);\n            const write = document.toProto();\n            write.updateMask = documentMask.toProto();\n            if (!transform.isEmpty) {\n                write.updateTransforms = transform.toProto(this._serializer);\n            }\n            return {\n                write,\n                precondition: precondition.toProto(),\n            };\n        };\n        this._ops.push(op);\n        return this;\n    }\n    /**\n     * Atomically commits all pending operations to the database and verifies all\n     * preconditions. Fails the entire write if any precondition is not met.\n     *\n     * @returns {Promise.<Array.<WriteResult>>} A Promise that resolves\n     * when this batch completes.\n     *\n     * @example\n     * let writeBatch = firestore.batch();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * writeBatch.set(documentRef, {foo: 'bar'});\n     *\n     * writeBatch.commit().then(() => {\n     *   console.log('Successfully executed batch.');\n     * });\n     */\n    commit() {\n        // Capture the error stack to preserve stack tracing across async calls.\n        const stack = Error().stack;\n        return this.commit_().catch(err => {\n            throw util_1.wrapError(err, stack);\n        });\n    }\n    /**\n     * Commits all pending operations to the database and verifies all\n     * preconditions.\n     *\n     * The writes in the batch are not applied atomically and can be applied out\n     * of order.\n     *\n     * @private\n     */\n    async bulkCommit() {\n        this._committed = true;\n        const tag = util_1.requestTag();\n        await this._firestore.initializeIfNeeded(tag);\n        const database = this._firestore.formattedName;\n        const request = { database, writes: [] };\n        const writes = this._ops.map(op => op());\n        for (const req of writes) {\n            if (req.precondition) {\n                req.write.currentDocument = req.precondition;\n            }\n            request.writes.push(req.write);\n        }\n        const retryCodes = [google_gax_1.Status.ABORTED, ...util_1.getRetryCodes('commit')];\n        const response = await this._firestore.request('batchWrite', request, tag, retryCodes);\n        return (response.writeResults || []).map((result, i) => {\n            const status = response.status[i];\n            const error = new google_gax_1.GoogleError(status.message || undefined);\n            error.code = status.code;\n            return new BatchWriteResult(result.updateTime ? timestamp_1.Timestamp.fromProto(result.updateTime) : null, error);\n        });\n    }\n    /**\n     * Commit method that takes an optional transaction ID.\n     *\n     * @private\n     * @param commitOptions Options to use for this commit.\n     * @param commitOptions.transactionId The transaction ID of this commit.\n     * @param commitOptions.requestTag A unique client-assigned identifier for\n     * this request.\n     * @returns  A Promise that resolves when this batch completes.\n     */\n    async commit_(commitOptions) {\n        // Note: We don't call `verifyNotCommitted()` to allow for retries.\n        this._committed = true;\n        const tag = (commitOptions && commitOptions.requestTag) || util_1.requestTag();\n        await this._firestore.initializeIfNeeded(tag);\n        const database = this._firestore.formattedName;\n        // On GCF, we periodically force transactional commits to allow for\n        // request retries in case GCF closes our backend connection.\n        const explicitTransaction = commitOptions && commitOptions.transactionId;\n        if (!explicitTransaction && this._shouldCreateTransaction()) {\n            logger_1.logger('WriteBatch.commit', tag, 'Using transaction for commit');\n            return this._firestore\n                .request('beginTransaction', { database }, tag)\n                .then(resp => {\n                return this.commit_({ transactionId: resp.transaction });\n            });\n        }\n        const request = { database, writes: [] };\n        const writes = this._ops.map(op => op());\n        for (const req of writes) {\n            if (req.precondition) {\n                req.write.currentDocument = req.precondition;\n            }\n            request.writes.push(req.write);\n        }\n        logger_1.logger('WriteBatch.commit', tag, 'Sending %d writes', request.writes.length);\n        let retryCodes;\n        if (explicitTransaction) {\n            request.transaction = explicitTransaction;\n        }\n        else {\n            // Commits outside of transaction should also be retried when they fail\n            // with status code ABORTED.\n            retryCodes = [google_gax_1.Status.ABORTED, ...util_1.getRetryCodes('commit')];\n        }\n        const response = await this._firestore.request('commit', request, tag, retryCodes);\n        return (response.writeResults || []).map(writeResult => new WriteResult(timestamp_1.Timestamp.fromProto(writeResult.updateTime || response.commitTime)));\n    }\n    /**\n     * Determines whether we should issue a transactional commit. On GCF, this\n     * happens after two minutes of idleness.\n     *\n     * @private\n     * @returns Whether to use a transaction.\n     */\n    _shouldCreateTransaction() {\n        if (!this._firestore._preferTransactions) {\n            return false;\n        }\n        if (this._firestore._lastSuccessfulRequest) {\n            const now = new Date().getTime();\n            return now - this._firestore._lastSuccessfulRequest > GCF_IDLE_TIMEOUT_MS;\n        }\n        return true;\n    }\n    /**\n     * Resets the WriteBatch and dequeues all pending operations.\n     * @private\n     */\n    _reset() {\n        this._ops.splice(0);\n        this._committed = false;\n    }\n}\nexports.WriteBatch = WriteBatch;\n/**\n * Validates the use of 'value' as a Precondition and enforces that 'exists'\n * and 'lastUpdateTime' use valid types.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The object to validate\n * @param allowExists Whether to allow the 'exists' preconditions.\n */\nfunction validatePrecondition(arg, value, allowExists) {\n    if (typeof value !== 'object' || value === null) {\n        throw new Error('Input is not an object.');\n    }\n    const precondition = value;\n    let conditions = 0;\n    if (precondition.exists !== undefined) {\n        ++conditions;\n        if (!allowExists) {\n            throw new Error(`${validate_1.invalidArgumentMessage(arg, 'precondition')} \"exists\" is not an allowed precondition.`);\n        }\n        if (typeof precondition.exists !== 'boolean') {\n            throw new Error(`${validate_1.invalidArgumentMessage(arg, 'precondition')} \"exists\" is not a boolean.'`);\n        }\n    }\n    if (precondition.lastUpdateTime !== undefined) {\n        ++conditions;\n        if (!(precondition.lastUpdateTime instanceof timestamp_1.Timestamp)) {\n            throw new Error(`${validate_1.invalidArgumentMessage(arg, 'precondition')} \"lastUpdateTime\" is not a Firestore Timestamp.`);\n        }\n    }\n    if (conditions > 1) {\n        throw new Error(`${validate_1.invalidArgumentMessage(arg, 'precondition')} Input specifies more than one precondition.`);\n    }\n}\n/**\n * Validates the use of 'value' as an update Precondition.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The object to validate.\n * @param options Optional validation options specifying whether the value can\n * be omitted.\n */\nfunction validateUpdatePrecondition(arg, value, options) {\n    if (!validate_1.validateOptional(value, options)) {\n        validatePrecondition(arg, value, /* allowExists= */ false);\n    }\n}\n/**\n * Validates the use of 'value' as a delete Precondition.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The object to validate.\n * @param options Optional validation options specifying whether the value can\n * be omitted.\n */\nfunction validateDeletePrecondition(arg, value, options) {\n    if (!validate_1.validateOptional(value, options)) {\n        validatePrecondition(arg, value, /* allowExists= */ true);\n    }\n}\n/**\n * Validates the use of 'value' as SetOptions and enforces that 'merge' is a\n * boolean.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The object to validate.\n * @param options Optional validation options specifying whether the value can\n * be omitted.\n * @throws if the input is not a valid SetOptions object.\n */\nfunction validateSetOptions(arg, value, options) {\n    if (!validate_1.validateOptional(value, options)) {\n        if (!util_1.isObject(value)) {\n            throw new Error(`${validate_1.invalidArgumentMessage(arg, 'set() options argument')} Input is not an object.`);\n        }\n        const setOptions = value;\n        if ('merge' in setOptions && typeof setOptions.merge !== 'boolean') {\n            throw new Error(`${validate_1.invalidArgumentMessage(arg, 'set() options argument')} \"merge\" is not a boolean.`);\n        }\n        if ('mergeFields' in setOptions) {\n            if (!Array.isArray(setOptions.mergeFields)) {\n                throw new Error(`${validate_1.invalidArgumentMessage(arg, 'set() options argument')} \"mergeFields\" is not an array.`);\n            }\n            for (let i = 0; i < setOptions.mergeFields.length; ++i) {\n                try {\n                    path_1.validateFieldPath(i, setOptions.mergeFields[i]);\n                }\n                catch (err) {\n                    throw new Error(`${validate_1.invalidArgumentMessage(arg, 'set() options argument')} \"mergeFields\" is not valid: ${err.message}`);\n                }\n            }\n        }\n        if ('merge' in setOptions && 'mergeFields' in setOptions) {\n            throw new Error(`${validate_1.invalidArgumentMessage(arg, 'set() options argument')} You cannot specify both \"merge\" and \"mergeFields\".`);\n        }\n    }\n}\nexports.validateSetOptions = validateSetOptions;\n/**\n * Validates a JavaScript object for usage as a Firestore document.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param obj JavaScript object to validate.\n * @param allowDeletes Whether to allow FieldValue.delete() sentinels.\n * @param allowUndefined Whether to allow nested properties that are `undefined`.\n * @throws when the object is invalid.\n */\nfunction validateDocumentData(arg, obj, allowDeletes, allowUndefined) {\n    if (!util_1.isPlainObject(obj)) {\n        throw new Error(validate_1.customObjectMessage(arg, obj));\n    }\n    serializer_1.validateUserInput(arg, obj, 'Firestore document', {\n        allowDeletes: allowDeletes ? 'all' : 'none',\n        allowTransforms: true,\n        allowUndefined,\n    });\n}\nexports.validateDocumentData = validateDocumentData;\n/**\n * Validates that a value can be used as field value during an update.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param val The value to verify.\n * @param allowUndefined Whether to allow nested properties that are `undefined`.\n * @param path The path to show in the error message.\n */\nfunction validateFieldValue(arg, val, allowUndefined, path) {\n    serializer_1.validateUserInput(arg, val, 'Firestore value', { allowDeletes: 'root', allowTransforms: true, allowUndefined }, path);\n}\nexports.validateFieldValue = validateFieldValue;\n/**\n * Validates that the update data does not contain any ambiguous field\n * definitions (such as 'a.b' and 'a').\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param data An update map with field/value pairs.\n */\nfunction validateNoConflictingFields(arg, data) {\n    const fields = [];\n    data.forEach((value, key) => {\n        fields.push(key);\n    });\n    fields.sort((left, right) => left.compareTo(right));\n    for (let i = 1; i < fields.length; ++i) {\n        if (fields[i - 1].isPrefixOf(fields[i])) {\n            throw new Error(`${validate_1.invalidArgumentMessage(arg, 'update map')} Field \"${fields[i - 1]}\" was specified multiple times.`);\n        }\n    }\n}\n/**\n * Validates that a JavaScript object is a map of field paths to field values.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param obj JavaScript object to validate.\n * @param allowUndefined Whether to allow nested properties that are `undefined`.\n * @throws when the object is invalid.\n */\nfunction validateUpdateMap(arg, obj, allowUndefined) {\n    if (!util_1.isPlainObject(obj)) {\n        throw new Error(validate_1.customObjectMessage(arg, obj));\n    }\n    let isEmpty = true;\n    if (obj) {\n        for (const prop of Object.keys(obj)) {\n            isEmpty = false;\n            validateFieldValue(arg, obj[prop], allowUndefined, new path_1.FieldPath(prop));\n        }\n    }\n    if (isEmpty) {\n        throw new Error('At least one field must be updated.');\n    }\n}\n//# sourceMappingURL=write-batch.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/firestore/build/src/write-batch.js?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/firestore/package.json":
/*!***************************************************************!*\
  !*** ./src/node_modules/@google-cloud/firestore/package.json ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"name\":\"@google-cloud/firestore\",\"description\":\"Firestore Client Library for Node.js\",\"version\":\"3.8.6\",\"license\":\"Apache-2.0\",\"author\":\"Google Inc.\",\"engines\":{\"node\":\"^8.13.0 || >=10.10.0\"},\"repository\":\"googleapis/nodejs-firestore\",\"main\":\"./build/src/index.js\",\"types\":\"./types/firestore.d.ts\",\"files\":[\"build/protos\",\"build/src\",\"!build/src/**/*.map\",\"types\"],\"keywords\":[\"google apis client\",\"google api client\",\"google apis\",\"google api\",\"google\",\"google cloud platform\",\"google cloud\",\"cloud\",\"firestore\"],\"scripts\":{\"predocs\":\"npm run compile\",\"docs\":\"jsdoc -c .jsdoc.js\",\"system-test\":\"mocha build/system-test --timeout 600000\",\"presystem-test\":\"npm run compile\",\"samples-test\":\"npm link && cd samples/ && npm link ../ && npm test && cd ../\",\"conformance\":\"mocha build/conformance\",\"preconformance\":\"npm run compile\",\"test-only\":\"c8 mocha build/test\",\"pretest-only\":\"npm run compile\",\"test\":\"npm run test-only && npm run conformance\",\"lint\":\"gts check\",\"clean\":\"gts clean\",\"compile\":\"tsc -p .\",\"postcompile\":\"node scripts/init-directories.js && cp -r dev/protos build && cp dev/src/v1beta1/*.json build/src/v1beta1/ && cp dev/src/v1/*.json build/src/v1/ && cp dev/conformance/test-definition.proto build/conformance && cp dev/conformance/conformance-tests/*.json build/conformance/conformance-tests\",\"fix\":\"gts fix\",\"prepare\":\"npm run compile\",\"docs-test\":\"linkinator docs\",\"predocs-test\":\"npm run docs\",\"prelint\":\"cd samples; npm link ../; npm install\",\"precompile\":\"gts clean\"},\"dependencies\":{\"deep-equal\":\"^2.0.0\",\"functional-red-black-tree\":\"^1.0.1\",\"google-gax\":\"^1.15.3\",\"readable-stream\":\"^3.4.0\",\"through2\":\"^3.0.0\"},\"devDependencies\":{\"@types/assert\":\"^1.4.0\",\"@types/chai\":\"^4.2.7\",\"@types/chai-as-promised\":\"^7.1.2\",\"@types/duplexify\":\"^3.5.0\",\"@types/extend\":\"^3.0.0\",\"@types/mocha\":\"^7.0.0\",\"@types/node\":\"^12.12.17\",\"@types/through2\":\"^2.0.34\",\"c8\":\"^7.0.0\",\"chai\":\"^4.1.2\",\"chai-as-promised\":\"^7.1.1\",\"codecov\":\"^3.6.1\",\"duplexify\":\"^4.0.0\",\"extend\":\"^3.0.2\",\"gts\":\"^1.1.2\",\"jsdoc\":\"^3.6.2\",\"jsdoc-fresh\":\"^1.0.2\",\"jsdoc-region-tag\":\"^1.0.2\",\"linkinator\":\"^2.0.0\",\"mocha\":\"^7.0.0\",\"protobufjs\":\"^6.8.6\",\"proxyquire\":\"^2.1.3\",\"ts-node\":\"^8.5.4\",\"typescript\":\"3.8.3\"}}');\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/firestore/package.json?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/storage/build/src/acl.js":
/*!*****************************************************************!*\
  !*** ./src/node_modules/@google-cloud/storage/build/src/acl.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst promisify_1 = __webpack_require__(/*! @google-cloud/promisify */ \"@google-cloud/promisify\");\nconst arrify = __webpack_require__(/*! arrify */ \"arrify\");\n/**\n * Attach functionality to a {@link Storage.acl} instance. This will add an\n * object for each role group (owners, readers, and writers), with each object\n * containing methods to add or delete a type of entity.\n *\n * As an example, here are a few methods that are created.\n *\n *   myBucket.acl.readers.deleteGroup('groupId', function(err) {});\n *\n *   myBucket.acl.owners.addUser('email@example.com', function(err, acl) {});\n *\n *   myBucket.acl.writers.addDomain('example.com', function(err, acl) {});\n *\n * @private\n */\nclass AclRoleAccessorMethods {\n    constructor() {\n        this.owners = {};\n        this.readers = {};\n        this.writers = {};\n        /**\n         * An object of convenience methods to add or delete owner ACL permissions\n         * for a given entity.\n         *\n         * The supported methods include:\n         *\n         *   - `myFile.acl.owners.addAllAuthenticatedUsers`\n         *   - `myFile.acl.owners.deleteAllAuthenticatedUsers`\n         *   - `myFile.acl.owners.addAllUsers`\n         *   - `myFile.acl.owners.deleteAllUsers`\n         *   - `myFile.acl.owners.addDomain`\n         *   - `myFile.acl.owners.deleteDomain`\n         *   - `myFile.acl.owners.addGroup`\n         *   - `myFile.acl.owners.deleteGroup`\n         *   - `myFile.acl.owners.addProject`\n         *   - `myFile.acl.owners.deleteProject`\n         *   - `myFile.acl.owners.addUser`\n         *   - `myFile.acl.owners.deleteUser`\n         *\n         * @name Acl#owners\n         *\n         * @example\n         * const storage = require('@google-cloud/storage')();\n         * const myBucket = storage.bucket('my-bucket');\n         * const myFile = myBucket.file('my-file');\n         *\n         * //-\n         * // Add a user as an owner of a file.\n         * //-\n         * const myBucket = gcs.bucket('my-bucket');\n         * const myFile = myBucket.file('my-file');\n         * myFile.acl.owners.addUser('email@example.com', function(err, aclObject)\n         * {});\n         *\n         * //-\n         * // For reference, the above command is the same as running the following.\n         * //-\n         * myFile.acl.add({\n         *   entity: 'user-email@example.com',\n         *   role: gcs.acl.OWNER_ROLE\n         * }, function(err, aclObject) {});\n         *\n         * //-\n         * // If the callback is omitted, we'll return a Promise.\n         * //-\n         * myFile.acl.owners.addUser('email@example.com').then(function(data) {\n         *   const aclObject = data[0];\n         *   const apiResponse = data[1];\n         * });\n         */\n        this.owners = {};\n        /**\n         * An object of convenience methods to add or delete reader ACL permissions\n         * for a given entity.\n         *\n         * The supported methods include:\n         *\n         *   - `myFile.acl.readers.addAllAuthenticatedUsers`\n         *   - `myFile.acl.readers.deleteAllAuthenticatedUsers`\n         *   - `myFile.acl.readers.addAllUsers`\n         *   - `myFile.acl.readers.deleteAllUsers`\n         *   - `myFile.acl.readers.addDomain`\n         *   - `myFile.acl.readers.deleteDomain`\n         *   - `myFile.acl.readers.addGroup`\n         *   - `myFile.acl.readers.deleteGroup`\n         *   - `myFile.acl.readers.addProject`\n         *   - `myFile.acl.readers.deleteProject`\n         *   - `myFile.acl.readers.addUser`\n         *   - `myFile.acl.readers.deleteUser`\n         *\n         * @name Acl#readers\n         *\n         * @example\n         * const storage = require('@google-cloud/storage')();\n         * const myBucket = storage.bucket('my-bucket');\n         * const myFile = myBucket.file('my-file');\n         *\n         * //-\n         * // Add a user as a reader of a file.\n         * //-\n         * myFile.acl.readers.addUser('email@example.com', function(err, aclObject)\n         * {});\n         *\n         * //-\n         * // For reference, the above command is the same as running the following.\n         * //-\n         * myFile.acl.add({\n         *   entity: 'user-email@example.com',\n         *   role: gcs.acl.READER_ROLE\n         * }, function(err, aclObject) {});\n         *\n         * //-\n         * // If the callback is omitted, we'll return a Promise.\n         * //-\n         * myFile.acl.readers.addUser('email@example.com').then(function(data) {\n         *   const aclObject = data[0];\n         *   const apiResponse = data[1];\n         * });\n         */\n        this.readers = {};\n        /**\n         * An object of convenience methods to add or delete writer ACL permissions\n         * for a given entity.\n         *\n         * The supported methods include:\n         *\n         *   - `myFile.acl.writers.addAllAuthenticatedUsers`\n         *   - `myFile.acl.writers.deleteAllAuthenticatedUsers`\n         *   - `myFile.acl.writers.addAllUsers`\n         *   - `myFile.acl.writers.deleteAllUsers`\n         *   - `myFile.acl.writers.addDomain`\n         *   - `myFile.acl.writers.deleteDomain`\n         *   - `myFile.acl.writers.addGroup`\n         *   - `myFile.acl.writers.deleteGroup`\n         *   - `myFile.acl.writers.addProject`\n         *   - `myFile.acl.writers.deleteProject`\n         *   - `myFile.acl.writers.addUser`\n         *   - `myFile.acl.writers.deleteUser`\n         *\n         * @name Acl#writers\n         *\n         * @example\n         * const storage = require('@google-cloud/storage')();\n         * const myBucket = storage.bucket('my-bucket');\n         * const myFile = myBucket.file('my-file');\n         *\n         * //-\n         * // Add a user as a writer of a file.\n         * //-\n         * myFile.acl.writers.addUser('email@example.com', function(err, aclObject)\n         * {});\n         *\n         * //-\n         * // For reference, the above command is the same as running the following.\n         * //-\n         * myFile.acl.add({\n         *   entity: 'user-email@example.com',\n         *   role: gcs.acl.WRITER_ROLE\n         * }, function(err, aclObject) {});\n         *\n         * //-\n         * // If the callback is omitted, we'll return a Promise.\n         * //-\n         * myFile.acl.writers.addUser('email@example.com').then(function(data) {\n         *   const aclObject = data[0];\n         *   const apiResponse = data[1];\n         * });\n         */\n        this.writers = {};\n        AclRoleAccessorMethods.roles.forEach(this._assignAccessMethods.bind(this));\n    }\n    _assignAccessMethods(role) {\n        const accessMethods = AclRoleAccessorMethods.accessMethods;\n        const entities = AclRoleAccessorMethods.entities;\n        const roleGroup = role.toLowerCase() + 's';\n        // tslint:disable-next-line:no-any\n        this[roleGroup] = entities.reduce((acc, entity) => {\n            const isPrefix = entity.charAt(entity.length - 1) === '-';\n            accessMethods.forEach(accessMethod => {\n                let method = accessMethod + entity[0].toUpperCase() + entity.substr(1);\n                if (isPrefix) {\n                    method = method.replace('-', '');\n                }\n                // Wrap the parent accessor method (e.g. `add` or `delete`) to avoid the\n                // more complex API of specifying an `entity` and `role`.\n                // tslint:disable-next-line:no-any\n                acc[method] = (entityId, options, callback) => {\n                    let apiEntity;\n                    if (typeof options === 'function') {\n                        callback = options;\n                        options = {};\n                    }\n                    if (isPrefix) {\n                        apiEntity = entity + entityId;\n                    }\n                    else {\n                        // If the entity is not a prefix, it is a special entity group\n                        // that does not require further details. The accessor methods\n                        // only accept a callback.\n                        apiEntity = entity;\n                        callback = entityId;\n                    }\n                    options = Object.assign({\n                        entity: apiEntity,\n                        role,\n                    }, options);\n                    const args = [options];\n                    if (typeof callback === 'function') {\n                        args.push(callback);\n                    }\n                    // tslint:disable-next-line:no-any\n                    return this[accessMethod].apply(this, args);\n                };\n            });\n            return acc;\n        }, {});\n    }\n}\nexports.AclRoleAccessorMethods = AclRoleAccessorMethods;\nAclRoleAccessorMethods.accessMethods = ['add', 'delete'];\nAclRoleAccessorMethods.entities = [\n    // Special entity groups that do not require further specification.\n    'allAuthenticatedUsers',\n    'allUsers',\n    // Entity groups that require specification, e.g. `user-email@example.com`.\n    'domain-',\n    'group-',\n    'project-',\n    'user-',\n];\nAclRoleAccessorMethods.roles = ['OWNER', 'READER', 'WRITER'];\n/**\n * Cloud Storage uses access control lists (ACLs) to manage object and\n * bucket access. ACLs are the mechanism you use to share objects with other\n * users and allow other users to access your buckets and objects.\n *\n * An ACL consists of one or more entries, where each entry grants permissions\n * to an entity. Permissions define the actions that can be performed against an\n * object or bucket (for example, `READ` or `WRITE`); the entity defines who the\n * permission applies to (for example, a specific user or group of users).\n *\n * Where an `entity` value is accepted, we follow the format the Cloud Storage\n * API expects.\n *\n * Refer to\n * https://cloud.google.com/storage/docs/json_api/v1/defaultObjectAccessControls\n * for the most up-to-date values.\n *\n *   - `user-userId`\n *   - `user-email`\n *   - `group-groupId`\n *   - `group-email`\n *   - `domain-domain`\n *   - `project-team-projectId`\n *   - `allUsers`\n *   - `allAuthenticatedUsers`\n *\n * Examples:\n *\n *   - The user \"liz@example.com\" would be `user-liz@example.com`.\n *   - The group \"example@googlegroups.com\" would be\n *     `group-example@googlegroups.com`.\n *   - To refer to all members of the Google Apps for Business domain\n *     \"example.com\", the entity would be `domain-example.com`.\n *\n * For more detailed information, see\n * [About Access Control Lists](http://goo.gl/6qBBPO).\n *\n * @constructor Acl\n * @mixin\n * @param {object} options Configuration options.\n */\nclass Acl extends AclRoleAccessorMethods {\n    constructor(options) {\n        super();\n        this.pathPrefix = options.pathPrefix;\n        this.request_ = options.request;\n    }\n    /**\n     * @typedef {array} AddAclResponse\n     * @property {object} 0 The Acl Objects.\n     * @property {object} 1 The full API response.\n     */\n    /**\n     * @callback AddAclCallback\n     * @param {?Error} err Request error, if any.\n     * @param {object} acl The Acl Objects.\n     * @param {object} apiResponse The full API response.\n     */\n    /**\n     * Add access controls on a {@link Bucket} or {@link File}.\n     *\n     * @see [BucketAccessControls: insert API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/bucketAccessControls/insert}\n     * @see [ObjectAccessControls: insert API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objectAccessControls/insert}\n     *\n     * @param {object} options Configuration options.\n     * @param {string} options.entity Whose permissions will be added.\n     * @param {string} options.role Permissions allowed for the defined entity.\n     *     See {@link https://cloud.google.com/storage/docs/access-control Access\n     * Control}.\n     * @param {number} [options.generation] **File Objects Only** Select a specific\n     *     revision of this file (as opposed to the latest version, the default).\n     * @param {string} [options.userProject] The ID of the project which will be\n     *     billed for the request.\n     * @param {AddAclCallback} [callback] Callback function.\n     * @returns {Promise<AddAclResponse>}\n     *\n     * @example\n     * const storage = require('@google-cloud/storage')();\n     * const myBucket = storage.bucket('my-bucket');\n     * const myFile = myBucket.file('my-file');\n     *\n     * const options = {\n     *   entity: 'user-useremail@example.com',\n     *   role: gcs.acl.OWNER_ROLE\n     * };\n     *\n     * myBucket.acl.add(options, function(err, aclObject, apiResponse) {});\n     *\n     * //-\n     * // For file ACL operations, you can also specify a `generation` property.\n     * // Here is how you would grant ownership permissions to a user on a\n     * specific\n     * // revision of a file.\n     * //-\n     * myFile.acl.add({\n     *   entity: 'user-useremail@example.com',\n     *   role: gcs.acl.OWNER_ROLE,\n     *   generation: 1\n     * }, function(err, aclObject, apiResponse) {});\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * myBucket.acl.add(options).then(function(data) {\n     *   const aclObject = data[0];\n     *   const apiResponse = data[1];\n     * });\n     *\n     * @example <caption>include:samples/acl.js</caption>\n     * region_tag:storage_add_file_owner\n     * Example of adding an owner to a file:\n     *\n     * @example <caption>include:samples/acl.js</caption>\n     * region_tag:storage_add_bucket_owner\n     * Example of adding an owner to a bucket:\n     *\n     * @example <caption>include:samples/acl.js</caption>\n     * region_tag:storage_add_bucket_default_owner\n     * Example of adding a default owner to a bucket:\n     */\n    add(options, callback) {\n        const query = {};\n        if (options.generation) {\n            query.generation = options.generation;\n        }\n        if (options.userProject) {\n            query.userProject = options.userProject;\n        }\n        this.request({\n            method: 'POST',\n            uri: '',\n            qs: query,\n            json: {\n                entity: options.entity,\n                role: options.role.toUpperCase(),\n            },\n        }, (err, resp) => {\n            if (err) {\n                callback(err, null, resp);\n                return;\n            }\n            callback(null, this.makeAclObject_(resp), resp);\n        });\n    }\n    /**\n     * @typedef {array} RemoveAclResponse\n     * @property {object} 0 The full API response.\n     */\n    /**\n     * @callback RemoveAclCallback\n     * @param {?Error} err Request error, if any.\n     * @param {object} apiResponse The full API response.\n     */\n    /**\n     * Delete access controls on a {@link Bucket} or {@link File}.\n     *\n     * @see [BucketAccessControls: delete API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/bucketAccessControls/delete}\n     * @see [ObjectAccessControls: delete API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objectAccessControls/delete}\n     *\n     * @param {object} options Configuration object.\n     * @param {string} options.entity Whose permissions will be revoked.\n     * @param {int} [options.generation] **File Objects Only** Select a specific\n     *     revision of this file (as opposed to the latest version, the default).\n     * @param {string} [options.userProject] The ID of the project which will be\n     *     billed for the request.\n     * @param {RemoveAclCallback} callback The callback function.\n     * @returns {Promise<RemoveAclResponse>}\n     *\n     * @example\n     * const storage = require('@google-cloud/storage')();\n     * const myBucket = storage.bucket('my-bucket');\n     * const myFile = myBucket.file('my-file');\n     *\n     * myBucket.acl.delete({\n     *   entity: 'user-useremail@example.com'\n     * }, function(err, apiResponse) {});\n     *\n     * //-\n     * // For file ACL operations, you can also specify a `generation` property.\n     * //-\n     * myFile.acl.delete({\n     *   entity: 'user-useremail@example.com',\n     *   generation: 1\n     * }, function(err, apiResponse) {});\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * myFile.acl.delete().then(function(data) {\n     *   const apiResponse = data[0];\n     * });\n     *\n     * @example <caption>include:samples/acl.js</caption>\n     * region_tag:storage_remove_bucket_owner\n     * Example of removing an owner from a bucket:\n     *\n     * @example <caption>include:samples/acl.js</caption>\n     * region_tag:storage_remove_bucket_default_owner\n     * Example of removing a default owner from a bucket:\n     *\n     * @example <caption>include:samples/acl.js</caption>\n     * region_tag:storage_remove_file_owner\n     * Example of removing an owner from a bucket:\n     */\n    delete(options, callback) {\n        const query = {};\n        if (options.generation) {\n            query.generation = options.generation;\n        }\n        if (options.userProject) {\n            query.userProject = options.userProject;\n        }\n        this.request({\n            method: 'DELETE',\n            uri: '/' + encodeURIComponent(options.entity),\n            qs: query,\n        }, (err, resp) => {\n            callback(err, resp);\n        });\n    }\n    /**\n     * @typedef {array} GetAclResponse\n     * @property {object|object[]} 0 Single or array of Acl Objects.\n     * @property {object} 1 The full API response.\n     */\n    /**\n     * @callback GetAclCallback\n     * @param {?Error} err Request error, if any.\n     * @param {object|object[]} acl Single or array of Acl Objects.\n     * @param {object} apiResponse The full API response.\n     */\n    /**\n     * Get access controls on a {@link Bucket} or {@link File}. If\n     * an entity is omitted, you will receive an array of all applicable access\n     * controls.\n     *\n     * @see [BucketAccessControls: get API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/bucketAccessControls/get}\n     * @see [ObjectAccessControls: get API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objectAccessControls/get}\n     *\n     * @param {object|function} [options] Configuration options. If you want to\n     *     receive a list of all access controls, pass the callback function as\n     * the only argument.\n     * @param {string} [options.entity] Whose permissions will be fetched.\n     * @param {number} [options.generation] **File Objects Only** Select a specific\n     *     revision of this file (as opposed to the latest version, the default).\n     * @param {string} [options.userProject] The ID of the project which will be\n     *     billed for the request.\n     * @param {GetAclCallback} [callback] Callback function.\n     * @returns {Promise<GetAclResponse>}\n     *\n     * @example\n     * const storage = require('@google-cloud/storage')();\n     * const myBucket = storage.bucket('my-bucket');\n     * const myFile = myBucket.file('my-file');\n     *\n     * myBucket.acl.get({\n     *   entity: 'user-useremail@example.com'\n     * }, function(err, aclObject, apiResponse) {});\n     *\n     * //-\n     * // Get all access controls.\n     * //-\n     * myBucket.acl.get(function(err, aclObjects, apiResponse) {\n     *   // aclObjects = [\n     *   //   {\n     *   //     entity: 'user-useremail@example.com',\n     *   //     role: 'owner'\n     *   //   }\n     *   // ]\n     * });\n     *\n     * //-\n     * // For file ACL operations, you can also specify a `generation` property.\n     * //-\n     * myFile.acl.get({\n     *   entity: 'user-useremail@example.com',\n     *   generation: 1\n     * }, function(err, aclObject, apiResponse) {});\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * myBucket.acl.get().then(function(data) {\n     *   const aclObject = data[0];\n     *   const apiResponse = data[1];\n     * });\n     *\n     * @example <caption>include:samples/acl.js</caption>\n     * region_tag:storage_print_file_acl\n     * Example of printing a file's ACL:\n     *\n     * @example <caption>include:samples/acl.js</caption>\n     * region_tag:storage_print_file_acl_for_user\n     * Example of printing a file's ACL for a specific user:\n     *\n     * @example <caption>include:samples/acl.js</caption>\n     * region_tag:storage_print_bucket_acl\n     * Example of printing a bucket's ACL:\n     *\n     * @example <caption>include:samples/acl.js</caption>\n     * region_tag:storage_print_bucket_acl_for_user\n     * Example of printing a bucket's ACL for a specific user:\n     */\n    get(optionsOrCallback, cb) {\n        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : null;\n        const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : cb;\n        let path = '';\n        const query = {};\n        if (options) {\n            path = '/' + encodeURIComponent(options.entity);\n            if (options.generation) {\n                query.generation = options.generation;\n            }\n            if (options.userProject) {\n                query.userProject = options.userProject;\n            }\n        }\n        this.request({\n            uri: path,\n            qs: query,\n        }, (err, resp) => {\n            if (err) {\n                callback(err, null, resp);\n                return;\n            }\n            let results;\n            if (resp.items) {\n                results = arrify(resp.items).map(this.makeAclObject_);\n            }\n            else {\n                results = this.makeAclObject_(resp);\n            }\n            callback(null, results, resp);\n        });\n    }\n    /**\n     * @typedef {array} UpdateAclResponse\n     * @property {object} 0 The updated Acl Objects.\n     * @property {object} 1 The full API response.\n     */\n    /**\n     * @callback UpdateAclCallback\n     * @param {?Error} err Request error, if any.\n     * @param {object} acl The updated Acl Objects.\n     * @param {object} apiResponse The full API response.\n     */\n    /**\n     * Update access controls on a {@link Bucket} or {@link File}.\n     *\n     * @see [BucketAccessControls: update API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/bucketAccessControls/update}\n     * @see [ObjectAccessControls: update API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objectAccessControls/update}\n     *\n     * @param {object} options Configuration options.\n     * @param {string} options.entity Whose permissions will be updated.\n     * @param {string} options.role Permissions allowed for the defined entity.\n     *     See {@link Storage.acl}.\n     * @param {number} [options.generation] **File Objects Only** Select a specific\n     *     revision of this file (as opposed to the latest version, the default).\n     * @param {string} [options.userProject] The ID of the project which will be\n     *     billed for the request.\n     * @param {UpdateAclCallback} [callback] Callback function.\n     * @returns {Promise<UpdateAclResponse>}\n     *\n     * @example\n     * const storage = require('@google-cloud/storage')();\n     * const myBucket = storage.bucket('my-bucket');\n     * const myFile = myBucket.file('my-file');\n     *\n     * const options = {\n     *   entity: 'user-useremail@example.com',\n     *   role: gcs.acl.WRITER_ROLE\n     * };\n     *\n     * myBucket.acl.update(options, function(err, aclObject, apiResponse) {});\n     *\n     * //-\n     * // For file ACL operations, you can also specify a `generation` property.\n     * //-\n     * myFile.acl.update({\n     *   entity: 'user-useremail@example.com',\n     *   role: gcs.acl.WRITER_ROLE,\n     *   generation: 1\n     * }, function(err, aclObject, apiResponse) {});\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * myFile.acl.update(options).then(function(data) {\n     *   const aclObject = data[0];\n     *   const apiResponse = data[1];\n     * });\n     */\n    update(options, callback) {\n        const query = {};\n        if (options.generation) {\n            query.generation = options.generation;\n        }\n        if (options.userProject) {\n            query.userProject = options.userProject;\n        }\n        this.request({\n            method: 'PUT',\n            uri: '/' + encodeURIComponent(options.entity),\n            qs: query,\n            json: {\n                role: options.role.toUpperCase(),\n            },\n        }, (err, resp) => {\n            if (err) {\n                callback(err, null, resp);\n                return;\n            }\n            callback(null, this.makeAclObject_(resp), resp);\n        });\n    }\n    /**\n     * Transform API responses to a consistent object format.\n     *\n     * @private\n     */\n    makeAclObject_(accessControlObject) {\n        const obj = {\n            entity: accessControlObject.entity,\n            role: accessControlObject.role,\n        };\n        if (accessControlObject.projectTeam) {\n            obj.projectTeam = accessControlObject.projectTeam;\n        }\n        return obj;\n    }\n    /**\n     * Patch requests up to the bucket's request object.\n     *\n     * @private\n     *\n     * @param {string} method Action.\n     * @param {string} path Request path.\n     * @param {*} query Request query object.\n     * @param {*} body Request body contents.\n     * @param {function} callback Callback function.\n     */\n    request(reqOpts, callback) {\n        reqOpts.uri = this.pathPrefix + reqOpts.uri;\n        this.request_(reqOpts, callback);\n    }\n}\nexports.Acl = Acl;\n/*! Developer Documentation\n *\n * All async methods (except for streams) will return a Promise in the event\n * that a callback is omitted.\n */\npromisify_1.promisifyAll(Acl, {\n    exclude: ['request'],\n});\n//# sourceMappingURL=acl.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/storage/build/src/acl.js?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/storage/build/src/bucket.js":
/*!********************************************************************!*\
  !*** ./src/node_modules/@google-cloud/storage/build/src/bucket.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst common_1 = __webpack_require__(/*! @google-cloud/common */ \"./src/node_modules/@google-cloud/common/build/src/index.js\");\nconst paginator_1 = __webpack_require__(/*! @google-cloud/paginator */ \"@google-cloud/paginator\");\nconst promisify_1 = __webpack_require__(/*! @google-cloud/promisify */ \"@google-cloud/promisify\");\nconst arrify = __webpack_require__(/*! arrify */ \"arrify\");\nconst extend = __webpack_require__(/*! extend */ \"extend\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst mime = __webpack_require__(/*! mime-types */ \"mime-types\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst p_limit_1 = __webpack_require__(/*! p-limit */ \"p-limit\");\nconst util_1 = __webpack_require__(/*! util */ \"util\");\nconst snakeize = __webpack_require__(/*! snakeize */ \"./src/node_modules/snakeize/index.js\");\nconst acl_1 = __webpack_require__(/*! ./acl */ \"./src/node_modules/@google-cloud/storage/build/src/acl.js\");\nconst file_1 = __webpack_require__(/*! ./file */ \"./src/node_modules/@google-cloud/storage/build/src/file.js\");\nconst iam_1 = __webpack_require__(/*! ./iam */ \"./src/node_modules/@google-cloud/storage/build/src/iam.js\");\nconst notification_1 = __webpack_require__(/*! ./notification */ \"./src/node_modules/@google-cloud/storage/build/src/notification.js\");\nconst signer_1 = __webpack_require__(/*! ./signer */ \"./src/node_modules/@google-cloud/storage/build/src/signer.js\");\nvar BucketActionToHTTPMethod;\n(function (BucketActionToHTTPMethod) {\n    BucketActionToHTTPMethod[\"list\"] = \"GET\";\n})(BucketActionToHTTPMethod = exports.BucketActionToHTTPMethod || (exports.BucketActionToHTTPMethod = {}));\n/**\n * The size of a file (in bytes) must be greater than this number to\n * automatically trigger a resumable upload.\n *\n * @const {number}\n * @private\n */\nconst RESUMABLE_THRESHOLD = 5000000;\n/**\n * Create a Bucket object to interact with a Cloud Storage bucket.\n *\n * @class\n * @hideconstructor\n *\n * @param {Storage} storage A {@link Storage} instance.\n * @param {string} name The name of the bucket.\n * @param {object} [options] Configuration object.\n * @param {string} [options.userProject] User project.\n *\n * @example\n * const {Storage} = require('@google-cloud/storage');\n * const storage = new Storage();\n * const bucket = storage.bucket('albums');\n */\nclass Bucket extends common_1.ServiceObject {\n    constructor(storage, name, options) {\n        options = options || {};\n        // Allow for \"gs://\"-style input, and strip any trailing slashes.\n        name = name.replace(/^gs:\\/\\//, '').replace(/\\/+$/, '');\n        const requestQueryObject = {};\n        const userProject = options.userProject;\n        if (typeof userProject === 'string') {\n            requestQueryObject.userProject = userProject;\n        }\n        const methods = {\n            /**\n             * Create a bucket.\n             *\n             * @method Bucket#create\n             * @param {CreateBucketRequest} [metadata] Metadata to set for the bucket.\n             * @param {CreateBucketCallback} [callback] Callback function.\n             * @returns {Promise<CreateBucketResponse>}\n             *\n             * @example\n             * const {Storage} = require('@google-cloud/storage');\n             * const storage = new Storage();\n             * const bucket = storage.bucket('albums');\n             * bucket.create(function(err, bucket, apiResponse) {\n             *   if (!err) {\n             *     // The bucket was created successfully.\n             *   }\n             * });\n             *\n             * //-\n             * // If the callback is omitted, we'll return a Promise.\n             * //-\n             * bucket.create().then(function(data) {\n             *   const bucket = data[0];\n             *   const apiResponse = data[1];\n             * });\n             */\n            create: {\n                reqOpts: {\n                    qs: requestQueryObject,\n                },\n            },\n            /**\n             * @typedef {object} DeleteBucketOptions Configuration options.\n             * @param {string} [userProject] The ID of the project which will be\n             *     billed for the request.\n             */\n            /**\n             * @typedef {array} DeleteBucketResponse\n             * @property {object} 0 The full API response.\n             */\n            /**\n             * @callback DeleteBucketCallback\n             * @param {?Error} err Request error, if any.\n             * @param {object} apiResponse The full API response.\n             */\n            /**\n             * Delete the bucket.\n             *\n             * @see [Buckets: delete API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/buckets/delete}\n             *\n             * @method Bucket#delete\n             * @param {DeleteBucketOptions} [options] Configuration options.\n             * @param {DeleteBucketCallback} [callback] Callback function.\n             * @returns {Promise<DeleteBucketResponse>}\n             *\n             * @example\n             * const {Storage} = require('@google-cloud/storage');\n             * const storage = new Storage();\n             * const bucket = storage.bucket('albums');\n             * bucket.delete(function(err, apiResponse) {});\n             *\n             * //-\n             * // If the callback is omitted, we'll return a Promise.\n             * //-\n             * bucket.delete().then(function(data) {\n             *   const apiResponse = data[0];\n             * });\n             *\n             * @example <caption>include:samples/buckets.js</caption>\n             * region_tag:storage_delete_bucket\n             * Another example:\n             */\n            delete: {\n                reqOpts: {\n                    qs: requestQueryObject,\n                },\n            },\n            /**\n             * @typedef {object} BucketExistsOptions Configuration options for Bucket#exists().\n             * @param {string} [userProject] The ID of the project which will be\n             *     billed for the request.\n             */\n            /**\n             * @typedef {array} BucketExistsResponse\n             * @property {boolean} 0 Whether the {@link Bucket} exists.\n             */\n            /**\n             * @callback BucketExistsCallback\n             * @param {?Error} err Request error, if any.\n             * @param {boolean} exists Whether the {@link Bucket} exists.\n             */\n            /**\n             * Check if the bucket exists.\n             *\n             * @method Bucket#exists\n             * @param {BucketExistsOptions} [options] Configuration options.\n             * @param {BucketExistsCallback} [callback] Callback function.\n             * @returns {Promise<BucketExistsResponse>}\n             *\n             * @example\n             * const {Storage} = require('@google-cloud/storage');\n             * const storage = new Storage();\n             * const bucket = storage.bucket('albums');\n             *\n             * bucket.exists(function(err, exists) {});\n             *\n             * //-\n             * // If the callback is omitted, we'll return a Promise.\n             * //-\n             * bucket.exists().then(function(data) {\n             *   const exists = data[0];\n             * });\n             */\n            exists: {\n                reqOpts: {\n                    qs: requestQueryObject,\n                },\n            },\n            /**\n             * @typedef {object} [GetBucketOptions] Configuration options for Bucket#get()\n             * @property {boolean} [autoCreate] Automatically create the object if\n             *     it does not exist. Default: `false`\n             * @property {string} [userProject] The ID of the project which will be\n             *     billed for the request.\n             */\n            /**\n             * @typedef {array} GetBucketResponse\n             * @property {Bucket} 0 The {@link Bucket}.\n             * @property {object} 1 The full API response.\n             */\n            /**\n             * @callback GetBucketCallback\n             * @param {?Error} err Request error, if any.\n             * @param {Bucket} bucket The {@link Bucket}.\n             * @param {object} apiResponse The full API response.\n             */\n            /**\n             * Get a bucket if it exists.\n             *\n             * You may optionally use this to \"get or create\" an object by providing\n             * an object with `autoCreate` set to `true`. Any extra configuration that\n             * is normally required for the `create` method must be contained within\n             * this object as well.\n             *\n             * @method Bucket#get\n             * @param {GetBucketOptions} [options] Configuration options.\n             * @param {GetBucketCallback} [callback] Callback function.\n             * @returns {Promise<GetBucketResponse>}\n             *\n             * @example\n             * const {Storage} = require('@google-cloud/storage');\n             * const storage = new Storage();\n             * const bucket = storage.bucket('albums');\n             *\n             * bucket.get(function(err, bucket, apiResponse) {\n             *   // `bucket.metadata` has been populated.\n             * });\n             *\n             * //-\n             * // If the callback is omitted, we'll return a Promise.\n             * //-\n             * bucket.get().then(function(data) {\n             *   const bucket = data[0];\n             *   const apiResponse = data[1];\n             * });\n             */\n            get: {\n                reqOpts: {\n                    qs: requestQueryObject,\n                },\n            },\n            /**\n             * @typedef {array} GetBucketMetadataResponse\n             * @property {object} 0 The bucket metadata.\n             * @property {object} 1 The full API response.\n             */\n            /**\n             * @callback GetBucketMetadataCallback\n             * @param {?Error} err Request error, if any.\n             * @param {object} metadata The bucket metadata.\n             * @param {object} apiResponse The full API response.\n             */\n            /**\n             * @typedef {object} GetBucketMetadataOptions Configuration options for Bucket#getMetadata().\n             * @property {string} [userProject] The ID of the project which will be\n             *     billed for the request.\n             */\n            /**\n             * Get the bucket's metadata.\n             *\n             * To set metadata, see {@link Bucket#setMetadata}.\n             *\n             * @see [Buckets: get API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/buckets/get}\n             *\n             * @method Bucket#getMetadata\n             * @param {GetBucketMetadataOptions} [options] Configuration options.\n             * @param {GetBucketMetadataCallback} [callback] Callback function.\n             * @returns {Promise<GetBucketMetadataResponse>}\n             *\n             * @example\n             * const {Storage} = require('@google-cloud/storage');\n             * const storage = new Storage();\n             * const bucket = storage.bucket('albums');\n             *\n             * bucket.getMetadata(function(err, metadata, apiResponse) {});\n             *\n             * //-\n             * // If the callback is omitted, we'll return a Promise.\n             * //-\n             * bucket.getMetadata().then(function(data) {\n             *   const metadata = data[0];\n             *   const apiResponse = data[1];\n             * });\n             *\n             * @example <caption>include:samples/requesterPays.js</caption>\n             * region_tag:storage_get_requester_pays_status\n             * Example of retrieving the requester pays status of a bucket:\n             */\n            getMetadata: {\n                reqOpts: {\n                    qs: requestQueryObject,\n                },\n            },\n            /**\n             * @typedef {object} SetBucketMetadataOptions Configuration options for Bucket#setMetadata().\n             * @property {string} [userProject] The ID of the project which will be\n             *     billed for the request.\n             */\n            /**\n             * @typedef {array} SetBucketMetadataResponse\n             * @property {object} apiResponse The full API response.\n             */\n            /**\n             * @callback SetBucketMetadataCallback\n             * @param {?Error} err Request error, if any.\n             * @param {object} metadata The bucket metadata.\n             */\n            /**\n             * Set the bucket's metadata.\n             *\n             * @see [Buckets: patch API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/buckets/patch}\n             *\n             * @method Bucket#setMetadata\n             * @param {object<string, *>} metadata The metadata you wish to set.\n             * @param {SetBucketMetadataOptions} [options] Configuration options.\n             * @param {SetBucketMetadataCallback} [callback] Callback function.\n             * @returns {Promise<SetBucketMetadataResponse>}\n             *\n             * @example\n             * const {Storage} = require('@google-cloud/storage');\n             * const storage = new Storage();\n             * const bucket = storage.bucket('albums');\n             *\n             * //-\n             * // Set website metadata field on the bucket.\n             * //-\n             * const metadata = {\n             *   website: {\n             *     mainPageSuffix: 'http://example.com',\n             *     notFoundPage: 'http://example.com/404.html'\n             *   }\n             * };\n             *\n             * bucket.setMetadata(metadata, function(err, apiResponse) {});\n             *\n             * //-\n             * // Enable versioning for your bucket.\n             * //-\n             * bucket.setMetadata({\n             *   versioning: {\n             *     enabled: true\n             *   }\n             * }, function(err, apiResponse) {});\n             *\n             * //-\n             * // Enable KMS encryption for objects within this bucket.\n             * //-\n             * bucket.setMetadata({\n             *   encryption: {\n             *     defaultKmsKeyName: 'projects/grape-spaceship-123/...'\n             *   }\n             * }, function(err, apiResponse) {});\n             *\n             * //-\n             * // Set the default event-based hold value for new objects in this\n             * // bucket.\n             * //-\n             * bucket.setMetadata({\n             *   defaultEventBasedHold: true\n             * }, function(err, apiResponse) {});\n             *\n             * //-\n             * // Remove object lifecycle rules.\n             * //-\n             * bucket.setMetadata({\n             *   lifecycle: null\n             * }, function(err, apiResponse) {});\n             *\n             * //-\n             * // If the callback is omitted, we'll return a Promise.\n             * //-\n             * bucket.setMetadata(metadata).then(function(data) {\n             *   const apiResponse = data[0];\n             * });\n             */\n            setMetadata: {\n                reqOpts: {\n                    qs: requestQueryObject,\n                },\n            },\n        };\n        super({\n            parent: storage,\n            baseUrl: '/b',\n            id: name,\n            createMethod: storage.createBucket.bind(storage),\n            methods,\n        });\n        this.name = name;\n        this.storage = storage;\n        this.userProject = options.userProject;\n        this.acl = new acl_1.Acl({\n            request: this.request.bind(this),\n            pathPrefix: '/acl',\n        });\n        this.acl.default = new acl_1.Acl({\n            request: this.request.bind(this),\n            pathPrefix: '/defaultObjectAcl',\n        });\n        this.iam = new iam_1.Iam(this);\n        this.getFilesStream = paginator_1.paginator.streamify('getFiles');\n    }\n    /**\n     * @typedef {object} AddLifecycleRuleOptions Configuration options for Bucket#addLifecycleRule().\n     * @property {string} [append=true] The new rules will be appended to any\n     *     pre-existing rules.\n     */\n    /**\n     * Add an object lifecycle management rule to the bucket.\n     *\n     * By default, an Object Lifecycle Management rule provided to this method\n     * will be included to the existing policy. To replace all existing rules,\n     * supply the `options` argument, setting `append` to `false`.\n     *\n     * @see [Object Lifecycle Management]{@link https://cloud.google.com/storage/docs/lifecycle}\n     * @see [Buckets: patch API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/buckets/patch}\n     *\n     * @param {LifecycleRule} rule The new lifecycle rule to be added to objects\n     *     in this bucket.\n     * @param {string} [rule.storageClass] When using the `setStorageClass`\n     *     action, provide this option to dictate which storage class the object\n     *     should update to.\n     * @param {AddLifecycleRuleOptions} [options] Configuration object.\n     * @param {boolean} [options.append=true] Append the new rule to the existing\n     *     policy.\n     * @param {SetBucketMetadataCallback} [callback] Callback function.\n     * @returns {Promise<SetBucketMetadataResponse>}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const bucket = storage.bucket('albums');\n     *\n     * //-\n     * // Automatically have an object deleted from this bucket once it is 3 years\n     * // of age.\n     * //-\n     * bucket.addLifecycleRule({\n     *   action: 'delete',\n     *   condition: {\n     *     age: 365 * 3 // Specified in days.\n     *   }\n     * }, function(err, apiResponse) {\n     *   if (err) {\n     *     // Error handling omitted.\n     *   }\n     *\n     *   const lifecycleRules = bucket.metadata.lifecycle.rule;\n     *\n     *   // Iterate over the Object Lifecycle Management rules on this bucket.\n     *   lifecycleRules.forEach(lifecycleRule => {});\n     * });\n     *\n     * //-\n     * // By default, the rule you provide will be added to the existing policy.\n     * // Optionally, you can disable this behavior to replace all of the\n     * // pre-existing rules.\n     * //-\n     * const options = {\n     *   append: false\n     * };\n     *\n     * bucket.addLifecycleRule({\n     *   action: 'delete',\n     *   condition: {\n     *     age: 365 * 3 // Specified in days.\n     *   }\n     * }, options, function(err, apiResponse) {\n     *   if (err) {\n     *     // Error handling omitted.\n     *   }\n     *\n     *   // All rules have been replaced with the new \"delete\" rule.\n     *\n     *   // Iterate over the Object Lifecycle Management rules on this bucket.\n     *   lifecycleRules.forEach(lifecycleRule => {});\n     * });\n     *\n     * //-\n     * // For objects created before 2018, \"downgrade\" the storage class.\n     * //-\n     * bucket.addLifecycleRule({\n     *   action: 'setStorageClass',\n     *   storageClass: 'COLDLINE',\n     *   condition: {\n     *     createdBefore: new Date('2018')\n     *   }\n     * }, function(err, apiResponse) {});\n     *\n     * //-\n     * // Delete objects created before 2016 which have the Coldline storage\n     * // class.\n     * //-\n     * bucket.addLifecycleRule({\n     *   action: 'delete',\n     *   condition: {\n     *     matchesStorageClass: [\n     *       'COLDLINE'\n     *     ],\n     *     createdBefore: new Date('2016')\n     *   }\n     * }, function(err, apiResponse) {});\n     */\n    addLifecycleRule(rule, optionsOrCallback, callback) {\n        let options;\n        if (typeof optionsOrCallback === 'function') {\n            callback = optionsOrCallback;\n        }\n        else if (optionsOrCallback) {\n            options = optionsOrCallback;\n        }\n        options = options || {};\n        callback = callback || common_1.util.noop;\n        const newLifecycleRules = arrify(rule).map(rule => {\n            if (typeof rule.action === 'object') {\n                // This is a raw-formatted rule object, the way the API expects.\n                // Just pass it through as-is.\n                return rule;\n            }\n            const apiFormattedRule = {};\n            apiFormattedRule.condition = {};\n            apiFormattedRule.action = {\n                type: rule.action,\n            };\n            // @TODO: Remove if the API becomes less picky.\n            if (rule.action === 'delete') {\n                apiFormattedRule.action.type = 'Delete';\n            }\n            if (rule.storageClass) {\n                apiFormattedRule.action.storageClass = rule.storageClass;\n            }\n            for (const condition in rule.condition) {\n                if (rule.condition[condition] instanceof Date) {\n                    apiFormattedRule.condition[condition] = rule.condition[condition]\n                        .toISOString()\n                        .replace(/T.+$/, '');\n                }\n                else {\n                    apiFormattedRule.condition[condition] = rule.condition[condition];\n                }\n            }\n            return apiFormattedRule;\n        });\n        if (options.append === false) {\n            this.setMetadata({ lifecycle: { rule: newLifecycleRules } }, callback);\n            return;\n        }\n        // The default behavior appends the previously-defined lifecycle rules with\n        // the new ones just passed in by the user.\n        this.getMetadata((err, metadata) => {\n            if (err) {\n                callback(err);\n                return;\n            }\n            const currentLifecycleRules = arrify(metadata.lifecycle && metadata.lifecycle.rule);\n            this.setMetadata({\n                lifecycle: {\n                    rule: currentLifecycleRules.concat(newLifecycleRules),\n                },\n            }, callback);\n        });\n    }\n    /**\n     * @typedef {object} CombineOptions\n     * @property {string} [kmsKeyName] Resource name of the Cloud KMS key, of\n     *     the form\n     *     `projects/my-project/locations/location/keyRings/my-kr/cryptoKeys/my-key`,\n     *     that will be used to encrypt the object. Overwrites the object\n     * metadata's `kms_key_name` value, if any.\n     * @property {string} [userProject] The ID of the project which will be\n     *     billed for the request.\n     */\n    /**\n     * @callback CombineCallback\n     * @param {?Error} err Request error, if any.\n     * @param {File} newFile The new {@link File}.\n     * @param {object} apiResponse The full API response.\n     */\n    /**\n     * @typedef {array} CombineResponse\n     * @property {File} 0 The new {@link File}.\n     * @property {object} 1 The full API response.\n     */\n    /**\n     * Combine multiple files into one new file.\n     *\n     * @see [Objects: compose API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objects/compose}\n     *\n     * @throws {Error} if a non-array is provided as sources argument.\n     * @throws {Error} if no sources are provided.\n     * @throws {Error} if no destination is provided.\n     *\n     * @param {string[]|File[]} sources The source files that will be\n     *     combined.\n     * @param {string|File} destination The file you would like the\n     *     source files combined into.\n     * @param {CombineOptions} [options] Configuration options.\n     * @param {CombineCallback} [callback] Callback function.\n     * @returns {Promise<CombineResponse>}\n     *\n     * @example\n     * const logBucket = storage.bucket('log-bucket');\n     *\n     * const sources = [\n     *   logBucket.file('2013-logs.txt'),\n     *   logBucket.file('2014-logs.txt')\n     * ];\n     *\n     * const allLogs = logBucket.file('all-logs.txt');\n     *\n     * logBucket.combine(sources, allLogs, function(err, newFile, apiResponse) {\n     *   // newFile === allLogs\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * logBucket.combine(sources, allLogs).then(function(data) {\n     *   const newFile = data[0];\n     *   const apiResponse = data[1];\n     * });\n     */\n    combine(sources, destination, optionsOrCallback, callback) {\n        if (!Array.isArray(sources) || sources.length === 0) {\n            throw new Error('You must provide at least one source file.');\n        }\n        if (!destination) {\n            throw new Error('A destination file must be specified.');\n        }\n        let options = {};\n        if (typeof optionsOrCallback === 'function') {\n            callback = optionsOrCallback;\n        }\n        else if (optionsOrCallback) {\n            options = optionsOrCallback;\n        }\n        const convertToFile = (file) => {\n            if (file instanceof file_1.File) {\n                return file;\n            }\n            return this.file(file);\n        };\n        // tslint:disable-next-line:no-any\n        sources = sources.map(convertToFile);\n        const destinationFile = convertToFile(destination);\n        callback = callback || common_1.util.noop;\n        if (!destinationFile.metadata.contentType) {\n            const destinationContentType = mime.contentType(destinationFile.name);\n            if (destinationContentType) {\n                destinationFile.metadata.contentType = destinationContentType;\n            }\n        }\n        // Make the request from the destination File object.\n        destinationFile.request({\n            method: 'POST',\n            uri: '/compose',\n            json: {\n                destination: {\n                    contentType: destinationFile.metadata.contentType,\n                },\n                sourceObjects: sources.map(source => {\n                    const sourceObject = {\n                        name: source.name,\n                    };\n                    if (source.metadata && source.metadata.generation) {\n                        sourceObject.generation = source.metadata.generation;\n                    }\n                    return sourceObject;\n                }),\n            },\n            qs: options,\n        }, (err, resp) => {\n            if (err) {\n                callback(err, null, resp);\n                return;\n            }\n            callback(null, destinationFile, resp);\n        });\n    }\n    /**\n     * See a [Objects:\n     * watchAll request\n     * body](https://cloud.google.com/storage/docs/json_api/v1/objects/watchAll).\n     *\n     * @typedef {object} CreateChannelConfig\n     * @property {string} address The address where notifications are\n     *     delivered for this channel.\n     * @extends WatchAllOptions\n     */\n    /**\n     * @typedef {object} CreateChannelOptions\n     * @property {string} [userProject] The ID of the project which will be\n     *     billed for the request.\n     */\n    /**\n     * @typedef {array} CreateChannelResponse\n     * @property {Channel} 0 The new {@link Channel}.\n     * @property {object} 1 The full API response.\n     */\n    /**\n     * @callback CreateChannelCallback\n     * @param {?Error} err Request error, if any.\n     * @param {Channel} channel The new {@link Channel}.\n     * @param {object} apiResponse The full API response.\n     */\n    /**\n     * Create a channel that will be notified when objects in this bucket changes.\n     *\n     * @throws {Error} If an ID is not provided.\n     * @throws {Error} If an address is not provided.\n     *\n     * @see [Objects: watchAll API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objects/watchAll}\n     *\n     * @param {string} id The ID of the channel to create.\n     * @param {CreateChannelConfig} config Configuration for creating channel.\n     * @param {CreateChannelOptions} [options] Configuration options.\n     * @param {CreateChannelCallback} [callback] Callback function.\n     * @returns {Promise<CreateChannelResponse>}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const bucket = storage.bucket('albums');\n     * const id = 'new-channel-id';\n     *\n     * const config = {\n     *   address: 'https://...'\n     * };\n     *\n     * bucket.createChannel(id, config, function(err, channel, apiResponse) {\n     *   if (!err) {\n     *     // Channel created successfully.\n     *   }\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * bucket.createChannel(id, config).then(function(data) {\n     *   const channel = data[0];\n     *   const apiResponse = data[1];\n     * });\n     */\n    createChannel(id, config, optionsOrCallback, callback) {\n        if (typeof id !== 'string') {\n            throw new Error('An ID is required to create a channel.');\n        }\n        if (typeof config.address !== 'string') {\n            throw new Error('An address is required to create a channel.');\n        }\n        let options = {};\n        if (typeof optionsOrCallback === 'function') {\n            callback = optionsOrCallback;\n        }\n        else if (optionsOrCallback) {\n            options = optionsOrCallback;\n        }\n        this.request({\n            method: 'POST',\n            uri: '/o/watch',\n            json: Object.assign({\n                id,\n                type: 'web_hook',\n            }, config),\n            qs: options,\n        }, (err, apiResponse) => {\n            if (err) {\n                callback(err, null, apiResponse);\n                return;\n            }\n            const resourceId = apiResponse.resourceId;\n            const channel = this.storage.channel(id, resourceId);\n            channel.metadata = apiResponse;\n            callback(null, channel, apiResponse);\n        });\n    }\n    /**\n     * Metadata to set for the Notification.\n     *\n     * @typedef {object} CreateNotificationOptions\n     * @property {object} [customAttributes] An optional list of additional\n     *     attributes to attach to each Cloud PubSub message published for this\n     *     notification subscription.\n     * @property {string[]} [eventTypes] If present, only send notifications about\n     *     listed event types. If empty, sent notifications for all event types.\n     * @property {string} [objectNamePrefix] If present, only apply this\n     *     notification configuration to object names that begin with this prefix.\n     * @property {string} [payloadFormat] The desired content of the Payload.\n     *     Defaults to `JSON_API_V1`.\n     *\n     *     Acceptable values are:\n     *     - `JSON_API_V1`\n     *\n     *     - `NONE`\n     * @property {string} [userProject] The ID of the project which will be\n     *     billed for the request.\n     */\n    /**\n     * @callback CreateNotificationCallback\n     * @param {?Error} err Request error, if any.\n     * @param {Notification} notification The new {@link Notification}.\n     * @param {object} apiResponse The full API response.\n     */\n    /**\n     * @typedef {array} CreateNotificationResponse\n     * @property {Notification} 0 The new {@link Notification}.\n     * @property {object} 1 The full API response.\n     */\n    /**\n     * Creates a notification subscription for the bucket.\n     *\n     * @see [Notifications: insert]{@link https://cloud.google.com/storage/docs/json_api/v1/notifications/insert}\n     *\n     * @param {Topic|string} topic The Cloud PubSub topic to which this\n     *     subscription publishes. If the project ID is omitted, the current\n     * project ID will be used.\n     *\n     *     Acceptable formats are:\n     *     - `projects/grape-spaceship-123/topics/my-topic`\n     *\n     *     - `my-topic`\n     * @param {CreateNotificationOptions} [options] Metadata to set for the\n     *     notification.\n     * @param {CreateNotificationCallback} [callback] Callback function.\n     * @returns {Promise<CreateNotificationResponse>}\n     * @throws {Error} If a valid topic is not provided.\n     * @see Notification#create\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const myBucket = storage.bucket('my-bucket');\n     *\n     * const callback = function(err, notification, apiResponse) {\n     *   if (!err) {\n     *     // The notification was created successfully.\n     *   }\n     * };\n     *\n     * myBucket.createNotification('my-topic', callback);\n     *\n     * //-\n     * // Configure the nofiication by providing Notification metadata.\n     * //-\n     * const metadata = {\n     *   objectNamePrefix: 'prefix-'\n     * };\n     *\n     * myBucket.createNotification('my-topic', metadata, callback);\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * myBucket.createNotification('my-topic').then(function(data) {\n     *   const notification = data[0];\n     *   const apiResponse = data[1];\n     * });\n     *\n     * @example <caption>include:samples/notifications.js</caption>\n     * region_tag:storage_create_notification\n     * Another example:\n     */\n    createNotification(topic, optionsOrCallback, callback) {\n        let options = {};\n        if (typeof optionsOrCallback === 'function') {\n            callback = optionsOrCallback;\n        }\n        else if (optionsOrCallback) {\n            options = optionsOrCallback;\n        }\n        const topicIsObject = topic !== null && typeof topic === 'object';\n        if (topicIsObject && common_1.util.isCustomType(topic, 'pubsub/topic')) {\n            // tslint:disable-next-line:no-any\n            topic = topic.name;\n        }\n        if (typeof topic !== 'string') {\n            throw new Error('A valid topic name is required.');\n        }\n        const body = Object.assign({ topic }, options);\n        if (body.topic.indexOf('projects') !== 0) {\n            body.topic = 'projects/{{projectId}}/topics/' + body.topic;\n        }\n        body.topic = '//pubsub.googleapis.com/' + body.topic;\n        if (!body.payloadFormat) {\n            body.payloadFormat = 'JSON_API_V1';\n        }\n        const query = {};\n        if (body.userProject) {\n            query.userProject = body.userProject;\n            delete body.userProject;\n        }\n        this.request({\n            method: 'POST',\n            uri: '/notificationConfigs',\n            json: snakeize(body),\n            qs: query,\n        }, (err, apiResponse) => {\n            if (err) {\n                callback(err, null, apiResponse);\n                return;\n            }\n            const notification = this.notification(apiResponse.id);\n            notification.metadata = apiResponse;\n            callback(null, notification, apiResponse);\n        });\n    }\n    /**\n     * @typedef {object} DeleteFilesOptions Query object. See {@link Bucket#getFiles}\n     *     for all of the supported properties.\n     * @property {boolean} [force] Suppress errors until all files have been\n     *     processed.\n     */\n    /**\n     * @callback DeleteFilesCallback\n     * @param {?Error|?Error[]} err Request error, if any, or array of errors from\n     *     files that were not able to be deleted.\n     * @param {object} [apiResponse] The full API response.\n     */\n    /**\n     * Iterate over the bucket's files, calling `file.delete()` on each.\n     *\n     * <strong>This is not an atomic request.</strong> A delete attempt will be\n     * made for each file individually. Any one can fail, in which case only a\n     * portion of the files you intended to be deleted would have.\n     *\n     * Operations are performed in parallel, up to 10 at once. The first error\n     * breaks the loop and will execute the provided callback with it. Specify\n     * `{ force: true }` to suppress the errors until all files have had a chance\n     * to be processed.\n     *\n     * The `query` object passed as the first argument will also be passed to\n     * {@link Bucket#getFiles}.\n     *\n     * @see [Objects: delete API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objects/delete}\n     *\n     * @param {DeleteFilesOptions} [query] Query object. See {@link Bucket#getFiles}\n     * @param {DeleteFilesCallback} [callback] Callback function.\n     * @returns {Promise}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const bucket = storage.bucket('albums');\n     *\n     * //-\n     * // Delete all of the files in the bucket.\n     * //-\n     * bucket.deleteFiles(function(err) {});\n     *\n     * //-\n     * // By default, if a file cannot be deleted, this method will stop deleting\n     * // files from your bucket. You can override this setting with `force:\n     * // true`.\n     * //-\n     * bucket.deleteFiles({\n     *   force: true\n     * }, function(errors) {\n     *   // `errors`:\n     *   //    Array of errors if any occurred, otherwise null.\n     * });\n     *\n     * //-\n     * // The first argument to this method acts as a query to\n     * // {@link Bucket#getFiles}. As an example, you can delete files\n     * // which match a prefix.\n     * //-\n     * bucket.deleteFiles({\n     *   prefix: 'images/'\n     * }, function(err) {\n     *   if (!err) {\n     *     // All files in the `images` directory have been deleted.\n     *   }\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * bucket.deleteFiles().then(function() {});\n     */\n    deleteFiles(queryOrCallback, callback) {\n        let query = {};\n        if (typeof queryOrCallback === 'function') {\n            callback = queryOrCallback;\n        }\n        else if (queryOrCallback) {\n            query = queryOrCallback;\n        }\n        const MAX_PARALLEL_LIMIT = 10;\n        const errors = [];\n        const deleteFile = (file) => {\n            return file.delete(query).catch(err => {\n                if (!query.force) {\n                    throw err;\n                }\n                errors.push(err);\n            });\n        };\n        this.getFiles(query)\n            .then(([files]) => {\n            const limit = p_limit_1.default(MAX_PARALLEL_LIMIT);\n            const promises = files.map(file => {\n                return limit(() => deleteFile(file));\n            });\n            return Promise.all(promises);\n        })\n            .then(() => callback(errors.length > 0 ? errors : null), callback);\n    }\n    /**\n     * @typedef {array} DeleteLabelsResponse\n     * @property {object} 0 The full API response.\n     */\n    /**\n     * @callback DeleteLabelsCallback\n     * @param {?Error} err Request error, if any.\n     * @param {object} metadata Bucket's metadata.\n     */\n    /**\n     * Delete one or more labels from this bucket.\n     *\n     * @param {string|string[]} labels The labels to delete. If no labels are\n     *     provided, all of the labels are removed.\n     * @param {DeleteLabelsCallback} [callback] Callback function.\n     * @returns {Promise<DeleteLabelsResponse>}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const bucket = storage.bucket('albums');\n     *\n     * //-\n     * // Delete all of the labels from this bucket.\n     * //-\n     * bucket.deleteLabels(function(err, apiResponse) {});\n     *\n     * //-\n     * // Delete a single label.\n     * //-\n     * bucket.deleteLabels('labelone', function(err, apiResponse) {});\n     *\n     * //-\n     * // Delete a specific set of labels.\n     * //-\n     * bucket.deleteLabels([\n     *   'labelone',\n     *   'labeltwo'\n     * ], function(err, apiResponse) {});\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * bucket.deleteLabels().then(function(data) {\n     *   const apiResponse = data[0];\n     * });\n     */\n    deleteLabels(labelsOrCallback, callback) {\n        let labels = new Array();\n        if (typeof labelsOrCallback === 'function') {\n            callback = labelsOrCallback;\n        }\n        else if (labelsOrCallback) {\n            labels = arrify(labelsOrCallback);\n        }\n        const deleteLabels = (labels) => {\n            const nullLabelMap = labels.reduce((nullLabelMap, labelKey) => {\n                nullLabelMap[labelKey] = null;\n                return nullLabelMap;\n            }, {});\n            this.setLabels(nullLabelMap, callback);\n        };\n        if (labels.length === 0) {\n            this.getLabels((err, labels) => {\n                if (err) {\n                    callback(err);\n                    return;\n                }\n                deleteLabels(Object.keys(labels));\n            });\n        }\n        else {\n            deleteLabels(labels);\n        }\n    }\n    /**\n     * @typedef {array} DisableRequesterPaysResponse\n     * @property {object} 0 The full API response.\n     */\n    /**\n     * @callback DisableRequesterPaysCallback\n     * @param {?Error} err Request error, if any.\n     * @param {object} apiResponse The full API response.\n     */\n    /**\n     * <div class=\"notice\">\n     *   <strong>Early Access Testers Only</strong>\n     *   <p>\n     *     This feature is not yet widely-available.\n     *   </p>\n     * </div>\n     *\n     * Disable `requesterPays` functionality from this bucket.\n     *\n     * @param {DisableRequesterPaysCallback} [callback] Callback function.\n     * @returns {Promise<DisableRequesterPaysCallback>}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const bucket = storage.bucket('albums');\n     *\n     * bucket.disableRequesterPays(function(err, apiResponse) {\n     *   if (!err) {\n     *     // requesterPays functionality disabled successfully.\n     *   }\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * bucket.disableRequesterPays().then(function(data) {\n     *   const apiResponse = data[0];\n     * });\n     *\n     * @example <caption>include:samples/requesterPays.js</caption>\n     * region_tag:storage_disable_requester_pays\n     * Example of disabling requester pays:\n     */\n    disableRequesterPays(callback) {\n        this.setMetadata({\n            billing: {\n                requesterPays: false,\n            },\n        }, callback || common_1.util.noop);\n    }\n    /**\n     * Configuration object for enabling logging.\n     *\n     * @typedef {object} EnableLoggingOptions\n     * @property {string|Bucket} [bucket] The bucket for the log entries. By\n     *     default, the current bucket is used.\n     * @property {string} prefix A unique prefix for log object names.\n     */\n    /**\n     * Enable logging functionality for this bucket. This will make two API\n     * requests, first to grant Cloud Storage WRITE permission to the bucket, then\n     * to set the appropriate configuration on the Bucket's metadata.\n     *\n     * @param {EnableLoggingOptions} config Configuration options.\n     * @param {SetBucketMetadataCallback} [callback] Callback function.\n     * @returns {Promise<SetBucketMetadataResponse>}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const bucket = storage.bucket('albums');\n     *\n     * const config = {\n     *   prefix: 'log'\n     * };\n     *\n     * bucket.enableLogging(config, function(err, apiResponse) {\n     *   if (!err) {\n     *     // Logging functionality enabled successfully.\n     *   }\n     * });\n     *\n     * @example <caption>Optionally, provide a destination bucket.</caption>\n     * const config = {\n     *   prefix: 'log',\n     *   bucket: 'destination-bucket'\n     * };\n     *\n     * bucket.enableLogging(config, function(err, apiResponse) {});\n     *\n     * @example <caption>If the callback is omitted, we'll return a Promise.</caption>\n     * bucket.enableLogging(config).then(function(data) {\n     *   const apiResponse = data[0];\n     * });\n     */\n    enableLogging(config, callback) {\n        if (!config ||\n            typeof config === 'function' ||\n            typeof config.prefix === 'undefined') {\n            throw new Error('A configuration object with a prefix is required.');\n        }\n        const logBucket = config.bucket\n            ? config.bucket.id || config.bucket\n            : this.id;\n        (async () => {\n            let setMetadataResponse;\n            try {\n                const [policy] = await this.iam.getPolicy();\n                policy.bindings.push({\n                    members: ['group:cloud-storage-analytics@google.com'],\n                    role: 'roles/storage.objectCreator',\n                });\n                await this.iam.setPolicy(policy);\n                [setMetadataResponse] = await this.setMetadata({\n                    logging: {\n                        logBucket,\n                        logObjectPrefix: config.prefix,\n                    },\n                });\n            }\n            catch (e) {\n                callback(e);\n                return;\n            }\n            callback(null, setMetadataResponse);\n        })();\n    }\n    /**\n     * @typedef {array} EnableRequesterPaysResponse\n     * @property {object} 0 The full API response.\n     */\n    /**\n     * @callback EnableRequesterPaysCallback\n     * @param {?Error} err Request error, if any.\n     * @param {object} apiResponse The full API response.\n     */\n    /**\n     * <div class=\"notice\">\n     *   <strong>Early Access Testers Only</strong>\n     *   <p>\n     *     This feature is not yet widely-available.\n     *   </p>\n     * </div>\n     *\n     * Enable `requesterPays` functionality for this bucket. This enables you, the\n     * bucket owner, to have the requesting user assume the charges for the access\n     * to your bucket and its contents.\n     *\n     * @param {EnableRequesterPaysCallback} [callback] Callback function.\n     * @returns {Promise<EnableRequesterPaysResponse>}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const bucket = storage.bucket('albums');\n     *\n     * bucket.enableRequesterPays(function(err, apiResponse) {\n     *   if (!err) {\n     *     // requesterPays functionality enabled successfully.\n     *   }\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * bucket.enableRequesterPays().then(function(data) {\n     *   const apiResponse = data[0];\n     * });\n     *\n     * @example <caption>include:samples/requesterPays.js</caption>\n     * region_tag:storage_enable_requester_pays\n     * Example of enabling requester pays:\n     */\n    enableRequesterPays(callback) {\n        this.setMetadata({\n            billing: {\n                requesterPays: true,\n            },\n        }, callback || common_1.util.noop);\n    }\n    /**\n     * Create a {@link File} object. See {@link File} to see how to handle\n     * the different use cases you may have.\n     *\n     * @param {string} name The name of the file in this bucket.\n     * @param {object} [options] Configuration options.\n     * @param {string|number} [options.generation] Only use a specific revision of\n     *     this file.\n     * @param {string} [options.encryptionKey] A custom encryption key. See\n     *     [Customer-supplied Encryption\n     * Keys](https://cloud.google.com/storage/docs/encryption#customer-supplied).\n     * @param {string} [options.kmsKeyName] The name of the Cloud KMS key that will\n     *     be used to encrypt the object. Must be in the format:\n     *     `projects/my-project/locations/location/keyRings/my-kr/cryptoKeys/my-key`.\n     *     KMS key ring must use the same location as the bucket.\n     * @returns {File}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const bucket = storage.bucket('albums');\n     * const file = bucket.file('my-existing-file.png');\n     */\n    file(name, options) {\n        if (!name) {\n            throw Error('A file name must be specified.');\n        }\n        return new file_1.File(this, name, options);\n    }\n    /**\n     * @typedef {array} GetFilesResponse\n     * @property {File[]} 0 Array of {@link File} instances.\n     */\n    /**\n     * @callback GetFilesCallback\n     * @param {?Error} err Request error, if any.\n     * @param {File[]} files Array of {@link File} instances.\n     */\n    /**\n     * Query object for listing files.\n     *\n     * @typedef {object} GetFilesOptions\n     * @property {boolean} [autoPaginate=true] Have pagination handled\n     *     automatically.\n     * @property {string} [delimiter] Results will contain only objects whose\n     *     names, aside from the prefix, do not contain delimiter. Objects whose\n     *     names, aside from the prefix, contain delimiter will have their name\n     *     truncated after the delimiter, returned in `apiResponse.prefixes`.\n     *     Duplicate prefixes are omitted.\n     * @property {string} [directory] Filter results based on a directory name, or\n     *     more technically, a \"prefix\".\n     * @property {string} [prefix] Filter results to objects whose names begin\n     *     with this prefix.\n     * @property {number} [maxApiCalls] Maximum number of API calls to make.\n     * @property {number} [maxResults] Maximum number of items plus prefixes to\n     *     return.\n     * @property {string} [pageToken] A previously-returned page token\n     *     representing part of the larger set of results to view.\n     * @property {string} [userProject] The ID of the project which will be\n     *     billed for the request.\n     * @property {boolean} [versions] If true, returns File objects scoped to\n     *     their versions.\n     */\n    /**\n     * Get {@link File} objects for the files currently in the bucket.\n     *\n     * @see [Objects: list API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objects/list}\n     *\n     * @param {GetFilesOptions} [query] Query object for listing files.\n     * @param {GetFilesCallback} [callback] Callback function.\n     * @returns {Promise<GetFilesResponse>}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const bucket = storage.bucket('albums');\n     *\n     * bucket.getFiles(function(err, files) {\n     *   if (!err) {\n     *     // files is an array of File objects.\n     *   }\n     * });\n     *\n     * //-\n     * // If your bucket has versioning enabled, you can get all of your files\n     * // scoped to their generation.\n     * //-\n     * bucket.getFiles({\n     *   versions: true\n     * }, function(err, files) {\n     *   // Each file is scoped to its generation.\n     * });\n     *\n     * //-\n     * // To control how many API requests are made and page through the results\n     * // manually, set `autoPaginate` to `false`.\n     * //-\n     * const callback = function(err, files, nextQuery, apiResponse) {\n     *   if (nextQuery) {\n     *     // More results exist.\n     *     bucket.getFiles(nextQuery, callback);\n     *   }\n     *\n     *   // The `metadata` property is populated for you with the metadata at the\n     *   // time of fetching.\n     *   files[0].metadata;\n     *\n     *   // However, in cases where you are concerned the metadata could have\n     *   // changed, use the `getMetadata` method.\n     *   files[0].getMetadata(function(err, metadata) {});\n     * };\n     *\n     * bucket.getFiles({\n     *   autoPaginate: false\n     * }, callback);\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * bucket.getFiles().then(function(data) {\n     *   const files = data[0];\n     * });\n     *\n     * @example <caption><h6>Simulating a File System</h6><p>With `autoPaginate: false`, it's possible to iterate over files which incorporate a common structure using a delimiter.</p><p>Consider the following remote objects:</p><ol><li>\"a\"</li><li>\"a/b/c/d\"</li><li>\"b/d/e\"</li></ol><p>Using a delimiter of `/` will return a single file, \"a\".</p><p>`apiResponse.prefixes` will return the \"sub-directories\" that were found:</p><ol><li>\"a/\"</li><li>\"b/\"</li></ol></caption>\n     * bucket.getFiles({\n     *   autoPaginate: false,\n     *   delimiter: '/'\n     * }, function(err, files, nextQuery, apiResponse) {\n     *   // files = [\n     *   //   {File} // File object for file \"a\"\n     *   // ]\n     *\n     *   // apiResponse.prefixes = [\n     *   //   'a/',\n     *   //   'b/'\n     *   // ]\n     * });\n     *\n     * @example <caption>Using prefixes, it's now possible to simulate a file system with follow-up requests.</caption>\n     * bucket.getFiles({\n     *   autoPaginate: false,\n     *   delimiter: '/',\n     *   prefix: 'a/'\n     * }, function(err, files, nextQuery, apiResponse) {\n     *   // No files found within \"directory\" a.\n     *   // files = []\n     *\n     *   // However, a \"sub-directory\" was found.\n     *   // This prefix can be used to continue traversing the \"file system\".\n     *   // apiResponse.prefixes = [\n     *   //   'a/b/'\n     *   // ]\n     * });\n     *\n     * @example <caption>include:samples/files.js</caption>\n     * region_tag:storage_list_files\n     * Another example:\n     *\n     * @example <caption>include:samples/files.js</caption>\n     * region_tag:storage_list_files_with_prefix\n     * Example of listing files, filtered by a prefix:\n     */\n    getFiles(queryOrCallback, callback) {\n        let query = typeof queryOrCallback === 'object' ? queryOrCallback : {};\n        if (!callback) {\n            callback = queryOrCallback;\n        }\n        query = Object.assign({}, query);\n        if (query.directory) {\n            query.prefix = `${query.directory}/`.replace(/\\/*$/, '/');\n            delete query.directory;\n        }\n        this.request({\n            uri: '/o',\n            qs: query,\n        }, (err, resp) => {\n            if (err) {\n                // tslint:disable-next-line:no-any\n                callback(err, null, null, resp);\n                return;\n            }\n            const files = arrify(resp.items).map((file) => {\n                const options = {};\n                if (query.versions) {\n                    options.generation = file.generation;\n                }\n                if (file.kmsKeyName) {\n                    options.kmsKeyName = file.kmsKeyName;\n                }\n                const fileInstance = this.file(file.name, options);\n                fileInstance.metadata = file;\n                return fileInstance;\n            });\n            let nextQuery = null;\n            if (resp.nextPageToken) {\n                nextQuery = Object.assign({}, query, {\n                    pageToken: resp.nextPageToken,\n                });\n            }\n            // tslint:disable-next-line:no-any\n            callback(null, files, nextQuery, resp);\n        });\n    }\n    /**\n     * @typedef {object} GetLabelsOptions Configuration options for Bucket#getLabels().\n     * @param {string} [userProject] The ID of the project which will be\n     *     billed for the request.\n     */\n    /**\n     * @typedef {array} GetLabelsResponse\n     * @property {object} 0 Object of labels currently set on this bucket.\n     */\n    /**\n     * @callback GetLabelsCallback\n     * @param {?Error} err Request error, if any.\n     * @param {object} labels Object of labels currently set on this bucket.\n     */\n    /**\n     * Get the labels currently set on this bucket.\n     *\n     * @param {object} [options] Configuration options.\n     * @param {string} [options.userProject] The ID of the project which will be\n     *     billed for the request.\n     * @param {GetLabelsCallback} [callback] Callback function.\n     * @returns {Promise<GetLabelsCallback>}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const bucket = storage.bucket('albums');\n     *\n     * bucket.getLabels(function(err, labels) {\n     *   if (err) {\n     *     // Error handling omitted.\n     *   }\n     *\n     *   // labels = {\n     *   //   label: 'labelValue',\n     *   //   ...\n     *   // }\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * bucket.getLabels().then(function(data) {\n     *   const labels = data[0];\n     * });\n     */\n    getLabels(optionsOrCallback, callback) {\n        let options = {};\n        if (typeof optionsOrCallback === 'function') {\n            callback = optionsOrCallback;\n        }\n        else if (optionsOrCallback) {\n            options = optionsOrCallback;\n        }\n        this.getMetadata(options, (err, metadata) => {\n            if (err) {\n                callback(err, null);\n                return;\n            }\n            callback(null, metadata.labels || {});\n        });\n    }\n    /**\n     * @typedef {object} GetNotificationOptions Configuration options for Bucket#getNotification().\n     * @property {string} [userProject] The ID of the project which will be\n     *     billed for the request.\n     */\n    /**\n     * @callback GetNotificationsCallback\n     * @param {?Error} err Request error, if any.\n     * @param {Notification[]} notifications Array of {@link Notification}\n     *     instances.\n     * @param {object} apiResponse The full API response.\n     */\n    /**\n     * @typedef {array} GetNotificationsResponse\n     * @property {Notification[]} 0 Array of {@link Notification} instances.\n     * @property {object} 1 The full API response.\n     */\n    /**\n     * Retrieves a list of notification subscriptions for a given bucket.\n     *\n     * @see [Notifications: list]{@link https://cloud.google.com/storage/docs/json_api/v1/notifications/list}\n     *\n     * @param {GetNotificationsOptions} [options] Configuration options.\n     * @param {GetNotificationsCallback} [callback] Callback function.\n     * @returns {Promise<GetNotificationsResponse>}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const bucket = storage.bucket('my-bucket');\n     *\n     * bucket.getNotifications(function(err, notifications, apiResponse) {\n     *   if (!err) {\n     *     // notifications is an array of Notification objects.\n     *   }\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * bucket.getNotifications().then(function(data) {\n     *   const notifications = data[0];\n     *   const apiResponse = data[1];\n     * });\n     *\n     * @example <caption>include:samples/notifications.js</caption>\n     * region_tag:storage_list_notifications\n     * Another example:\n     */\n    getNotifications(optionsOrCallback, callback) {\n        let options = {};\n        if (typeof optionsOrCallback === 'function') {\n            callback = optionsOrCallback;\n        }\n        else if (optionsOrCallback) {\n            options = optionsOrCallback;\n        }\n        this.request({\n            uri: '/notificationConfigs',\n            qs: options,\n        }, (err, resp) => {\n            if (err) {\n                callback(err, null, resp);\n                return;\n            }\n            const notifications = arrify(resp.items).map((notification) => {\n                const notificationInstance = this.notification(notification.id);\n                notificationInstance.metadata = notification;\n                return notificationInstance;\n            });\n            callback(null, notifications, resp);\n        });\n    }\n    /**\n     * @typedef {array} GetSignedUrlResponse\n     * @property {object} 0 The signed URL.\n     */\n    /**\n     * @callback GetSignedUrlCallback\n     * @param {?Error} err Request error, if any.\n     * @param {object} url The signed URL.\n     */\n    /**\n     * @typedef {object} GetBucketSignedUrlConfig\n     * @property {string} action Currently only supports \"list\" (HTTP: GET).\n     * @property {*} expires A timestamp when this link will expire. Any value\n     *     given is passed to `new Date()`.\n     *     Note: 'v4' supports maximum duration of 7 days (604800 seconds) from now.\n     * @property {string} [version='v2'] The signing version to use, either\n     *     'v2' or 'v4'.\n     * @param {boolean} [virtualHostedStyle=false] Use virtual hosted-style\n     *     URLs ('https://mybucket.storage.googleapis.com/...') instead of path-style\n     *     ('https://storage.googleapis.com/mybucket/...'). Virtual hosted-style URLs\n     *     should generally be preferred instaed of path-style URL.\n     *     Currently defaults to `false` for path-style, although this may change in a\n     *     future major-version release.\n     * @property {string} [cname] The cname for this bucket, i.e.,\n     *     \"https://cdn.example.com\".\n     *     See [reference]{@link https://cloud.google.com/storage/docs/access-control/signed-urls#example}\n     * @property {object} [extensionHeaders] If these headers are used, the\n     *     server will check to make sure that the client provides matching\n     * values. See [Canonical extension\n     * headers](https://cloud.google.com/storage/docs/access-control/signed-urls#about-canonical-extension-headers)\n     *     for the requirements of this feature, most notably:\n     *       - The header name must be prefixed with `x-goog-`\n     *       - The header name must be all lowercase\n     *     Note: Multi-valued header passed as an array in the extensionHeaders\n     *           object is converted into a string, delimited by `,` with\n     *           no space. Requests made using the signed URL will need to\n     *           delimit multi-valued headers using a single `,` as well, or\n     *           else the server will report a mismatched signature.\n     * @param {object} [config.queryParams] Additional query parameters to include\n     *     in the signed URL.\n     */\n    /**\n     * Get a signed URL to allow limited time access to a bucket.\n     *\n     * In Google Cloud Platform environments, such as Cloud Functions and App\n     * Engine, you usually don't provide a `keyFilename` or `credentials` during\n     * instantiation. In those environments, we call the\n     * [signBlob\n     * API](https://cloud.google.com/iam/reference/rest/v1/projects.serviceAccounts/signBlob#authorization-scopes)\n     * to create a signed URL. That API requires either the\n     * `https://www.googleapis.com/auth/iam` or\n     * `https://www.googleapis.com/auth/cloud-platform` scope, so be sure they are\n     * enabled.\n     *\n     * @see [Signed URLs Reference]{@link https://cloud.google.com/storage/docs/access-control/signed-urls}\n     *\n     * @throws {Error} if an expiration timestamp from the past is given.\n     *\n     * @param {GetBucketSignedUrlConfig} config Configuration object.\n     * @param {GetSignedUrlCallback} [callback] Callback function.\n     * @returns {Promise<GetSignedUrlResponse>}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const myBucket = storage.bucket('my-bucket');\n     *\n     * //-\n     * // Generate a URL that allows temporary access to list files in a bucket.\n     * //-\n     * const request = require('request');\n     *\n     * const config = {\n     *   action: 'list',\n     *   expires: '03-17-2025'\n     * };\n     *\n     * bucket.getSignedUrl(config, function(err, url) {\n     *   if (err) {\n     *     console.error(err);\n     *     return;\n     *   }\n     *\n     *   // The bucket is now available to be listed from this URL.\n     *   request(url, function(err, resp) {\n     *     // resp.statusCode = 200\n     *   });\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * bucket.getSignedUrl(config).then(function(data) {\n     *   const url = data[0];\n     * });\n     */\n    getSignedUrl(cfg, callback) {\n        const method = BucketActionToHTTPMethod[cfg.action];\n        if (!method) {\n            throw new Error('The action is not provided or invalid.');\n        }\n        const signConfig = {\n            method,\n            expires: cfg.expires,\n            version: cfg.version,\n            cname: cfg.cname,\n            extensionHeaders: cfg.extensionHeaders || {},\n            queryParams: cfg.queryParams || {},\n        };\n        if (!this.signer) {\n            this.signer = new signer_1.URLSigner(this.storage.authClient, this);\n        }\n        this.signer\n            .getSignedUrl(signConfig)\n            .then(signedUrl => callback(null, signedUrl), callback);\n    }\n    /**\n     * @callback BucketLockCallback\n     * @param {?Error} err Request error, if any.\n     * @param {object} apiResponse The full API response.\n     */\n    /**\n     * Lock a previously-defined retention policy. This will prevent changes to\n     * the policy.\n     *\n     * @throws {Error} if a metageneration is not provided.\n     *\n     * @param {Number|String} metageneration The bucket's metageneration. This is\n     *     accesssible from calling {@link File#getMetadata}.\n     * @param {BucketLockCallback} [callback] Callback function.\n     * @returns {Promise<BucketLockResponse>}\n     *\n     * @example\n     * const storage = require('@google-cloud/storage')();\n     * const bucket = storage.bucket('albums');\n     *\n     * const metageneration = 2;\n     *\n     * bucket.lock(metageneration, function(err, apiResponse) {});\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * bucket.lock(metageneration).then(function(data) {\n     *   const apiResponse = data[0];\n     * });\n     */\n    lock(metageneration, callback) {\n        const metatype = typeof metageneration;\n        if (metatype !== 'number' && metatype !== 'string') {\n            throw new Error('A metageneration must be provided.');\n        }\n        this.request({\n            method: 'POST',\n            uri: '/lockRetentionPolicy',\n            qs: {\n                ifMetagenerationMatch: metageneration,\n            },\n        }, callback);\n    }\n    /**\n     * @typedef {array} MakeBucketPrivateResponse\n     * @property {File[]} 0 List of files made private.\n     */\n    /**\n     * @callback MakeBucketPrivateCallback\n     * @param {?Error} err Request error, if any.\n     * @param {File[]} files List of files made private.\n     */\n    /**\n     * @typedef {object} MakeBucketPrivateOptions\n     * @param {boolean} [includeFiles=false] Make each file in the bucket\n     *     private.\n     * @param {boolean} [force] Queue errors occurred while making files\n     *     private until all files have been processed.\n     * @param {string} [userProject] The ID of the project which will be\n     *     billed for the request.\n     */\n    /**\n     * Make the bucket listing private.\n     *\n     * You may also choose to make the contents of the bucket private by\n     * specifying `includeFiles: true`. This will automatically run\n     * {@link File#makePrivate} for every file in the bucket.\n     *\n     * When specifying `includeFiles: true`, use `force: true` to delay execution\n     * of your callback until all files have been processed. By default, the\n     * callback is executed after the first error. Use `force` to queue such\n     * errors until all files have been processed, after which they will be\n     * returned as an array as the first argument to your callback.\n     *\n     * NOTE: This may cause the process to be long-running and use a high number\n     * of requests. Use with caution.\n     *\n     * @see [Buckets: patch API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/buckets/patch}\n     *\n     * @param {MakeBucketPrivateOptions} [options] Configuration options.\n     * @param {MakeBucketPrivateCallback} [callback] Callback function.\n     * @returns {Promise<MakeBucketPrivateResponse>}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const bucket = storage.bucket('albums');\n     *\n     * //-\n     * // Make the bucket private.\n     * //-\n     * bucket.makePrivate(function(err) {});\n     *\n     * //-\n     * // Make the bucket and its contents private.\n     * //-\n     * const opts = {\n     *   includeFiles: true\n     * };\n     *\n     * bucket.makePrivate(opts, function(err, files) {\n     *   // `err`:\n     *   //    The first error to occur, otherwise null.\n     *   //\n     *   // `files`:\n     *   //    Array of files successfully made private in the bucket.\n     * });\n     *\n     * //-\n     * // Make the bucket and its contents private, using force to suppress errors\n     * // until all files have been processed.\n     * //-\n     * const opts = {\n     *   includeFiles: true,\n     *   force: true\n     * };\n     *\n     * bucket.makePrivate(opts, function(errors, files) {\n     *   // `errors`:\n     *   //    Array of errors if any occurred, otherwise null.\n     *   //\n     *   // `files`:\n     *   //    Array of files successfully made private in the bucket.\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * bucket.makePrivate(opts).then(function(data) {\n     *   const files = data[0];\n     * });\n     */\n    makePrivate(optionsOrCallback, callback) {\n        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};\n        callback =\n            typeof optionsOrCallback === 'function' ? optionsOrCallback : callback;\n        options.private = true;\n        const query = {\n            predefinedAcl: 'projectPrivate',\n        };\n        if (options.userProject) {\n            query.userProject = options.userProject;\n        }\n        this.setMetadata({\n            // You aren't allowed to set both predefinedAcl & acl properties on\n            // a bucket so acl must explicitly be nullified.\n            acl: null,\n        }, query)\n            .then(() => {\n            if (options.includeFiles) {\n                return util_1.promisify(this.makeAllFilesPublicPrivate_).call(this, options);\n            }\n            return [];\n        })\n            .then(files => callback(null, files), callback);\n    }\n    /**\n     * @typedef {object} MakeBucketPublicOptions\n     * @param {boolean} [includeFiles=false] Make each file in the bucket\n     *     private.\n     * @param {boolean} [force] Queue errors occurred while making files\n     *     private until all files have been processed.\n     */\n    /**\n     * @callback MakeBucketPublicCallback\n     * @param {?Error} err Request error, if any.\n     * @param {File[]} files List of files made public.\n     */\n    /**\n     * @typedef {array} MakeBucketPublicResponse\n     * @property {File[]} 0 List of files made public.\n     */\n    /**\n     * Make the bucket publicly readable.\n     *\n     * You may also choose to make the contents of the bucket publicly readable by\n     * specifying `includeFiles: true`. This will automatically run\n     * {@link File#makePublic} for every file in the bucket.\n     *\n     * When specifying `includeFiles: true`, use `force: true` to delay execution\n     * of your callback until all files have been processed. By default, the\n     * callback is executed after the first error. Use `force` to queue such\n     * errors until all files have been processed, after which they will be\n     * returned as an array as the first argument to your callback.\n     *\n     * NOTE: This may cause the process to be long-running and use a high number\n     * of requests. Use with caution.\n     *\n     * @see [Buckets: patch API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/buckets/patch}\n     *\n     * @param {MakeBucketPublicOptions} [options] Configuration options.\n     * @param {MakeBucketPublicCallback} [callback] Callback function.\n     * @returns {Promise<MakeBucketPublicResponse>}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const bucket = storage.bucket('albums');\n     *\n     * //-\n     * // Make the bucket publicly readable.\n     * //-\n     * bucket.makePublic(function(err) {});\n     *\n     * //-\n     * // Make the bucket and its contents publicly readable.\n     * //-\n     * const opts = {\n     *   includeFiles: true\n     * };\n     *\n     * bucket.makePublic(opts, function(err, files) {\n     *   // `err`:\n     *   //    The first error to occur, otherwise null.\n     *   //\n     *   // `files`:\n     *   //    Array of files successfully made public in the bucket.\n     * });\n     *\n     * //-\n     * // Make the bucket and its contents publicly readable, using force to\n     * // suppress errors until all files have been processed.\n     * //-\n     * const opts = {\n     *   includeFiles: true,\n     *   force: true\n     * };\n     *\n     * bucket.makePublic(opts, function(errors, files) {\n     *   // `errors`:\n     *   //    Array of errors if any occurred, otherwise null.\n     *   //\n     *   // `files`:\n     *   //    Array of files successfully made public in the bucket.\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * bucket.makePublic(opts).then(function(data) {\n     *   const files = data[0];\n     * });\n     */\n    makePublic(optionsOrCallback, callback) {\n        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};\n        callback =\n            typeof optionsOrCallback === 'function' ? optionsOrCallback : callback;\n        const req = extend(true, { public: true }, options);\n        this.acl\n            .add({\n            entity: 'allUsers',\n            role: 'READER',\n        })\n            .then(() => {\n            return this.acl.default.add({\n                entity: 'allUsers',\n                role: 'READER',\n            });\n        })\n            .then(() => {\n            if (req.includeFiles) {\n                return util_1.promisify(this.makeAllFilesPublicPrivate_).call(this, req);\n            }\n            return [];\n        })\n            .then(files => callback(null, files), callback);\n    }\n    /**\n     * Get a reference to a Cloud Pub/Sub Notification.\n     *\n     * @param {string} id ID of notification.\n     * @returns {Notification}\n     * @see Notification\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const bucket = storage.bucket('my-bucket');\n     * const notification = bucket.notification('1');\n     */\n    notification(id) {\n        if (!id) {\n            throw new Error('You must supply a notification ID.');\n        }\n        return new notification_1.Notification(this, id);\n    }\n    /**\n     * Remove an already-existing retention policy from this bucket, if it is not\n     * locked.\n     *\n     * @param {SetBucketMetadataCallback} [callback] Callback function.\n     * @returns {Promise<SetBucketMetadataResponse>}\n     *\n     * @example\n     * const storage = require('@google-cloud/storage')();\n     * const bucket = storage.bucket('albums');\n     *\n     * bucket.removeRetentionPeriod(function(err, apiResponse) {});\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * bucket.removeRetentionPeriod().then(function(data) {\n     *   const apiResponse = data[0];\n     * });\n     */\n    removeRetentionPeriod(callback) {\n        this.setMetadata({\n            retentionPolicy: null,\n        }, callback);\n    }\n    /**\n     * Makes request and applies userProject query parameter if necessary.\n     *\n     * @private\n     *\n     * @param {object} reqOpts - The request options.\n     * @param {function} callback - The callback function.\n     */\n    request(reqOpts, callback) {\n        if (this.userProject && (!reqOpts.qs || !reqOpts.qs.userProject)) {\n            reqOpts.qs = extend(reqOpts.qs, { userProject: this.userProject });\n        }\n        return super.request(reqOpts, callback);\n    }\n    /**\n     * @typedef {array} SetLabelsResponse\n     * @property {object} 0 The bucket metadata.\n     */\n    /**\n     * @callback SetLabelsCallback\n     * @param {?Error} err Request error, if any.\n     * @param {object} metadata The bucket metadata.\n     */\n    /**\n     * @typedef {object} SetLabelsOptions Configuration options for Bucket#setLabels().\n     * @property {string} [userProject] The ID of the project which will be\n     *     billed for the request.\n     */\n    /**\n     * Set labels on the bucket.\n     *\n     * This makes an underlying call to {@link Bucket#setMetadata}, which\n     * is a PATCH request. This means an individual label can be overwritten, but\n     * unmentioned labels will not be touched.\n     *\n     * @param {object<string, string>} labels Labels to set on the bucket.\n     * @param {object} [options] Configuration options.\n     * @param {SetLabelsCallback} [callback] Callback function.\n     * @returns {Promise<SetLabelsResponse>}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const bucket = storage.bucket('albums');\n     *\n     * const labels = {\n     *   labelone: 'labelonevalue',\n     *   labeltwo: 'labeltwovalue'\n     * };\n     *\n     * bucket.setLabels(labels, function(err, metadata) {\n     *   if (!err) {\n     *     // Labels set successfully.\n     *   }\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * bucket.setLabels(labels).then(function(data) {\n     *   const metadata = data[0];\n     * });\n     */\n    setLabels(labels, optionsOrCallback, callback) {\n        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};\n        callback =\n            typeof optionsOrCallback === 'function' ? optionsOrCallback : callback;\n        callback = callback || common_1.util.noop;\n        this.setMetadata({ labels }, options, callback);\n    }\n    /**\n     * Lock all objects contained in the bucket, based on their creation time. Any\n     * attempt to overwrite or delete objects younger than the retention period\n     * will result in a `PERMISSION_DENIED` error.\n     *\n     * An unlocked retention policy can be modified or removed from the bucket via\n     * {@link File#removeRetentionPeriod} and {@link File#setRetentionPeriod}. A\n     * locked retention policy cannot be removed or shortened in duration for the\n     * lifetime of the bucket. Attempting to remove or decrease period of a locked\n     * retention policy will result in a `PERMISSION_DENIED` error. You can still\n     * increase the policy.\n     *\n     * @param {*} duration In seconds, the minimum retention time for all objects\n     *     contained in this bucket.\n     * @param {SetBucketMetadataCallback} [callback] Callback function.\n     * @returns {Promise<SetBucketMetadataResponse>}\n     *\n     * @example\n     * const storage = require('@google-cloud/storage')();\n     * const bucket = storage.bucket('albums');\n     *\n     * const DURATION_SECONDS = 15780000; // 6 months.\n     *\n     * //-\n     * // Lock the objects in this bucket for 6 months.\n     * //-\n     * bucket.setRetentionPeriod(DURATION_SECONDS, function(err, apiResponse) {});\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * bucket.setRetentionPeriod(DURATION_SECONDS).then(function(data) {\n     *   const apiResponse = data[0];\n     * });\n     */\n    setRetentionPeriod(duration, callback) {\n        this.setMetadata({\n            retentionPolicy: {\n                retentionPeriod: duration,\n            },\n        }, callback);\n    }\n    /**\n     * This can be used to set the CORS configuration on the bucket.\n     *\n     * The configuration will be overwritten with the value passed into this.\n     *\n     * @param {Cors[]} corsConfiguration The new CORS configuration to set\n     * @param {SetBucketMetadataCallback} [callback] Callback function.\n     * @returns {Promise<SetBucketMetadataResponse>}\n     *\n     * @example\n     * const storage = require('@google-cloud/storage')();\n     * const bucket = storage.bucket('albums');\n     *\n     * const corsConfiguration = [{maxAgeSeconds: 3600}]; // 1 hour\n     * bucket.setCorsConfiguration(corsConfiguration);\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * bucket.setCorsConfiguration(corsConfiguration).then(function(data) {\n     *   const apiResponse = data[0];\n     * });\n     */\n    setCorsConfiguration(corsConfiguration, callback) {\n        this.setMetadata({\n            cors: corsConfiguration,\n        }, callback);\n    }\n    /**\n     * @typedef {object} SetBucketStorageClassOptions\n     * @param {string} [userProject] - The ID of the project which will be\n     *     billed for the request.\n     */\n    /**\n     * @callback SetBucketStorageClassCallback\n     * @param {?Error} err Request error, if any.\n     */\n    /**\n     * Set the default storage class for new files in this bucket.\n     *\n     * @see [Storage Classes]{@link https://cloud.google.com/storage/docs/storage-classes}\n     *\n     * @param {string} storageClass The new storage class. (`standard`,\n     *     `nearline`, `coldline`, or `archive`).\n     *     **Note:** The storage classes `multi_regional`, `regional`, and\n     *     `durable_reduced_availability` are now legacy and will be deprecated in\n     *     the future.\n     * @param {object} [options] Configuration options.\n     * @param {string} [options.userProject] - The ID of the project which will be\n     *     billed for the request.\n     * @param {SetStorageClassCallback} [callback] Callback function.\n     * @returns {Promise}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const bucket = storage.bucket('albums');\n     *\n     * bucket.setStorageClass('nearline', function(err, apiResponse) {\n     *   if (err) {\n     *     // Error handling omitted.\n     *   }\n     *\n     *   // The storage class was updated successfully.\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * bucket.setStorageClass('nearline').then(function() {});\n     */\n    setStorageClass(storageClass, optionsOrCallback, callback) {\n        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};\n        callback =\n            typeof optionsOrCallback === 'function' ? optionsOrCallback : callback;\n        // In case we get input like `storageClass`, convert to `storage_class`.\n        storageClass = storageClass\n            .replace(/-/g, '_')\n            .replace(/([a-z])([A-Z])/g, (_, low, up) => {\n            return low + '_' + up;\n        })\n            .toUpperCase();\n        this.setMetadata({ storageClass }, options, callback);\n    }\n    /**\n     * Set a user project to be billed for all requests made from this Bucket\n     * object and any files referenced from this Bucket object.\n     *\n     * @param {string} userProject The user project.\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const bucket = storage.bucket('albums');\n     *\n     * bucket.setUserProject('grape-spaceship-123');\n     */\n    setUserProject(userProject) {\n        this.userProject = userProject;\n        const methods = [\n            'create',\n            'delete',\n            'exists',\n            'get',\n            'getMetadata',\n            'setMetadata',\n        ];\n        methods.forEach(method => {\n            const methodConfig = this.methods[method];\n            if (typeof methodConfig === 'object') {\n                if (typeof methodConfig.reqOpts === 'object') {\n                    extend(methodConfig.reqOpts.qs, { userProject });\n                }\n                else {\n                    methodConfig.reqOpts = {\n                        qs: { userProject },\n                    };\n                }\n            }\n        });\n    }\n    /**\n     * @typedef {object} UploadOptions Configuration options for Bucket#upload().\n     * @param {string|File} [options.destination] The place to save\n     *     your file. If given a string, the file will be uploaded to the bucket\n     *     using the string as a filename. When given a File object, your local\n     * file will be uploaded to the File object's bucket and under the File\n     * object's name. Lastly, when this argument is omitted, the file is uploaded\n     * to your bucket using the name of the local file.\n     * @param {string} [options.encryptionKey] A custom encryption key. See\n     *     [Customer-supplied Encryption\n     * Keys](https://cloud.google.com/storage/docs/encryption#customer-supplied).\n     * @param {boolean} [options.gzip] Automatically gzip the file. This will set\n     *     `options.metadata.contentEncoding` to `gzip`.\n     * @param {string} [options.kmsKeyName] The name of the Cloud KMS key that will\n     *     be used to encrypt the object. Must be in the format:\n     *     `projects/my-project/locations/location/keyRings/my-kr/cryptoKeys/my-key`.\n     * @param {object} [options.metadata] See an\n     *     [Objects: insert request\n     * body](https://cloud.google.com/storage/docs/json_api/v1/objects/insert#request_properties_JSON).\n     * @param {string} [options.offset] The starting byte of the upload stream, for\n     *     resuming an interrupted upload. Defaults to 0.\n     * @param {string} [options.predefinedAcl] Apply a predefined set of access\n     *     controls to this object.\n     *\n     *     Acceptable values are:\n     *     - **`authenticatedRead`** - Object owner gets `OWNER` access, and\n     *       `allAuthenticatedUsers` get `READER` access.\n     *\n     *     - **`bucketOwnerFullControl`** - Object owner gets `OWNER` access, and\n     *       project team owners get `OWNER` access.\n     *\n     *     - **`bucketOwnerRead`** - Object owner gets `OWNER` access, and project\n     *       team owners get `READER` access.\n     *\n     *     - **`private`** - Object owner gets `OWNER` access.\n     *\n     *     - **`projectPrivate`** - Object owner gets `OWNER` access, and project\n     *       team members get access according to their roles.\n     *\n     *     - **`publicRead`** - Object owner gets `OWNER` access, and `allUsers`\n     * get `READER` access.\n     * @param {boolean} [options.private] Make the uploaded file private. (Alias for\n     *     `options.predefinedAcl = 'private'`)\n     * @param {boolean} [options.public] Make the uploaded file public. (Alias for\n     *     `options.predefinedAcl = 'publicRead'`)\n     * @param {boolean} [options.resumable] Force a resumable upload. (default:\n     *     true for files larger than 5 MB).\n     * @param {string} [options.uri] The URI for an already-created resumable\n     *     upload. See {@link File#createResumableUpload}.\n     * @param {string} [options.userProject] The ID of the project which will be\n     *     billed for the request.\n     * @param {string|boolean} [options.validation] Possible values: `\"md5\"`,\n     *     `\"crc32c\"`, or `false`. By default, data integrity is validated with an\n     *     MD5 checksum for maximum reliability. CRC32c will provide better\n     *     performance with less reliability. You may also choose to skip\n     * validation completely, however this is **not recommended**.\n     */\n    /**\n     * @typedef {array} UploadResponse\n     * @property {object} 0 The uploaded {@link File}.\n     * @property {object} 1 The full API response.\n     */\n    /**\n     * @callback UploadCallback\n     * @param {?Error} err Request error, if any.\n     * @param {object} file The uploaded {@link File}.\n     * @param {object} apiResponse The full API response.\n     */\n    /**\n     * Upload a file to the bucket. This is a convenience method that wraps\n     * {@link File#createWriteStream}.\n     *\n     * You can specify whether or not an upload is resumable by setting\n     * `options.resumable`. *Resumable uploads are enabled by default if your\n     * input file is larger than 5 MB.*\n     *\n     * For faster crc32c computation, you must manually install\n     * [`fast-crc32c`](http://www.gitnpm.com/fast-crc32c):\n     *\n     *     $ npm install --save fast-crc32c\n     *\n     * @see [Upload Options (Simple or Resumable)]{@link https://cloud.google.com/storage/docs/json_api/v1/how-tos/upload#uploads}\n     * @see [Objects: insert API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objects/insert}\n     *\n     * @param {string} pathString The fully qualified path to the file you\n     *     wish to upload to your bucket.\n     * @param {UploadOptions} [options] Configuration options.\n     * @param {UploadCallback} [callback] Callback function.\n     * @returns {Promise<UploadResponse>}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const bucket = storage.bucket('albums');\n     *\n     * //-\n     * // Upload a file from a local path.\n     * //-\n     * bucket.upload('/local/path/image.png', function(err, file, apiResponse) {\n     *   // Your bucket now contains:\n     *   // - \"image.png\" (with the contents of `/local/path/image.png')\n     *\n     *   // `file` is an instance of a File object that refers to your new file.\n     * });\n     *\n     *\n     * //-\n     * // It's not always that easy. You will likely want to specify the filename\n     * // used when your new file lands in your bucket.\n     * //\n     * // You may also want to set metadata or customize other options.\n     * //-\n     * const options = {\n     *   destination: 'new-image.png',\n     *   resumable: true,\n     *   validation: 'crc32c',\n     *   metadata: {\n     *     metadata: {\n     *       event: 'Fall trip to the zoo'\n     *     }\n     *   }\n     * };\n     *\n     * bucket.upload('local-image.png', options, function(err, file) {\n     *   // Your bucket now contains:\n     *   // - \"new-image.png\" (with the contents of `local-image.png')\n     *\n     *   // `file` is an instance of a File object that refers to your new file.\n     * });\n     *\n     * //-\n     * // You can also have a file gzip'd on the fly.\n     * //-\n     * bucket.upload('index.html', { gzip: true }, function(err, file) {\n     *   // Your bucket now contains:\n     *   // - \"index.html\" (automatically compressed with gzip)\n     *\n     *   // Downloading the file with `file.download` will automatically decode\n     * the\n     *   // file.\n     * });\n     *\n     * //-\n     * // You may also re-use a File object, {File}, that references\n     * // the file you wish to create or overwrite.\n     * //-\n     * const options = {\n     *   destination: bucket.file('existing-file.png'),\n     *   resumable: false\n     * };\n     *\n     * bucket.upload('local-img.png', options, function(err, newFile) {\n     *   // Your bucket now contains:\n     *   // - \"existing-file.png\" (with the contents of `local-img.png')\n     *\n     *   // Note:\n     *   // The `newFile` parameter is equal to `file`.\n     * });\n     *\n     * //-\n     * // To use\n     * // <a\n     * href=\"https://cloud.google.com/storage/docs/encryption#customer-supplied\">\n     * // Customer-supplied Encryption Keys</a>, provide the `encryptionKey`\n     * option.\n     * //-\n     * const crypto = require('crypto');\n     * const encryptionKey = crypto.randomBytes(32);\n     *\n     * bucket.upload('img.png', {\n     *   encryptionKey: encryptionKey\n     * }, function(err, newFile) {\n     *   // `img.png` was uploaded with your custom encryption key.\n     *\n     *   // `newFile` is already configured to use the encryption key when making\n     *   // operations on the remote object.\n     *\n     *   // However, to use your encryption key later, you must create a `File`\n     *   // instance with the `key` supplied:\n     *   const file = bucket.file('img.png', {\n     *     encryptionKey: encryptionKey\n     *   });\n     *\n     *   // Or with `file#setEncryptionKey`:\n     *   const file = bucket.file('img.png');\n     *   file.setEncryptionKey(encryptionKey);\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * bucket.upload('local-image.png').then(function(data) {\n     *   const file = data[0];\n     * });\n     *\n     * To upload a file from a URL, use {@link File#createWriteStream}.\n     *\n     * @example <caption>include:samples/files.js</caption>\n     * region_tag:storage_upload_file\n     * Another example:\n     *\n     * @example <caption>include:samples/encryption.js</caption>\n     * region_tag:storage_upload_encrypted_file\n     * Example of uploading an encrypted file:\n     */\n    upload(pathString, optionsOrCallback, callback) {\n        // tslint:disable-next-line:no-any\n        if (global['GCLOUD_SANDBOX_ENV']) {\n            return;\n        }\n        let options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};\n        callback =\n            typeof optionsOrCallback === 'function' ? optionsOrCallback : callback;\n        options = Object.assign({\n            metadata: {},\n        }, options);\n        let newFile;\n        if (options.destination instanceof file_1.File) {\n            newFile = options.destination;\n        }\n        else if (options.destination != null &&\n            typeof options.destination === 'string') {\n            // Use the string as the name of the file.\n            newFile = this.file(options.destination, {\n                encryptionKey: options.encryptionKey,\n                kmsKeyName: options.kmsKeyName,\n            });\n        }\n        else {\n            // Resort to using the name of the incoming file.\n            const destination = path.basename(pathString);\n            newFile = this.file(destination, {\n                encryptionKey: options.encryptionKey,\n                kmsKeyName: options.kmsKeyName,\n            });\n        }\n        const contentType = mime.contentType(path.basename(pathString));\n        if (contentType && !options.metadata.contentType) {\n            options.metadata.contentType = contentType;\n        }\n        if (options.resumable != null && typeof options.resumable === 'boolean') {\n            upload();\n        }\n        else {\n            // Determine if the upload should be resumable if it's over the threshold.\n            fs.stat(pathString, (err, fd) => {\n                if (err) {\n                    callback(err);\n                    return;\n                }\n                options.resumable = fd.size > RESUMABLE_THRESHOLD;\n                upload();\n            });\n        }\n        function upload() {\n            fs.createReadStream(pathString)\n                .on('error', callback)\n                .pipe(newFile.createWriteStream(options))\n                .on('error', callback)\n                .on('finish', () => {\n                callback(null, newFile, newFile.metadata);\n            });\n        }\n    }\n    /**\n     * @private\n     *\n     * @typedef {object} MakeAllFilesPublicPrivateOptions\n     * @property {boolean} [force] Suppress errors until all files have been\n     *     processed.\n     * @property {boolean} [private] Make files private.\n     * @property {boolean} [public] Make files public.\n     * @property {string} [userProject] The ID of the project which will be\n     *     billed for the request.\n     */\n    /**\n     * @private\n     *\n     * @callback SetBucketMetadataCallback\n     * @param {?Error} err Request error, if any.\n     * @param {File[]} files Files that were updated.\n     */\n    /**\n     * @typedef {array} MakeAllFilesPublicPrivateResponse\n     * @property {File[]} 0 List of files affected.\n     */\n    /**\n     * Iterate over all of a bucket's files, calling `file.makePublic()` (public)\n     * or `file.makePrivate()` (private) on each.\n     *\n     * Operations are performed in parallel, up to 10 at once. The first error\n     * breaks the loop, and will execute the provided callback with it. Specify\n     * `{ force: true }` to suppress the errors.\n     *\n     * @private\n     *\n     * @param {MakeAllFilesPublicPrivateOptions} [options] Configuration options.\n     * @param {MakeAllFilesPublicPrivateCallback} callback Callback function.\n     *\n     * @return {Promise<MakeAllFilesPublicPrivateResponse>}\n     */\n    makeAllFilesPublicPrivate_(optionsOrCallback, callback) {\n        const MAX_PARALLEL_LIMIT = 10;\n        const errors = [];\n        const updatedFiles = [];\n        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};\n        callback =\n            typeof optionsOrCallback === 'function' ? optionsOrCallback : callback;\n        const processFile = async (file) => {\n            try {\n                await (options.public ? file.makePublic() : file.makePrivate(options));\n                updatedFiles.push(file);\n            }\n            catch (e) {\n                if (!options.force) {\n                    throw e;\n                }\n                errors.push(e);\n            }\n        };\n        this.getFiles(options)\n            .then(([files]) => {\n            const limit = p_limit_1.default(MAX_PARALLEL_LIMIT);\n            const promises = files.map(file => {\n                return limit(() => processFile(file));\n            });\n            return Promise.all(promises);\n        })\n            .then(() => callback(errors.length > 0 ? errors : null, updatedFiles), err => callback(err, updatedFiles));\n    }\n    getId() {\n        return this.id;\n    }\n}\nexports.Bucket = Bucket;\n/*! Developer Documentation\n *\n * These methods can be auto-paginated.\n */\npaginator_1.paginator.extend(Bucket, 'getFiles');\n/*! Developer Documentation\n *\n * All async methods (except for streams) will return a Promise in the event\n * that a callback is omitted.\n */\npromisify_1.promisifyAll(Bucket, {\n    exclude: ['request', 'file', 'notification'],\n});\n//# sourceMappingURL=bucket.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/storage/build/src/bucket.js?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/storage/build/src/channel.js":
/*!*********************************************************************!*\
  !*** ./src/node_modules/@google-cloud/storage/build/src/channel.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst common_1 = __webpack_require__(/*! @google-cloud/common */ \"./src/node_modules/@google-cloud/common/build/src/index.js\");\nconst promisify_1 = __webpack_require__(/*! @google-cloud/promisify */ \"@google-cloud/promisify\");\n/**\n * Create a channel object to interact with a Cloud Storage channel.\n *\n * @see [Object Change Notification]{@link https://cloud.google.com/storage/docs/object-change-notification}\n *\n * @class\n *\n * @param {string} id The ID of the channel.\n * @param {string} resourceId The resource ID of the channel.\n *\n * @example\n * const {Storage} = require('@google-cloud/storage');\n * const storage = new Storage();\n * const channel = storage.channel('id', 'resource-id');\n */\nclass Channel extends common_1.ServiceObject {\n    constructor(storage, id, resourceId) {\n        const config = {\n            parent: storage,\n            baseUrl: '/channels',\n            // An ID shouldn't be included in the API requests.\n            // RE:\n            // https://github.com/GoogleCloudPlatform/google-cloud-node/issues/1145\n            id: '',\n            methods: {\n            // Only need `request`.\n            },\n        };\n        super(config);\n        // TODO: remove type cast to any once ServiceObject's type declaration has\n        // been fixed. https://github.com/googleapis/nodejs-common/issues/176\n        const metadata = this.metadata;\n        metadata.id = id;\n        metadata.resourceId = resourceId;\n    }\n    /**\n     * @typedef {array} StopResponse\n     * @property {object} 0 The full API response.\n     */\n    /**\n     * @callback StopCallback\n     * @param {?Error} err Request error, if any.\n     * @param {object} apiResponse The full API response.\n     */\n    /**\n     * Stop this channel.\n     *\n     * @param {StopCallback} [callback] Callback function.\n     * @returns {Promise<StopResponse>}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const channel = storage.channel('id', 'resource-id');\n     * channel.stop(function(err, apiResponse) {\n     *   if (!err) {\n     *     // Channel stopped successfully.\n     *   }\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * channel.stop().then(function(data) {\n     *   const apiResponse = data[0];\n     * });\n     */\n    stop(callback) {\n        callback = callback || common_1.util.noop;\n        this.request({\n            method: 'POST',\n            uri: '/stop',\n            json: this.metadata,\n        }, (err, apiResponse) => {\n            callback(err, apiResponse);\n        });\n    }\n}\nexports.Channel = Channel;\n/*! Developer Documentation\n *\n * All async methods (except for streams) will return a Promise in the event\n * that a callback is omitted.\n */\npromisify_1.promisifyAll(Channel);\n//# sourceMappingURL=channel.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/storage/build/src/channel.js?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/storage/build/src/file.js":
/*!******************************************************************!*\
  !*** ./src/node_modules/@google-cloud/storage/build/src/file.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst common_1 = __webpack_require__(/*! @google-cloud/common */ \"./src/node_modules/@google-cloud/common/build/src/index.js\");\nconst promisify_1 = __webpack_require__(/*! @google-cloud/promisify */ \"@google-cloud/promisify\");\nconst compressible = __webpack_require__(/*! compressible */ \"compressible\");\nconst concat = __webpack_require__(/*! concat-stream */ \"concat-stream\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst dateFormat = __webpack_require__(/*! date-and-time */ \"./src/node_modules/date-and-time/date-and-time.js\");\nconst extend = __webpack_require__(/*! extend */ \"extend\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst hashStreamValidation = __webpack_require__(/*! hash-stream-validation */ \"./src/node_modules/hash-stream-validation/index.js\");\nconst mime = __webpack_require__(/*! mime */ \"mime\");\nconst once = __webpack_require__(/*! onetime */ \"onetime\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst pumpify = __webpack_require__(/*! pumpify */ \"pumpify\");\nconst resumableUpload = __webpack_require__(/*! gcs-resumable-upload */ \"./src/node_modules/gcs-resumable-upload/build/src/index.js\");\nconst streamEvents = __webpack_require__(/*! stream-events */ \"./src/node_modules/stream-events/index.js\");\nconst through = __webpack_require__(/*! through2 */ \"through2\");\nconst xdgBasedir = __webpack_require__(/*! xdg-basedir */ \"xdg-basedir\");\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\nconst bucket_1 = __webpack_require__(/*! ./bucket */ \"./src/node_modules/@google-cloud/storage/build/src/bucket.js\");\nconst acl_1 = __webpack_require__(/*! ./acl */ \"./src/node_modules/@google-cloud/storage/build/src/acl.js\");\nconst signer_1 = __webpack_require__(/*! ./signer */ \"./src/node_modules/@google-cloud/storage/build/src/signer.js\");\nconst duplexify = __webpack_require__(/*! duplexify */ \"duplexify\");\nconst util_1 = __webpack_require__(/*! ./util */ \"./src/node_modules/@google-cloud/storage/build/src/util.js\");\nconst gaxios_1 = __webpack_require__(/*! gaxios */ \"gaxios\");\nvar ActionToHTTPMethod;\n(function (ActionToHTTPMethod) {\n    ActionToHTTPMethod[\"read\"] = \"GET\";\n    ActionToHTTPMethod[\"write\"] = \"PUT\";\n    ActionToHTTPMethod[\"delete\"] = \"DELETE\";\n    ActionToHTTPMethod[\"resumable\"] = \"POST\";\n})(ActionToHTTPMethod = exports.ActionToHTTPMethod || (exports.ActionToHTTPMethod = {}));\n/**\n * Custom error type for errors related to creating a resumable upload.\n *\n * @private\n */\nclass ResumableUploadError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'ResumableUploadError';\n    }\n}\n/**\n * @const {string}\n * @private\n */\nconst STORAGE_UPLOAD_BASE_URL = 'https://storage.googleapis.com/upload/storage/v1/b';\n/**\n * @const {string}\n * @private\n */\nexports.STORAGE_POST_POLICY_BASE_URL = 'https://storage.googleapis.com';\n/**\n * @const {RegExp}\n * @private\n */\nconst GS_URL_REGEXP = /^gs:\\/\\/([a-z0-9_.-]+)\\/(.+)$/;\nclass RequestError extends Error {\n}\nconst SEVEN_DAYS = 7 * 24 * 60 * 60;\n/**\n * A File object is created from your {@link Bucket} object using\n * {@link Bucket#file}.\n *\n * @class\n */\nclass File extends common_1.ServiceObject {\n    /**\n     * @typedef {object} FileOptions Options passed to the File constructor.\n     * @property {string} [encryptionKey] A custom encryption key.\n     * @property {number} [generation] Generation to scope the file to.\n     * @property {string} [kmsKeyName] Cloud KMS Key used to encrypt this\n     *     object, if the object is encrypted by such a key. Limited availability;\n     *     usable only by enabled projects.\n     * @property {string} [userProject] The ID of the project which will be\n     *     billed for all requests made from File object.\n     */\n    /**\n     * Constructs a file object.\n     *\n     * @param {Bucket} bucket The Bucket instance this file is\n     *     attached to.\n     * @param {string} name The name of the remote file.\n     * @param {FileOptions} [options] Configuration options.\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const myBucket = storage.bucket('my-bucket');\n     *\n     * const file = myBucket.file('my-file');\n     */\n    constructor(bucket, name, options = {}) {\n        const requestQueryObject = {};\n        let generation;\n        if (options.generation != null) {\n            if (typeof options.generation === 'string') {\n                generation = Number(options.generation);\n            }\n            else {\n                generation = options.generation;\n            }\n            if (!isNaN(generation)) {\n                requestQueryObject.generation = generation;\n            }\n        }\n        const userProject = options.userProject || bucket.userProject;\n        if (typeof userProject === 'string') {\n            requestQueryObject.userProject = userProject;\n        }\n        const methods = {\n            /**\n             * @typedef {array} DeleteFileResponse\n             * @property {object} 0 The full API response.\n             */\n            /**\n             * @callback DeleteFileCallback\n             * @param {?Error} err Request error, if any.\n             * @param {object} apiResponse The full API response.\n             */\n            /**\n             * Delete the file.\n             *\n             * @see [Objects: delete API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objects/delete}\n             *\n             * @method File#delete\n             * @param {object} [options] Configuration options.\n             * @param {string} [options.userProject] The ID of the project which will be\n             *     billed for the request.\n             * @param {DeleteFileCallback} [callback] Callback function.\n             * @returns {Promise<DeleteFileResponse>}\n             *\n             * @example\n             * const {Storage} = require('@google-cloud/storage');\n             * const storage = new Storage();\n             * const myBucket = storage.bucket('my-bucket');\n             *\n             * const file = myBucket.file('my-file');\n             * file.delete(function(err, apiResponse) {});\n             *\n             * //-\n             * // If the callback is omitted, we'll return a Promise.\n             * //-\n             * file.delete().then(function(data) {\n             *   const apiResponse = data[0];\n             * });\n             *\n             * @example <caption>include:samples/files.js</caption>\n             * region_tag:storage_delete_file\n             * Another example:\n             */\n            delete: {\n                reqOpts: {\n                    qs: requestQueryObject,\n                },\n            },\n            /**\n             * @typedef {array} FileExistsResponse\n             * @property {boolean} 0 Whether the {@link File} exists.\n             */\n            /**\n             * @callback FileExistsCallback\n             * @param {?Error} err Request error, if any.\n             * @param {boolean} exists Whether the {@link File} exists.\n             */\n            /**\n             * Check if the file exists.\n             *\n             * @method File#exists\n             * @param {options} [options] Configuration options.\n             * @param {string} [options.userProject] The ID of the project which will be\n             *     billed for the request.\n             * @param {FileExistsCallback} [callback] Callback function.\n             * @returns {Promise<FileExistsResponse>}\n             *\n             * @example\n             * const {Storage} = require('@google-cloud/storage');\n             * const storage = new Storage();\n             * const myBucket = storage.bucket('my-bucket');\n             *\n             * const file = myBucket.file('my-file');\n             *\n             * file.exists(function(err, exists) {});\n             *\n             * //-\n             * // If the callback is omitted, we'll return a Promise.\n             * //-\n             * file.exists().then(function(data) {\n             *   const exists = data[0];\n             * });\n             */\n            exists: {\n                reqOpts: {\n                    qs: requestQueryObject,\n                },\n            },\n            /**\n             * @typedef {array} GetFileResponse\n             * @property {File} 0 The {@link File}.\n             * @property {object} 1 The full API response.\n             */\n            /**\n             * @callback GetFileCallback\n             * @param {?Error} err Request error, if any.\n             * @param {File} file The {@link File}.\n             * @param {object} apiResponse The full API response.\n             */\n            /**\n             * Get a file object and its metadata if it exists.\n             *\n             * @method File#get\n             * @param {options} [options] Configuration options.\n             * @param {string} [options.userProject] The ID of the project which will be\n             *     billed for the request.\n             * @param {GetFileCallback} [callback] Callback function.\n             * @returns {Promise<GetFileResponse>}\n             *\n             * @example\n             * const {Storage} = require('@google-cloud/storage');\n             * const storage = new Storage();\n             * const myBucket = storage.bucket('my-bucket');\n             *\n             * const file = myBucket.file('my-file');\n             *\n             * file.get(function(err, file, apiResponse) {\n             *   // file.metadata` has been populated.\n             * });\n             *\n             * //-\n             * // If the callback is omitted, we'll return a Promise.\n             * //-\n             * file.get().then(function(data) {\n             *   const file = data[0];\n             *   const apiResponse = data[1];\n             * });\n             */\n            get: {\n                reqOpts: {\n                    qs: requestQueryObject,\n                },\n            },\n            /**\n             * @typedef {array} GetFileMetadataResponse\n             * @property {object} 0 The {@link File} metadata.\n             * @property {object} 1 The full API response.\n             */\n            /**\n             * @callback GetFileMetadataCallback\n             * @param {?Error} err Request error, if any.\n             * @param {object} metadata The {@link File} metadata.\n             * @param {object} apiResponse The full API response.\n             */\n            /**\n             * Get the file's metadata.\n             *\n             * @see [Objects: get API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objects/get}\n             *\n             * @method File#getMetadata\n             * @param {object} [options] Configuration options.\n             * @param {string} [options.userProject] The ID of the project which will be\n             *     billed for the request.\n             * @param {GetFileMetadataCallback} [callback] Callback function.\n             * @returns {Promise<GetFileMetadataResponse>}\n             *\n             * @example\n             * const {Storage} = require('@google-cloud/storage');\n             * const storage = new Storage();\n             * const myBucket = storage.bucket('my-bucket');\n             *\n             * const file = myBucket.file('my-file');\n             *\n             * file.getMetadata(function(err, metadata, apiResponse) {});\n             *\n             * //-\n             * // If the callback is omitted, we'll return a Promise.\n             * //-\n             * file.getMetadata().then(function(data) {\n             *   const metadata = data[0];\n             *   const apiResponse = data[1];\n             * });\n             *\n             * @example <caption>include:samples/files.js</caption>\n             * region_tag:storage_get_metadata\n             * Another example:\n             */\n            getMetadata: {\n                reqOpts: {\n                    qs: requestQueryObject,\n                },\n            },\n            /**\n             * @typedef {object} SetFileMetadataOptions Configuration options for File#setMetadata().\n             * @param {string} [userProject] The ID of the project which will be billed for the request.\n             */\n            /**\n             * @callback SetFileMetadataCallback\n             * @param {?Error} err Request error, if any.\n             * @param {object} apiResponse The full API response.\n             */\n            /**\n             * @typedef {array} SetFileMetadataResponse\n             * @property {object} 0 The full API response.\n             */\n            /**\n             * Merge the given metadata with the current remote file's metadata. This\n             * will set metadata if it was previously unset or update previously set\n             * metadata. To unset previously set metadata, set its value to null.\n             *\n             * You can set custom key/value pairs in the metadata key of the given\n             * object, however the other properties outside of this object must adhere\n             * to the [official API documentation](https://goo.gl/BOnnCK).\n             *\n             * NOTE: multiple calls to setMetadata in parallel might result in\n             * unpredictable results. See [issue]{@link\n             * https://github.com/googleapis/nodejs-storage/issues/274}.\n             *\n             * See the examples below for more information.\n             *\n             * @see [Objects: patch API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objects/patch}\n             *\n             * @method File#setMetadata\n             * @param {object} [metadata] The metadata you wish to update.\n             * @param {SetFileMetadataOptions} [options] Configuration options.\n             * @param {SetFileMetadataCallback} [callback] Callback function.\n             * @returns {Promise<SetFileMetadataResponse>}\n             *\n             * @example\n             * const {Storage} = require('@google-cloud/storage');\n             * const storage = new Storage();\n             * const myBucket = storage.bucket('my-bucket');\n             *\n             * const file = myBucket.file('my-file');\n             *\n             * const metadata = {\n             *   contentType: 'application/x-font-ttf',\n             *   metadata: {\n             *     my: 'custom',\n             *     properties: 'go here'\n             *   }\n             * };\n             *\n             * file.setMetadata(metadata, function(err, apiResponse) {});\n             *\n             * // Assuming current metadata = { hello: 'world', unsetMe: 'will do' }\n             * file.setMetadata({\n             *   metadata: {\n             *     abc: '123', // will be set.\n             *     unsetMe: null, // will be unset (deleted).\n             *     hello: 'goodbye' // will be updated from 'world' to 'goodbye'.\n             *   }\n             * }, function(err, apiResponse) {\n             *   // metadata should now be { abc: '123', hello: 'goodbye' }\n             * });\n             *\n             * //-\n             * // Set a temporary hold on this file from its bucket's retention period\n             * // configuration.\n             * //\n             * file.setMetadata({\n             *   temporaryHold: true\n             * }, function(err, apiResponse) {});\n             *\n             * //-\n             * // Alternatively, you may set a temporary hold. This will follow the\n             * // same behavior as an event-based hold, with the exception that the\n             * // bucket's retention policy will not renew for this file from the time\n             * // the hold is released.\n             * //-\n             * file.setMetadata({\n             *   eventBasedHold: true\n             * }, function(err, apiResponse) {});\n             *\n             * //-\n             * // If the callback is omitted, we'll return a Promise.\n             * //-\n             * file.setMetadata(metadata).then(function(data) {\n             *   const apiResponse = data[0];\n             * });\n             */\n            setMetadata: {\n                reqOpts: {\n                    qs: requestQueryObject,\n                },\n            },\n        };\n        super({\n            parent: bucket,\n            baseUrl: '/o',\n            id: encodeURIComponent(name),\n            methods,\n        });\n        this.bucket = bucket;\n        // tslint:disable-next-line:no-any\n        this.storage = bucket.parent;\n        // @TODO Can this duplicate code from above be avoided?\n        if (options.generation != null) {\n            let generation;\n            if (typeof options.generation === 'string') {\n                generation = Number(options.generation);\n            }\n            else {\n                generation = options.generation;\n            }\n            if (!isNaN(generation)) {\n                this.generation = generation;\n            }\n        }\n        this.kmsKeyName = options.kmsKeyName;\n        this.userProject = userProject;\n        this.name = name;\n        if (options.encryptionKey) {\n            this.setEncryptionKey(options.encryptionKey);\n        }\n        this.acl = new acl_1.Acl({\n            request: this.request.bind(this),\n            pathPrefix: '/acl',\n        });\n    }\n    /**\n     * @typedef {array} CopyResponse\n     * @property {File} 0 The copied {@link File}.\n     * @property {object} 1 The full API response.\n     */\n    /**\n     * @callback CopyCallback\n     * @param {?Error} err Request error, if any.\n     * @param {File} copiedFile The copied {@link File}.\n     * @param {object} apiResponse The full API response.\n     */\n    /**\n     * @typedef {object} CopyOptions Configuration options for File#copy(). See an\n     *     [Object\n     * resource](https://cloud.google.com/storage/docs/json_api/v1/objects#resource).\n     * @property {string} [destinationKmsKeyName] Resource name of the Cloud\n     *     KMS key, of the form\n     *     `projects/my-project/locations/location/keyRings/my-kr/cryptoKeys/my-key`,\n     *     that will be used to encrypt the object. Overwrites the object\n     * metadata's `kms_key_name` value, if any.\n     * @property {string} [keepAcl] This parameter is not supported and will be\n     *     removed in the next major.\n     * @property {string} [predefinedAcl] Set the ACL for the new file.\n     * @property {string} [token] A previously-returned `rewriteToken` from an\n     *     unfinished rewrite request.\n     * @property {string} [userProject] The ID of the project which will be\n     *     billed for the request.\n     */\n    /**\n     * Copy this file to another file. By default, this will copy the file to the\n     * same bucket, but you can choose to copy it to another Bucket by providing\n     * a Bucket or File object or a URL starting with \"gs://\".\n     *\n     * @see [Objects: rewrite API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objects/rewrite}\n     *\n     * @throws {Error} If the destination file is not provided.\n     *\n     * @param {string|Bucket|File} destination Destination file.\n     * @param {CopyOptions} [options] Configuration options. See an\n     * @param {CopyCallback} [callback] Callback function.\n     * @returns {Promise<CopyResponse>}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     *\n     * //-\n     * // You can pass in a variety of types for the destination.\n     * //\n     * // For all of the below examples, assume we are working with the following\n     * // Bucket and File objects.\n     * //-\n     * const bucket = storage.bucket('my-bucket');\n     * const file = bucket.file('my-image.png');\n     *\n     * //-\n     * // If you pass in a string for the destination, the file is copied to its\n     * // current bucket, under the new name provided.\n     * //-\n     * file.copy('my-image-copy.png', function(err, copiedFile, apiResponse) {\n     *   // `my-bucket` now contains:\n     *   // - \"my-image.png\"\n     *   // - \"my-image-copy.png\"\n     *\n     *   // `copiedFile` is an instance of a File object that refers to your new\n     *   // file.\n     * });\n     *\n     * //-\n     * // If you pass in a string starting with \"gs://\" for the destination, the\n     * // file is copied to the other bucket and under the new name provided.\n     * //-\n     * const newLocation = 'gs://another-bucket/my-image-copy.png';\n     * file.copy(newLocation, function(err, copiedFile, apiResponse) {\n     *   // `my-bucket` still contains:\n     *   // - \"my-image.png\"\n     *   //\n     *   // `another-bucket` now contains:\n     *   // - \"my-image-copy.png\"\n     *\n     *   // `copiedFile` is an instance of a File object that refers to your new\n     *   // file.\n     * });\n     *\n     * //-\n     * // If you pass in a Bucket object, the file will be copied to that bucket\n     * // using the same name.\n     * //-\n     * const anotherBucket = storage.bucket('another-bucket');\n     * file.copy(anotherBucket, function(err, copiedFile, apiResponse) {\n     *   // `my-bucket` still contains:\n     *   // - \"my-image.png\"\n     *   //\n     *   // `another-bucket` now contains:\n     *   // - \"my-image.png\"\n     *\n     *   // `copiedFile` is an instance of a File object that refers to your new\n     *   // file.\n     * });\n     *\n     * //-\n     * // If you pass in a File object, you have complete control over the new\n     * // bucket and filename.\n     * //-\n     * const anotherFile = anotherBucket.file('my-awesome-image.png');\n     * file.copy(anotherFile, function(err, copiedFile, apiResponse) {\n     *   // `my-bucket` still contains:\n     *   // - \"my-image.png\"\n     *   //\n     *   // `another-bucket` now contains:\n     *   // - \"my-awesome-image.png\"\n     *\n     *   // Note:\n     *   // The `copiedFile` parameter is equal to `anotherFile`.\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * file.copy(newLocation).then(function(data) {\n     *   const newFile = data[0];\n     *   const apiResponse = data[1];\n     * });\n     *\n     * @example <caption>include:samples/files.js</caption>\n     * region_tag:storage_copy_file\n     * Another example:\n     */\n    copy(destination, optionsOrCallback, callback) {\n        const noDestinationError = new Error('Destination file should have a name.');\n        if (!destination) {\n            throw noDestinationError;\n        }\n        let options = {};\n        if (typeof optionsOrCallback === 'function') {\n            callback = optionsOrCallback;\n        }\n        else if (optionsOrCallback) {\n            options = optionsOrCallback;\n        }\n        if (options.hasOwnProperty('keepAcl')) {\n            // TODO: remove keepAcl from interface in next major.\n            emitWarning();\n        }\n        options = extend(true, {}, options);\n        callback = callback || common_1.util.noop;\n        let destBucket;\n        let destName;\n        let newFile;\n        if (typeof destination === 'string') {\n            const parsedDestination = GS_URL_REGEXP.exec(destination);\n            if (parsedDestination !== null && parsedDestination.length === 3) {\n                destBucket = this.storage.bucket(parsedDestination[1]);\n                destName = parsedDestination[2];\n            }\n            else {\n                destBucket = this.bucket;\n                destName = destination;\n            }\n        }\n        else if (destination instanceof bucket_1.Bucket) {\n            destBucket = destination;\n            destName = this.name;\n        }\n        else if (destination instanceof File) {\n            destBucket = destination.bucket;\n            destName = destination.name;\n            newFile = destination;\n        }\n        else {\n            throw noDestinationError;\n        }\n        const query = {};\n        if (this.generation !== undefined) {\n            query.sourceGeneration = this.generation;\n        }\n        if (options.token !== undefined) {\n            query.rewriteToken = options.token;\n        }\n        if (options.userProject !== undefined) {\n            query.userProject = options.userProject;\n            delete options.userProject;\n        }\n        if (options.predefinedAcl !== undefined) {\n            query.destinationPredefinedAcl = options.predefinedAcl;\n            delete options.predefinedAcl;\n        }\n        newFile = newFile || destBucket.file(destName);\n        const headers = {};\n        if (this.encryptionKey !== undefined) {\n            headers['x-goog-copy-source-encryption-algorithm'] = 'AES256';\n            headers['x-goog-copy-source-encryption-key'] = this.encryptionKeyBase64;\n            headers['x-goog-copy-source-encryption-key-sha256'] = this.encryptionKeyHash;\n        }\n        if (newFile.encryptionKey !== undefined) {\n            this.setEncryptionKey(newFile.encryptionKey);\n        }\n        else if (options.destinationKmsKeyName !== undefined) {\n            query.destinationKmsKeyName = options.destinationKmsKeyName;\n            delete options.destinationKmsKeyName;\n        }\n        else if (newFile.kmsKeyName !== undefined) {\n            query.destinationKmsKeyName = newFile.kmsKeyName;\n        }\n        if (query.destinationKmsKeyName) {\n            this.kmsKeyName = query.destinationKmsKeyName;\n            const keyIndex = this.interceptors.indexOf(this.encryptionKeyInterceptor);\n            if (keyIndex > -1) {\n                this.interceptors.splice(keyIndex, 1);\n            }\n        }\n        this.request({\n            method: 'POST',\n            uri: `/rewriteTo/b/${destBucket.name}/o/${encodeURIComponent(newFile.name)}`,\n            qs: query,\n            json: options,\n            headers,\n        }, (err, resp) => {\n            if (err) {\n                callback(err, null, resp);\n                return;\n            }\n            if (resp.rewriteToken) {\n                const options = {\n                    token: resp.rewriteToken,\n                };\n                if (query.userProject) {\n                    options.userProject = query.userProject;\n                }\n                if (query.destinationKmsKeyName) {\n                    options.destinationKmsKeyName = query.destinationKmsKeyName;\n                }\n                this.copy(newFile, options, callback);\n                return;\n            }\n            callback(null, newFile, resp);\n        });\n    }\n    /**\n     * @typedef {object} CreateReadStreamOptions Configuration options for File#createReadStream.\n     * @property {string} [userProject] The ID of the project which will be\n     *     billed for the request.\n     * @property {string|boolean} [validation] Possible values: `\"md5\"`,\n     *     `\"crc32c\"`, or `false`. By default, data integrity is validated with a\n     *     CRC32c checksum. You may use MD5 if preferred, but that hash is not\n     *     supported for composite objects. An error will be raised if MD5 is\n     *     specified but is not available. You may also choose to skip validation\n     *     completely, however this is **not recommended**.\n     * @property {number} [start] A byte offset to begin the file's download\n     *     from. Default is 0. NOTE: Byte ranges are inclusive; that is,\n     *     `options.start = 0` and `options.end = 999` represent the first 1000\n     *     bytes in a file or object. NOTE: when specifying a byte range, data\n     *     integrity is not available.\n     * @property {number} [end] A byte offset to stop reading the file at.\n     *     NOTE: Byte ranges are inclusive; that is, `options.start = 0` and\n     *     `options.end = 999` represent the first 1000 bytes in a file or object.\n     *     NOTE: when specifying a byte range, data integrity is not available.\n     * @property {boolean} [decompress=true] Disable auto decompression of the\n     *     received data. By default this option is set to `true`.\n     *     Applicable in cases where the data was uploaded with\n     *     `gzip: true` option. See {@link File#createWriteStream}.\n     */\n    /**\n     * Create a readable stream to read the contents of the remote file. It can be\n     * piped to a writable stream or listened to for 'data' events to read a\n     * file's contents.\n     *\n     * In the unlikely event there is a mismatch between what you downloaded and\n     * the version in your Bucket, your error handler will receive an error with\n     * code \"CONTENT_DOWNLOAD_MISMATCH\". If you receive this error, the best\n     * recourse is to try downloading the file again.\n     *\n     * For faster crc32c computation, you must manually install\n     * [`fast-crc32c`](http://www.gitnpm.com/fast-crc32c):\n     *\n     *     $ npm install --save fast-crc32c\n     *\n     * NOTE: Readable streams will emit the `end` event when the file is fully\n     * downloaded.\n     *\n     * @param {CreateReadStreamOptions} [options] Configuration options.\n     * @returns {ReadableStream}\n     *\n     * @example\n     * //-\n     * // <h4>Downloading a File</h4>\n     * //\n     * // The example below demonstrates how we can reference a remote file, then\n     * // pipe its contents to a local file. This is effectively creating a local\n     * // backup of your remote data.\n     * //-\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const bucket = storage.bucket('my-bucket');\n     *\n     * const fs = require('fs');\n     * const remoteFile = bucket.file('image.png');\n     * const localFilename = '/Users/stephen/Photos/image.png';\n     *\n     * remoteFile.createReadStream()\n     *   .on('error', function(err) {})\n     *   .on('response', function(response) {\n     *     // Server connected and responded with the specified status and headers.\n     *    })\n     *   .on('end', function() {\n     *     // The file is fully downloaded.\n     *   })\n     *   .pipe(fs.createWriteStream(localFilename));\n     *\n     * //-\n     * // To limit the downloaded data to only a byte range, pass an options\n     * // object.\n     * //-\n     * const logFile = myBucket.file('access_log');\n     * logFile.createReadStream({\n     *     start: 10000,\n     *     end: 20000\n     *   })\n     *   .on('error', function(err) {})\n     *   .pipe(fs.createWriteStream('/Users/stephen/logfile.txt'));\n     *\n     * //-\n     * // To read a tail byte range, specify only `options.end` as a negative\n     * // number.\n     * //-\n     * const logFile = myBucket.file('access_log');\n     * logFile.createReadStream({\n     *     end: -100\n     *   })\n     *   .on('error', function(err) {})\n     *   .pipe(fs.createWriteStream('/Users/stephen/logfile.txt'));\n     */\n    createReadStream(options = {}) {\n        options = Object.assign({ decompress: true }, options);\n        const rangeRequest = typeof options.start === 'number' || typeof options.end === 'number';\n        const tailRequest = options.end < 0;\n        // tslint:disable-next-line:no-any\n        let validateStream; // Created later, if necessary.\n        // TODO: remove `through2` dependency in favor of native PassThrough\n        // once Node 8 support is discontinued\n        const throughStream = streamEvents(through());\n        let isServedCompressed = true;\n        let crc32c = true;\n        let md5 = false;\n        let refreshedMetadata = false;\n        if (typeof options.validation === 'string') {\n            // tslint:disable-next-line:no-any\n            options.validation = options.validation.toLowerCase();\n            crc32c = options.validation === 'crc32c';\n            md5 = options.validation === 'md5';\n        }\n        else if (options.validation === false) {\n            crc32c = false;\n        }\n        if (rangeRequest) {\n            if (typeof options.validation === 'string' ||\n                options.validation === true) {\n                throw new Error('Cannot use validation with file ranges (start/end).');\n            }\n            // Range requests can't receive data integrity checks.\n            crc32c = false;\n            md5 = false;\n        }\n        // Authenticate the request, then pipe the remote API request to the stream\n        // returned to the user.\n        const makeRequest = () => {\n            const query = {\n                alt: 'media',\n            };\n            if (this.generation) {\n                query.generation = this.generation;\n            }\n            if (options.userProject) {\n                query.userProject = options.userProject;\n            }\n            const headers = {\n                'Accept-Encoding': 'gzip',\n                'Cache-Control': 'no-store',\n            };\n            if (rangeRequest) {\n                const start = typeof options.start === 'number' ? options.start : '0';\n                const end = typeof options.end === 'number' ? options.end : '';\n                headers.Range = `bytes=${tailRequest ? end : `${start}-${end}`}`;\n            }\n            const reqOpts = {\n                forever: false,\n                uri: '',\n                headers,\n                qs: query,\n            };\n            this.requestStream(reqOpts)\n                .on('error', err => {\n                throughStream.destroy(err);\n            })\n                .on('response', res => {\n                throughStream.emit('response', res);\n                // tslint:disable-next-line:no-any\n                common_1.util.handleResp(null, res, null, onResponse);\n            })\n                .resume();\n            // We listen to the response event from the request stream so that we\n            // can...\n            //\n            //   1) Intercept any data from going to the user if an error occurred.\n            //   2) Calculate the hashes from the http.IncomingMessage response\n            //   stream,\n            //      which will return the bytes from the source without decompressing\n            //      gzip'd content. We then send it through decompressed, if\n            //      applicable, to the user.\n            const onResponse = (err, _body, rawResponseStream) => {\n                if (err) {\n                    // Get error message from the body.\n                    rawResponseStream.pipe(concat(body => {\n                        err.message = body.toString();\n                        throughStream.destroy(err);\n                    }));\n                    return;\n                }\n                rawResponseStream.on('error', onComplete);\n                const headers = rawResponseStream.toJSON().headers;\n                isServedCompressed = headers['content-encoding'] === 'gzip';\n                const shouldRunValidation = !rangeRequest && (crc32c || md5);\n                const throughStreams = [];\n                if (shouldRunValidation) {\n                    validateStream = hashStreamValidation({ crc32c, md5 });\n                    throughStreams.push(validateStream);\n                }\n                if (isServedCompressed && options.decompress) {\n                    throughStreams.push(zlib.createGunzip());\n                }\n                if (throughStreams.length === 1) {\n                    rawResponseStream =\n                        // tslint:disable-next-line:no-any\n                        rawResponseStream.pipe(throughStreams[0]);\n                }\n                else if (throughStreams.length > 1) {\n                    rawResponseStream = rawResponseStream.pipe(pumpify.obj(throughStreams));\n                }\n                rawResponseStream\n                    .on('error', onComplete)\n                    .on('end', onComplete)\n                    .pipe(throughStream, { end: false });\n            };\n            // This is hooked to the `complete` event from the request stream. This is\n            // our chance to validate the data and let the user know if anything went\n            // wrong.\n            let onCompleteCalled = false;\n            const onComplete = (err) => {\n                if (err) {\n                    onCompleteCalled = true;\n                    throughStream.destroy(err);\n                    return;\n                }\n                if (rangeRequest) {\n                    onCompleteCalled = true;\n                    throughStream.end();\n                    return;\n                }\n                if (!refreshedMetadata) {\n                    refreshedMetadata = true;\n                    this.getMetadata({ userProject: options.userProject }, onComplete);\n                    return;\n                }\n                if (onCompleteCalled) {\n                    return;\n                }\n                onCompleteCalled = true;\n                // TODO(https://github.com/googleapis/nodejs-storage/issues/709):\n                // Remove once the backend issue is fixed.\n                // If object is stored compressed (having metadata.contentEncoding === 'gzip')\n                // and was served decompressed, then skip checksum validation because the\n                // remote checksum is computed against the compressed version of the object.\n                if (this.metadata.contentEncoding === 'gzip' && !isServedCompressed) {\n                    throughStream.end();\n                    return;\n                }\n                const hashes = {\n                    crc32c: this.metadata.crc32c,\n                    md5: this.metadata.md5Hash,\n                };\n                // If we're doing validation, assume the worst-- a data integrity\n                // mismatch. If not, these tests won't be performed, and we can assume\n                // the best.\n                let failed = crc32c || md5;\n                if (crc32c && hashes.crc32c) {\n                    // We must remove the first four bytes from the returned checksum.\n                    // http://stackoverflow.com/questions/25096737/\n                    //   base64-encoding-of-crc32c-long-value\n                    failed = !validateStream.test('crc32c', hashes.crc32c.substr(4));\n                }\n                if (md5 && hashes.md5) {\n                    failed = !validateStream.test('md5', hashes.md5);\n                }\n                if (md5 && !hashes.md5) {\n                    const hashError = new RequestError([\n                        'MD5 verification was specified, but is not available for the',\n                        'requested object. MD5 is not available for composite objects.',\n                    ].join(' '));\n                    hashError.code = 'MD5_NOT_AVAILABLE';\n                    throughStream.destroy(hashError);\n                }\n                else if (failed) {\n                    const mismatchError = new RequestError([\n                        'The downloaded data did not match the data from the server.',\n                        'To be sure the content is the same, you should download the',\n                        'file again.',\n                    ].join(' '));\n                    mismatchError.code = 'CONTENT_DOWNLOAD_MISMATCH';\n                    throughStream.destroy(mismatchError);\n                }\n                else {\n                    throughStream.end();\n                }\n            };\n        };\n        throughStream.on('reading', makeRequest);\n        return throughStream;\n    }\n    /**\n     * @callback CreateResumableUploadCallback\n     * @param {?Error} err Request error, if any.\n     * @param {string} uri The resumable upload's unique session URI.\n     */\n    /**\n     * @typedef {array} CreateResumableUploadResponse\n     * @property {string} 0 The resumable upload's unique session URI.\n     */\n    /**\n     * @typedef {object} CreateResumableUploadOptions\n     * @property {string} [configPath] A full JSON file path to use with\n     *     `gcs-resumable-upload`. This maps to the [configstore option by the\n     *     same\n     * name](https://github.com/yeoman/configstore/tree/0df1ec950d952b1f0dfb39ce22af8e505dffc71a#configpath).\n     * @property {object} [metadata] Metadata to set on the file.\n     * @property {string} [origin] Origin header to set for the upload.\n     * @property {string} [predefinedAcl] Apply a predefined set of access\n     *     controls to this object.\n     *\n     *     Acceptable values are:\n     *     - **`authenticatedRead`** - Object owner gets `OWNER` access, and\n     *       `allAuthenticatedUsers` get `READER` access.\n     *\n     *     - **`bucketOwnerFullControl`** - Object owner gets `OWNER` access, and\n     *       project team owners get `OWNER` access.\n     *\n     *     - **`bucketOwnerRead`** - Object owner gets `OWNER` access, and project\n     *       team owners get `READER` access.\n     *\n     *     - **`private`** - Object owner gets `OWNER` access.\n     *\n     *     - **`projectPrivate`** - Object owner gets `OWNER` access, and project\n     *       team members get access according to their roles.\n     *\n     *     - **`publicRead`** - Object owner gets `OWNER` access, and `allUsers`\n     * get `READER` access.\n     * @property {boolean} [private] Make the uploaded file private. (Alias for\n     *     `options.predefinedAcl = 'private'`)\n     * @property {boolean} [public] Make the uploaded file public. (Alias for\n     *     `options.predefinedAcl = 'publicRead'`)\n     * @property {string} [userProject] The ID of the project which will be\n     *     billed for the request.\n     */\n    /**\n     * Create a unique resumable upload session URI. This is the first step when\n     * performing a resumable upload.\n     *\n     * See the [Resumable upload\n     * guide](https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload)\n     * for more on how the entire process works.\n     *\n     * <h4>Note</h4>\n     *\n     * If you are just looking to perform a resumable upload without worrying\n     * about any of the details, see {@link File#createWriteStream}. Resumable\n     * uploads are performed by default.\n     *\n     * @see [Resumable upload guide]{@link https://cloud.google.com/storage/docs/json_api/v1/how-tos/resumable-upload}\n     *\n     * @param {CreateResumableUploadOptions} [options] Configuration options.\n     * @param {CreateResumableUploadCallback} [callback] Callback function.\n     * @returns {Promise<CreateResumableUploadResponse>}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const myBucket = storage.bucket('my-bucket');\n     *\n     * const file = myBucket.file('my-file');\n     * file.createResumableUpload(function(err, uri) {\n     *   if (!err) {\n     *     // `uri` can be used to PUT data to.\n     *   }\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * file.createResumableUpload().then(function(data) {\n     *   const uri = data[0];\n     * });\n     */\n    createResumableUpload(optionsOrCallback, callback) {\n        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};\n        callback =\n            typeof optionsOrCallback === 'function' ? optionsOrCallback : callback;\n        resumableUpload.createURI({\n            authClient: this.storage.authClient,\n            bucket: this.bucket.name,\n            configPath: options.configPath,\n            file: this.name,\n            generation: this.generation,\n            key: this.encryptionKey,\n            kmsKeyName: this.kmsKeyName,\n            metadata: options.metadata,\n            offset: options.offset,\n            origin: options.origin,\n            predefinedAcl: options.predefinedAcl,\n            private: options.private,\n            public: options.public,\n            userProject: options.userProject || this.userProject,\n        }, callback);\n    }\n    /**\n     * @typedef {object} CreateWriteStreamOptions Configuration options for File#createWriteStream().\n     * @property {string} [configPath] **This only applies to resumable\n     *     uploads.** A full JSON file path to use with `gcs-resumable-upload`.\n     *     This maps to the [configstore option by the same\n     * name](https://github.com/yeoman/configstore/tree/0df1ec950d952b1f0dfb39ce22af8e505dffc71a#configpath).\n     * @property {string} [contentType] Alias for\n     *     `options.metadata.contentType`. If set to `auto`, the file name is used\n     *     to determine the contentType.\n     * @property {string|boolean} [gzip] If true, automatically gzip the file.\n     *     If set to `auto`, the contentType is used to determine if the file\n     * should be gzipped. This will set `options.metadata.contentEncoding` to\n     * `gzip` if necessary.\n     * @property {object} [metadata] See the examples below or\n     *     [Objects: insert request\n     * body](https://cloud.google.com/storage/docs/json_api/v1/objects/insert#request_properties_JSON)\n     *     for more details.\n     * @property {number} [offset] The starting byte of the upload stream, for\n     *     resuming an interrupted upload. Defaults to 0.\n     * @property {string} [predefinedAcl] Apply a predefined set of access\n     *     controls to this object.\n     *\n     *     Acceptable values are:\n     *     - **`authenticatedRead`** - Object owner gets `OWNER` access, and\n     *       `allAuthenticatedUsers` get `READER` access.\n     *\n     *     - **`bucketOwnerFullControl`** - Object owner gets `OWNER` access, and\n     *       project team owners get `OWNER` access.\n     *\n     *     - **`bucketOwnerRead`** - Object owner gets `OWNER` access, and project\n     *       team owners get `READER` access.\n     *\n     *     - **`private`** - Object owner gets `OWNER` access.\n     *\n     *     - **`projectPrivate`** - Object owner gets `OWNER` access, and project\n     *       team members get access according to their roles.\n     *\n     *     - **`publicRead`** - Object owner gets `OWNER` access, and `allUsers`\n     * get `READER` access.\n     * @property {boolean} [private] Make the uploaded file private. (Alias for\n     *     `options.predefinedAcl = 'private'`)\n     * @property {boolean} [public] Make the uploaded file public. (Alias for\n     *     `options.predefinedAcl = 'publicRead'`)\n     * @property {boolean} [resumable] Force a resumable upload. NOTE: When\n     *     working with streams, the file format and size is unknown until it's\n     *     completely consumed. Because of this, it's best for you to be explicit\n     *     for what makes sense given your input.\n     * @property {string} [uri] The URI for an already-created resumable\n     *     upload. See {@link File#createResumableUpload}.\n     * @property {string} [userProject] The ID of the project which will be\n     *     billed for the request.\n     * @property {string|boolean} [validation] Possible values: `\"md5\"`,\n     *     `\"crc32c\"`, or `false`. By default, data integrity is validated with a\n     *     CRC32c checksum. You may use MD5 if preferred, but that hash is not\n     *     supported for composite objects. An error will be raised if MD5 is\n     *     specified but is not available. You may also choose to skip validation\n     *     completely, however this is **not recommended**.\n     *     NOTE: Validation is automatically skipped for objects that were\n     *     uploaded using the `gzip` option and have already compressed content.\n     */\n    /**\n     * Create a writable stream to overwrite the contents of the file in your\n     * bucket.\n     *\n     * A File object can also be used to create files for the first time.\n     *\n     * Resumable uploads are automatically enabled and must be shut off explicitly\n     * by setting `options.resumable` to `false`.\n     *\n     * Resumable uploads require write access to the $HOME directory. Through\n     * [`config-store`](http://www.gitnpm.com/configstore), some metadata is\n     * stored. By default, if the directory is not writable, we will fall back to\n     * a simple upload. However, if you explicitly request a resumable upload, and\n     * we cannot write to the config directory, we will return a\n     * `ResumableUploadError`.\n     *\n     * <p class=\"notice\">\n     *   There is some overhead when using a resumable upload that can cause\n     *   noticeable performance degradation while uploading a series of small\n     * files. When uploading files less than 10MB, it is recommended that the\n     * resumable feature is disabled.\n     * </p>\n     *\n     * For faster crc32c computation, you must manually install\n     * [`fast-crc32c`](http://www.gitnpm.com/fast-crc32c):\n     *\n     *     $ npm install --save fast-crc32c\n     *\n     * NOTE: Writable streams will emit the `finish` event when the file is fully\n     * uploaded.\n     *\n     * @see [Upload Options (Simple or Resumable)]{@link https://cloud.google.com/storage/docs/json_api/v1/how-tos/upload}\n     * @see [Objects: insert API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objects/insert}\n     *\n     * @param {CreateWriteStreamOptions} [options] Configuration options.\n     * @returns {WritableStream}\n     *\n     * @example\n     * const fs = require('fs');\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const myBucket = storage.bucket('my-bucket');\n     *\n     * const file = myBucket.file('my-file');\n     *\n     * //-\n     * // <h4>Uploading a File</h4>\n     * //\n     * // Now, consider a case where we want to upload a file to your bucket. You\n     * // have the option of using {@link Bucket#upload}, but that is just\n     * // a convenience method which will do the following.\n     * //-\n     * fs.createReadStream('/Users/stephen/Photos/birthday-at-the-zoo/panda.jpg')\n     *   .pipe(file.createWriteStream())\n     *   .on('error', function(err) {})\n     *   .on('finish', function() {\n     *     // The file upload is complete.\n     *   });\n     *\n     * //-\n     * // <h4>Uploading a File with gzip compression</h4>\n     * //-\n     * fs.createReadStream('/Users/stephen/site/index.html')\n     *   .pipe(file.createWriteStream({ gzip: true }))\n     *   .on('error', function(err) {})\n     *   .on('finish', function() {\n     *     // The file upload is complete.\n     *   });\n     *\n     * //-\n     * // Downloading the file with `createReadStream` will automatically decode\n     * // the file.\n     * //-\n     *\n     * //-\n     * // <h4>Uploading a File with Metadata</h4>\n     * //\n     * // One last case you may run into is when you want to upload a file to your\n     * // bucket and set its metadata at the same time. Like above, you can use\n     * // {@link Bucket#upload} to do this, which is just a wrapper around\n     * // the following.\n     * //-\n     * fs.createReadStream('/Users/stephen/Photos/birthday-at-the-zoo/panda.jpg')\n     *   .pipe(file.createWriteStream({\n     *     metadata: {\n     *       contentType: 'image/jpeg',\n     *       metadata: {\n     *         custom: 'metadata'\n     *       }\n     *     }\n     *   }))\n     *   .on('error', function(err) {})\n     *   .on('finish', function() {\n     *     // The file upload is complete.\n     *   });\n     */\n    // tslint:disable-next-line:no-any\n    createWriteStream(options = {}) {\n        options = Object.assign({ metadata: {} }, options);\n        if (options.contentType) {\n            options.metadata.contentType = options.contentType;\n            if (options.metadata.contentType === 'auto') {\n                options.metadata.contentType = mime.getType(this.name);\n            }\n        }\n        let gzip = options.gzip;\n        if (gzip === 'auto') {\n            gzip = compressible(options.metadata.contentType);\n        }\n        if (gzip) {\n            options.metadata.contentEncoding = 'gzip';\n        }\n        let crc32c = true;\n        let md5 = false;\n        if (typeof options.validation === 'string') {\n            options.validation = options.validation.toLowerCase();\n            crc32c = options.validation === 'crc32c';\n            md5 = options.validation === 'md5';\n        }\n        else if (options.validation === false) {\n            crc32c = false;\n        }\n        // Collect data as it comes in to store in a hash. This is compared to the\n        // checksum value on the returned metadata from the API.\n        const validateStream = hashStreamValidation({\n            crc32c,\n            md5,\n        });\n        const fileWriteStream = duplexify();\n        const stream = streamEvents(pumpify([\n            gzip ? zlib.createGzip() : through(),\n            validateStream,\n            fileWriteStream,\n        ]));\n        // Wait until we've received data to determine what upload technique to use.\n        stream.on('writing', () => {\n            if (options.resumable === false) {\n                this.startSimpleUpload_(fileWriteStream, options);\n                return;\n            }\n            if (options.configPath) {\n                this.startResumableUpload_(fileWriteStream, options);\n                return;\n            }\n            // Same as configstore:\n            // https://github.com/yeoman/configstore/blob/f09f067e50e6a636cfc648a6fc36a522062bd49d/index.js#L11\n            const configDir = xdgBasedir.config || os.tmpdir();\n            fs.access(configDir, fs.constants.W_OK, err => {\n                if (err) {\n                    if (options.resumable) {\n                        const error = new ResumableUploadError([\n                            'A resumable upload could not be performed. The directory,',\n                            `${configDir}, is not writable. You may try another upload,`,\n                            'this time setting `options.resumable` to `false`.',\n                        ].join(' '));\n                        stream.destroy(error);\n                        return;\n                    }\n                    // User didn't care, resumable or not. Fall back to simple upload.\n                    this.startSimpleUpload_(fileWriteStream, options);\n                    return;\n                }\n                this.startResumableUpload_(fileWriteStream, options);\n            });\n        });\n        fileWriteStream.on('response', stream.emit.bind(stream, 'response'));\n        // This is to preserve the `finish` event. We wait until the request stream\n        // emits \"complete\", as that is when we do validation of the data. After\n        // that is successful, we can allow the stream to naturally finish.\n        //\n        // Reference for tracking when we can use a non-hack solution:\n        // https://github.com/nodejs/node/pull/2314\n        fileWriteStream.on('prefinish', () => {\n            stream.cork();\n        });\n        // Compare our hashed version vs the completed upload's version.\n        fileWriteStream.on('complete', () => {\n            const metadata = this.metadata;\n            // If we're doing validation, assume the worst-- a data integrity\n            // mismatch. If not, these tests won't be performed, and we can assume the\n            // best.\n            let failed = crc32c || md5;\n            if (crc32c && metadata.crc32c) {\n                // We must remove the first four bytes from the returned checksum.\n                // http://stackoverflow.com/questions/25096737/\n                //   base64-encoding-of-crc32c-long-value\n                failed = !validateStream.test('crc32c', metadata.crc32c.substr(4));\n            }\n            if (md5 && metadata.md5Hash) {\n                failed = !validateStream.test('md5', metadata.md5Hash);\n            }\n            if (failed) {\n                this.delete((err) => {\n                    let code;\n                    let message;\n                    if (err) {\n                        code = 'FILE_NO_UPLOAD_DELETE';\n                        message = [\n                            'The uploaded data did not match the data from the server. As a',\n                            'precaution, we attempted to delete the file, but it was not',\n                            'successful. To be sure the content is the same, you should try',\n                            'removing the file manually, then uploading the file again.',\n                            '\\n\\nThe delete attempt failed with this message:',\n                            '\\n\\n  ' + err.message,\n                        ].join(' ');\n                    }\n                    else if (md5 && !metadata.md5Hash) {\n                        code = 'MD5_NOT_AVAILABLE';\n                        message = [\n                            'MD5 verification was specified, but is not available for the',\n                            'requested object. MD5 is not available for composite objects.',\n                        ].join(' ');\n                    }\n                    else {\n                        code = 'FILE_NO_UPLOAD';\n                        message = [\n                            'The uploaded data did not match the data from the server. As a',\n                            'precaution, the file has been deleted. To be sure the content',\n                            'is the same, you should try uploading the file again.',\n                        ].join(' ');\n                    }\n                    const error = new RequestError(message);\n                    error.code = code;\n                    error.errors = [err];\n                    fileWriteStream.destroy(error);\n                });\n                return;\n            }\n            stream.uncork();\n        });\n        return stream;\n    }\n    /**\n     * Delete failed resumable upload file cache.\n     *\n     * Resumable file upload cache the config file to restart upload in case of\n     * failure. In certain scenarios, the resumable upload will not works and\n     * upload file cache needs to be deleted to upload the same file.\n     *\n     * Following are some of the scenarios.\n     *\n     * Resumable file upload failed even though the file is successfully saved\n     * on the google storage and need to clean up a resumable file cache to\n     * update the same file.\n     *\n     * Resumable file upload failed due to pre-condition\n     * (i.e generation number is not matched) and want to upload a same\n     * file with the new generation number.\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const myBucket = storage.bucket('my-bucket');\n     *\n     * const file = myBucket.file('my-file', { generation: 0 });\n     * const contents = 'This is the contents of the file.';\n     *\n     * file.save(contents, function(err) {\n     *   if (err) {\n     *     file.deleteResumableCache();\n     *   }\n     * });\n     *\n     */\n    deleteResumableCache() {\n        const uploadStream = resumableUpload.upload({\n            bucket: this.bucket.name,\n            file: this.name,\n            generation: this.generation,\n        });\n        uploadStream.deleteConfig();\n    }\n    /**\n     * @typedef {array} DownloadResponse\n     * @property [0] The contents of a File.\n     */\n    /**\n     * @callback DownloadCallback\n     * @param err Request error, if any.\n     * @param contents The contents of a File.\n     */\n    /**\n     * Convenience method to download a file into memory or to a local\n     * destination.\n     *\n     * @param {object} [options] Configuration options. The arguments match those\n     *     passed to {@link File#createReadStream}.\n     * @param {string} [options.destination] Local file path to write the file's\n     *     contents to.\n     * @param {string} [options.userProject] The ID of the project which will be\n     *     billed for the request.\n     * @param {DownloadCallback} [callback] Callback function.\n     * @returns {Promise<DownloadResponse>}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const myBucket = storage.bucket('my-bucket');\n     *\n     * const file = myBucket.file('my-file');\n     *\n     * //-\n     * // Download a file into memory. The contents will be available as the\n     * second\n     * // argument in the demonstration below, `contents`.\n     * //-\n     * file.download(function(err, contents) {});\n     *\n     * //-\n     * // Download a file to a local destination.\n     * //-\n     * file.download({\n     *   destination: '/Users/me/Desktop/file-backup.txt'\n     * }, function(err) {});\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * file.download().then(function(data) {\n     *   const contents = data[0];\n     * });\n     *\n     * @example <caption>include:samples/files.js</caption>\n     * region_tag:storage_download_file\n     * Another example:\n     *\n     * @example <caption>include:samples/encryption.js</caption>\n     * region_tag:storage_download_encrypted_file\n     * Example of downloading an encrypted file:\n     *\n     * @example <caption>include:samples/requesterPays.js</caption>\n     * region_tag:storage_download_file_requester_pays\n     * Example of downloading a file where the requester pays:\n     */\n    download(optionsOrCallback, callback) {\n        let options;\n        if (typeof optionsOrCallback === 'function') {\n            callback = optionsOrCallback;\n            options = {};\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        callback = once(callback);\n        const destination = options.destination;\n        delete options.destination;\n        const fileStream = this.createReadStream(options);\n        if (destination) {\n            fileStream\n                .on('error', callback)\n                .pipe(fs.createWriteStream(destination))\n                .on('error', callback)\n                .on('finish', callback);\n        }\n        else {\n            fileStream.on('error', callback).pipe(concat(callback.bind(null, null)));\n        }\n    }\n    /**\n     * The Storage API allows you to use a custom key for server-side encryption.\n     *\n     * @see [Customer-supplied Encryption Keys]{@link https://cloud.google.com/storage/docs/encryption#customer-supplied}\n     *\n     * @param {string|buffer} encryptionKey An AES-256 encryption key.\n     * @returns {File}\n     *\n     * @example\n     * const crypto = require('crypto');\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const myBucket = storage.bucket('my-bucket');\n     *\n     * const encryptionKey = crypto.randomBytes(32);\n     *\n     * const fileWithCustomEncryption = myBucket.file('my-file');\n     * fileWithCustomEncryption.setEncryptionKey(encryptionKey);\n     *\n     * const fileWithoutCustomEncryption = myBucket.file('my-file');\n     *\n     * fileWithCustomEncryption.save('data', function(err) {\n     *   // Try to download with the File object that hasn't had\n     *   // `setEncryptionKey()` called:\n     *   fileWithoutCustomEncryption.download(function(err) {\n     *     // We will receive an error:\n     *     //   err.message === 'Bad Request'\n     *\n     *     // Try again with the File object we called `setEncryptionKey()` on:\n     *     fileWithCustomEncryption.download(function(err, contents) {\n     *       // contents.toString() === 'data'\n     *     });\n     *   });\n     * });\n     *\n     * @example <caption>include:samples/encryption.js</caption>\n     * region_tag:storage_upload_encrypted_file\n     * Example of uploading an encrypted file:\n     *\n     * @example <caption>include:samples/encryption.js</caption>\n     * region_tag:storage_download_encrypted_file\n     * Example of downloading an encrypted file:\n     */\n    setEncryptionKey(encryptionKey) {\n        this.encryptionKey = encryptionKey;\n        this.encryptionKeyBase64 = Buffer.from(encryptionKey).toString('base64');\n        this.encryptionKeyHash = crypto\n            .createHash('sha256')\n            // tslint:disable-next-line:no-any\n            .update(this.encryptionKeyBase64, 'base64')\n            .digest('base64');\n        this.encryptionKeyInterceptor = {\n            request: reqOpts => {\n                reqOpts.headers = reqOpts.headers || {};\n                reqOpts.headers['x-goog-encryption-algorithm'] = 'AES256';\n                reqOpts.headers['x-goog-encryption-key'] = this.encryptionKeyBase64;\n                reqOpts.headers['x-goog-encryption-key-sha256'] = this.encryptionKeyHash;\n                return reqOpts;\n            },\n        };\n        this.interceptors.push(this.encryptionKeyInterceptor);\n        return this;\n    }\n    /**\n     * @typedef {array} GetExpirationDateResponse\n     * @property {date} 0 A Date object representing the earliest time this file's\n     *     retention policy will expire.\n     */\n    /**\n     * @callback GetExpirationDateCallback\n     * @param {?Error} err Request error, if any.\n     * @param {date} expirationDate A Date object representing the earliest time\n     *     this file's retention policy will expire.\n     */\n    /**\n     * If this bucket has a retention policy defined, use this method to get a\n     * Date object representing the earliest time this file will expire.\n     *\n     * @param {GetExpirationDateCallback} [callback] Callback function.\n     * @returns {Promise<GetExpirationDateResponse>}\n     *\n     * @example\n     * const storage = require('@google-cloud/storage')();\n     * const myBucket = storage.bucket('my-bucket');\n     *\n     * const file = myBucket.file('my-file');\n     *\n     * file.getExpirationDate(function(err, expirationDate) {\n     *   // expirationDate is a Date object.\n     * });\n     */\n    getExpirationDate(callback) {\n        this.getMetadata((err, metadata, apiResponse) => {\n            if (err) {\n                callback(err, null, apiResponse);\n                return;\n            }\n            if (!metadata.retentionExpirationTime) {\n                const error = new Error('An expiration time is not available.');\n                callback(error, null, apiResponse);\n                return;\n            }\n            callback(null, new Date(metadata.retentionExpirationTime), apiResponse);\n        });\n    }\n    /**\n     * @typedef {array} GetSignedPolicyResponse\n     * @property {object} 0 The document policy.\n     */\n    /**\n     * @callback GetSignedPolicyCallback\n     * @param {?Error} err Request error, if any.\n     * @param {object} policy The document policy.\n     */\n    /**\n     * Get a v2 signed policy document to allow a user to upload data with a POST\n     * request.\n     *\n     * In Google Cloud Platform environments, such as Cloud Functions and App\n     * Engine, you usually don't provide a `keyFilename` or `credentials` during\n     * instantiation. In those environments, we call the\n     * [signBlob\n     * API](https://cloud.google.com/iam/reference/rest/v1/projects.serviceAccounts/signBlob#authorization-scopes)\n     * to create a signed policy. That API requires either the\n     * `https://www.googleapis.com/auth/iam` or\n     * `https://www.googleapis.com/auth/cloud-platform` scope, so be sure they are\n     * enabled.\n     *\n     * @see [Policy Document Reference]{@link https://cloud.google.com/storage/docs/xml-api/post-object#policydocument}\n     *\n     * @deprecated `getSignedPolicy()` is deprecated in favor of\n     *     `generateSignedPostPolicyV2()` and `generateSignedPostPolicyV4()`.\n     *     Currently, this method is an alias to `getSignedPolicyV2()`,\n     *     and will be removed in a future major release.\n     *     We recommend signing new policies using v4.\n     *\n     * @throws {Error} If an expiration timestamp from the past is given.\n     * @throws {Error} If options.equals has an array with less or more than two\n     *     members.\n     * @throws {Error} If options.startsWith has an array with less or more than two\n     *     members.\n     *\n     * @param {object} options Configuration options.\n     * @param {array|array[]} [options.equals] Array of request parameters and\n     *     their expected value (e.g. [['$<field>', '<value>']]). Values are\n     *     translated into equality constraints in the conditions field of the\n     *     policy document (e.g. ['eq', '$<field>', '<value>']). If only one\n     *     equality condition is to be specified, options.equals can be a one-\n     *     dimensional array (e.g. ['$<field>', '<value>']).\n     * @param {*} options.expires - A timestamp when this policy will expire. Any\n     *     value given is passed to `new Date()`.\n     * @param {array|array[]} [options.startsWith] Array of request parameters and\n     *     their expected prefixes (e.g. [['$<field>', '<value>']). Values are\n     *     translated into starts-with constraints in the conditions field of the\n     *     policy document (e.g. ['starts-with', '$<field>', '<value>']). If only\n     *     one prefix condition is to be specified, options.startsWith can be a\n     * one- dimensional array (e.g. ['$<field>', '<value>']).\n     * @param {string} [options.acl] ACL for the object from possibly predefined\n     *     ACLs.\n     * @param {string} [options.successRedirect] The URL to which the user client\n     *     is redirected if the upload is successful.\n     * @param {string} [options.successStatus] - The status of the Google Storage\n     *     response if the upload is successful (must be string).\n     * @param {object} [options.contentLengthRange]\n     * @param {number} [options.contentLengthRange.min] Minimum value for the\n     *     request's content length.\n     * @param {number} [options.contentLengthRange.max] Maximum value for the\n     *     request's content length.\n     * @param {GetSignedPolicyCallback} [callback] Callback function.\n     * @returns {Promise<GetSignedPolicyResponse>}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const myBucket = storage.bucket('my-bucket');\n     *\n     * const file = myBucket.file('my-file');\n     * const options = {\n     *   equals: ['$Content-Type', 'image/jpeg'],\n     *   expires: '10-25-2022',\n     *   contentLengthRange: {\n     *     min: 0,\n     *     max: 1024\n     *   }\n     * };\n     *\n     * file.getSignedPolicy(options, function(err, policy) {\n     *   // policy.string: the policy document in plain text.\n     *   // policy.base64: the policy document in base64.\n     *   // policy.signature: the policy signature in base64.\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * file.getSignedPolicy(options).then(function(data) {\n     *   const policy = data[0];\n     * });\n     */\n    getSignedPolicy(optionsOrCallback, cb) {\n        const args = util_1.normalize(optionsOrCallback, cb);\n        const options = args.options;\n        const callback = args.callback;\n        this.generateSignedPostPolicyV2(options, callback);\n    }\n    /**\n     * @typedef {array} GenerateSignedPostPolicyV2Response\n     * @property {object} 0 The document policy.\n     */\n    /**\n     * @callback GenerateSignedPostPolicyV2Callback\n     * @param {?Error} err Request error, if any.\n     * @param {object} policy The document policy.\n     */\n    /**\n     * Get a signed policy document to allow a user to upload data with a POST\n     * request.\n     *\n     * In Google Cloud Platform environments, such as Cloud Functions and App\n     * Engine, you usually don't provide a `keyFilename` or `credentials` during\n     * instantiation. In those environments, we call the\n     * [signBlob\n     * API](https://cloud.google.com/iam/reference/rest/v1/projects.serviceAccounts/signBlob#authorization-scopes)\n     * to create a signed policy. That API requires either the\n     * `https://www.googleapis.com/auth/iam` or\n     * `https://www.googleapis.com/auth/cloud-platform` scope, so be sure they are\n     * enabled.\n     *\n     * @see [POST Object with the V2 signing process]{@link https://cloud.google.com/storage/docs/xml-api/post-object-v2}\n     *\n     * @throws {Error} If an expiration timestamp from the past is given.\n     * @throws {Error} If options.equals has an array with less or more than two\n     *     members.\n     * @throws {Error} If options.startsWith has an array with less or more than two\n     *     members.\n     *\n     * @param {object} options Configuration options.\n     * @param {array|array[]} [options.equals] Array of request parameters and\n     *     their expected value (e.g. [['$<field>', '<value>']]). Values are\n     *     translated into equality constraints in the conditions field of the\n     *     policy document (e.g. ['eq', '$<field>', '<value>']). If only one\n     *     equality condition is to be specified, options.equals can be a one-\n     *     dimensional array (e.g. ['$<field>', '<value>']).\n     * @param {*} options.expires - A timestamp when this policy will expire. Any\n     *     value given is passed to `new Date()`.\n     * @param {array|array[]} [options.startsWith] Array of request parameters and\n     *     their expected prefixes (e.g. [['$<field>', '<value>']). Values are\n     *     translated into starts-with constraints in the conditions field of the\n     *     policy document (e.g. ['starts-with', '$<field>', '<value>']). If only\n     *     one prefix condition is to be specified, options.startsWith can be a\n     * one- dimensional array (e.g. ['$<field>', '<value>']).\n     * @param {string} [options.acl] ACL for the object from possibly predefined\n     *     ACLs.\n     * @param {string} [options.successRedirect] The URL to which the user client\n     *     is redirected if the upload is successful.\n     * @param {string} [options.successStatus] - The status of the Google Storage\n     *     response if the upload is successful (must be string).\n     * @param {object} [options.contentLengthRange]\n     * @param {number} [options.contentLengthRange.min] Minimum value for the\n     *     request's content length.\n     * @param {number} [options.contentLengthRange.max] Maximum value for the\n     *     request's content length.\n     * @param {GenerateSignedPostPolicyV2Callback} [callback] Callback function.\n     * @returns {Promise<GenerateSignedPostPolicyV2Response>}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const myBucket = storage.bucket('my-bucket');\n     *\n     * const file = myBucket.file('my-file');\n     * const options = {\n     *   equals: ['$Content-Type', 'image/jpeg'],\n     *   expires: '10-25-2022',\n     *   contentLengthRange: {\n     *     min: 0,\n     *     max: 1024\n     *   }\n     * };\n     *\n     * file.generateSignedPostPolicyV2(options, function(err, policy) {\n     *   // policy.string: the policy document in plain text.\n     *   // policy.base64: the policy document in base64.\n     *   // policy.signature: the policy signature in base64.\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * file.generateSignedPostPolicyV2(options).then(function(data) {\n     *   const policy = data[0];\n     * });\n     */\n    generateSignedPostPolicyV2(optionsOrCallback, cb) {\n        const args = util_1.normalize(optionsOrCallback, cb);\n        let options = args.options;\n        const callback = args.callback;\n        const expires = new Date(options.expires);\n        if (isNaN(expires.getTime())) {\n            throw new Error('The expiration date provided was invalid.');\n        }\n        if (expires.valueOf() < Date.now()) {\n            throw new Error('An expiration date cannot be in the past.');\n        }\n        options = Object.assign({}, options);\n        const conditions = [\n            ['eq', '$key', this.name],\n            {\n                bucket: this.bucket.name,\n            },\n        ];\n        if (Array.isArray(options.equals)) {\n            if (!Array.isArray(options.equals[0])) {\n                options.equals = [options.equals];\n            }\n            options.equals.forEach(condition => {\n                if (!Array.isArray(condition) || condition.length !== 2) {\n                    throw new Error('Equals condition must be an array of 2 elements.');\n                }\n                conditions.push(['eq', condition[0], condition[1]]);\n            });\n        }\n        if (Array.isArray(options.startsWith)) {\n            if (!Array.isArray(options.startsWith[0])) {\n                options.startsWith = [options.startsWith];\n            }\n            options.startsWith.forEach(condition => {\n                if (!Array.isArray(condition) || condition.length !== 2) {\n                    throw new Error('StartsWith condition must be an array of 2 elements.');\n                }\n                conditions.push(['starts-with', condition[0], condition[1]]);\n            });\n        }\n        if (options.acl) {\n            conditions.push({\n                acl: options.acl,\n            });\n        }\n        if (options.successRedirect) {\n            conditions.push({\n                success_action_redirect: options.successRedirect,\n            });\n        }\n        if (options.successStatus) {\n            conditions.push({\n                success_action_status: options.successStatus,\n            });\n        }\n        if (options.contentLengthRange) {\n            const min = options.contentLengthRange.min;\n            const max = options.contentLengthRange.max;\n            if (typeof min !== 'number' || typeof max !== 'number') {\n                throw new Error('ContentLengthRange must have numeric min & max fields.');\n            }\n            conditions.push(['content-length-range', min, max]);\n        }\n        const policy = {\n            expiration: expires.toISOString(),\n            conditions,\n        };\n        const policyString = JSON.stringify(policy);\n        const policyBase64 = Buffer.from(policyString).toString('base64');\n        this.storage.authClient.sign(policyBase64).then(signature => {\n            callback(null, {\n                string: policyString,\n                base64: policyBase64,\n                signature,\n            });\n        }, err => {\n            callback(new signer_1.SigningError(err.message));\n        });\n    }\n    /**\n     * @typedef {object} SignedPostPolicyV4Output\n     * @property {string} url The request URL.\n     * @property {object} fields The form fields to include in the POST request.\n     */\n    /**\n     * @typedef {array} GenerateSignedPostPolicyV4Response\n     * @property {SignedPostPolicyV4Output} 0 An object containing the request URL and form fields.\n     */\n    /**\n     * @callback GenerateSignedPostPolicyV4Callback\n     * @param {?Error} err Request error, if any.\n     * @param {SignedPostPolicyV4Output} output An object containing the request URL and form fields.\n     */\n    /**\n     * Get a v4 signed policy document to allow a user to upload data with a POST\n     * request.\n     *\n     * In Google Cloud Platform environments, such as Cloud Functions and App\n     * Engine, you usually don't provide a `keyFilename` or `credentials` during\n     * instantiation. In those environments, we call the\n     * [signBlob\n     * API](https://cloud.google.com/iam/reference/rest/v1/projects.serviceAccounts/signBlob#authorization-scopes)\n     * to create a signed policy. That API requires either the\n     * `https://www.googleapis.com/auth/iam` or\n     * `https://www.googleapis.com/auth/cloud-platform` scope, so be sure they are\n     * enabled.\n     *\n     * @see [Policy Document Reference]{@link https://cloud.google.com/storage/docs/xml-api/post-object#policydocument}\n     *\n     * @param {object} options Configuration options.\n     * @param {Date|number|string} options.expires - A timestamp when this policy will expire. Any\n     *     value given is passed to `new Date()`.\n     * @param {boolean} [config.virtualHostedStyle=false] Use virtual hosted-style\n     *     URLs ('https://mybucket.storage.googleapis.com/...') instead of path-style\n     *     ('https://storage.googleapis.com/mybucket/...'). Virtual hosted-style URLs\n     *     should generally be preferred instaed of path-style URL.\n     *     Currently defaults to `false` for path-style, although this may change in a\n     *     future major-version release.\n     * @param {string} [config.bucketBoundHostname] The bucket-bound hostname to return in\n     *     the result, e.g. \"https://cdn.example.com\".\n     * @param {object} [config.fields] [Form fields]{@link https://cloud.google.com/storage/docs/xml-api/post-object#policydocument}\n     *     to include in the signed policy. Any fields with key beginning with 'x-ignore-'\n     *     will not be included in the policy to be signed.\n     * @param {object[]} [config.conditions] [Conditions]{@link https://cloud.google.com/storage/docs/authentication/signatures#policy-document}\n     *     to include in the signed policy. All fields given in `config.fields` are\n     *     automatically included in the conditions array, adding the same entry\n     *     in both `fields` and `conditions` will result in duplicate entries.\n     *\n     * @param {GenerateSignedPostPolicyV4Callback} [callback] Callback function.\n     * @returns {Promise<GenerateSignedPostPolicyV4Response>}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const myBucket = storage.bucket('my-bucket');\n     *\n     * const file = myBucket.file('my-file');\n     * const options = {\n     *   expires: '10-25-2022',\n     *   conditions: [\n     *     ['eq', '$Content-Type', 'image/jpeg'],\n     *     ['content-length-range', 0, 1024],\n     *   ],\n     *   fields: {\n     *     acl: 'public-read',\n     *     'x-goog-meta-foo': 'bar',\n     *     'x-ignore-mykey': 'data'\n     *   }\n     * };\n     *\n     * file.generateSignedPostPolicyV4(options, function(err, response) {\n     *   // response.url The request URL\n     *   // response.fields The form fields (including the signature) to include\n     *   //     to be used to upload objects by HTML forms.\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * file.generateSignedPostPolicyV4(options).then(function(data) {\n     *   const response = data[0];\n     *   // response.url The request URL\n     *   // response.fields The form fields (including the signature) to include\n     *   //     to be used to upload objects by HTML forms.\n     * });\n     */\n    generateSignedPostPolicyV4(optionsOrCallback, cb) {\n        const args = util_1.normalize(optionsOrCallback, cb);\n        let options = args.options;\n        const callback = args.callback;\n        const expires = new Date(options.expires);\n        if (isNaN(expires.getTime())) {\n            throw new Error('The expiration date provided was invalid.');\n        }\n        if (expires.valueOf() < Date.now()) {\n            throw new Error('An expiration date cannot be in the past.');\n        }\n        if (expires.valueOf() - Date.now() > SEVEN_DAYS * 1000) {\n            throw new Error(`Max allowed expiration is seven days (${SEVEN_DAYS} seconds).`);\n        }\n        options = Object.assign({}, options);\n        let fields = Object.assign({}, options.fields);\n        const now = new Date();\n        const nowISO = dateFormat.format(now, 'YYYYMMDD[T]HHmmss[Z]', true);\n        const todayISO = dateFormat.format(now, 'YYYYMMDD', true);\n        const sign = async () => {\n            const { client_email } = await this.storage.authClient.getCredentials();\n            const credential = `${client_email}/${todayISO}/auto/storage/goog4_request`;\n            fields = Object.assign(Object.assign({}, fields), { key: this.name, 'x-goog-date': nowISO, 'x-goog-credential': credential, 'x-goog-algorithm': 'GOOG4-RSA-SHA256' });\n            const conditions = options.conditions || [];\n            Object.entries(fields).forEach(([key, value]) => {\n                if (!key.startsWith('x-ignore-')) {\n                    conditions.push({ [key]: value });\n                }\n            });\n            const expiration = dateFormat.format(expires, 'YYYY-MM-DD[T]HH:mm:ss[Z]', true);\n            const policy = {\n                conditions,\n                expiration,\n            };\n            const policyString = JSON.stringify(policy);\n            const policyBase64 = Buffer.from(policyString).toString('base64');\n            try {\n                const signature = await this.storage.authClient.sign(policyBase64);\n                const signatureHex = Buffer.from(signature, 'base64').toString('hex');\n                fields['policy'] = policyBase64;\n                fields['x-goog-signature'] = signatureHex;\n                let url;\n                if (options.virtualHostedStyle) {\n                    url = `https://${this.bucket.name}.storage.googleapis.com/`;\n                }\n                else if (options.bucketBoundHostname) {\n                    url = `${options.bucketBoundHostname}/`;\n                }\n                else {\n                    url = `${exports.STORAGE_POST_POLICY_BASE_URL}/${this.bucket.name}/`;\n                }\n                return {\n                    url,\n                    fields,\n                };\n            }\n            catch (err) {\n                throw new signer_1.SigningError(err.message);\n            }\n        };\n        sign().then(res => callback(null, res), callback);\n    }\n    /**\n     * @typedef {array} GetSignedUrlResponse\n     * @property {object} 0 The signed URL.\n     */\n    /**\n     * @callback GetSignedUrlCallback\n     * @param {?Error} err Request error, if any.\n     * @param {object} url The signed URL.\n     */\n    /**\n     * Get a signed URL to allow limited time access to the file.\n     *\n     * In Google Cloud Platform environments, such as Cloud Functions and App\n     * Engine, you usually don't provide a `keyFilename` or `credentials` during\n     * instantiation. In those environments, we call the\n     * [signBlob\n     * API](https://cloud.google.com/iam/reference/rest/v1/projects.serviceAccounts/signBlob#authorization-scopes)\n     * to create a signed URL. That API requires either the\n     * `https://www.googleapis.com/auth/iam` or\n     * `https://www.googleapis.com/auth/cloud-platform` scope, so be sure they are\n     * enabled.\n     *\n     * @see [Signed URLs Reference]{@link https://cloud.google.com/storage/docs/access-control/signed-urls}\n     *\n     * @throws {Error} if an expiration timestamp from the past is given.\n     *\n     * @param {object} config Configuration object.\n     * @param {string} config.action \"read\" (HTTP: GET), \"write\" (HTTP: PUT), or\n     *     \"delete\" (HTTP: DELETE), \"resumable\" (HTTP: POST).\n     *     When using \"resumable\", the header `X-Goog-Resumable: start` has\n     *     to be sent when making a request with the signed URL.\n     * @param {*} config.expires A timestamp when this link will expire. Any value\n     *     given is passed to `new Date()`.\n     *     Note: 'v4' supports maximum duration of 7 days (604800 seconds) from now.\n     *     See [reference]{@link https://cloud.google.com/storage/docs/access-control/signed-urls#example}\n     * @param {string} [config.version='v2'] The signing version to use, either\n     *     'v2' or 'v4'.\n     * @param {boolean} [config.virtualHostedStyle=false] Use virtual hosted-style\n     *     URLs ('https://mybucket.storage.googleapis.com/...') instead of path-style\n     *     ('https://storage.googleapis.com/mybucket/...'). Virtual hosted-style URLs\n     *     should generally be preferred instaed of path-style URL.\n     *     Currently defaults to `false` for path-style, although this may change in a\n     *     future major-version release.\n     * @param {string} [config.cname] The cname for this bucket, i.e.,\n     *     \"https://cdn.example.com\".\n     * @param {string} [config.contentMd5] The MD5 digest value in base64. Just like\n     *     if you provide this, the client must provide this HTTP header with this same\n     *     value in its request, so to if this parameter is not provided here,\n     *     the client must not provide any value for this HTTP header in its request.\n     * @param {string} [config.contentType] Just like if you provide this, the client\n     *     must provide this HTTP header with this same value in its request, so to if\n     *     this parameter is not provided here, the client must not provide any value\n     *     for this HTTP header in its request.\n     * @param {object} [config.extensionHeaders] If these headers are used, the\n     *     server will check to make sure that the client provides matching\n     * values. See [Canonical extension\n     * headers](https://cloud.google.com/storage/docs/access-control/signed-urls#about-canonical-extension-headers)\n     *     for the requirements of this feature, most notably:\n     *       - The header name must be prefixed with `x-goog-`\n     *       - The header name must be all lowercase\n     *     Note: Multi-valued header passed as an array in the extensionHeaders\n     *           object is converted into a string, delimited by `,` with\n     *           no space. Requests made using the signed URL will need to\n     *           delimit multi-valued headers using a single `,` as well, or\n     *           else the server will report a mismatched signature.\n     * @param {object} [config.queryParams] Additional query parameters to include\n     *     in the signed URL.\n     * @param {string} [config.promptSaveAs] The filename to prompt the user to\n     *     save the file as when the signed url is accessed. This is ignored if\n     *     `config.responseDisposition` is set.\n     * @param {string} [config.responseDisposition] The\n     *     [response-content-disposition parameter](http://goo.gl/yMWxQV) of the\n     *     signed url.\n     * @param {string} [config.responseType] The response-content-type parameter\n     *     of the signed url.\n     * @param {GetSignedUrlCallback} [callback] Callback function.\n     * @returns {Promise<GetSignedUrlResponse>}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const myBucket = storage.bucket('my-bucket');\n     *\n     * const file = myBucket.file('my-file');\n     *\n     * //-\n     * // Generate a URL that allows temporary access to download your file.\n     * //-\n     * const request = require('request');\n     *\n     * const config = {\n     *   action: 'read',\n     *   expires: '03-17-2025'\n     * };\n     *\n     * file.getSignedUrl(config, function(err, url) {\n     *   if (err) {\n     *     console.error(err);\n     *     return;\n     *   }\n     *\n     *   // The file is now available to read from this URL.\n     *   request(url, function(err, resp) {\n     *     // resp.statusCode = 200\n     *   });\n     * });\n     *\n     * //-\n     * // Generate a URL to allow write permissions. This means anyone with this\n     * URL\n     * // can send a POST request with new data that will overwrite the file.\n     * //-\n     * file.getSignedUrl({\n     *   action: 'write',\n     *   expires: '03-17-2025'\n     * }, function(err, url) {\n     *   if (err) {\n     *     console.error(err);\n     *     return;\n     *   }\n     *\n     *   // The file is now available to be written to.\n     *   const writeStream = request.put(url);\n     *   writeStream.end('New data');\n     *\n     *   writeStream.on('complete', function(resp) {\n     *     // Confirm the new content was saved.\n     *     file.download(function(err, fileContents) {\n     *       console.log('Contents:', fileContents.toString());\n     *       // Contents: New data\n     *     });\n     *   });\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * file.getSignedUrl(config).then(function(data) {\n     *   const url = data[0];\n     * });\n     *\n     * @example <caption>include:samples/files.js</caption>\n     * region_tag:storage_generate_signed_url\n     * Another example:\n     */\n    getSignedUrl(cfg, callback) {\n        const method = ActionToHTTPMethod[cfg.action];\n        if (!method) {\n            throw new Error('The action is not provided or invalid.');\n        }\n        const extensionHeaders = util_1.objectKeyToLowercase(cfg.extensionHeaders || {});\n        if (cfg.action === 'resumable') {\n            extensionHeaders['x-goog-resumable'] = 'start';\n        }\n        const queryParams = Object.assign({}, cfg.queryParams);\n        if (typeof cfg.responseType === 'string') {\n            queryParams['response-content-type'] = cfg.responseType;\n        }\n        if (typeof cfg.promptSaveAs === 'string') {\n            queryParams['response-content-disposition'] =\n                'attachment; filename=\"' + cfg.promptSaveAs + '\"';\n        }\n        if (typeof cfg.responseDisposition === 'string') {\n            queryParams['response-content-disposition'] = cfg.responseDisposition;\n        }\n        if (this.generation) {\n            queryParams['generation'] = this.generation.toString();\n        }\n        const signConfig = {\n            method,\n            expires: cfg.expires,\n            extensionHeaders,\n            queryParams,\n            contentMd5: cfg.contentMd5,\n            contentType: cfg.contentType,\n        };\n        if (cfg.cname) {\n            signConfig.cname = cfg.cname;\n        }\n        if (cfg.version) {\n            signConfig.version = cfg.version;\n        }\n        if (cfg.virtualHostedStyle) {\n            signConfig.virtualHostedStyle = cfg.virtualHostedStyle;\n        }\n        if (!this.signer) {\n            this.signer = new signer_1.URLSigner(this.storage.authClient, this.bucket, this);\n        }\n        this.signer\n            .getSignedUrl(signConfig)\n            .then(signedUrl => callback(null, signedUrl), callback);\n    }\n    /**\n     * @callback IsPublicCallback\n     * @param {?Error} err Request error, if any.\n     * @param {boolean} resp Whether file is public or not.\n     */\n    /**\n     * @typedef {array} IsPublicResponse\n     * @property {boolean} 0 Whether file is public or not.\n     */\n    /**\n     * Check whether this file is public or not by sending\n     * a HEAD request without credentials.\n     * No errors from the server indicates that the current\n     * file is public.\n     * A 403-Forbidden error {@link https://cloud.google.com/storage/docs/json_api/v1/status-codes#403_Forbidden}\n     * indicates that file is private.\n     * Any other non 403 error is propagated to user.\n     *\n     * @param {IsPublicCallback} [callback] Callback function.\n     * @returns {Promise<IsPublicResponse>}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const myBucket = storage.bucket('my-bucket');\n     *\n     * const file = myBucket.file('my-file');\n     *\n     * //-\n     * // Check whether the file is publicly accessible.\n     * //-\n     * file.isPublic(function(err, resp) {\n     *   if (err) {\n     *     console.error(err);\n     *     return;\n     *   }\n     *   console.log(`the file ${file.id} is public: ${resp}`) ;\n     * })\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * file.isPublic().then(function(data) {\n     *   const resp = data[0];\n     * });\n     */\n    isPublic(callback) {\n        gaxios_1.request({\n            method: 'HEAD',\n            url: `http://${this.bucket.name}.storage.googleapis.com/${encodeURIComponent(this.name)}`,\n        }).then(() => callback(null, true), (err) => {\n            if (err.code === '403') {\n                callback(null, false);\n            }\n            else {\n                callback(err);\n            }\n        });\n    }\n    /**\n     * @typedef {object} MakeFilePrivateOptions Configuration options for File#makePrivate().\n     * @property {boolean} [strict] If true, set the file to be private to\n     *     only the owner user. Otherwise, it will be private to the project.\n     * @property {string} [userProject] The ID of the project which will be\n     *     billed for the request.\n     */\n    /**\n     * @callback MakeFilePrivateCallback\n     * @param {?Error} err Request error, if any.\n     * @param {object} apiResponse The full API response.\n     */\n    /**\n     * @typedef {array} MakeFilePrivateResponse\n     * @property {object} 0 The full API response.\n     */\n    /**\n     * Make a file private to the project and remove all other permissions.\n     * Set `options.strict` to true to make the file private to only the owner.\n     *\n     * @see [Objects: patch API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objects/patch}\n     *\n     * @param {MakeFilePrivateOptions} [options] Configuration options.\n     * @param {MakeFilePrivateCallback} [callback] Callback function.\n     * @returns {Promise<MakeFilePrivateResponse>}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const myBucket = storage.bucket('my-bucket');\n     *\n     * const file = myBucket.file('my-file');\n     *\n     * //-\n     * // Set the file private so only project maintainers can see and modify it.\n     * //-\n     * file.makePrivate(function(err) {});\n     *\n     * //-\n     * // Set the file private so only the owner can see and modify it.\n     * //-\n     * file.makePrivate({ strict: true }, function(err) {});\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * file.makePrivate().then(function(data) {\n     *   const apiResponse = data[0];\n     * });\n     */\n    makePrivate(optionsOrCallback, callback) {\n        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};\n        callback =\n            typeof optionsOrCallback === 'function' ? optionsOrCallback : callback;\n        const query = {\n            predefinedAcl: options.strict ? 'private' : 'projectPrivate',\n        };\n        if (options.userProject) {\n            query.userProject = options.userProject;\n        }\n        this.setMetadata({\n            // You aren't allowed to set both predefinedAcl & acl properties on a\n            // file, so acl must explicitly be nullified, destroying all previous\n            // acls on the file.\n            acl: null,\n        }, query, callback);\n    }\n    /**\n     * @typedef {array} MakeFilePublicResponse\n     * @property {object} 0 The full API response.\n     */\n    /**\n     * @callback MakeFilePublicCallback\n     * @param {?Error} err Request error, if any.\n     * @param {object} apiResponse The full API response.\n     */\n    /**\n     * Set a file to be publicly readable and maintain all previous permissions.\n     *\n     * @see [ObjectAccessControls: insert API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objectAccessControls/insert}\n     *\n     * @param {MakeFilePublicCallback} [callback] Callback function.\n     * @returns {Promise<MakeFilePublicResponse>}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const myBucket = storage.bucket('my-bucket');\n     *\n     * const file = myBucket.file('my-file');\n     *\n     * file.makePublic(function(err, apiResponse) {});\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * file.makePublic().then(function(data) {\n     *   const apiResponse = data[0];\n     * });\n     *\n     * @example <caption>include:samples/files.js</caption>\n     * region_tag:storage_make_public\n     * Another example:\n     */\n    makePublic(callback) {\n        callback = callback || common_1.util.noop;\n        this.acl.add({\n            entity: 'allUsers',\n            role: 'READER',\n        }, (err, acl, resp) => {\n            callback(err, resp);\n        });\n    }\n    /**\n     * @typedef {array} MoveResponse\n     * @property {File} 0 The destination File.\n     * @property {object} 1 The full API response.\n     */\n    /**\n     * @callback MoveCallback\n     * @param {?Error} err Request error, if any.\n     * @param {?File} destinationFile The destination File.\n     * @param {object} apiResponse The full API response.\n     */\n    /**\n     * @typedef {object} MoveOptions Configuration options for File#move(). See an\n     *     [Object\n     * resource](https://cloud.google.com/storage/docs/json_api/v1/objects#resource).\n     * @param {string} [userProject] The ID of the project which will be\n     *     billed for the request.\n     */\n    /**\n     * Move this file to another location. By default, this will rename the file\n     * and keep it in the same bucket, but you can choose to move it to another\n     * Bucket by providing a Bucket or File object or a URL beginning with\n     * \"gs://\".\n     *\n     * **Warning**:\n     * There is currently no atomic `move` method in the Cloud Storage API,\n     * so this method is a composition of {@link File#copy} (to the new\n     * location) and {@link File#delete} (from the old location). While\n     * unlikely, it is possible that an error returned to your callback could be\n     * triggered from either one of these API calls failing, which could leave a\n     * duplicate file lingering. The error message will indicate what operation\n     * has failed.\n     *\n     * @see [Objects: copy API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objects/copy}\n     *\n     * @throws {Error} If the destination file is not provided.\n     *\n     * @param {string|Bucket|File} destination Destination file.\n     * @param {MoveCallback} [callback] Callback function.\n     * @returns {Promise<MoveResponse>}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * //-\n     * // You can pass in a variety of types for the destination.\n     * //\n     * // For all of the below examples, assume we are working with the following\n     * // Bucket and File objects.\n     * //-\n     * const bucket = storage.bucket('my-bucket');\n     * const file = bucket.file('my-image.png');\n     *\n     * //-\n     * // If you pass in a string for the destination, the file is moved to its\n     * // current bucket, under the new name provided.\n     * //-\n     * file.move('my-image-new.png', function(err, destinationFile, apiResponse) {\n     *   // `my-bucket` no longer contains:\n     *   // - \"my-image.png\"\n     *   // but contains instead:\n     *   // - \"my-image-new.png\"\n     *\n     *   // `destinationFile` is an instance of a File object that refers to your\n     *   // new file.\n     * });\n     *\n     * //-\n     * // If you pass in a string starting with \"gs://\" for the destination, the\n     * // file is copied to the other bucket and under the new name provided.\n     * //-\n     * const newLocation = 'gs://another-bucket/my-image-new.png';\n     * file.move(newLocation, function(err, destinationFile, apiResponse) {\n     *   // `my-bucket` no longer contains:\n     *   // - \"my-image.png\"\n     *   //\n     *   // `another-bucket` now contains:\n     *   // - \"my-image-new.png\"\n     *\n     *   // `destinationFile` is an instance of a File object that refers to your\n     *   // new file.\n     * });\n     *\n     * //-\n     * // If you pass in a Bucket object, the file will be moved to that bucket\n     * // using the same name.\n     * //-\n     * const anotherBucket = gcs.bucket('another-bucket');\n     *\n     * file.move(anotherBucket, function(err, destinationFile, apiResponse) {\n     *   // `my-bucket` no longer contains:\n     *   // - \"my-image.png\"\n     *   //\n     *   // `another-bucket` now contains:\n     *   // - \"my-image.png\"\n     *\n     *   // `destinationFile` is an instance of a File object that refers to your\n     *   // new file.\n     * });\n     *\n     * //-\n     * // If you pass in a File object, you have complete control over the new\n     * // bucket and filename.\n     * //-\n     * const anotherFile = anotherBucket.file('my-awesome-image.png');\n     *\n     * file.move(anotherFile, function(err, destinationFile, apiResponse) {\n     *   // `my-bucket` no longer contains:\n     *   // - \"my-image.png\"\n     *   //\n     *   // `another-bucket` now contains:\n     *   // - \"my-awesome-image.png\"\n     *\n     *   // Note:\n     *   // The `destinationFile` parameter is equal to `anotherFile`.\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * file.move('my-image-new.png').then(function(data) {\n     *   const destinationFile = data[0];\n     *   const apiResponse = data[1];\n     * });\n     *\n     * @example <caption>include:samples/files.js</caption>\n     * region_tag:storage_move_file\n     * Another example:\n     */\n    move(destination, optionsOrCallback, callback) {\n        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};\n        callback =\n            typeof optionsOrCallback === 'function' ? optionsOrCallback : callback;\n        callback = callback || common_1.util.noop;\n        this.copy(destination, options, (err, destinationFile, copyApiResponse) => {\n            if (err) {\n                err.message = 'file#copy failed with an error - ' + err.message;\n                callback(err, null, copyApiResponse);\n                return;\n            }\n            if (this.name !== destinationFile.name ||\n                this.bucket.name !== destinationFile.bucket.name) {\n                this.delete(options, (err, apiResponse) => {\n                    if (err) {\n                        err.message = 'file#delete failed with an error - ' + err.message;\n                        callback(err, destinationFile, apiResponse);\n                        return;\n                    }\n                    callback(null, destinationFile, copyApiResponse);\n                });\n            }\n            else {\n                callback(null, destinationFile, copyApiResponse);\n            }\n        });\n    }\n    /**\n     * Makes request and applies userProject query parameter if necessary.\n     *\n     * @private\n     *\n     * @param {object} reqOpts - The request options.\n     * @param {function} callback - The callback function.\n     */\n    request(reqOpts, callback) {\n        return this.parent.request.call(this, reqOpts, callback);\n    }\n    /**\n     * @callback RotateEncryptionKeyCallback\n     * @extends CopyCallback\n     */\n    /**\n     * @typedef RotateEncryptionKeyResponse\n     * @extends CopyResponse\n     */\n    /**\n     * @param {string|buffer|object} RotateEncryptionKeyOptions Configuration options\n     *     for File#rotateEncryptionKey().\n     * If a string or Buffer is provided, it is interpreted as an AES-256,\n     * customer-supplied encryption key. If you'd like to use a Cloud KMS key\n     * name, you must specify an options object with the property name:\n     * `kmsKeyName`.\n     * @param {string|buffer} [options.encryptionKey] An AES-256 encryption key.\n     * @param {string} [options.kmsKeyName] A Cloud KMS key name.\n     */\n    /**\n     * This method allows you to update the encryption key associated with this\n     * file.\n     *\n     * @see [Customer-supplied Encryption Keys]{@link https://cloud.google.com/storage/docs/encryption#customer-supplied}\n     *\n     * @param {RotateEncryptionKeyOptions} [options] - Configuration options.\n     * @param {RotateEncryptionKeyCallback} [callback]\n     * @returns {Promise<File>}\n     *\n     * @example <caption>include:samples/encryption.js</caption>\n     * region_tag:storage_rotate_encryption_key\n     * Example of rotating the encryption key for this file:\n     */\n    rotateEncryptionKey(optionsOrCallback, callback) {\n        callback =\n            typeof optionsOrCallback === 'function' ? optionsOrCallback : callback;\n        let options = {};\n        if (typeof optionsOrCallback === 'string' ||\n            optionsOrCallback instanceof Buffer) {\n            options = {\n                encryptionKey: optionsOrCallback,\n            };\n        }\n        else if (typeof optionsOrCallback === 'object') {\n            options = optionsOrCallback;\n        }\n        const newFile = this.bucket.file(this.id, options);\n        this.copy(newFile, callback);\n    }\n    /**\n     * @typedef {object} SaveOptions\n     * @extends CreateWriteStreamOptions\n     */\n    /**\n     * @callback SaveCallback\n     * @param {?Error} err Request error, if any.\n     */\n    /**\n     * Write arbitrary data to a file.\n     *\n     * *This is a convenience method which wraps {@link File#createWriteStream}.*\n     *\n     * Resumable uploads are automatically enabled and must be shut off explicitly\n     * by setting `options.resumable` to `false`.\n     *\n     * <p class=\"notice\">\n     *   There is some overhead when using a resumable upload that can cause\n     *   noticeable performance degradation while uploading a series of small\n     * files. When uploading files less than 10MB, it is recommended that the\n     * resumable feature is disabled.\n     * </p>\n     *\n     * @param {*} data The data to write to a file.\n     * @param {SaveOptions} [options] See {@link File#createWriteStream}'s `options`\n     *     parameter.\n     * @param {SaveCallback} [callback] Callback function.\n     * @returns {Promise}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const myBucket = storage.bucket('my-bucket');\n     *\n     * const file = myBucket.file('my-file');\n     * const contents = 'This is the contents of the file.';\n     *\n     * file.save(contents, function(err) {\n     *   if (!err) {\n     *     // File written successfully.\n     *   }\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * file.save(contents).then(function() {});\n     */\n    save(data, optionsOrCallback, callback) {\n        // tslint:enable:no-any\n        callback =\n            typeof optionsOrCallback === 'function' ? optionsOrCallback : callback;\n        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};\n        this.createWriteStream(options)\n            .on('error', callback)\n            .on('finish', callback)\n            .end(data);\n    }\n    /**\n     * @typedef {array} SetStorageClassResponse\n     * @property {object} 0 The full API response.\n     */\n    /**\n     * @typedef {object} SetStorageClassOptions Configuration options for File#setStorageClass().\n     * @property {string} [userProject] The ID of the project which will be\n     *     billed for the request.\n     */\n    /**\n     * @callback SetStorageClassCallback\n     * @param {?Error} err Request error, if any.\n     * @param {object} apiResponse The full API response.\n     */\n    /**\n     * Set the storage class for this file.\n     *\n     * @see [Per-Object Storage Class]{@link https://cloud.google.com/storage/docs/per-object-storage-class}\n     * @see [Storage Classes]{@link https://cloud.google.com/storage/docs/storage-classes}\n     *\n     * @param {string} storageClass The new storage class. (`standard`,\n     *     `nearline`, `coldline`, or `archive`)\n     *     **Note:** The storage classes `multi_regional` and `regional`\n     *     are now legacy and will be deprecated in the future.\n     * @param {SetStorageClassOptions} [options] Configuration options.\n     * @param {string} [options.userProject] The ID of the project which will be\n     *     billed for the request.\n     * @param {SetStorageClassCallback} [callback] Callback function.\n     * @returns {Promise<SetStorageClassResponse>}\n     *\n     * @example\n     * file.setStorageClass('nearline', function(err, apiResponse) {\n     *   if (err) {\n     *     // Error handling omitted.\n     *   }\n     *\n     *   // The storage class was updated successfully.\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * file.setStorageClass('nearline').then(function() {});\n     */\n    setStorageClass(storageClass, optionsOrCallback, callback) {\n        callback =\n            typeof optionsOrCallback === 'function' ? optionsOrCallback : callback;\n        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};\n        const req = extend(true, {}, options);\n        // In case we get input like `storageClass`, convert to `storage_class`.\n        req.storageClass = storageClass\n            .replace(/-/g, '_')\n            .replace(/([a-z])([A-Z])/g, (_, low, up) => {\n            return low + '_' + up;\n        })\n            .toUpperCase();\n        this.copy(this, req, (err, file, apiResponse) => {\n            if (err) {\n                callback(err, apiResponse);\n                return;\n            }\n            this.metadata = file.metadata;\n            callback(null, apiResponse);\n        });\n    }\n    /**\n     * Set a user project to be billed for all requests made from this File\n     * object.\n     *\n     * @param {string} userProject The user project.\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const bucket = storage.bucket('albums');\n     * const file = bucket.file('my-file');\n     *\n     * file.setUserProject('grape-spaceship-123');\n     */\n    setUserProject(userProject) {\n        this.bucket.setUserProject.call(this, userProject);\n    }\n    /**\n     * This creates a gcs-resumable-upload upload stream.\n     *\n     * @see [gcs-resumable-upload]{@link https://github.com/stephenplusplus/gcs-resumable-upload}\n     *\n     * @param {Duplexify} stream - Duplexify stream of data to pipe to the file.\n     * @param {object=} options - Configuration object.\n     *\n     * @private\n     */\n    startResumableUpload_(dup, options) {\n        options = Object.assign({\n            metadata: {},\n        }, options);\n        const uploadStream = resumableUpload.upload({\n            authClient: this.storage.authClient,\n            bucket: this.bucket.name,\n            configPath: options.configPath,\n            file: this.name,\n            generation: this.generation,\n            key: this.encryptionKey,\n            kmsKeyName: this.kmsKeyName,\n            metadata: options.metadata,\n            offset: options.offset,\n            predefinedAcl: options.predefinedAcl,\n            private: options.private,\n            public: options.public,\n            uri: options.uri,\n            userProject: options.userProject || this.userProject,\n        });\n        uploadStream\n            .on('response', resp => {\n            dup.emit('response', resp);\n        })\n            .on('metadata', metadata => {\n            this.metadata = metadata;\n        })\n            .on('finish', () => {\n            dup.emit('complete');\n        });\n        dup.setWritable(uploadStream);\n    }\n    /**\n     * Takes a readable stream and pipes it to a remote file. Unlike\n     * `startResumableUpload_`, which uses the resumable upload technique, this\n     * method uses a simple upload (all or nothing).\n     *\n     * @param {Duplexify} dup - Duplexify stream of data to pipe to the file.\n     * @param {object=} options - Configuration object.\n     *\n     * @private\n     */\n    startSimpleUpload_(dup, options) {\n        options = Object.assign({\n            metadata: {},\n        }, options);\n        const reqOpts = {\n            qs: {\n                name: this.name,\n            },\n            uri: `${STORAGE_UPLOAD_BASE_URL}/${this.bucket.name}/o`,\n        };\n        if (this.generation !== undefined) {\n            reqOpts.qs.ifGenerationMatch = this.generation;\n        }\n        if (this.kmsKeyName !== undefined) {\n            reqOpts.qs.kmsKeyName = this.kmsKeyName;\n        }\n        if (options.userProject || this.userProject) {\n            reqOpts.qs.userProject = options.userProject || this.userProject;\n        }\n        if (options.predefinedAcl) {\n            reqOpts.qs.predefinedAcl = options.predefinedAcl;\n        }\n        else if (options.private) {\n            reqOpts.qs.predefinedAcl = 'private';\n        }\n        else if (options.public) {\n            reqOpts.qs.predefinedAcl = 'publicRead';\n        }\n        common_1.util.makeWritableStream(dup, {\n            makeAuthenticatedRequest: (reqOpts) => {\n                this.request(reqOpts, (err, body, resp) => {\n                    if (err) {\n                        dup.destroy(err);\n                        return;\n                    }\n                    this.metadata = body;\n                    dup.emit('response', resp);\n                    dup.emit('complete');\n                });\n            },\n            metadata: options.metadata,\n            request: reqOpts,\n        });\n    }\n}\nexports.File = File;\n/*! Developer Documentation\n *\n * All async methods (except for streams) will return a Promise in the event\n * that a callback is omitted.\n */\npromisify_1.promisifyAll(File, {\n    exclude: ['request', 'setEncryptionKey'],\n});\nlet warned = false;\nfunction emitWarning() {\n    if (!warned) {\n        warned = true;\n        process.emitWarning('keepAcl parameter is not supported and will be removed in the next major', 'DeprecationWarning');\n    }\n}\nexports.emitWarning = emitWarning;\n//# sourceMappingURL=file.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/storage/build/src/file.js?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/storage/build/src/hmacKey.js":
/*!*********************************************************************!*\
  !*** ./src/node_modules/@google-cloud/storage/build/src/hmacKey.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst common_1 = __webpack_require__(/*! @google-cloud/common */ \"./src/node_modules/@google-cloud/common/build/src/index.js\");\n/**\n * An HmacKey object contains metadata of an HMAC key created from a\n * service account through the {@link Storage} client using\n * {@link Storage#createHmacKey}.\n *\n * @see [HMAC keys documentation]{@link https://cloud.google.com/storage/docs/authentication/hmackeys}\n *\n * @class\n */\nclass HmacKey extends common_1.ServiceObject {\n    /**\n     * @typedef {object} HmacKeyOptions\n     * @property {string} [projectId] The project ID of the project that owns\n     *     the service account of the requested HMAC key. If not provided,\n     *     the project ID used to instantiate the Storage client will be used.\n     */\n    /**\n     * Constructs an HmacKey object.\n     *\n     * Note: this only create a local reference to an HMAC key, to create\n     * an HMAC key, use {@link Storage#createHmacKey}.\n     *\n     * @param {Storage} storage The Storage instance this HMAC key is\n     *     attached to.\n     * @param {string} accessId The unique accessId for this HMAC key.\n     * @param {HmacKeyOptions} options Constructor configurations.\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const hmacKey = storage.hmacKey('access-id');\n     */\n    constructor(storage, accessId, options) {\n        const methods = {\n            /**\n             * @typedef {object} DeleteHmacKeyOptions\n             * @property {string} [userProject] This parameter is currently ignored.\n             */\n            /**\n             * @typedef {array} DeleteHmacKeyResponse\n             * @property {object} 0 The full API response.\n             */\n            /**\n             * @callback DeleteHmacKeyCallback\n             * @param {?Error} err Request error, if any.\n             * @param {object} apiResponse The full API response.\n             */\n            /**\n             * Deletes an HMAC key.\n             * Key state must be set to `INACTIVE` prior to deletion.\n             * Caution: HMAC keys cannot be recovered once you delete them.\n             *\n             * The authenticated user must have `storage.hmacKeys.delete` permission for the project in which the key exists.\n             *\n             * @method HmacKey#delete\n             * @param {DeleteHmacKeyOptions} [options] Configuration options.\n             * @param {DeleteHmacKeyCallback} [callback] Callback function.\n             * @returns {Promise<DeleteHmacKeyResponse>}\n             *\n             * @example\n             * const {Storage} = require('@google-cloud/storage');\n             * const storage = new Storage();\n             *\n             * //-\n             * // Delete HMAC key after making the key inactive.\n             * //-\n             * const hmacKey = storage.hmacKey('ACCESS_ID');\n             * hmacKey.setMetadata({state: 'INACTIVE'}, (err, hmacKeyMetadata) => {\n             *     if (err) {\n             *       // The request was an error.\n             *       console.error(err);\n             *       return;\n             *     }\n             *     hmacKey.delete((err) => {\n             *       if (err) {\n             *         console.error(err);\n             *         return;\n             *       }\n             *       // The HMAC key is deleted.\n             *     });\n             *   });\n             *\n             * //-\n             * // If the callback is omitted, a promise is returned.\n             * //-\n             * const hmacKey = storage.hmacKey('ACCESS_ID');\n             * hmacKey\n             *   .setMetadata({state: 'INACTIVE'})\n             *   .then(() => {\n             *     return hmacKey.delete();\n             *   });\n             */\n            delete: true,\n            /**\n             * @callback GetHmacKeyCallback\n             * @param {?Error} err Request error, if any.\n             * @param {HmacKey} hmacKey this {@link HmacKey} instance.\n             * @param {object} apiResponse The full API response.\n             */\n            /**\n             * @typedef {array} GetHmacKeyResponse\n             * @property {HmacKey} 0 This {@link HmacKey} instance.\n             * @property {object} 1 The full API response.\n             */\n            /**\n             * @typedef {object} GetHmacKeyOptions\n             * @property {string} [userProject] This parameter is currently ignored.\n             */\n            /**\n             * Retrieves and populate an HMAC key's metadata, and return\n             * this {@link HmacKey} instance.\n             *\n             * HmacKey.get() does not give the HMAC key secret, as\n             * it is only returned on creation.\n             *\n             * The authenticated user must have `storage.hmacKeys.get` permission\n             * for the project in which the key exists.\n             *\n             * @method HmacKey#get\n             * @param {GetHmacKeyOptions} [options] Configuration options.\n             * @param {GetHmacKeyCallback} [callback] Callback function.\n             * @returns {Promise<GetHmacKeyResponse>}\n             *\n             * @example\n             * const {Storage} = require('@google-cloud/storage');\n             * const storage = new Storage();\n             *\n             * //-\n             * // Get the HmacKey's Metadata.\n             * //-\n             * storage.hmacKey('ACCESS_ID')\n             *   .get((err, hmacKey) => {\n             *     if (err) {\n             *       // The request was an error.\n             *       console.error(err);\n             *       return;\n             *     }\n             *     // do something with the returned HmacKey object.\n             *   });\n             *\n             * //-\n             * // If the callback is omitted, a promise is returned.\n             * //-\n             * storage.hmacKey('ACCESS_ID')\n             *   .get()\n             *   .then((data) => {\n             *     const hmacKey = data[0];\n             *   });\n             */\n            get: true,\n            /**\n             * @typedef {object} GetHmacKeyMetadataOptions\n             * @property {string} [userProject] This parameter is currently ignored.\n             */\n            /**\n             * Retrieves and populate an HMAC key's metadata, and return\n             * the HMAC key's metadata as an object.\n             *\n             * HmacKey.getMetadata() does not give the HMAC key secret, as\n             * it is only returned on creation.\n             *\n             * The authenticated user must have `storage.hmacKeys.get` permission\n             * for the project in which the key exists.\n             *\n             * @method HmacKey#getMetadata\n             * @param {GetHmacKeyMetadataOptions} [options] Configuration options.\n             * @param {HmacKeyMetadataCallback} [callback] Callback function.\n             * @returns {Promise<HmacKeyMetadataResponse>}\n             *\n             * @example\n             * const {Storage} = require('@google-cloud/storage');\n             * const storage = new Storage();\n             *\n             * //-\n             * // Get the HmacKey's metadata and populate to the metadata property.\n             * //-\n             * storage.hmacKey('ACCESS_ID')\n             *   .getMetadata((err, hmacKeyMetadata) => {\n             *     if (err) {\n             *       // The request was an error.\n             *       console.error(err);\n             *       return;\n             *     }\n             *     console.log(hmacKeyMetadata);\n             *   });\n             *\n             * //-\n             * // If the callback is omitted, a promise is returned.\n             * //-\n             * storage.hmacKey('ACCESS_ID')\n             *   .getMetadata()\n             *   .then((data) => {\n             *     const hmacKeyMetadata = data[0];\n             *     console.log(hmacKeyMetadata);\n             *   });\n             */\n            getMetadata: true,\n            /**\n             * @typedef {object} SetHmacKeyMetadata Subset of {@link HmacKeyMetadata} to update.\n             * @property {string} state New state of the HmacKey. Either 'ACTIVE' or 'INACTIVE'.\n             * @property {string} [etag] Include an etag from a previous get HMAC key request\n             *    to perform safe read-modify-write.\n             */\n            /**\n             * @typedef {object} SetHmacKeyMetadataOptions\n             * @property {string} [userProject] This parameter is currently ignored.\n             */\n            /**\n             * @callback HmacKeyMetadataCallback\n             * @param {?Error} err Request error, if any.\n             * @param {HmacKeyMetadata} metadata The updated {@link HmacKeyMetadata} object.\n             * @param {object} apiResponse The full API response.\n             */\n            /**\n             * @typedef {array} HmacKeyMetadataResponse\n             * @property {HmacKeyMetadata} 0 The updated {@link HmacKeyMetadata} object.\n             * @property {object} 1 The full API response.\n             */\n            /**\n             * Updates the state of an HMAC key. See {@link SetHmacKeyMetadata} for\n             * valid states.\n             *\n             * @method HmacKey#setMetadata\n             * @param {SetHmacKeyMetadata} metadata The new metadata.\n             * @param {SetHmacKeyMetadataOptions} [options] Configuration options.\n             * @param {HmacKeyMetadataCallback} [callback] Callback function.\n             * @returns {Promise<HmacKeyMetadataResponse>}\n             *\n             * @example\n             * const {Storage} = require('@google-cloud/storage');\n             * const storage = new Storage();\n             *\n             * const metadata = {\n             *   state: 'INACTIVE',\n             * };\n             *\n             * storage.hmacKey('ACCESS_ID')\n             *   .setMetadata(metadata, (err, hmacKeyMetadata) => {\n             *     if (err) {\n             *       // The request was an error.\n             *       console.error(err);\n             *       return;\n             *     }\n             *     console.log(hmacKeyMetadata);\n             *   });\n             *\n             * //-\n             * // If the callback is omitted, a promise is returned.\n             * //-\n             * storage.hmacKey('ACCESS_ID')\n             *   .setMetadata(metadata)\n             *   .then((data) => {\n             *     const hmacKeyMetadata = data[0];\n             *     console.log(hmacKeyMetadata);\n             *   });\n             */\n            setMetadata: {\n                reqOpts: {\n                    method: 'PUT',\n                },\n            },\n        };\n        const projectId = (options && options.projectId) || storage.projectId;\n        super({\n            parent: storage,\n            id: accessId,\n            baseUrl: `/projects/${projectId}/hmacKeys`,\n            methods,\n        });\n    }\n}\nexports.HmacKey = HmacKey;\n//# sourceMappingURL=hmacKey.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/storage/build/src/hmacKey.js?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/storage/build/src/iam.js":
/*!*****************************************************************!*\
  !*** ./src/node_modules/@google-cloud/storage/build/src/iam.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst promisify_1 = __webpack_require__(/*! @google-cloud/promisify */ \"@google-cloud/promisify\");\nconst arrify = __webpack_require__(/*! arrify */ \"arrify\");\nconst util_1 = __webpack_require__(/*! ./util */ \"./src/node_modules/@google-cloud/storage/build/src/util.js\");\n/**\n * Get and set IAM policies for your Cloud Storage bucket.\n *\n * @see [Cloud Storage IAM Management](https://cloud.google.com/storage/docs/access-control/iam#short_title_iam_management)\n * @see [Granting, Changing, and Revoking Access](https://cloud.google.com/iam/docs/granting-changing-revoking-access)\n * @see [IAM Roles](https://cloud.google.com/iam/docs/understanding-roles)\n *\n * @constructor Iam\n * @mixin\n *\n * @param {Bucket} bucket The parent instance.\n * @example\n * const {Storage} = require('@google-cloud/storage');\n * const storage = new Storage();\n * const bucket = storage.bucket('my-bucket');\n * // bucket.iam\n */\nclass Iam {\n    constructor(bucket) {\n        this.request_ = bucket.request.bind(bucket);\n        this.resourceId_ = 'buckets/' + bucket.getId();\n    }\n    /**\n     * @typedef {object} GetPolicyOptions Requested options for IAM#getPolicy().\n     * @property {number} [requestedPolicyVersion] The version of IAM policies to\n     *     request. If a policy with a condition is requested without setting\n     *     this, the server will return an error. This must be set to a value\n     *     of 3 to retrieve IAM policies containing conditions. This is to\n     *     prevent client code that isn't aware of IAM conditions from\n     *     interpreting and modifying policies incorrectly. The service might\n     *     return a policy with version lower than the one that was requested,\n     *     based on the feature syntax in the policy fetched.\n     *     @see [IAM Policy versions]{@link https://cloud.google.com/iam/docs/policies#versions}\n     * @property {string} [userProject] The ID of the project which will be\n     *     billed for the request.\n     */\n    /**\n     * @typedef {array} GetPolicyResponse\n     * @property {Policy} 0 The policy.\n     * @property {object} 1 The full API response.\n     */\n    /**\n     * @typedef {object} Policy\n     * @property {PolicyBinding[]} policy.bindings Bindings associate members with roles.\n     * @property {string} [policy.etag] Etags are used to perform a read-modify-write.\n     * @property {number} [policy.version] The syntax schema version of the Policy.\n     *      To set an IAM policy with conditional binding, this field must be set to\n     *      3 or greater.\n     *     @see [IAM Policy versions]{@link https://cloud.google.com/iam/docs/policies#versions}\n     */\n    /**\n     * @typedef {object} PolicyBinding\n     * @property {string} role Role that is assigned to members.\n     * @property {string[]} members Specifies the identities requesting access for the bucket.\n     * @property {Expr} [condition] The condition that is associated with this binding.\n     */\n    /**\n     * @typedef {object} Expr\n     * @property {string} [title] An optional title for the expression, i.e. a\n     *     short string describing its purpose. This can be used e.g. in UIs\n     *     which allow to enter the expression.\n     * @property {string} [description] An optional description of the\n     *     expression. This is a longer text which describes the expression,\n     *     e.g. when hovered over it in a UI.\n     * @property {string} expression Textual representation of an expression in\n     *     Common Expression Language syntax. The application context of the\n     *     containing message determines which well-known feature set of CEL\n     *     is supported.The condition that is associated with this binding.\n     *\n     * @see [Condition] https://cloud.google.com/storage/docs/access-control/iam#conditions\n     */\n    /**\n     * Get the IAM policy.\n     *\n     * @param {GetPolicyOptions} [options] Request options.\n     * @param {GetPolicyCallback} [callback] Callback function.\n     * @returns {Promise<GetPolicyResponse>}\n     *\n     * @see [Buckets: setIamPolicy API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/buckets/getIamPolicy}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const bucket = storage.bucket('my-bucket');\n     *\n     * bucket.iam.getPolicy(\n     *     {requestedPolicyVersion: 3},\n     *     function(err, policy, apiResponse) {\n     *\n     *     },\n     * );\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * bucket.iam.getPolicy({requestedPolicyVersion: 3})\n     *   .then(function(data) {\n     *     const policy = data[0];\n     *     const apiResponse = data[1];\n     *   });\n     *\n     * @example <caption>include:samples/iam.js</caption>\n     * region_tag:storage_view_bucket_iam_members\n     * Example of retrieving a bucket's IAM policy:\n     */\n    getPolicy(optionsOrCallback, callback) {\n        const { options, callback: cb } = util_1.normalize(optionsOrCallback, callback);\n        const qs = {};\n        if (options.userProject) {\n            qs.userProject = options.userProject;\n        }\n        if (options.requestedPolicyVersion != null) {\n            qs.optionsRequestedPolicyVersion = options.requestedPolicyVersion;\n        }\n        this.request_({\n            uri: '/iam',\n            qs,\n        }, cb);\n    }\n    /**\n     * Set the IAM policy.\n     *\n     * @throws {Error} If no policy is provided.\n     *\n     * @param {Policy} policy The policy.\n     * @param {SetPolicyOptions} [options] Configuration opbject.\n     * @param {SetPolicyCallback} callback Callback function.\n     * @returns {Promise<SetPolicyResponse>}\n     *\n     * @see [Buckets: setIamPolicy API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/buckets/setIamPolicy}\n     * @see [IAM Roles](https://cloud.google.com/iam/docs/understanding-roles)\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const bucket = storage.bucket('my-bucket');\n     *\n     * const myPolicy = {\n     *   bindings: [\n     *     {\n     *       role: 'roles/storage.admin',\n     *       members:\n     * ['serviceAccount:myotherproject@appspot.gserviceaccount.com']\n     *     }\n     *   ]\n     * };\n     *\n     * bucket.iam.setPolicy(myPolicy, function(err, policy, apiResponse) {});\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * bucket.iam.setPolicy(myPolicy).then(function(data) {\n     *   const policy = data[0];\n     *   const apiResponse = data[1];\n     * });\n     *\n     * @example <caption>include:samples/iam.js</caption>\n     * region_tag:storage_add_bucket_iam_member\n     * Example of adding to a bucket's IAM policy:\n     *\n     * @example <caption>include:samples/iam.js</caption>\n     * region_tag:storage_remove_bucket_iam_member\n     * Example of removing from a bucket's IAM policy:\n     */\n    setPolicy(policy, optionsOrCallback, callback) {\n        if (policy === null || typeof policy !== 'object') {\n            throw new Error('A policy object is required.');\n        }\n        const { options, callback: cb } = util_1.normalize(optionsOrCallback, callback);\n        this.request_({\n            method: 'PUT',\n            uri: '/iam',\n            json: Object.assign({\n                resourceId: this.resourceId_,\n            }, policy),\n            qs: options,\n        }, cb);\n    }\n    /**\n     * Test a set of permissions for a resource.\n     *\n     * @throws {Error} If permissions are not provided.\n     *\n     * @param {string|string[]} permissions The permission(s) to test for.\n     * @param {TestIamPermissionsOptions} [options] Configuration object.\n     * @param {TestIamPermissionsCallback} [callback] Callback function.\n     * @returns {Promise<TestIamPermissionsResponse>}\n     *\n     * @see [Buckets: testIamPermissions API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/buckets/testIamPermissions}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const bucket = storage.bucket('my-bucket');\n     *\n     * //-\n     * // Test a single permission.\n     * //-\n     * const test = 'storage.buckets.delete';\n     *\n     * bucket.iam.testPermissions(test, function(err, permissions, apiResponse) {\n     *   console.log(permissions);\n     *   // {\n     *   //   \"storage.buckets.delete\": true\n     *   // }\n     * });\n     *\n     * //-\n     * // Test several permissions at once.\n     * //-\n     * const tests = [\n     *   'storage.buckets.delete',\n     *   'storage.buckets.get'\n     * ];\n     *\n     * bucket.iam.testPermissions(tests, function(err, permissions) {\n     *   console.log(permissions);\n     *   // {\n     *   //   \"storage.buckets.delete\": false,\n     *   //   \"storage.buckets.get\": true\n     *   // }\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * bucket.iam.testPermissions(test).then(function(data) {\n     *   const permissions = data[0];\n     *   const apiResponse = data[1];\n     * });\n     */\n    testPermissions(permissions, optionsOrCallback, callback) {\n        if (!Array.isArray(permissions) && typeof permissions !== 'string') {\n            throw new Error('Permissions are required.');\n        }\n        const { options, callback: cb } = util_1.normalize(optionsOrCallback, callback);\n        const permissionsArray = arrify(permissions);\n        const req = Object.assign({\n            permissions: permissionsArray,\n        }, options);\n        this.request_({\n            uri: '/iam/testPermissions',\n            qs: req,\n            useQuerystring: true,\n        }, (err, resp) => {\n            if (err) {\n                cb(err, null, resp);\n                return;\n            }\n            const availablePermissions = arrify(resp.permissions);\n            const permissionsHash = permissionsArray.reduce((acc, permission) => {\n                acc[permission] = availablePermissions.indexOf(permission) > -1;\n                return acc;\n            }, {});\n            cb(null, permissionsHash, resp);\n        });\n    }\n}\nexports.Iam = Iam;\n/*! Developer Documentation\n *\n * All async methods (except for streams) will return a Promise in the event\n * that a callback is omitted.\n */\npromisify_1.promisifyAll(Iam);\n//# sourceMappingURL=iam.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/storage/build/src/iam.js?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/storage/build/src/index.js":
/*!*******************************************************************!*\
  !*** ./src/node_modules/@google-cloud/storage/build/src/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar bucket_1 = __webpack_require__(/*! ./bucket */ \"./src/node_modules/@google-cloud/storage/build/src/bucket.js\");\nexports.Bucket = bucket_1.Bucket;\nvar channel_1 = __webpack_require__(/*! ./channel */ \"./src/node_modules/@google-cloud/storage/build/src/channel.js\");\nexports.Channel = channel_1.Channel;\nvar file_1 = __webpack_require__(/*! ./file */ \"./src/node_modules/@google-cloud/storage/build/src/file.js\");\nexports.File = file_1.File;\nvar hmacKey_1 = __webpack_require__(/*! ./hmacKey */ \"./src/node_modules/@google-cloud/storage/build/src/hmacKey.js\");\nexports.HmacKey = hmacKey_1.HmacKey;\nvar iam_1 = __webpack_require__(/*! ./iam */ \"./src/node_modules/@google-cloud/storage/build/src/iam.js\");\nexports.Iam = iam_1.Iam;\nvar notification_1 = __webpack_require__(/*! ./notification */ \"./src/node_modules/@google-cloud/storage/build/src/notification.js\");\nexports.Notification = notification_1.Notification;\nvar storage_1 = __webpack_require__(/*! ./storage */ \"./src/node_modules/@google-cloud/storage/build/src/storage.js\");\nexports.Storage = storage_1.Storage;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/storage/build/src/index.js?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/storage/build/src/notification.js":
/*!**************************************************************************!*\
  !*** ./src/node_modules/@google-cloud/storage/build/src/notification.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst common_1 = __webpack_require__(/*! @google-cloud/common */ \"./src/node_modules/@google-cloud/common/build/src/index.js\");\nconst promisify_1 = __webpack_require__(/*! @google-cloud/promisify */ \"@google-cloud/promisify\");\n/**\n * A Notification object is created from your {@link Bucket} object using\n * {@link Bucket#notification}. Use it to interact with Cloud Pub/Sub\n * notifications.\n *\n * @see [Cloud Pub/Sub Notifications for Google Cloud Storage]{@link https://cloud.google.com/storage/docs/pubsub-notifications}\n *\n * @class\n * @hideconstructor\n *\n * @param {Bucket} bucket The bucket instance this notification is attached to.\n * @param {string} id The ID of the notification.\n *\n * @example\n * const {Storage} = require('@google-cloud/storage');\n * const storage = new Storage();\n * const myBucket = storage.bucket('my-bucket');\n *\n * const notification = myBucket.notification('1');\n */\nclass Notification extends common_1.ServiceObject {\n    constructor(bucket, id) {\n        const methods = {\n            /**\n             * Creates a notification subscription for the bucket.\n             *\n             * @see [Notifications: insert]{@link https://cloud.google.com/storage/docs/json_api/v1/notifications/insert}\n             * @method Notification#exists\n             *\n             * @param {Topic|string} topic The Cloud PubSub topic to which this\n             *     subscription publishes. If the project ID is omitted, the current\n             *     project ID will be used.\n             *\n             *     Acceptable formats are:\n             *     - `projects/grape-spaceship-123/topics/my-topic`\n             *\n             *     - `my-topic`\n             * @param {CreateNotificationRequest} [options] Metadata to set for\n             *     the notification.\n             * @param {CreateNotificationCallback} [callback] Callback function.\n             * @returns {Promise<CreateNotificationResponse>}\n             * @throws {Error} If a valid topic is not provided.\n             *\n             * @example\n             * const {Storage} = require('@google-cloud/storage');\n             * const storage = new Storage();\n             * const myBucket = storage.bucket('my-bucket');\n             * const notification = myBucket.notification('1');\n             *\n             * notification.create(function(err, notification, apiResponse) {\n             *   if (!err) {\n             *     // The notification was created successfully.\n             *   }\n             * });\n             *\n             * //-\n             * // If the callback is omitted, we'll return a Promise.\n             * //-\n             * notification.create().then(function(data) {\n             *   const notification = data[0];\n             *   const apiResponse = data[1];\n             * });\n             */\n            create: true,\n            /**\n             * @typedef {array} NotificationExistsResponse\n             * @property {boolean} 0 Whether the notification exists or not.\n             */\n            /**\n             * @callback NotificationExistsCallback\n             * @param {?Error} err Request error, if any.\n             * @param {boolean} exists Whether the notification exists or not.\n             */\n            /**\n             * Check if the notification exists.\n             *\n             * @method Notification#exists\n             * @param {NotificationExistsCallback} [callback] Callback function.\n             * @returns {Promise<NotificationExistsResponse>}\n             *\n             * @example\n             * const {Storage} = require('@google-cloud/storage');\n             * const storage = new Storage();\n             * const myBucket = storage.bucket('my-bucket');\n             * const notification = myBucket.notification('1');\n             *\n             * notification.exists(function(err, exists) {});\n             *\n             * //-\n             * // If the callback is omitted, we'll return a Promise.\n             * //-\n             * notification.exists().then(function(data) {\n             *   const exists = data[0];\n             * });\n             */\n            exists: true,\n        };\n        super({\n            parent: bucket,\n            baseUrl: '/notificationConfigs',\n            id: id.toString(),\n            createMethod: bucket.createNotification.bind(bucket),\n            methods,\n        });\n    }\n    /**\n     * @typedef {array} DeleteNotificationResponse\n     * @property {object} 0 The full API response.\n     */\n    /**\n     * Permanently deletes a notification subscription.\n     *\n     * @see [Notifications: delete API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/notifications/delete}\n     *\n     * @param {object} [options] Configuration options.\n     * @param {string} [options.userProject] The ID of the project which will be\n     *     billed for the request.\n     * @param {DeleteNotificationCallback} [callback] Callback function.\n     * @returns {Promise<DeleteNotificationResponse>}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const myBucket = storage.bucket('my-bucket');\n     * const notification = myBucket.notification('1');\n     *\n     * notification.delete(function(err, apiResponse) {});\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * notification.delete().then(function(data) {\n     *   const apiResponse = data[0];\n     * });\n     *\n     * @example <caption>include:samples/notifications.js</caption>\n     * region_tag:storage_delete_notification\n     * Another example:\n     */\n    delete(optionsOrCallback, callback) {\n        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};\n        callback =\n            typeof optionsOrCallback === 'function' ? optionsOrCallback : callback;\n        this.request({\n            method: 'DELETE',\n            uri: '',\n            qs: options,\n        }, callback || common_1.util.noop);\n    }\n    /**\n     * Get a notification and its metadata if it exists.\n     *\n     * @see [Notifications: get API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/notifications/get}\n     *\n     * @param {object} [options] Configuration options.\n     *     See {@link Bucket#createNotification} for create options.\n     * @param {boolean} [options.autoCreate] Automatically create the object if\n     *     it does not exist. Default: `false`.\n     * @param {string} [options.userProject] The ID of the project which will be\n     *     billed for the request.\n     * @param {GetNotificationCallback} [callback] Callback function.\n     * @return {Promise<GetNotificationCallback>}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const myBucket = storage.bucket('my-bucket');\n     * const notification = myBucket.notification('1');\n     *\n     * notification.get(function(err, notification, apiResponse) {\n     *   // `notification.metadata` has been populated.\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * notification.get().then(function(data) {\n     *   const notification = data[0];\n     *   const apiResponse = data[1];\n     * });\n     */\n    get(optionsOrCallback, callback) {\n        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};\n        callback =\n            typeof optionsOrCallback === 'function' ? optionsOrCallback : callback;\n        const autoCreate = options.autoCreate;\n        delete options.autoCreate;\n        const onCreate = (err, notification, apiResponse) => {\n            if (err) {\n                if (err.code === 409) {\n                    this.get(options, callback);\n                    return;\n                }\n                callback(err, null, apiResponse);\n                return;\n            }\n            callback(null, notification, apiResponse);\n        };\n        this.getMetadata(options, (err, metadata) => {\n            if (err) {\n                if (err.code === 404 && autoCreate) {\n                    const args = [];\n                    if (Object.keys(options).length > 0) {\n                        args.push(options);\n                    }\n                    args.push(onCreate);\n                    // tslint:disable-next-line no-any\n                    this.create.apply(this, args);\n                    return;\n                }\n                callback(err, null, metadata);\n                return;\n            }\n            callback(null, this, metadata);\n        });\n    }\n    /**\n     * Get the notification's metadata.\n     *\n     * @see [Notifications: get API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/notifications/get}\n     *\n     * @param {object} [options] Configuration options.\n     * @param {string} [options.userProject] The ID of the project which will be\n     *     billed for the request.\n     * @param {GetNotificationMetadataCallback} [callback] Callback function.\n     * @returns {Promise<GetNotificationMetadataResponse>}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const myBucket = storage.bucket('my-bucket');\n     * const notification = myBucket.notification('1');\n     *\n     * notification.getMetadata(function(err, metadata, apiResponse) {});\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * notification.getMetadata().then(function(data) {\n     *   const metadata = data[0];\n     *   const apiResponse = data[1];\n     * });\n     *\n     * @example <caption>include:samples/notifications.js</caption>\n     * region_tag:storage_notifications_get_metadata\n     * Another example:\n     */\n    getMetadata(optionsOrCallback, callback) {\n        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};\n        callback =\n            typeof optionsOrCallback === 'function' ? optionsOrCallback : callback;\n        this.request({\n            uri: '',\n            qs: options,\n        }, (err, resp) => {\n            if (err) {\n                callback(err, null, resp);\n                return;\n            }\n            this.metadata = resp;\n            callback(null, this.metadata, resp);\n        });\n    }\n}\nexports.Notification = Notification;\n/*! Developer Documentation\n *\n * All async methods (except for streams) will return a Promise in the event\n * that a callback is omitted.\n */\npromisify_1.promisifyAll(Notification);\n//# sourceMappingURL=notification.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/storage/build/src/notification.js?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/storage/build/src/signer.js":
/*!********************************************************************!*\
  !*** ./src/node_modules/@google-cloud/storage/build/src/signer.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// Copyright 2020 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst dateFormat = __webpack_require__(/*! date-and-time */ \"./src/node_modules/date-and-time/date-and-time.js\");\nconst url = __webpack_require__(/*! url */ \"url\");\nconst util_1 = __webpack_require__(/*! ./util */ \"./src/node_modules/@google-cloud/storage/build/src/util.js\");\n/*\n * Default signing version for getSignedUrl is 'v2'.\n */\nconst DEFAULT_SIGNING_VERSION = 'v2';\nconst SEVEN_DAYS = 604800;\n/**\n * @const {string}\n * @private\n */\nexports.PATH_STYLED_HOST = 'https://storage.googleapis.com';\nclass URLSigner {\n    constructor(authClient, bucket, file) {\n        this.bucket = bucket;\n        this.file = file;\n        this.authClient = authClient;\n    }\n    getSignedUrl(cfg) {\n        const expiresInSeconds = this.parseExpires(cfg.expires);\n        const method = cfg.method;\n        let customHost;\n        // Default style is `path`.\n        const isVirtualHostedStyle = cfg.virtualHostedStyle || false;\n        if (cfg.cname) {\n            customHost = cfg.cname;\n        }\n        else if (isVirtualHostedStyle) {\n            customHost = `https://${this.bucket.name}.storage.googleapis.com`;\n        }\n        const config = Object.assign({}, cfg, {\n            method,\n            expiration: expiresInSeconds,\n            bucket: this.bucket.name,\n            file: this.file ? util_1.encodeURI(this.file.name, false) : undefined,\n        });\n        if (customHost) {\n            config.cname = customHost;\n        }\n        const version = cfg.version || DEFAULT_SIGNING_VERSION;\n        let promise;\n        if (version === 'v2') {\n            promise = this.getSignedUrlV2(config);\n        }\n        else if (version === 'v4') {\n            promise = this.getSignedUrlV4(config);\n        }\n        else {\n            throw new Error(`Invalid signed URL version: ${version}. Supported versions are 'v2' and 'v4'.`);\n        }\n        return promise.then(query => {\n            query = Object.assign(query, cfg.queryParams);\n            const signedUrl = new url.URL(config.cname || exports.PATH_STYLED_HOST);\n            signedUrl.pathname = this.getResourcePath(!!config.cname, this.bucket.name, config.file);\n            // tslint:disable-next-line:no-any\n            signedUrl.search = util_1.qsStringify(query);\n            return signedUrl.href;\n        });\n    }\n    getSignedUrlV2(config) {\n        const canonicalHeadersString = this.getCanonicalHeaders(config.extensionHeaders || {});\n        const resourcePath = this.getResourcePath(false, config.bucket, config.file);\n        const blobToSign = [\n            config.method,\n            config.contentMd5 || '',\n            config.contentType || '',\n            config.expiration,\n            canonicalHeadersString + resourcePath,\n        ].join('\\n');\n        const sign = async () => {\n            const authClient = this.authClient;\n            try {\n                const signature = await authClient.sign(blobToSign);\n                const credentials = await authClient.getCredentials();\n                return {\n                    GoogleAccessId: credentials.client_email,\n                    Expires: config.expiration,\n                    Signature: signature,\n                };\n            }\n            catch (err) {\n                const signingErr = new SigningError(err.message);\n                signingErr.stack = err.stack;\n                throw signingErr;\n            }\n        };\n        return sign();\n    }\n    getSignedUrlV4(config) {\n        const now = new Date();\n        const nowInSeconds = Math.floor(now.valueOf() / 1000);\n        const expiresPeriodInSeconds = config.expiration - nowInSeconds;\n        // v4 limit expiration to be 7 days maximum\n        if (expiresPeriodInSeconds > SEVEN_DAYS) {\n            throw new Error(`Max allowed expiration is seven days (${SEVEN_DAYS} seconds).`);\n        }\n        const extensionHeaders = Object.assign({}, config.extensionHeaders);\n        const fqdn = new url.URL(config.cname || exports.PATH_STYLED_HOST);\n        extensionHeaders.host = fqdn.host;\n        if (config.contentMd5) {\n            extensionHeaders['content-md5'] = config.contentMd5;\n        }\n        if (config.contentType) {\n            extensionHeaders['content-type'] = config.contentType;\n        }\n        let contentSha256;\n        const sha256Header = extensionHeaders['x-goog-content-sha256'];\n        if (sha256Header) {\n            if (typeof sha256Header !== 'string' ||\n                !/[A-Fa-f0-9]{40}/.test(sha256Header)) {\n                throw new Error('The header X-Goog-Content-SHA256 must be a hexadecimal string.');\n            }\n            contentSha256 = sha256Header;\n        }\n        const signedHeaders = Object.keys(extensionHeaders)\n            .map(header => header.toLowerCase())\n            .sort()\n            .join(';');\n        const extensionHeadersString = this.getCanonicalHeaders(extensionHeaders);\n        const datestamp = dateFormat.format(now, 'YYYYMMDD', true);\n        const credentialScope = `${datestamp}/auto/storage/goog4_request`;\n        const sign = async () => {\n            const credentials = await this.authClient.getCredentials();\n            const credential = `${credentials.client_email}/${credentialScope}`;\n            const dateISO = dateFormat.format(now, 'YYYYMMDD[T]HHmmss[Z]', true);\n            const queryParams = Object.assign({ 'X-Goog-Algorithm': 'GOOG4-RSA-SHA256', 'X-Goog-Credential': credential, 'X-Goog-Date': dateISO, 'X-Goog-Expires': expiresPeriodInSeconds.toString(10), 'X-Goog-SignedHeaders': signedHeaders }, (config.queryParams || {}));\n            // tslint:disable-next-line:no-any\n            const canonicalQueryParams = this.getCanonicalQueryParams(queryParams);\n            const canonicalRequest = this.getCanonicalRequest(config.method, this.getResourcePath(!!config.cname, config.bucket, config.file), canonicalQueryParams, extensionHeadersString, signedHeaders, contentSha256);\n            const hash = crypto\n                .createHash('sha256')\n                .update(canonicalRequest)\n                .digest('hex');\n            const blobToSign = [\n                'GOOG4-RSA-SHA256',\n                dateISO,\n                credentialScope,\n                hash,\n            ].join('\\n');\n            try {\n                const signature = await this.authClient.sign(blobToSign);\n                const signatureHex = Buffer.from(signature, 'base64').toString('hex');\n                const signedQuery = Object.assign({}, queryParams, {\n                    'X-Goog-Signature': signatureHex,\n                });\n                return signedQuery;\n            }\n            catch (err) {\n                const signingErr = new SigningError(err.message);\n                signingErr.stack = err.stack;\n                throw signingErr;\n            }\n        };\n        return sign();\n    }\n    /**\n     * Create canonical headers for signing v4 url.\n     *\n     * The canonical headers for v4-signing a request demands header names are\n     * first lowercased, followed by sorting the header names.\n     * Then, construct the canonical headers part of the request:\n     *  <lowercasedHeaderName> + \":\" + Trim(<value>) + \"\\n\"\n     *  ..\n     *  <lowercasedHeaderName> + \":\" + Trim(<value>) + \"\\n\"\n     *\n     * @param headers\n     * @private\n     */\n    getCanonicalHeaders(headers) {\n        // Sort headers by their lowercased names\n        const sortedHeaders = util_1.objectEntries(headers)\n            // Convert header names to lowercase\n            .map(([headerName, value]) => [\n            headerName.toLowerCase(),\n            value,\n        ])\n            .sort((a, b) => a[0].localeCompare(b[0]));\n        return sortedHeaders\n            .filter(([_, value]) => value !== undefined)\n            .map(([headerName, value]) => {\n            // - Convert Array (multi-valued header) into string, delimited by\n            //      ',' (no space).\n            // - Trim leading and trailing spaces.\n            // - Convert sequential (2+) spaces into a single space\n            const canonicalValue = `${value}`.trim().replace(/\\s{2,}/g, ' ');\n            return `${headerName}:${canonicalValue}\\n`;\n        })\n            .join('');\n    }\n    getCanonicalRequest(method, path, query, headers, signedHeaders, contentSha256) {\n        return [\n            method,\n            path,\n            query,\n            headers,\n            signedHeaders,\n            contentSha256 || 'UNSIGNED-PAYLOAD',\n        ].join('\\n');\n    }\n    getCanonicalQueryParams(query) {\n        return util_1.objectEntries(query)\n            .map(([key, value]) => [util_1.encodeURI(key, true), util_1.encodeURI(value, true)])\n            .sort((a, b) => (a[0] < b[0] ? -1 : 1))\n            .map(([key, value]) => `${key}=${value}`)\n            .join('&');\n    }\n    getResourcePath(cname, bucket, file) {\n        if (cname) {\n            return '/' + (file || '');\n        }\n        else if (file) {\n            return `/${bucket}/${file}`;\n        }\n        else {\n            return `/${bucket}`;\n        }\n    }\n    parseExpires(expires, current = new Date()) {\n        const expiresInMSeconds = new Date(expires).valueOf();\n        if (isNaN(expiresInMSeconds)) {\n            throw new Error('The expiration date provided was invalid.');\n        }\n        if (expiresInMSeconds < current.valueOf()) {\n            throw new Error('An expiration date cannot be in the past.');\n        }\n        return Math.round(expiresInMSeconds / 1000); // The API expects seconds.\n    }\n}\nexports.URLSigner = URLSigner;\n/**\n * Custom error type for errors related to getting signed errors and policies.\n *\n * @private\n */\nclass SigningError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'SigningError';\n    }\n}\nexports.SigningError = SigningError;\n//# sourceMappingURL=signer.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/storage/build/src/signer.js?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/storage/build/src/storage.js":
/*!*********************************************************************!*\
  !*** ./src/node_modules/@google-cloud/storage/build/src/storage.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst common_1 = __webpack_require__(/*! @google-cloud/common */ \"./src/node_modules/@google-cloud/common/build/src/index.js\");\nconst paginator_1 = __webpack_require__(/*! @google-cloud/paginator */ \"@google-cloud/paginator\");\nconst promisify_1 = __webpack_require__(/*! @google-cloud/promisify */ \"@google-cloud/promisify\");\nconst arrify = __webpack_require__(/*! arrify */ \"arrify\");\nconst bucket_1 = __webpack_require__(/*! ./bucket */ \"./src/node_modules/@google-cloud/storage/build/src/bucket.js\");\nconst channel_1 = __webpack_require__(/*! ./channel */ \"./src/node_modules/@google-cloud/storage/build/src/channel.js\");\nconst file_1 = __webpack_require__(/*! ./file */ \"./src/node_modules/@google-cloud/storage/build/src/file.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"./src/node_modules/@google-cloud/storage/build/src/util.js\");\nconst hmacKey_1 = __webpack_require__(/*! ./hmacKey */ \"./src/node_modules/@google-cloud/storage/build/src/hmacKey.js\");\n/*! Developer Documentation\n *\n * Invoke this method to create a new Storage object bound with pre-determined\n * configuration options. For each object that can be created (e.g., a bucket),\n * there is an equivalent static and instance method. While they are classes,\n * they can be instantiated without use of the `new` keyword.\n */\n/**\n * <h4>ACLs</h4>\n * Cloud Storage uses access control lists (ACLs) to manage object and\n * bucket access. ACLs are the mechanism you use to share files with other users\n * and allow other users to access your buckets and files.\n *\n * To learn more about ACLs, read this overview on\n * [Access Control](https://cloud.google.com/storage/docs/access-control).\n *\n * @see [Cloud Storage overview]{@link https://cloud.google.com/storage/docs/overview}\n * @see [Access Control]{@link https://cloud.google.com/storage/docs/access-control}\n *\n * @class\n */\nclass Storage extends common_1.Service {\n    /**\n     * @typedef {object} StorageOptions\n     * @property {string} [projectId] The project ID from the Google Developer's\n     *     Console, e.g. 'grape-spaceship-123'. We will also check the environment\n     *     variable `GCLOUD_PROJECT` for your project ID. If your app is running\n     * in an environment which supports {@link\n     * https://cloud.google.com/docs/authentication/production#providing_credentials_to_your_application\n     * Application Default Credentials}, your project ID will be detected\n     * automatically.\n     * @property {string} [keyFilename] Full path to the a .json, .pem, or .p12 key\n     *     downloaded from the Google Developers Console. If you provide a path to\n     * a JSON file, the `projectId` option above is not necessary. NOTE: .pem and\n     *     .p12 require you to specify the `email` option as well.\n     * @property {string} [email] Account email address. Required when using a .pem\n     *     or .p12 keyFilename.\n     * @property {object} [credentials] Credentials object.\n     * @property {string} [credentials.client_email]\n     * @property {string} [credentials.private_key]\n     * @property {boolean} [autoRetry=true] Automatically retry requests if the\n     *     response is related to rate limits or certain intermittent server\n     * errors. We will exponentially backoff subsequent requests by default.\n     * @property {number} [maxRetries=3] Maximum number of automatic retries\n     *     attempted before returning the error.\n     * @property {Constructor} [promise] Custom promise module to use instead of\n     *     native Promises.\n     */\n    /**\n     * Constructs the Storage client.\n     *\n     * @example <caption>Create a client that uses Application Default Credentials\n     * (ADC)</caption> const {Storage} = require('@google-cloud/storage'); const\n     * storage = new Storage();\n     *\n     * @example <caption>Create a client with explicit credentials</caption>\n     * storage');/storage');\n     * const storage = new Storage({\n     *   projectId: 'your-project-id',\n     *   keyFilename: '/path/to/keyfile.json'\n     * });\n     *\n     * @param {StorageOptions} [options] Configuration options.\n     */\n    constructor(options = {}) {\n        options = Object.assign({}, options, {\n            apiEndpoint: options.apiEndpoint || 'storage.googleapis.com',\n        });\n        const url = process.env.STORAGE_EMULATOR_HOST ||\n            `https://${options.apiEndpoint}/storage/v1`;\n        const config = {\n            apiEndpoint: options.apiEndpoint,\n            baseUrl: url,\n            projectIdRequired: false,\n            scopes: [\n                'https://www.googleapis.com/auth/iam',\n                'https://www.googleapis.com/auth/cloud-platform',\n                'https://www.googleapis.com/auth/devstorage.full_control',\n            ],\n            packageJson: __webpack_require__(/*! ../../package.json */ \"./src/node_modules/@google-cloud/storage/package.json\"),\n        };\n        super(config, options);\n        /**\n         * Reference to {@link Storage.acl}.\n         *\n         * @name Storage#acl\n         * @see Storage.acl\n         */\n        this.acl = Storage.acl;\n        this.getBucketsStream = paginator_1.paginator.streamify('getBuckets');\n        this.getHmacKeysStream = paginator_1.paginator.streamify('getHmacKeys');\n    }\n    /**\n     * Get a reference to a Cloud Storage bucket.\n     *\n     * @param {string} name Name of the bucket.\n     * @param {object} [options] Configuration object.\n     * @param {string} [options.kmsKeyName] A Cloud KMS key that will be used to\n     *     encrypt objects inserted into this bucket, if no encryption method is\n     *     specified.\n     * @param {string} [options.userProject] User project to be billed for all\n     *     requests made from this Bucket object.\n     * @returns {Bucket}\n     * @see Bucket\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const albums = storage.bucket('albums');\n     * const photos = storage.bucket('photos');\n     */\n    bucket(name, options) {\n        if (!name) {\n            throw new Error('A bucket name is needed to use Cloud Storage.');\n        }\n        return new bucket_1.Bucket(this, name, options);\n    }\n    /**\n     * Reference a channel to receive notifications about changes to your bucket.\n     *\n     * @param {string} id The ID of the channel.\n     * @param {string} resourceId The resource ID of the channel.\n     * @returns {Channel}\n     * @see Channel\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const channel = storage.channel('id', 'resource-id');\n     */\n    channel(id, resourceId) {\n        return new channel_1.Channel(this, id, resourceId);\n    }\n    /**\n     * @typedef {array} CreateBucketResponse\n     * @property {Bucket} 0 The new {@link Bucket}.\n     * @property {object} 1 The full API response.\n     */\n    /**\n     * @callback CreateBucketCallback\n     * @param {?Error} err Request error, if any.\n     * @param {Bucket} bucket The new {@link Bucket}.\n     * @param {object} apiResponse The full API response.\n     */\n    /**\n     * Metadata to set for the bucket.\n     *\n     * @typedef {object} CreateBucketRequest\n     * @property {boolean} [archive=false] Specify the storage class as Archive.\n     * @property {boolean} [coldline=false] Specify the storage class as Coldline.\n     * @property {Cors[]} [cors=[]] Specify the CORS configuration to use.\n     * @property {boolean} [dra=false] Specify the storage class as Durable Reduced\n     *     Availability.\n     * @property {boolean} [multiRegional=false] Specify the storage class as\n     *     Multi-Regional.\n     * @property {boolean} [nearline=false] Specify the storage class as Nearline.\n     * @property {boolean} [regional=false] Specify the storage class as Regional.\n     * @property {boolean} [requesterPays=false] **Early Access Testers Only**\n     *     Force the use of the User Project metadata field to assign operational\n     *     costs when an operation is made on a Bucket and its objects.\n     * @property {boolean} [standard=true] Specify the storage class as Standard.\n     * @property {Versioning} [versioning=undefined] Specify the versioning status.\n     * @property {string} [userProject] The ID of the project which will be billed\n     *     for the request.\n     */\n    /**\n     * Create a bucket.\n     *\n     * Cloud Storage uses a flat namespace, so you can't create a bucket with\n     * a name that is already in use. For more information, see\n     * [Bucket Naming\n     * Guidelines](https://cloud.google.com/storage/docs/bucketnaming.html#requirements).\n     *\n     * @see [Buckets: insert API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/buckets/insert}\n     * @see [Storage Classes]{@link https://cloud.google.com/storage/docs/storage-classes}\n     *\n     * @param {string} name Name of the bucket to create.\n     * @param {CreateBucketRequest} [metadata] Metadata to set for the bucket.\n     * @param {CreateBucketCallback} [callback] Callback function.\n     * @returns {Promise<CreateBucketResponse>}\n     * @throws {Error} If a name is not provided.\n     * @see Bucket#create\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const callback = function(err, bucket, apiResponse) {\n     *   // `bucket` is a Bucket object.\n     * };\n     *\n     * storage.createBucket('new-bucket', callback);\n     *\n     * //-\n     * // Create a bucket in a specific location and region. <em>See the <a\n     * // href=\"https://cloud.google.com/storage/docs/json_api/v1/buckets/insert\">\n     * // Official JSON API docs</a> for complete details on the `location`\n     * option.\n     * // </em>\n     * //-\n     * const metadata = {\n     *   location: 'US-CENTRAL1',\n     *   regional: true\n     * };\n     *\n     * storage.createBucket('new-bucket', metadata, callback);\n     *\n     * //-\n     * // Create a bucket with a retention policy of 6 months.\n     * //-\n     * const metadata = {\n     *   retentionPolicy: {\n     *     retentionPeriod: 15780000 // 6 months in seconds.\n     *   }\n     * };\n     *\n     * storage.createBucket('new-bucket', metadata, callback);\n     *\n     * //-\n     * // Enable versioning on a new bucket.\n     * //-\n     * const metadata = {\n     *   versioning: {\n     *     enabled: true\n     *   }\n     * };\n     *\n     * storage.createBucket('new-bucket', metadata, callback);\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * storage.createBucket('new-bucket').then(function(data) {\n     *   const bucket = data[0];\n     *   const apiResponse = data[1];\n     * });\n     *\n     * @example <caption>include:samples/buckets.js</caption>\n     * region_tag:storage_create_bucket\n     * Another example:\n     */\n    createBucket(name, metadataOrCallback, callback) {\n        if (!name) {\n            throw new Error('A name is required to create a bucket.');\n        }\n        let metadata;\n        if (!callback) {\n            callback = metadataOrCallback;\n            metadata = {};\n        }\n        else {\n            metadata = metadataOrCallback;\n        }\n        const body = Object.assign({}, metadata, { name });\n        const storageClasses = {\n            archive: 'ARCHIVE',\n            coldline: 'COLDLINE',\n            dra: 'DURABLE_REDUCED_AVAILABILITY',\n            multiRegional: 'MULTI_REGIONAL',\n            nearline: 'NEARLINE',\n            regional: 'REGIONAL',\n            standard: 'STANDARD',\n        };\n        Object.keys(storageClasses).forEach(storageClass => {\n            if (body[storageClass]) {\n                body.storageClass = storageClasses[storageClass];\n                delete body[storageClass];\n            }\n        });\n        if (body.requesterPays) {\n            body.billing = {\n                requesterPays: body.requesterPays,\n            };\n            delete body.requesterPays;\n        }\n        const query = {\n            project: this.projectId,\n        };\n        if (body.userProject) {\n            query.userProject = body.userProject;\n            delete body.userProject;\n        }\n        this.request({\n            method: 'POST',\n            uri: '/b',\n            qs: query,\n            json: body,\n        }, (err, resp) => {\n            if (err) {\n                callback(err, null, resp);\n                return;\n            }\n            const bucket = this.bucket(name);\n            bucket.metadata = resp;\n            callback(null, bucket, resp);\n        });\n    }\n    /**\n     * @typedef {object} CreateHmacKeyOptions\n     * @property {string} [projectId] The project ID of the project that owns\n     *     the service account of the requested HMAC key. If not provided,\n     *     the project ID used to instantiate the Storage client will be used.\n     * @property {string} [userProject] This parameter is currently ignored.\n     */\n    /**\n     * @typedef {object} HmacKeyMetadata\n     * @property {string} accessId The access id identifies which HMAC key was\n     *     used to sign a request when authenticating with HMAC.\n     * @property {string} etag Used to perform a read-modify-write of the key.\n     * @property {string} id The resource name of the HMAC key.\n     * @property {string} projectId The project ID.\n     * @property {string} serviceAccountEmail The service account's email this\n     *     HMAC key is created for.\n     * @property {string} state The state of this HMAC key. One of \"ACTIVE\",\n     *     \"INACTIVE\" or \"DELETED\".\n     * @property {string} timeCreated The creation time of the HMAC key in\n     *     RFC 3339 format.\n     * @property {string} [updated] The time this HMAC key was last updated in\n     *     RFC 3339 format.\n     */\n    /**\n     * @typedef {array} CreateHmacKeyResponse\n     * @property {HmacKey} 0 The HmacKey instance created from API response.\n     * @property {string} 1 The HMAC key's secret used to access the XML API.\n     * @property {object} 3 The raw API response.\n     */\n    /**\n     * @callback CreateHmacKeyCallback Callback function.\n     * @param {?Error} err Request error, if any.\n     * @param {HmacKey} hmacKey The HmacKey instance created from API response.\n     * @param {string} secret The HMAC key's secret used to access the XML API.\n     * @param {object} apiResponse The raw API response.\n     */\n    /**\n     * Create an HMAC key associated with an service account to authenticate\n     * requests to the Cloud Storage XML API.\n     *\n     * @see [HMAC keys documentation]{@link https://cloud.google.com/storage/docs/authentication/hmackeys}\n     *\n     * @param {string} serviceAccountEmail The service account's email address\n     *     with which the HMAC key is created for.\n     * @param {CreateHmacKeyCallback} [callback] Callback function.\n     * @return {Promise<CreateHmacKeyResponse>}\n     *\n     * @example\n     * const {Storage} = require('google-cloud/storage');\n     * const storage = new Storage();\n     *\n     * // Replace with your service account's email address\n     * const serviceAccountEmail =\n     *   'my-service-account@appspot.gserviceaccount.com';\n     *\n     * storage.createHmacKey(serviceAccountEmail, function(err, hmacKey, secret) {\n     *   if (!err) {\n     *     // Securely store the secret for use with the XML API.\n     *   }\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * storage.createHmacKey(serviceAccountEmail)\n     *   .then((response) => {\n     *     const hmacKey = response[0];\n     *     const secret = response[1];\n     *     // Securely store the secret for use with the XML API.\n     *   });\n     */\n    createHmacKey(serviceAccountEmail, optionsOrCb, cb) {\n        if (typeof serviceAccountEmail !== 'string') {\n            throw new Error('The first argument must be a service account email to create an HMAC key.');\n        }\n        const { options, callback } = util_1.normalize(optionsOrCb, cb);\n        const query = Object.assign({}, options, { serviceAccountEmail });\n        const projectId = query.projectId || this.projectId;\n        delete query.projectId;\n        this.request({\n            method: 'POST',\n            uri: `/projects/${projectId}/hmacKeys`,\n            qs: query,\n        }, (err, resp) => {\n            if (err) {\n                callback(err, null, null, resp);\n                return;\n            }\n            const metadata = resp.metadata;\n            const hmacKey = this.hmacKey(metadata.accessId, {\n                projectId: metadata.projectId,\n            });\n            hmacKey.metadata = resp.metadata;\n            callback(null, hmacKey, resp.secret, resp);\n        });\n    }\n    /**\n     * Query object for listing buckets.\n     *\n     * @typedef {object} GetBucketsRequest\n     * @property {boolean} [autoPaginate=true] Have pagination handled\n     *     automatically.\n     * @property {number} [maxApiCalls] Maximum number of API calls to make.\n     * @property {number} [maxResults] Maximum number of items plus prefixes to\n     *     return.\n     * @property {string} [pageToken] A previously-returned page token\n     *     representing part of the larger set of results to view.\n     * @property {string} [userProject] The ID of the project which will be billed\n     *     for the request.\n     */\n    /**\n     * @typedef {array} GetBucketsResponse\n     * @property {Bucket[]} 0 Array of {@link Bucket} instances.\n     */\n    /**\n     * @callback GetBucketsCallback\n     * @param {?Error} err Request error, if any.\n     * @param {Bucket[]} buckets Array of {@link Bucket} instances.\n     */\n    /**\n     * Get Bucket objects for all of the buckets in your project.\n     *\n     * @see [Buckets: list API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/buckets/list}\n     *\n     * @param {GetBucketsRequest} [query] Query object for listing buckets.\n     * @param {GetBucketsCallback} [callback] Callback function.\n     * @returns {Promise<GetBucketsResponse>}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * storage.getBuckets(function(err, buckets) {\n     *   if (!err) {\n     *     // buckets is an array of Bucket objects.\n     *   }\n     * });\n     *\n     * //-\n     * // To control how many API requests are made and page through the results\n     * // manually, set `autoPaginate` to `false`.\n     * //-\n     * const callback = function(err, buckets, nextQuery, apiResponse) {\n     *   if (nextQuery) {\n     *     // More results exist.\n     *     storage.getBuckets(nextQuery, callback);\n     *   }\n     *\n     *   // The `metadata` property is populated for you with the metadata at the\n     *   // time of fetching.\n     *   buckets[0].metadata;\n     *\n     *   // However, in cases where you are concerned the metadata could have\n     *   // changed, use the `getMetadata` method.\n     *   buckets[0].getMetadata(function(err, metadata, apiResponse) {});\n     * };\n     *\n     * storage.getBuckets({\n     *   autoPaginate: false\n     * }, callback);\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * storage.getBuckets().then(function(data) {\n     *   const buckets = data[0];\n     * });\n     *\n     * @example <caption>include:samples/buckets.js</caption>\n     * region_tag:storage_list_buckets\n     * Another example:\n     */\n    getBuckets(optionsOrCallback, cb) {\n        const { options, callback } = util_1.normalize(optionsOrCallback, cb);\n        options.project = options.project || this.projectId;\n        this.request({\n            uri: '/b',\n            qs: options,\n        }, (err, resp) => {\n            if (err) {\n                callback(err, null, null, resp);\n                return;\n            }\n            const buckets = arrify(resp.items).map((bucket) => {\n                const bucketInstance = this.bucket(bucket.id);\n                bucketInstance.metadata = bucket;\n                return bucketInstance;\n            });\n            const nextQuery = resp.nextPageToken\n                ? Object.assign({}, options, { pageToken: resp.nextPageToken })\n                : null;\n            callback(null, buckets, nextQuery, resp);\n        });\n    }\n    getHmacKeys(optionsOrCb, cb) {\n        const { options, callback } = util_1.normalize(optionsOrCb, cb);\n        const query = Object.assign({}, options);\n        const projectId = query.projectId || this.projectId;\n        delete query.projectId;\n        this.request({\n            uri: `/projects/${projectId}/hmacKeys`,\n            qs: query,\n        }, (err, resp) => {\n            if (err) {\n                callback(err, null, null, resp);\n                return;\n            }\n            const hmacKeys = arrify(resp.items).map((hmacKey) => {\n                const hmacKeyInstance = this.hmacKey(hmacKey.accessId, {\n                    projectId: hmacKey.projectId,\n                });\n                hmacKeyInstance.metadata = hmacKey;\n                return hmacKeyInstance;\n            });\n            const nextQuery = resp.nextPageToken\n                ? Object.assign({}, options, { pageToken: resp.nextPageToken })\n                : null;\n            callback(null, hmacKeys, nextQuery, resp);\n        });\n    }\n    /**\n     * @typedef {array} GetServiceAccountResponse\n     * @property {object} 0 The service account resource.\n     * @property {object} 1 The full\n     * [API\n     * response](https://cloud.google.com/storage/docs/json_api/v1/projects/serviceAccount#resource).\n     */\n    /**\n     * @callback GetServiceAccountCallback\n     * @param {?Error} err Request error, if any.\n     * @param {object} serviceAccount The serviceAccount resource.\n     * @param {string} serviceAccount.emailAddress The service account email\n     *     address.\n     * @param {object} apiResponse The full\n     * [API\n     * response](https://cloud.google.com/storage/docs/json_api/v1/projects/serviceAccount#resource).\n     */\n    /**\n     * Get the email address of this project's Google Cloud Storage service\n     * account.\n     *\n     * @see [Projects.serviceAccount: get API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/projects/serviceAccount/get}\n     * @see [Projects.serviceAccount Resource]{@link https://cloud.google.com/storage/docs/json_api/v1/projects/serviceAccount#resource}\n     *\n     * @param {object} [options] Configuration object.\n     * @param {string} [options.userProject] User project to be billed for this\n     *     request.\n     * @param {GetServiceAccountCallback} [callback] Callback function.\n     * @returns {Promise<GetServiceAccountResponse>}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     *\n     * storage.getServiceAccount(function(err, serviceAccount, apiResponse) {\n     *   if (!err) {\n     *     const serviceAccountEmail = serviceAccount.emailAddress;\n     *   }\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * storage.getServiceAccount().then(function(data) {\n     *   const serviceAccountEmail = data[0].emailAddress;\n     *   const apiResponse = data[1];\n     * });\n     */\n    getServiceAccount(optionsOrCallback, cb) {\n        const { options, callback } = util_1.normalize(optionsOrCallback, cb);\n        this.request({\n            uri: `/projects/${this.projectId}/serviceAccount`,\n            qs: options,\n        }, (err, resp) => {\n            if (err) {\n                callback(err, null, resp);\n                return;\n            }\n            const camelCaseResponse = {};\n            for (const prop in resp) {\n                if (resp.hasOwnProperty(prop)) {\n                    const camelCaseProp = prop.replace(/_(\\w)/g, (_, match) => match.toUpperCase());\n                    camelCaseResponse[camelCaseProp] = resp[prop];\n                }\n            }\n            callback(null, camelCaseResponse, resp);\n        });\n    }\n    /**\n     * Get a reference to an HmacKey object.\n     * Note: this does not fetch the HMAC key's metadata. Use HmacKey#get() to\n     * retrieve and populate the metadata.\n     *\n     * To get a reference to an HMAC key that's not created for a service\n     * account in the same project used to instantiate the Storage client,\n     * supply the project's ID as `projectId` in the `options` argument.\n     *\n     * @param {string} accessId The HMAC key's access ID.\n     * @param {HmacKeyOptions} options HmacKey constructor owptions.\n     * @returns {HmacKey}\n     * @see HmacKey\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const hmacKey = storage.hmacKey('ACCESS_ID');\n     */\n    hmacKey(accessId, options) {\n        if (!accessId) {\n            throw new Error('An access ID is needed to create an HmacKey object.');\n        }\n        return new hmacKey_1.HmacKey(this, accessId, options);\n    }\n}\nexports.Storage = Storage;\n/**\n * {@link Bucket} class.\n *\n * @name Storage.Bucket\n * @see Bucket\n * @type {Constructor}\n */\nStorage.Bucket = bucket_1.Bucket;\n/**\n * {@link Channel} class.\n *\n * @name Storage.Channel\n * @see Channel\n * @type {Constructor}\n */\nStorage.Channel = channel_1.Channel;\n/**\n * {@link File} class.\n *\n * @name Storage.File\n * @see File\n * @type {Constructor}\n */\nStorage.File = file_1.File;\n/**\n * {@link HmacKey} class.\n *\n * @name Storage.HmacKey\n * @see HmacKey\n * @type {Constructor}\n */\nStorage.HmacKey = hmacKey_1.HmacKey;\n/**\n * Cloud Storage uses access control lists (ACLs) to manage object and\n * bucket access. ACLs are the mechanism you use to share objects with other\n * users and allow other users to access your buckets and objects.\n *\n * This object provides constants to refer to the three permission levels that\n * can be granted to an entity:\n *\n *   - `gcs.acl.OWNER_ROLE` - (\"OWNER\")\n *   - `gcs.acl.READER_ROLE` - (\"READER\")\n *   - `gcs.acl.WRITER_ROLE` - (\"WRITER\")\n *\n * @see [About Access Control Lists]{@link https://cloud.google.com/storage/docs/access-control/lists}\n *\n * @name Storage.acl\n * @type {object}\n * @property {string} OWNER_ROLE\n * @property {string} READER_ROLE\n * @property {string} WRITER_ROLE\n *\n * @example\n * const {Storage} = require('@google-cloud/storage');\n * const storage = new Storage();\n * const albums = storage.bucket('albums');\n *\n * //-\n * // Make all of the files currently in a bucket publicly readable.\n * //-\n * const options = {\n *   entity: 'allUsers',\n *   role: storage.acl.READER_ROLE\n * };\n *\n * albums.acl.add(options, function(err, aclObject) {});\n *\n * //-\n * // Make any new objects added to a bucket publicly readable.\n * //-\n * albums.acl.default.add(options, function(err, aclObject) {});\n *\n * //-\n * // Grant a user ownership permissions to a bucket.\n * //-\n * albums.acl.add({\n *   entity: 'user-useremail@example.com',\n *   role: storage.acl.OWNER_ROLE\n * }, function(err, aclObject) {});\n *\n * //-\n * // If the callback is omitted, we'll return a Promise.\n * //-\n * albums.acl.add(options).then(function(data) {\n *   const aclObject = data[0];\n *   const apiResponse = data[1];\n * });\n */\nStorage.acl = {\n    OWNER_ROLE: 'OWNER',\n    READER_ROLE: 'READER',\n    WRITER_ROLE: 'WRITER',\n};\n/*! Developer Documentation\n *\n * These methods can be auto-paginated.\n */\npaginator_1.paginator.extend(Storage, ['getBuckets', 'getHmacKeys']);\n/*! Developer Documentation\n *\n * All async methods (except for streams) will return a Promise in the event\n * that a callback is omitted.\n */\npromisify_1.promisifyAll(Storage, {\n    exclude: ['bucket', 'channel', 'hmacKey'],\n});\n//# sourceMappingURL=storage.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/storage/build/src/storage.js?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/storage/build/src/util.js":
/*!******************************************************************!*\
  !*** ./src/node_modules/@google-cloud/storage/build/src/util.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst querystring = __webpack_require__(/*! querystring */ \"querystring\");\nfunction normalize(optionsOrCallback, cb) {\n    const options = (typeof optionsOrCallback === 'object'\n        ? optionsOrCallback\n        : {});\n    const callback = (typeof optionsOrCallback === 'function'\n        ? optionsOrCallback\n        : cb);\n    return { options, callback };\n}\nexports.normalize = normalize;\n/**\n * Flatten an object into an Array of arrays, [[key, value], ..].\n * Implements Object.entries() for Node.js <8\n * @internal\n */\nfunction objectEntries(obj) {\n    return Object.keys(obj).map(key => [key, obj[key]]);\n}\nexports.objectEntries = objectEntries;\n/**\n * Encode `str` with encodeURIComponent, plus these\n * reserved characters: `! * ' ( )`.\n *\n * @see [MDN: fixedEncodeURIComponent]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent}\n *\n * @param {string} str The URI component to encode.\n * @return {string} The encoded string.\n */\nfunction fixedEncodeURIComponent(str) {\n    return encodeURIComponent(str).replace(/[!'()*]/g, c => '%' +\n        c\n            .charCodeAt(0)\n            .toString(16)\n            .toUpperCase());\n}\nexports.fixedEncodeURIComponent = fixedEncodeURIComponent;\n/**\n * URI encode `uri` for generating signed URLs, using fixedEncodeURIComponent.\n *\n * Encode every byte except `A-Z a-Z 0-9 ~ - . _`.\n *\n * @param {string} uri The URI to encode.\n * @param [boolean=false] encodeSlash If `true`, the \"/\" character is not encoded.\n * @return {string} The encoded string.\n */\nfunction encodeURI(uri, encodeSlash) {\n    // Split the string by `/`, and conditionally rejoin them with either\n    // %2F if encodeSlash is `true`, or '/' if `false`.\n    return uri\n        .split('/')\n        .map(fixedEncodeURIComponent)\n        .join(encodeSlash ? '%2F' : '/');\n}\nexports.encodeURI = encodeURI;\n/**\n * Serialize an object to a URL query string using util.encodeURI(uri, true).\n * @param {string} url The object to serialize.\n * @return {string} Serialized string.\n */\nfunction qsStringify(qs) {\n    return querystring.stringify(qs, '&', '=', {\n        encodeURIComponent: (component) => encodeURI(component, true),\n    });\n}\nexports.qsStringify = qsStringify;\nfunction objectKeyToLowercase(object) {\n    const newObj = {};\n    for (let key of Object.keys(object)) {\n        const value = object[key];\n        key = key.toLowerCase();\n        newObj[key] = value;\n    }\n    return newObj;\n}\nexports.objectKeyToLowercase = objectKeyToLowercase;\n//# sourceMappingURL=util.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/storage/build/src/util.js?");

/***/ }),

/***/ "./src/node_modules/@google-cloud/storage/package.json":
/*!*************************************************************!*\
  !*** ./src/node_modules/@google-cloud/storage/package.json ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"name\":\"@google-cloud/storage\",\"description\":\"Cloud Storage Client Library for Node.js\",\"version\":\"4.7.0\",\"license\":\"Apache-2.0\",\"author\":\"Google Inc.\",\"engines\":{\"node\":\">=8.10.0\"},\"repository\":\"googleapis/nodejs-storage\",\"main\":\"./build/src/index.js\",\"types\":\"./build/src/index.d.ts\",\"files\":[\"build/src\",\"!build/src/**/*.map\",\"AUTHORS\",\"CONTRIBUTORS\",\"COPYING\"],\"keywords\":[\"google apis client\",\"google api client\",\"google apis\",\"google api\",\"google\",\"google cloud platform\",\"google cloud\",\"cloud\",\"google storage\",\"storage\"],\"scripts\":{\"predocs\":\"npm run compile\",\"docs\":\"jsdoc -c .jsdoc.js\",\"system-test\":\"mocha build/system-test --timeout 600000 --exit\",\"conformance-test\":\"mocha build/conformance-test\",\"preconformance-test\":\"npm run compile\",\"presystem-test\":\"npm run compile\",\"test\":\"c8 mocha build/test\",\"pretest\":\"npm run compile\",\"lint\":\"eslint samples/ && gts check\",\"samples-test\":\"npm link && cd samples/ && npm link ../ && npm test && cd ../\",\"all-test\":\"npm test && npm run system-test && npm run samples-test\",\"check\":\"gts check\",\"clean\":\"gts clean\",\"compile\":\"tsc -p .\",\"fix\":\"gts fix && eslint --fix \\'**/*.js\\'\",\"prepare\":\"npm run compile\",\"docs-test\":\"linkinator docs\",\"predocs-test\":\"npm run docs\",\"benchwrapper\":\"node bin/benchwrapper.js\",\"prelint\":\"cd samples; npm link ../; npm i\"},\"dependencies\":{\"@google-cloud/common\":\"^2.1.1\",\"@google-cloud/paginator\":\"^2.0.0\",\"@google-cloud/promisify\":\"^1.0.0\",\"arrify\":\"^2.0.0\",\"compressible\":\"^2.0.12\",\"concat-stream\":\"^2.0.0\",\"date-and-time\":\"^0.13.0\",\"duplexify\":\"^3.5.0\",\"extend\":\"^3.0.2\",\"gaxios\":\"^3.0.0\",\"gcs-resumable-upload\":\"^2.2.4\",\"hash-stream-validation\":\"^0.2.2\",\"mime\":\"^2.2.0\",\"mime-types\":\"^2.0.8\",\"onetime\":\"^5.1.0\",\"p-limit\":\"^2.2.0\",\"pumpify\":\"^2.0.0\",\"readable-stream\":\"^3.4.0\",\"snakeize\":\"^0.1.0\",\"stream-events\":\"^1.0.1\",\"through2\":\"^3.0.0\",\"xdg-basedir\":\"^4.0.0\"},\"devDependencies\":{\"@google-cloud/pubsub\":\"^1.0.0\",\"@grpc/proto-loader\":\"^0.5.1\",\"@types/compressible\":\"^2.0.0\",\"@types/concat-stream\":\"^1.6.0\",\"@types/configstore\":\"^4.0.0\",\"@types/date-and-time\":\"^0.6.0\",\"@types/extend\":\"^3.0.0\",\"@types/mime\":\"^2.0.0\",\"@types/mime-types\":\"^2.1.0\",\"@types/mocha\":\"^7.0.0\",\"@types/nock\":\"^10.0.0\",\"@types/node\":\"^11.13.4\",\"@types/node-fetch\":\"^2.1.3\",\"@types/proxyquire\":\"^1.3.28\",\"@types/pumpify\":\"^1.4.1\",\"@types/sinon\":\"^7.0.10\",\"@types/through2\":\"^2.0.33\",\"@types/tmp\":\"0.1.0\",\"@types/uuid\":\"^7.0.0\",\"@types/xdg-basedir\":\"^2.0.0\",\"c8\":\"^7.0.0\",\"codecov\":\"^3.0.0\",\"eslint\":\"^6.0.0\",\"eslint-config-prettier\":\"^6.0.0\",\"eslint-plugin-node\":\"^11.0.0\",\"eslint-plugin-prettier\":\"^3.0.0\",\"form-data\":\"^3.0.0\",\"grpc\":\"^1.22.2\",\"gts\":\"^1.0.0\",\"jsdoc\":\"^3.6.2\",\"jsdoc-fresh\":\"^1.0.1\",\"jsdoc-region-tag\":\"^1.0.2\",\"linkinator\":\"^2.0.0\",\"mocha\":\"^7.0.0\",\"nock\":\"~12.0.0\",\"node-fetch\":\"^2.2.0\",\"normalize-newline\":\"^3.0.0\",\"prettier\":\"^1.7.0\",\"proxyquire\":\"^2.1.3\",\"sinon\":\"^9.0.0\",\"tmp\":\"^0.1.0\",\"typescript\":\"3.6.4\",\"uuid\":\"^7.0.0\",\"yargs\":\"^15.0.0\"}}');\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/@google-cloud/storage/package.json?");

/***/ }),

/***/ "./src/node_modules/available-typed-arrays/index.js":
/*!**********************************************************!*\
  !*** ./src/node_modules/available-typed-arrays/index.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar possibleNames = [\n\t'BigInt64Array',\n\t'BigUint64Array',\n\t'Float32Array',\n\t'Float64Array',\n\t'Int16Array',\n\t'Int32Array',\n\t'Int8Array',\n\t'Uint16Array',\n\t'Uint32Array',\n\t'Uint8Array',\n\t'Uint8ClampedArray'\n];\n\nmodule.exports = function availableTypedArrays() {\n\tvar out = [];\n\tfor (var i = 0; i < possibleNames.length; i++) {\n\t\tif (typeof global[possibleNames[i]] === 'function') {\n\t\t\tout[out.length] = possibleNames[i];\n\t\t}\n\t}\n\treturn out;\n};\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/available-typed-arrays/index.js?");

/***/ }),

/***/ "./src/node_modules/boolbase/index.js":
/*!********************************************!*\
  !*** ./src/node_modules/boolbase/index.js ***!
  \********************************************/
/***/ ((module) => {

eval("module.exports = {\n\ttrueFunc: function trueFunc(){\n\t\treturn true;\n\t},\n\tfalseFunc: function falseFunc(){\n\t\treturn false;\n\t}\n};\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/boolbase/index.js?");

/***/ }),

/***/ "./src/node_modules/cheerio-select/lib/helpers.js":
/*!********************************************************!*\
  !*** ./src/node_modules/cheerio-select/lib/helpers.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.groupSelectors = exports.getDocumentRoot = void 0;\nvar positionals_1 = __webpack_require__(/*! ./positionals */ \"./src/node_modules/cheerio-select/lib/positionals.js\");\nfunction getDocumentRoot(node) {\n    while (node.parent)\n        node = node.parent;\n    return node;\n}\nexports.getDocumentRoot = getDocumentRoot;\nfunction groupSelectors(selectors) {\n    var filteredSelectors = [];\n    var plainSelectors = [];\n    for (var _i = 0, selectors_1 = selectors; _i < selectors_1.length; _i++) {\n        var selector = selectors_1[_i];\n        if (selector.some(positionals_1.isFilter)) {\n            filteredSelectors.push(selector);\n        }\n        else {\n            plainSelectors.push(selector);\n        }\n    }\n    return [plainSelectors, filteredSelectors];\n}\nexports.groupSelectors = groupSelectors;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/cheerio-select/lib/helpers.js?");

/***/ }),

/***/ "./src/node_modules/cheerio-select/lib/index.js":
/*!******************************************************!*\
  !*** ./src/node_modules/cheerio-select/lib/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.select = exports.filter = exports.some = exports.is = exports.aliases = exports.pseudos = exports.filters = void 0;\nvar css_what_1 = __webpack_require__(/*! css-what */ \"./src/node_modules/css-what/lib/index.js\");\nvar css_select_1 = __webpack_require__(/*! css-select */ \"./src/node_modules/css-select/lib/index.js\");\nvar DomUtils = __importStar(__webpack_require__(/*! domutils */ \"./src/node_modules/domutils/lib/index.js\"));\nvar helpers_1 = __webpack_require__(/*! ./helpers */ \"./src/node_modules/cheerio-select/lib/helpers.js\");\nvar positionals_1 = __webpack_require__(/*! ./positionals */ \"./src/node_modules/cheerio-select/lib/positionals.js\");\n// Re-export pseudo extension points\nvar css_select_2 = __webpack_require__(/*! css-select */ \"./src/node_modules/css-select/lib/index.js\");\nObject.defineProperty(exports, \"filters\", ({ enumerable: true, get: function () { return css_select_2.filters; } }));\nObject.defineProperty(exports, \"pseudos\", ({ enumerable: true, get: function () { return css_select_2.pseudos; } }));\nObject.defineProperty(exports, \"aliases\", ({ enumerable: true, get: function () { return css_select_2.aliases; } }));\n/** Used to indicate a scope should be filtered. Might be ignored when filtering. */\nvar SCOPE_PSEUDO = {\n    type: \"pseudo\",\n    name: \"scope\",\n    data: null,\n};\n/** Used for actually filtering for scope. */\nvar CUSTOM_SCOPE_PSEUDO = __assign({}, SCOPE_PSEUDO);\nvar UNIVERSAL_SELECTOR = { type: \"universal\", namespace: null };\nfunction is(element, selector, options) {\n    if (options === void 0) { options = {}; }\n    return some([element], selector, options);\n}\nexports.is = is;\nfunction some(elements, selector, options) {\n    if (options === void 0) { options = {}; }\n    if (typeof selector === \"function\")\n        return elements.some(selector);\n    var _a = helpers_1.groupSelectors(css_what_1.parse(selector, options)), plain = _a[0], filtered = _a[1];\n    return ((plain.length > 0 && elements.some(css_select_1._compileToken(plain, options))) ||\n        filtered.some(function (sel) { return filterBySelector(sel, elements, options).length > 0; }));\n}\nexports.some = some;\nfunction filterByPosition(filter, elems, data, options) {\n    var num = typeof data === \"string\" ? parseInt(data, 10) : NaN;\n    switch (filter) {\n        case \"first\":\n        case \"lt\":\n            // Already done in `getLimit`\n            return elems;\n        case \"last\":\n            return elems.length > 0 ? [elems[elems.length - 1]] : elems;\n        case \"nth\":\n        case \"eq\":\n            return isFinite(num) && Math.abs(num) < elems.length\n                ? [num < 0 ? elems[elems.length + num] : elems[num]]\n                : [];\n        case \"gt\":\n            return isFinite(num) ? elems.slice(num + 1) : [];\n        case \"even\":\n            return elems.filter(function (_, i) { return i % 2 === 0; });\n        case \"odd\":\n            return elems.filter(function (_, i) { return i % 2 === 1; });\n        case \"not\": {\n            var filtered_1 = new Set(filterParsed(data, elems, options));\n            return elems.filter(function (e) { return !filtered_1.has(e); });\n        }\n    }\n}\nfunction filter(selector, elements, options) {\n    if (options === void 0) { options = {}; }\n    return filterParsed(css_what_1.parse(selector, options), elements, options);\n}\nexports.filter = filter;\n/**\n * Filter a set of elements by a selector.\n *\n * Will return elements in the original order.\n *\n * @param selector Selector to filter by.\n * @param elements Elements to filter.\n * @param options Options for selector.\n */\nfunction filterParsed(selector, elements, options) {\n    if (elements.length === 0)\n        return [];\n    var _a = helpers_1.groupSelectors(selector), plainSelectors = _a[0], filteredSelectors = _a[1];\n    var found;\n    if (plainSelectors.length) {\n        var filtered = filterElements(elements, plainSelectors, options);\n        // If there are no filters, just return\n        if (filteredSelectors.length === 0) {\n            return filtered;\n        }\n        // Otherwise, we have to do some filtering\n        if (filtered.length) {\n            found = new Set(filtered);\n        }\n    }\n    for (var i = 0; i < filteredSelectors.length && (found === null || found === void 0 ? void 0 : found.size) !== elements.length; i++) {\n        var filteredSelector = filteredSelectors[i];\n        var missing = found\n            ? elements.filter(function (e) { return DomUtils.isTag(e) && !found.has(e); })\n            : elements;\n        if (missing.length === 0)\n            break;\n        var filtered = filterBySelector(filteredSelector, elements, options);\n        if (filtered.length) {\n            if (!found) {\n                /*\n                 * If we haven't found anything before the last selector,\n                 * just return what we found now.\n                 */\n                if (i === filteredSelectors.length - 1) {\n                    return filtered;\n                }\n                found = new Set(filtered);\n            }\n            else {\n                filtered.forEach(function (el) { return found.add(el); });\n            }\n        }\n    }\n    return typeof found !== \"undefined\"\n        ? (found.size === elements.length\n            ? elements\n            : // Filter elements to preserve order\n                elements.filter(function (el) {\n                    return found.has(el);\n                }))\n        : [];\n}\nfunction filterBySelector(selector, elements, options) {\n    var _a;\n    if (selector.some(css_what_1.isTraversal)) {\n        /*\n         * Get root node, run selector with the scope\n         * set to all of our nodes.\n         */\n        var root = (_a = options.root) !== null && _a !== void 0 ? _a : helpers_1.getDocumentRoot(elements[0]);\n        var sel = __spreadArray(__spreadArray([], selector), [CUSTOM_SCOPE_PSEUDO]);\n        return findFilterElements(root, sel, options, true, elements);\n    }\n    // Performance optimization: If we don't have to traverse, just filter set.\n    return findFilterElements(elements, selector, options, false);\n}\nfunction select(selector, root, options) {\n    if (options === void 0) { options = {}; }\n    if (typeof selector === \"function\") {\n        return find(root, selector);\n    }\n    var _a = helpers_1.groupSelectors(css_what_1.parse(selector, options)), plain = _a[0], filtered = _a[1];\n    var results = filtered.map(function (sel) {\n        return findFilterElements(root, sel, options, true);\n    });\n    // Plain selectors can be queried in a single go\n    if (plain.length) {\n        results.push(findElements(root, plain, options, Infinity));\n    }\n    // If there was only a single selector, just return the result\n    if (results.length === 1) {\n        return results[0];\n    }\n    // Sort results, filtering for duplicates\n    return DomUtils.uniqueSort(results.reduce(function (a, b) { return __spreadArray(__spreadArray([], a), b); }));\n}\nexports.select = select;\n// Traversals that are treated differently in css-select.\nvar specialTraversal = new Set([\"descendant\", \"adjacent\"]);\nfunction includesScopePseudo(t) {\n    return (t !== SCOPE_PSEUDO &&\n        t.type === \"pseudo\" &&\n        (t.name === \"scope\" ||\n            (Array.isArray(t.data) &&\n                t.data.some(function (data) { return data.some(includesScopePseudo); }))));\n}\nfunction addContextIfScope(selector, options, scopeContext) {\n    return scopeContext && selector.some(includesScopePseudo)\n        ? __assign(__assign({}, options), { context: scopeContext }) : options;\n}\n/**\n *\n * @param root Element(s) to search from.\n * @param selector Selector to look for.\n * @param options Options for querying.\n * @param queryForSelector Query multiple levels deep for the initial selector, even if it doesn't contain a traversal.\n * @param scopeContext Optional context for a :scope.\n */\nfunction findFilterElements(root, selector, options, queryForSelector, scopeContext) {\n    var filterIndex = selector.findIndex(positionals_1.isFilter);\n    var sub = selector.slice(0, filterIndex);\n    var filter = selector[filterIndex];\n    /*\n     * Set the number of elements to retrieve.\n     * Eg. for :first, we only have to get a single element.\n     */\n    var limit = positionals_1.getLimit(filter.name, filter.data);\n    if (limit === 0)\n        return [];\n    var subOpts = addContextIfScope(sub, options, scopeContext);\n    /*\n     * Skip `findElements` call if our selector starts with a positional\n     * pseudo.\n     */\n    var elemsNoLimit = sub.length === 0 && !Array.isArray(root)\n        ? DomUtils.getChildren(root).filter(DomUtils.isTag)\n        : sub.length === 0 || (sub.length === 1 && sub[0] === SCOPE_PSEUDO)\n            ? (Array.isArray(root) ? root : [root]).filter(DomUtils.isTag)\n            : queryForSelector || sub.some(css_what_1.isTraversal)\n                ? findElements(root, [sub], subOpts, limit)\n                : filterElements(root, [sub], subOpts);\n    var elems = elemsNoLimit.slice(0, limit);\n    var result = filterByPosition(filter.name, elems, filter.data, options);\n    if (result.length === 0 || selector.length === filterIndex + 1) {\n        return result;\n    }\n    var remainingSelector = selector.slice(filterIndex + 1);\n    var remainingHasTraversal = remainingSelector.some(css_what_1.isTraversal);\n    var remainingOpts = addContextIfScope(remainingSelector, options, scopeContext);\n    if (remainingHasTraversal) {\n        /*\n         * Some types of traversals have special logic when they start a selector\n         * in css-select. If this is the case, add a universal selector in front of\n         * the selector to avoid this behavior.\n         */\n        if (specialTraversal.has(remainingSelector[0].type)) {\n            remainingSelector.unshift(UNIVERSAL_SELECTOR);\n        }\n        /*\n         * Add a scope token in front of the remaining selector,\n         * to make sure traversals don't match elements that aren't a\n         * part of the considered tree.\n         */\n        remainingSelector.unshift(SCOPE_PSEUDO);\n    }\n    /*\n     * If we have another filter, recursively call `findFilterElements`,\n     * with the `recursive` flag disabled. We only have to look for more\n     * elements when we see a traversal.\n     *\n     * Otherwise,\n     */\n    return remainingSelector.some(positionals_1.isFilter)\n        ? findFilterElements(result, remainingSelector, options, false, scopeContext)\n        : remainingHasTraversal\n            ? // Query existing elements to resolve traversal.\n                findElements(result, [remainingSelector], remainingOpts, Infinity)\n            : // If we don't have any more traversals, simply filter elements.\n                filterElements(result, [remainingSelector], remainingOpts);\n}\nfunction findElements(root, sel, options, limit) {\n    if (limit === 0)\n        return [];\n    var query = css_select_1._compileToken(sel, options, root);\n    return find(root, query, limit);\n}\nfunction find(root, query, limit) {\n    if (limit === void 0) { limit = Infinity; }\n    var elems = css_select_1.prepareContext(root, DomUtils, query.shouldTestNextSiblings);\n    return DomUtils.find(function (node) { return DomUtils.isTag(node) && query(node); }, elems, true, limit);\n}\nfunction filterElements(elements, sel, options) {\n    var els = (Array.isArray(elements) ? elements : [elements]).filter(DomUtils.isTag);\n    if (els.length === 0)\n        return els;\n    var query = css_select_1._compileToken(sel, options);\n    return els.filter(query);\n}\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/cheerio-select/lib/index.js?");

/***/ }),

/***/ "./src/node_modules/cheerio-select/lib/positionals.js":
/*!************************************************************!*\
  !*** ./src/node_modules/cheerio-select/lib/positionals.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getLimit = exports.isFilter = exports.filterNames = void 0;\nexports.filterNames = new Set([\n    \"first\",\n    \"last\",\n    \"eq\",\n    \"gt\",\n    \"nth\",\n    \"lt\",\n    \"even\",\n    \"odd\",\n]);\nfunction isFilter(s) {\n    if (s.type !== \"pseudo\")\n        return false;\n    if (exports.filterNames.has(s.name))\n        return true;\n    if (s.name === \"not\" && Array.isArray(s.data)) {\n        // Only consider `:not` with embedded filters\n        return s.data.some(function (s) { return s.some(isFilter); });\n    }\n    return false;\n}\nexports.isFilter = isFilter;\nfunction getLimit(filter, data) {\n    var num = data != null ? parseInt(data, 10) : NaN;\n    switch (filter) {\n        case \"first\":\n            return 1;\n        case \"nth\":\n        case \"eq\":\n            return isFinite(num) ? (num >= 0 ? num + 1 : Infinity) : 0;\n        case \"lt\":\n            return isFinite(num) ? (num >= 0 ? num : Infinity) : 0;\n        case \"gt\":\n            return isFinite(num) ? Infinity : 0;\n        default:\n            return Infinity;\n    }\n}\nexports.getLimit = getLimit;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/cheerio-select/lib/positionals.js?");

/***/ }),

/***/ "./src/node_modules/cheerio/lib/api/attributes.js":
/*!********************************************************!*\
  !*** ./src/node_modules/cheerio/lib/api/attributes.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/**\n * Methods for getting and modifying attributes.\n *\n * @module cheerio/attributes\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.toggleClass = exports.removeClass = exports.addClass = exports.hasClass = exports.removeAttr = exports.val = exports.data = exports.prop = exports.attr = void 0;\nvar static_1 = __webpack_require__(/*! ../static */ \"./src/node_modules/cheerio/lib/static.js\");\nvar utils_1 = __webpack_require__(/*! ../utils */ \"./src/node_modules/cheerio/lib/utils.js\");\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar rspace = /\\s+/;\nvar dataAttrPrefix = 'data-';\n/*\n * Lookup table for coercing string data-* attributes to their corresponding\n * JavaScript primitives\n */\nvar primitives = {\n    null: null,\n    true: true,\n    false: false,\n};\n// Attributes that are booleans\nvar rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i;\n// Matches strings that look like JSON objects or arrays\nvar rbrace = /^{[^]*}$|^\\[[^]*]$/;\nfunction getAttr(elem, name, xmlMode) {\n    var _a;\n    if (!elem || !utils_1.isTag(elem))\n        return undefined;\n    (_a = elem.attribs) !== null && _a !== void 0 ? _a : (elem.attribs = {});\n    // Return the entire attribs object if no attribute specified\n    if (!name) {\n        return elem.attribs;\n    }\n    if (hasOwn.call(elem.attribs, name)) {\n        // Get the (decoded) attribute\n        return !xmlMode && rboolean.test(name) ? name : elem.attribs[name];\n    }\n    // Mimic the DOM and return text content as value for `option's`\n    if (elem.name === 'option' && name === 'value') {\n        return static_1.text(elem.children);\n    }\n    // Mimic DOM with default value for radios/checkboxes\n    if (elem.name === 'input' &&\n        (elem.attribs.type === 'radio' || elem.attribs.type === 'checkbox') &&\n        name === 'value') {\n        return 'on';\n    }\n    return undefined;\n}\n/**\n * Sets the value of an attribute. The attribute will be deleted if the value is `null`.\n *\n * @private\n * @param el - The element to set the attribute on.\n * @param name - The attribute's name.\n * @param value - The attribute's value.\n */\nfunction setAttr(el, name, value) {\n    if (value === null) {\n        removeAttribute(el, name);\n    }\n    else {\n        el.attribs[name] = \"\" + value;\n    }\n}\nfunction attr(name, value) {\n    // Set the value (with attr map support)\n    if (typeof name === 'object' || value !== undefined) {\n        if (typeof value === 'function') {\n            if (typeof name !== 'string') {\n                {\n                    throw new Error('Bad combination of arguments.');\n                }\n            }\n            return utils_1.domEach(this, function (el, i) {\n                if (utils_1.isTag(el))\n                    setAttr(el, name, value.call(el, i, el.attribs[name]));\n            });\n        }\n        return utils_1.domEach(this, function (el) {\n            if (!utils_1.isTag(el))\n                return;\n            if (typeof name === 'object') {\n                Object.keys(name).forEach(function (objName) {\n                    var objValue = name[objName];\n                    setAttr(el, objName, objValue);\n                });\n            }\n            else {\n                setAttr(el, name, value);\n            }\n        });\n    }\n    return arguments.length > 1\n        ? this\n        : getAttr(this[0], name, this.options.xmlMode);\n}\nexports.attr = attr;\n/**\n * Gets a node's prop.\n *\n * @private\n * @category Attributes\n * @param el - Elenent to get the prop of.\n * @param name - Name of the prop.\n * @returns The prop's value.\n */\nfunction getProp(el, name, xmlMode) {\n    if (!el || !utils_1.isTag(el))\n        return;\n    return name in el\n        ? // @ts-expect-error TS doesn't like us accessing the value directly here.\n            el[name]\n        : !xmlMode && rboolean.test(name)\n            ? getAttr(el, name, false) !== undefined\n            : getAttr(el, name, xmlMode);\n}\n/**\n * Sets the value of a prop.\n *\n * @private\n * @param el - The element to set the prop on.\n * @param name - The prop's name.\n * @param value - The prop's value.\n */\nfunction setProp(el, name, value, xmlMode) {\n    if (name in el) {\n        // @ts-expect-error Overriding value\n        el[name] = value;\n    }\n    else {\n        setAttr(el, name, !xmlMode && rboolean.test(name) ? (value ? '' : null) : \"\" + value);\n    }\n}\nfunction prop(name, value) {\n    var _this = this;\n    if (typeof name === 'string' && value === undefined) {\n        switch (name) {\n            case 'style': {\n                var property_1 = this.css();\n                var keys = Object.keys(property_1);\n                keys.forEach(function (p, i) {\n                    property_1[i] = p;\n                });\n                property_1.length = keys.length;\n                return property_1;\n            }\n            case 'tagName':\n            case 'nodeName': {\n                var el = this[0];\n                return utils_1.isTag(el) ? el.name.toUpperCase() : undefined;\n            }\n            case 'outerHTML':\n                return this.clone().wrap('<container />').parent().html();\n            case 'innerHTML':\n                return this.html();\n            default:\n                return getProp(this[0], name, this.options.xmlMode);\n        }\n    }\n    if (typeof name === 'object' || value !== undefined) {\n        if (typeof value === 'function') {\n            if (typeof name === 'object') {\n                throw new Error('Bad combination of arguments.');\n            }\n            return utils_1.domEach(this, function (el, i) {\n                if (utils_1.isTag(el))\n                    setProp(el, name, value.call(el, i, getProp(el, name, _this.options.xmlMode)), _this.options.xmlMode);\n            });\n        }\n        return utils_1.domEach(this, function (el) {\n            if (!utils_1.isTag(el))\n                return;\n            if (typeof name === 'object') {\n                Object.keys(name).forEach(function (key) {\n                    var val = name[key];\n                    setProp(el, key, val, _this.options.xmlMode);\n                });\n            }\n            else {\n                setProp(el, name, value, _this.options.xmlMode);\n            }\n        });\n    }\n    return undefined;\n}\nexports.prop = prop;\n/**\n * Sets the value of a data attribute.\n *\n * @private\n * @param el - The element to set the data attribute on.\n * @param name - The data attribute's name.\n * @param value - The data attribute's value.\n */\nfunction setData(el, name, value) {\n    var _a;\n    var elem = el;\n    (_a = elem.data) !== null && _a !== void 0 ? _a : (elem.data = {});\n    if (typeof name === 'object')\n        Object.assign(elem.data, name);\n    else if (typeof name === 'string' && value !== undefined) {\n        elem.data[name] = value;\n    }\n}\n/**\n * Read the specified attribute from the equivalent HTML5 `data-*` attribute,\n * and (if present) cache the value in the node's internal data store. If no\n * attribute name is specified, read *all* HTML5 `data-*` attributes in this manner.\n *\n * @private\n * @category Attributes\n * @param el - Elenent to get the data attribute of.\n * @param name - Name of the data attribute.\n * @returns The data attribute's value, or a map with all of the data attribute.\n */\nfunction readData(el, name) {\n    var domNames;\n    var jsNames;\n    var value;\n    if (name == null) {\n        domNames = Object.keys(el.attribs).filter(function (attrName) {\n            return attrName.startsWith(dataAttrPrefix);\n        });\n        jsNames = domNames.map(function (domName) {\n            return utils_1.camelCase(domName.slice(dataAttrPrefix.length));\n        });\n    }\n    else {\n        domNames = [dataAttrPrefix + utils_1.cssCase(name)];\n        jsNames = [name];\n    }\n    for (var idx = 0; idx < domNames.length; ++idx) {\n        var domName = domNames[idx];\n        var jsName = jsNames[idx];\n        if (hasOwn.call(el.attribs, domName) &&\n            !hasOwn.call(el.data, jsName)) {\n            value = el.attribs[domName];\n            if (hasOwn.call(primitives, value)) {\n                value = primitives[value];\n            }\n            else if (value === String(Number(value))) {\n                value = Number(value);\n            }\n            else if (rbrace.test(value)) {\n                try {\n                    value = JSON.parse(value);\n                }\n                catch (e) {\n                    /* Ignore */\n                }\n            }\n            el.data[jsName] = value;\n        }\n    }\n    return name == null ? el.data : value;\n}\nfunction data(name, value) {\n    var _a;\n    var elem = this[0];\n    if (!elem || !utils_1.isTag(elem))\n        return;\n    var dataEl = elem;\n    (_a = dataEl.data) !== null && _a !== void 0 ? _a : (dataEl.data = {});\n    // Return the entire data object if no data specified\n    if (!name) {\n        return readData(dataEl);\n    }\n    // Set the value (with attr map support)\n    if (typeof name === 'object' || value !== undefined) {\n        utils_1.domEach(this, function (el) {\n            if (utils_1.isTag(el))\n                if (typeof name === 'object')\n                    setData(el, name);\n                else\n                    setData(el, name, value);\n        });\n        return this;\n    }\n    if (hasOwn.call(dataEl.data, name)) {\n        return dataEl.data[name];\n    }\n    return readData(dataEl, name);\n}\nexports.data = data;\nfunction val(value) {\n    var querying = arguments.length === 0;\n    var element = this[0];\n    if (!element || !utils_1.isTag(element))\n        return querying ? undefined : this;\n    switch (element.name) {\n        case 'textarea':\n            return this.text(value);\n        case 'select': {\n            var option = this.find('option:selected');\n            if (!querying) {\n                if (this.attr('multiple') == null && typeof value === 'object') {\n                    return this;\n                }\n                this.find('option').removeAttr('selected');\n                var values = typeof value !== 'object' ? [value] : value;\n                for (var i = 0; i < values.length; i++) {\n                    this.find(\"option[value=\\\"\" + values[i] + \"\\\"]\").attr('selected', '');\n                }\n                return this;\n            }\n            return this.attr('multiple')\n                ? option.toArray().map(function (el) { return static_1.text(el.children); })\n                : option.attr('value');\n        }\n        case 'input':\n        case 'option':\n            return querying\n                ? this.attr('value')\n                : this.attr('value', value);\n    }\n    return undefined;\n}\nexports.val = val;\n/**\n * Remove an attribute.\n *\n * @private\n * @param elem - Node to remove attribute from.\n * @param name - Name of the attribute to remove.\n */\nfunction removeAttribute(elem, name) {\n    if (!elem.attribs || !hasOwn.call(elem.attribs, name))\n        return;\n    delete elem.attribs[name];\n}\n/**\n * Splits a space-separated list of names to individual names.\n *\n * @category Attributes\n * @param names - Names to split.\n * @returns - Split names.\n */\nfunction splitNames(names) {\n    return names ? names.trim().split(rspace) : [];\n}\n/**\n * Method for removing attributes by `name`.\n *\n * @category Attributes\n * @example\n *\n * ```js\n * $('.pear').removeAttr('class').html();\n * //=> <li>Pear</li>\n *\n * $('.apple').attr('id', 'favorite');\n * $('.apple').removeAttr('id class').html();\n * //=> <li>Apple</li>\n * ```\n *\n * @param name - Name of the attribute.\n * @returns The instance itself.\n * @see {@link https://api.jquery.com/removeAttr/}\n */\nfunction removeAttr(name) {\n    var attrNames = splitNames(name);\n    var _loop_1 = function (i) {\n        utils_1.domEach(this_1, function (elem) {\n            if (utils_1.isTag(elem))\n                removeAttribute(elem, attrNames[i]);\n        });\n    };\n    var this_1 = this;\n    for (var i = 0; i < attrNames.length; i++) {\n        _loop_1(i);\n    }\n    return this;\n}\nexports.removeAttr = removeAttr;\n/**\n * Check to see if *any* of the matched elements have the given `className`.\n *\n * @category Attributes\n * @example\n *\n * ```js\n * $('.pear').hasClass('pear');\n * //=> true\n *\n * $('apple').hasClass('fruit');\n * //=> false\n *\n * $('li').hasClass('pear');\n * //=> true\n * ```\n *\n * @param className - Name of the class.\n * @returns Indicates if an element has the given `className`.\n * @see {@link https://api.jquery.com/hasClass/}\n */\nfunction hasClass(className) {\n    return this.toArray().some(function (elem) {\n        var clazz = utils_1.isTag(elem) && elem.attribs.class;\n        var idx = -1;\n        if (clazz && className.length) {\n            while ((idx = clazz.indexOf(className, idx + 1)) > -1) {\n                var end = idx + className.length;\n                if ((idx === 0 || rspace.test(clazz[idx - 1])) &&\n                    (end === clazz.length || rspace.test(clazz[end]))) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    });\n}\nexports.hasClass = hasClass;\n/**\n * Adds class(es) to all of the matched elements. Also accepts a `function`.\n *\n * @category Attributes\n * @example\n *\n * ```js\n * $('.pear').addClass('fruit').html();\n * //=> <li class=\"pear fruit\">Pear</li>\n *\n * $('.apple').addClass('fruit red').html();\n * //=> <li class=\"apple fruit red\">Apple</li>\n * ```\n *\n * @param value - Name of new class.\n * @returns The instance itself.\n * @see {@link https://api.jquery.com/addClass/}\n */\nfunction addClass(value) {\n    // Support functions\n    if (typeof value === 'function') {\n        return utils_1.domEach(this, function (el, i) {\n            if (utils_1.isTag(el)) {\n                var className = el.attribs.class || '';\n                addClass.call([el], value.call(el, i, className));\n            }\n        });\n    }\n    // Return if no value or not a string or function\n    if (!value || typeof value !== 'string')\n        return this;\n    var classNames = value.split(rspace);\n    var numElements = this.length;\n    for (var i = 0; i < numElements; i++) {\n        var el = this[i];\n        // If selected element isn't a tag, move on\n        if (!utils_1.isTag(el))\n            continue;\n        // If we don't already have classes — always set xmlMode to false here, as it doesn't matter for classes\n        var className = getAttr(el, 'class', false);\n        if (!className) {\n            setAttr(el, 'class', classNames.join(' ').trim());\n        }\n        else {\n            var setClass = \" \" + className + \" \";\n            // Check if class already exists\n            for (var j = 0; j < classNames.length; j++) {\n                var appendClass = classNames[j] + \" \";\n                if (!setClass.includes(\" \" + appendClass))\n                    setClass += appendClass;\n            }\n            setAttr(el, 'class', setClass.trim());\n        }\n    }\n    return this;\n}\nexports.addClass = addClass;\n/**\n * Removes one or more space-separated classes from the selected elements. If no\n * `className` is defined, all classes will be removed. Also accepts a `function`.\n *\n * @category Attributes\n * @example\n *\n * ```js\n * $('.pear').removeClass('pear').html();\n * //=> <li class=\"\">Pear</li>\n *\n * $('.apple').addClass('red').removeClass().html();\n * //=> <li class=\"\">Apple</li>\n * ```\n *\n * @param name - Name of the class. If not specified, removes all elements.\n * @returns The instance itself.\n * @see {@link https://api.jquery.com/removeClass/}\n */\nfunction removeClass(name) {\n    // Handle if value is a function\n    if (typeof name === 'function') {\n        return utils_1.domEach(this, function (el, i) {\n            if (utils_1.isTag(el))\n                removeClass.call([el], name.call(el, i, el.attribs.class || ''));\n        });\n    }\n    var classes = splitNames(name);\n    var numClasses = classes.length;\n    var removeAll = arguments.length === 0;\n    return utils_1.domEach(this, function (el) {\n        if (!utils_1.isTag(el))\n            return;\n        if (removeAll) {\n            // Short circuit the remove all case as this is the nice one\n            el.attribs.class = '';\n        }\n        else {\n            var elClasses = splitNames(el.attribs.class);\n            var changed = false;\n            for (var j = 0; j < numClasses; j++) {\n                var index = elClasses.indexOf(classes[j]);\n                if (index >= 0) {\n                    elClasses.splice(index, 1);\n                    changed = true;\n                    /*\n                     * We have to do another pass to ensure that there are not duplicate\n                     * classes listed\n                     */\n                    j--;\n                }\n            }\n            if (changed) {\n                el.attribs.class = elClasses.join(' ');\n            }\n        }\n    });\n}\nexports.removeClass = removeClass;\n/**\n * Add or remove class(es) from the matched elements, depending on either the\n * class's presence or the value of the switch argument. Also accepts a `function`.\n *\n * @category Attributes\n * @example\n *\n * ```js\n * $('.apple.green').toggleClass('fruit green red').html();\n * //=> <li class=\"apple fruit red\">Apple</li>\n *\n * $('.apple.green').toggleClass('fruit green red', true).html();\n * //=> <li class=\"apple green fruit red\">Apple</li>\n * ```\n *\n * @param value - Name of the class. Can also be a function.\n * @param stateVal - If specified the state of the class.\n * @returns The instance itself.\n * @see {@link https://api.jquery.com/toggleClass/}\n */\nfunction toggleClass(value, stateVal) {\n    // Support functions\n    if (typeof value === 'function') {\n        return utils_1.domEach(this, function (el, i) {\n            if (utils_1.isTag(el)) {\n                toggleClass.call([el], value.call(el, i, el.attribs.class || '', stateVal), stateVal);\n            }\n        });\n    }\n    // Return if no value or not a string or function\n    if (!value || typeof value !== 'string')\n        return this;\n    var classNames = value.split(rspace);\n    var numClasses = classNames.length;\n    var state = typeof stateVal === 'boolean' ? (stateVal ? 1 : -1) : 0;\n    var numElements = this.length;\n    for (var i = 0; i < numElements; i++) {\n        var el = this[i];\n        // If selected element isn't a tag, move on\n        if (!utils_1.isTag(el))\n            continue;\n        var elementClasses = splitNames(el.attribs.class);\n        // Check if class already exists\n        for (var j = 0; j < numClasses; j++) {\n            // Check if the class name is currently defined\n            var index = elementClasses.indexOf(classNames[j]);\n            // Add if stateValue === true or we are toggling and there is no value\n            if (state >= 0 && index < 0) {\n                elementClasses.push(classNames[j]);\n            }\n            else if (state <= 0 && index >= 0) {\n                // Otherwise remove but only if the item exists\n                elementClasses.splice(index, 1);\n            }\n        }\n        el.attribs.class = elementClasses.join(' ');\n    }\n    return this;\n}\nexports.toggleClass = toggleClass;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/cheerio/lib/api/attributes.js?");

/***/ }),

/***/ "./src/node_modules/cheerio/lib/api/css.js":
/*!*************************************************!*\
  !*** ./src/node_modules/cheerio/lib/api/css.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.css = void 0;\nvar utils_1 = __webpack_require__(/*! ../utils */ \"./src/node_modules/cheerio/lib/utils.js\");\nfunction css(prop, val) {\n    if ((prop != null && val != null) ||\n        // When `prop` is a \"plain\" object\n        (typeof prop === 'object' && !Array.isArray(prop))) {\n        return utils_1.domEach(this, function (el, i) {\n            if (utils_1.isTag(el)) {\n                // `prop` can't be an array here anymore.\n                setCss(el, prop, val, i);\n            }\n        });\n    }\n    return getCss(this[0], prop);\n}\nexports.css = css;\n/**\n * Set styles of all elements.\n *\n * @private\n * @param el - Element to set style of.\n * @param prop - Name of property.\n * @param value - Value to set property to.\n * @param idx - Optional index within the selection.\n */\nfunction setCss(el, prop, value, idx) {\n    if (typeof prop === 'string') {\n        var styles = getCss(el);\n        var val = typeof value === 'function' ? value.call(el, idx, styles[prop]) : value;\n        if (val === '') {\n            delete styles[prop];\n        }\n        else if (val != null) {\n            styles[prop] = val;\n        }\n        el.attribs.style = stringify(styles);\n    }\n    else if (typeof prop === 'object') {\n        Object.keys(prop).forEach(function (k, i) {\n            setCss(el, k, prop[k], i);\n        });\n    }\n}\nfunction getCss(el, prop) {\n    if (!el || !utils_1.isTag(el))\n        return;\n    var styles = parse(el.attribs.style);\n    if (typeof prop === 'string') {\n        return styles[prop];\n    }\n    if (Array.isArray(prop)) {\n        var newStyles_1 = {};\n        prop.forEach(function (item) {\n            if (styles[item] != null) {\n                newStyles_1[item] = styles[item];\n            }\n        });\n        return newStyles_1;\n    }\n    return styles;\n}\n/**\n * Stringify `obj` to styles.\n *\n * @private\n * @category CSS\n * @param obj - Object to stringify.\n * @returns The serialized styles.\n */\nfunction stringify(obj) {\n    return Object.keys(obj).reduce(function (str, prop) { return \"\" + str + (str ? ' ' : '') + prop + \": \" + obj[prop] + \";\"; }, '');\n}\n/**\n * Parse `styles`.\n *\n * @private\n * @category CSS\n * @param styles - Styles to be parsed.\n * @returns The parsed styles.\n */\nfunction parse(styles) {\n    styles = (styles || '').trim();\n    if (!styles)\n        return {};\n    return styles.split(';').reduce(function (obj, str) {\n        var n = str.indexOf(':');\n        // Skip if there is no :, or if it is the first/last character\n        if (n < 1 || n === str.length - 1)\n            return obj;\n        obj[str.slice(0, n).trim()] = str.slice(n + 1).trim();\n        return obj;\n    }, {});\n}\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/cheerio/lib/api/css.js?");

/***/ }),

/***/ "./src/node_modules/cheerio/lib/api/forms.js":
/*!***************************************************!*\
  !*** ./src/node_modules/cheerio/lib/api/forms.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.serializeArray = exports.serialize = void 0;\nvar utils_1 = __webpack_require__(/*! ../utils */ \"./src/node_modules/cheerio/lib/utils.js\");\n/*\n * https://github.com/jquery/jquery/blob/2.1.3/src/manipulation/var/rcheckableType.js\n * https://github.com/jquery/jquery/blob/2.1.3/src/serialize.js\n */\nvar submittableSelector = 'input,select,textarea,keygen';\nvar r20 = /%20/g;\nvar rCRLF = /\\r?\\n/g;\n/**\n * Encode a set of form elements as a string for submission.\n *\n * @category Forms\n * @returns The serialized form.\n * @see {@link https://api.jquery.com/serialize/}\n */\nfunction serialize() {\n    // Convert form elements into name/value objects\n    var arr = this.serializeArray();\n    // Serialize each element into a key/value string\n    var retArr = arr.map(function (data) {\n        return encodeURIComponent(data.name) + \"=\" + encodeURIComponent(data.value);\n    });\n    // Return the resulting serialization\n    return retArr.join('&').replace(r20, '+');\n}\nexports.serialize = serialize;\n/**\n * Encode a set of form elements as an array of names and values.\n *\n * @category Forms\n * @example\n *\n * ```js\n * $('<form><input name=\"foo\" value=\"bar\" /></form>').serializeArray();\n * //=> [ { name: 'foo', value: 'bar' } ]\n * ```\n *\n * @returns The serialized form.\n * @see {@link https://api.jquery.com/serializeArray/}\n */\nfunction serializeArray() {\n    var _this = this;\n    // Resolve all form elements from either forms or collections of form elements\n    return this.map(function (_, elem) {\n        var $elem = _this._make(elem);\n        if (utils_1.isTag(elem) && elem.name === 'form') {\n            return $elem.find(submittableSelector).toArray();\n        }\n        return $elem.filter(submittableSelector).toArray();\n    })\n        .filter(\n    // Verify elements have a name (`attr.name`) and are not disabled (`:enabled`)\n    '[name!=\"\"]:enabled' +\n        // And cannot be clicked (`[type=submit]`) or are used in `x-www-form-urlencoded` (`[type=file]`)\n        ':not(:submit, :button, :image, :reset, :file)' +\n        // And are either checked/don't have a checkable state\n        ':matches([checked], :not(:checkbox, :radio))'\n    // Convert each of the elements to its value(s)\n    )\n        .map(function (_, elem) {\n        var _a;\n        var $elem = _this._make(elem);\n        var name = $elem.attr('name'); // We have filtered for elements with a name before.\n        // If there is no value set (e.g. `undefined`, `null`), then default value to empty\n        var value = (_a = $elem.val()) !== null && _a !== void 0 ? _a : '';\n        // If we have an array of values (e.g. `<select multiple>`), return an array of key/value pairs\n        if (Array.isArray(value)) {\n            return value.map(function (val) {\n                /*\n                 * We trim replace any line endings (e.g. `\\r` or `\\r\\n` with `\\r\\n`) to guarantee consistency across platforms\n                 * These can occur inside of `<textarea>'s`\n                 */\n                return ({ name: name, value: val.replace(rCRLF, '\\r\\n') });\n            });\n        }\n        // Otherwise (e.g. `<input type=\"text\">`, return only one key/value pair\n        return { name: name, value: value.replace(rCRLF, '\\r\\n') };\n    })\n        .toArray();\n}\nexports.serializeArray = serializeArray;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/cheerio/lib/api/forms.js?");

/***/ }),

/***/ "./src/node_modules/cheerio/lib/api/manipulation.js":
/*!**********************************************************!*\
  !*** ./src/node_modules/cheerio/lib/api/manipulation.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.clone = exports.text = exports.toString = exports.html = exports.empty = exports.replaceWith = exports.remove = exports.insertBefore = exports.before = exports.insertAfter = exports.after = exports.wrapAll = exports.unwrap = exports.wrapInner = exports.wrap = exports.prepend = exports.append = exports.prependTo = exports.appendTo = exports._makeDomArray = void 0;\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\nvar domhandler_1 = __webpack_require__(/*! domhandler */ \"./src/node_modules/domhandler/lib/index.js\");\n/**\n * Methods for modifying the DOM structure.\n *\n * @module cheerio/manipulation\n */\nvar domhandler_2 = __webpack_require__(/*! domhandler */ \"./src/node_modules/domhandler/lib/index.js\");\nvar parse_1 = tslib_1.__importStar(__webpack_require__(/*! ../parse */ \"./src/node_modules/cheerio/lib/parse.js\"));\nvar static_1 = __webpack_require__(/*! ../static */ \"./src/node_modules/cheerio/lib/static.js\");\nvar utils_1 = __webpack_require__(/*! ../utils */ \"./src/node_modules/cheerio/lib/utils.js\");\nvar htmlparser2_1 = __webpack_require__(/*! htmlparser2 */ \"./src/node_modules/htmlparser2/lib/index.js\");\n/**\n * Create an array of nodes, recursing into arrays and parsing strings if necessary.\n *\n * @private\n * @category Manipulation\n * @param elem - Elements to make an array of.\n * @param clone - Optionally clone nodes.\n * @returns The array of nodes.\n */\nfunction _makeDomArray(elem, clone) {\n    var _this = this;\n    if (elem == null) {\n        return [];\n    }\n    if (utils_1.isCheerio(elem)) {\n        return clone ? utils_1.cloneDom(elem.get()) : elem.get();\n    }\n    if (Array.isArray(elem)) {\n        return elem.reduce(function (newElems, el) { return newElems.concat(_this._makeDomArray(el, clone)); }, []);\n    }\n    if (typeof elem === 'string') {\n        return parse_1.default(elem, this.options, false).children;\n    }\n    return clone ? utils_1.cloneDom([elem]) : [elem];\n}\nexports._makeDomArray = _makeDomArray;\nfunction _insert(concatenator) {\n    return function () {\n        var _this = this;\n        var elems = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            elems[_i] = arguments[_i];\n        }\n        var lastIdx = this.length - 1;\n        return utils_1.domEach(this, function (el, i) {\n            if (!domhandler_1.hasChildren(el))\n                return;\n            var domSrc = typeof elems[0] === 'function'\n                ? elems[0].call(el, i, static_1.html(el.children))\n                : elems;\n            var dom = _this._makeDomArray(domSrc, i < lastIdx);\n            concatenator(dom, el.children, el);\n        });\n    };\n}\n/**\n * Modify an array in-place, removing some number of elements and adding new\n * elements directly following them.\n *\n * @private\n * @category Manipulation\n * @param array - Target array to splice.\n * @param spliceIdx - Index at which to begin changing the array.\n * @param spliceCount - Number of elements to remove from the array.\n * @param newElems - Elements to insert into the array.\n * @param parent - The parent of the node.\n * @returns The spliced array.\n */\nfunction uniqueSplice(array, spliceIdx, spliceCount, newElems, parent) {\n    var _a, _b;\n    var spliceArgs = tslib_1.__spreadArray([\n        spliceIdx,\n        spliceCount\n    ], newElems);\n    var prev = array[spliceIdx - 1] || null;\n    var next = array[spliceIdx + spliceCount] || null;\n    /*\n     * Before splicing in new elements, ensure they do not already appear in the\n     * current array.\n     */\n    for (var idx = 0; idx < newElems.length; ++idx) {\n        var node = newElems[idx];\n        var oldParent = node.parent;\n        if (oldParent) {\n            var prevIdx = oldParent.children.indexOf(newElems[idx]);\n            if (prevIdx > -1) {\n                oldParent.children.splice(prevIdx, 1);\n                if (parent === oldParent && spliceIdx > prevIdx) {\n                    spliceArgs[0]--;\n                }\n            }\n        }\n        node.parent = parent;\n        if (node.prev) {\n            node.prev.next = (_a = node.next) !== null && _a !== void 0 ? _a : null;\n        }\n        if (node.next) {\n            node.next.prev = (_b = node.prev) !== null && _b !== void 0 ? _b : null;\n        }\n        node.prev = newElems[idx - 1] || prev;\n        node.next = newElems[idx + 1] || next;\n    }\n    if (prev) {\n        prev.next = newElems[0];\n    }\n    if (next) {\n        next.prev = newElems[newElems.length - 1];\n    }\n    return array.splice.apply(array, spliceArgs);\n}\n/**\n * Insert every element in the set of matched elements to the end of the target.\n *\n * @category Manipulation\n * @example\n *\n * ```js\n * $('<li class=\"plum\">Plum</li>').appendTo('#fruits');\n * $.html();\n * //=>  <ul id=\"fruits\">\n * //      <li class=\"apple\">Apple</li>\n * //      <li class=\"orange\">Orange</li>\n * //      <li class=\"pear\">Pear</li>\n * //      <li class=\"plum\">Plum</li>\n * //    </ul>\n * ```\n *\n * @param target - Element to append elements to.\n * @returns The instance itself.\n * @see {@link https://api.jquery.com/appendTo/}\n */\nfunction appendTo(target) {\n    var appendTarget = utils_1.isCheerio(target) ? target : this._make(target);\n    appendTarget.append(this);\n    return this;\n}\nexports.appendTo = appendTo;\n/**\n * Insert every element in the set of matched elements to the beginning of the target.\n *\n * @category Manipulation\n * @example\n *\n * ```js\n * $('<li class=\"plum\">Plum</li>').prependTo('#fruits');\n * $.html();\n * //=>  <ul id=\"fruits\">\n * //      <li class=\"plum\">Plum</li>\n * //      <li class=\"apple\">Apple</li>\n * //      <li class=\"orange\">Orange</li>\n * //      <li class=\"pear\">Pear</li>\n * //    </ul>\n * ```\n *\n * @param target - Element to prepend elements to.\n * @returns The instance itself.\n * @see {@link https://api.jquery.com/prependTo/}\n */\nfunction prependTo(target) {\n    var prependTarget = utils_1.isCheerio(target) ? target : this._make(target);\n    prependTarget.prepend(this);\n    return this;\n}\nexports.prependTo = prependTo;\n/**\n * Inserts content as the *last* child of each of the selected elements.\n *\n * @category Manipulation\n * @example\n *\n * ```js\n * $('ul').append('<li class=\"plum\">Plum</li>');\n * $.html();\n * //=>  <ul id=\"fruits\">\n * //      <li class=\"apple\">Apple</li>\n * //      <li class=\"orange\">Orange</li>\n * //      <li class=\"pear\">Pear</li>\n * //      <li class=\"plum\">Plum</li>\n * //    </ul>\n * ```\n *\n * @see {@link https://api.jquery.com/append/}\n */\nexports.append = _insert(function (dom, children, parent) {\n    uniqueSplice(children, children.length, 0, dom, parent);\n});\n/**\n * Inserts content as the *first* child of each of the selected elements.\n *\n * @category Manipulation\n * @example\n *\n * ```js\n * $('ul').prepend('<li class=\"plum\">Plum</li>');\n * $.html();\n * //=>  <ul id=\"fruits\">\n * //      <li class=\"plum\">Plum</li>\n * //      <li class=\"apple\">Apple</li>\n * //      <li class=\"orange\">Orange</li>\n * //      <li class=\"pear\">Pear</li>\n * //    </ul>\n * ```\n *\n * @see {@link https://api.jquery.com/prepend/}\n */\nexports.prepend = _insert(function (dom, children, parent) {\n    uniqueSplice(children, 0, 0, dom, parent);\n});\nfunction _wrap(insert) {\n    return function (wrapper) {\n        var lastIdx = this.length - 1;\n        var lastParent = this.parents().last();\n        for (var i = 0; i < this.length; i++) {\n            var el = this[i];\n            var wrap_1 = typeof wrapper === 'function'\n                ? wrapper.call(el, i, el)\n                : typeof wrapper === 'string' && !utils_1.isHtml(wrapper)\n                    ? lastParent.find(wrapper).clone()\n                    : wrapper;\n            var wrapperDom = this._makeDomArray(wrap_1, i < lastIdx)[0];\n            if (!wrapperDom || !htmlparser2_1.DomUtils.hasChildren(wrapperDom))\n                continue;\n            var elInsertLocation = wrapperDom;\n            /*\n             * Find the deepest child. Only consider the first tag child of each node\n             * (ignore text); stop if no children are found.\n             */\n            var j = 0;\n            while (j < elInsertLocation.children.length) {\n                var child = elInsertLocation.children[j];\n                if (utils_1.isTag(child)) {\n                    elInsertLocation = child;\n                    j = 0;\n                }\n                else {\n                    j++;\n                }\n            }\n            insert(el, elInsertLocation, [wrapperDom]);\n        }\n        return this;\n    };\n}\n/**\n * The .wrap() function can take any string or object that could be passed to\n * the $() factory function to specify a DOM structure. This structure may be\n * nested several levels deep, but should contain only one inmost element. A\n * copy of this structure will be wrapped around each of the elements in the set\n * of matched elements. This method returns the original set of elements for\n * chaining purposes.\n *\n * @category Manipulation\n * @example\n *\n * ```js\n * const redFruit = $('<div class=\"red-fruit\"></div>');\n * $('.apple').wrap(redFruit);\n *\n * //=> <ul id=\"fruits\">\n * //     <div class=\"red-fruit\">\n * //      <li class=\"apple\">Apple</li>\n * //     </div>\n * //     <li class=\"orange\">Orange</li>\n * //     <li class=\"plum\">Plum</li>\n * //   </ul>\n *\n * const healthy = $('<div class=\"healthy\"></div>');\n * $('li').wrap(healthy);\n *\n * //=> <ul id=\"fruits\">\n * //     <div class=\"healthy\">\n * //       <li class=\"apple\">Apple</li>\n * //     </div>\n * //     <div class=\"healthy\">\n * //       <li class=\"orange\">Orange</li>\n * //     </div>\n * //     <div class=\"healthy\">\n * //        <li class=\"plum\">Plum</li>\n * //     </div>\n * //   </ul>\n * ```\n *\n * @param wrapper - The DOM structure to wrap around each element in the selection.\n * @see {@link https://api.jquery.com/wrap/}\n */\nexports.wrap = _wrap(function (el, elInsertLocation, wrapperDom) {\n    var parent = el.parent;\n    if (!parent)\n        return;\n    var siblings = parent.children;\n    var index = siblings.indexOf(el);\n    parse_1.update([el], elInsertLocation);\n    /*\n     * The previous operation removed the current element from the `siblings`\n     * array, so the `dom` array can be inserted without removing any\n     * additional elements.\n     */\n    uniqueSplice(siblings, index, 0, wrapperDom, parent);\n});\n/**\n * The .wrapInner() function can take any string or object that could be passed\n * to the $() factory function to specify a DOM structure. This structure may be\n * nested several levels deep, but should contain only one inmost element. The\n * structure will be wrapped around the content of each of the elements in the\n * set of matched elements.\n *\n * @category Manipulation\n * @example\n *\n * ```js\n * const redFruit = $('<div class=\"red-fruit\"></div>');\n * $('.apple').wrapInner(redFruit);\n *\n * //=> <ul id=\"fruits\">\n * //     <li class=\"apple\">\n * //       <div class=\"red-fruit\">Apple</div>\n * //     </li>\n * //     <li class=\"orange\">Orange</li>\n * //     <li class=\"pear\">Pear</li>\n * //   </ul>\n *\n * const healthy = $('<div class=\"healthy\"></div>');\n * $('li').wrapInner(healthy);\n *\n * //=> <ul id=\"fruits\">\n * //     <li class=\"apple\">\n * //       <div class=\"healthy\">Apple</div>\n * //     </li>\n * //     <li class=\"orange\">\n * //       <div class=\"healthy\">Orange</div>\n * //     </li>\n * //     <li class=\"pear\">\n * //       <div class=\"healthy\">Pear</div>\n * //     </li>\n * //   </ul>\n * ```\n *\n * @param wrapper - The DOM structure to wrap around the content of each element\n *   in the selection.\n * @returns The instance itself, for chaining.\n * @see {@link https://api.jquery.com/wrapInner/}\n */\nexports.wrapInner = _wrap(function (el, elInsertLocation, wrapperDom) {\n    if (!domhandler_1.hasChildren(el))\n        return;\n    parse_1.update(el.children, elInsertLocation);\n    parse_1.update(wrapperDom, el);\n});\n/**\n * The .unwrap() function, removes the parents of the set of matched elements\n * from the DOM, leaving the matched elements in their place.\n *\n * @category Manipulation\n * @example <caption>without selector</caption>\n *\n * ```js\n * const $ = cheerio.load(\n *   '<div id=test>\\n  <div><p>Hello</p></div>\\n  <div><p>World</p></div>\\n</div>'\n * );\n * $('#test p').unwrap();\n *\n * //=> <div id=test>\n * //     <p>Hello</p>\n * //     <p>World</p>\n * //   </div>\n * ```\n *\n * @example <caption>with selector</caption>\n *\n * ```js\n * const $ = cheerio.load(\n *   '<div id=test>\\n  <p>Hello</p>\\n  <b><p>World</p></b>\\n</div>'\n * );\n * $('#test p').unwrap('b');\n *\n * //=> <div id=test>\n * //     <p>Hello</p>\n * //     <p>World</p>\n * //   </div>\n * ```\n *\n * @param selector - A selector to check the parent element against. If an\n *   element's parent does not match the selector, the element won't be unwrapped.\n * @returns The instance itself, for chaining.\n * @see {@link https://api.jquery.com/unwrap/}\n */\nfunction unwrap(selector) {\n    var _this = this;\n    this.parent(selector)\n        .not('body')\n        .each(function (_, el) {\n        _this._make(el).replaceWith(el.children);\n    });\n    return this;\n}\nexports.unwrap = unwrap;\n/**\n * The .wrapAll() function can take any string or object that could be passed to\n * the $() function to specify a DOM structure. This structure may be nested\n * several levels deep, but should contain only one inmost element. The\n * structure will be wrapped around all of the elements in the set of matched\n * elements, as a single group.\n *\n * @category Manipulation\n * @example <caption>With markup passed to `wrapAll`</caption>\n *\n * ```js\n * const $ = cheerio.load(\n *   '<div class=\"container\"><div class=\"inner\">First</div><div class=\"inner\">Second</div></div>'\n * );\n * $('.inner').wrapAll(\"<div class='new'></div>\");\n *\n * //=> <div class=\"container\">\n * //     <div class='new'>\n * //       <div class=\"inner\">First</div>\n * //       <div class=\"inner\">Second</div>\n * //     </div>\n * //   </div>\n * ```\n *\n * @example <caption>With an existing cheerio instance</caption>\n *\n * ```js\n * const $ = cheerio.load(\n *   '<span>Span 1</span><strong>Strong</strong><span>Span 2</span>'\n * );\n * const wrap = $('<div><p><em><b></b></em></p></div>');\n * $('span').wrapAll(wrap);\n *\n * //=> <div>\n * //     <p>\n * //       <em>\n * //         <b>\n * //           <span>Span 1</span>\n * //           <span>Span 2</span>\n * //         </b>\n * //       </em>\n * //     </p>\n * //   </div>\n * //   <strong>Strong</strong>\n * ```\n *\n * @param wrapper - The DOM structure to wrap around all matched elements in the\n *   selection.\n * @returns The instance itself.\n * @see {@link https://api.jquery.com/wrapAll/}\n */\nfunction wrapAll(wrapper) {\n    var el = this[0];\n    if (el) {\n        var wrap_2 = this._make(typeof wrapper === 'function' ? wrapper.call(el, 0, el) : wrapper).insertBefore(el);\n        // If html is given as wrapper, wrap may contain text elements\n        var elInsertLocation = void 0;\n        for (var i = 0; i < wrap_2.length; i++) {\n            if (wrap_2[i].type === 'tag')\n                elInsertLocation = wrap_2[i];\n        }\n        var j = 0;\n        /*\n         * Find the deepest child. Only consider the first tag child of each node\n         * (ignore text); stop if no children are found.\n         */\n        while (elInsertLocation && j < elInsertLocation.children.length) {\n            var child = elInsertLocation.children[j];\n            if (child.type === 'tag') {\n                elInsertLocation = child;\n                j = 0;\n            }\n            else {\n                j++;\n            }\n        }\n        if (elInsertLocation)\n            this._make(elInsertLocation).append(this);\n    }\n    return this;\n}\nexports.wrapAll = wrapAll;\n/* eslint-disable jsdoc/check-param-names*/\n/**\n * Insert content next to each element in the set of matched elements.\n *\n * @category Manipulation\n * @example\n *\n * ```js\n * $('.apple').after('<li class=\"plum\">Plum</li>');\n * $.html();\n * //=>  <ul id=\"fruits\">\n * //      <li class=\"apple\">Apple</li>\n * //      <li class=\"plum\">Plum</li>\n * //      <li class=\"orange\">Orange</li>\n * //      <li class=\"pear\">Pear</li>\n * //    </ul>\n * ```\n *\n * @param content - HTML string, DOM element, array of DOM elements or Cheerio\n *   to insert after each element in the set of matched elements.\n * @returns The instance itself.\n * @see {@link https://api.jquery.com/after/}\n */\nfunction after() {\n    var _this = this;\n    var elems = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        elems[_i] = arguments[_i];\n    }\n    var lastIdx = this.length - 1;\n    return utils_1.domEach(this, function (el, i) {\n        var parent = el.parent;\n        if (!htmlparser2_1.DomUtils.hasChildren(el) || !parent) {\n            return;\n        }\n        var siblings = parent.children;\n        var index = siblings.indexOf(el);\n        // If not found, move on\n        /* istanbul ignore next */\n        if (index < 0)\n            return;\n        var domSrc = typeof elems[0] === 'function'\n            ? elems[0].call(el, i, static_1.html(el.children))\n            : elems;\n        var dom = _this._makeDomArray(domSrc, i < lastIdx);\n        // Add element after `this` element\n        uniqueSplice(siblings, index + 1, 0, dom, parent);\n    });\n}\nexports.after = after;\n/* eslint-enable jsdoc/check-param-names*/\n/**\n * Insert every element in the set of matched elements after the target.\n *\n * @category Manipulation\n * @example\n *\n * ```js\n * $('<li class=\"plum\">Plum</li>').insertAfter('.apple');\n * $.html();\n * //=>  <ul id=\"fruits\">\n * //      <li class=\"apple\">Apple</li>\n * //      <li class=\"plum\">Plum</li>\n * //      <li class=\"orange\">Orange</li>\n * //      <li class=\"pear\">Pear</li>\n * //    </ul>\n * ```\n *\n * @param target - Element to insert elements after.\n * @returns The set of newly inserted elements.\n * @see {@link https://api.jquery.com/insertAfter/}\n */\nfunction insertAfter(target) {\n    var _this = this;\n    if (typeof target === 'string') {\n        target = this._make(target);\n    }\n    this.remove();\n    var clones = [];\n    this._makeDomArray(target).forEach(function (el) {\n        var clonedSelf = _this.clone().toArray();\n        var parent = el.parent;\n        if (!parent) {\n            return;\n        }\n        var siblings = parent.children;\n        var index = siblings.indexOf(el);\n        // If not found, move on\n        /* istanbul ignore next */\n        if (index < 0)\n            return;\n        // Add cloned `this` element(s) after target element\n        uniqueSplice(siblings, index + 1, 0, clonedSelf, parent);\n        clones.push.apply(clones, clonedSelf);\n    });\n    return this._make(clones);\n}\nexports.insertAfter = insertAfter;\n/* eslint-disable jsdoc/check-param-names*/\n/**\n * Insert content previous to each element in the set of matched elements.\n *\n * @category Manipulation\n * @example\n *\n * ```js\n * $('.apple').before('<li class=\"plum\">Plum</li>');\n * $.html();\n * //=>  <ul id=\"fruits\">\n * //      <li class=\"plum\">Plum</li>\n * //      <li class=\"apple\">Apple</li>\n * //      <li class=\"orange\">Orange</li>\n * //      <li class=\"pear\">Pear</li>\n * //    </ul>\n * ```\n *\n * @param content - HTML string, DOM element, array of DOM elements or Cheerio\n *   to insert before each element in the set of matched elements.\n * @returns The instance itself.\n * @see {@link https://api.jquery.com/before/}\n */\nfunction before() {\n    var _this = this;\n    var elems = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        elems[_i] = arguments[_i];\n    }\n    var lastIdx = this.length - 1;\n    return utils_1.domEach(this, function (el, i) {\n        var parent = el.parent;\n        if (!htmlparser2_1.DomUtils.hasChildren(el) || !parent) {\n            return;\n        }\n        var siblings = parent.children;\n        var index = siblings.indexOf(el);\n        // If not found, move on\n        /* istanbul ignore next */\n        if (index < 0)\n            return;\n        var domSrc = typeof elems[0] === 'function'\n            ? elems[0].call(el, i, static_1.html(el.children))\n            : elems;\n        var dom = _this._makeDomArray(domSrc, i < lastIdx);\n        // Add element before `el` element\n        uniqueSplice(siblings, index, 0, dom, parent);\n    });\n}\nexports.before = before;\n/* eslint-enable jsdoc/check-param-names*/\n/**\n * Insert every element in the set of matched elements before the target.\n *\n * @category Manipulation\n * @example\n *\n * ```js\n * $('<li class=\"plum\">Plum</li>').insertBefore('.apple');\n * $.html();\n * //=>  <ul id=\"fruits\">\n * //      <li class=\"plum\">Plum</li>\n * //      <li class=\"apple\">Apple</li>\n * //      <li class=\"orange\">Orange</li>\n * //      <li class=\"pear\">Pear</li>\n * //    </ul>\n * ```\n *\n * @param target - Element to insert elements before.\n * @returns The set of newly inserted elements.\n * @see {@link https://api.jquery.com/insertBefore/}\n */\nfunction insertBefore(target) {\n    var _this = this;\n    var targetArr = this._make(target);\n    this.remove();\n    var clones = [];\n    utils_1.domEach(targetArr, function (el) {\n        var clonedSelf = _this.clone().toArray();\n        var parent = el.parent;\n        if (!parent) {\n            return;\n        }\n        var siblings = parent.children;\n        var index = siblings.indexOf(el);\n        // If not found, move on\n        /* istanbul ignore next */\n        if (index < 0)\n            return;\n        // Add cloned `this` element(s) after target element\n        uniqueSplice(siblings, index, 0, clonedSelf, parent);\n        clones.push.apply(clones, clonedSelf);\n    });\n    return this._make(clones);\n}\nexports.insertBefore = insertBefore;\n/**\n * Removes the set of matched elements from the DOM and all their children.\n * `selector` filters the set of matched elements to be removed.\n *\n * @category Manipulation\n * @example\n *\n * ```js\n * $('.pear').remove();\n * $.html();\n * //=>  <ul id=\"fruits\">\n * //      <li class=\"apple\">Apple</li>\n * //      <li class=\"orange\">Orange</li>\n * //    </ul>\n * ```\n *\n * @param selector - Optional selector for elements to remove.\n * @returns The instance itself.\n * @see {@link https://api.jquery.com/remove/}\n */\nfunction remove(selector) {\n    // Filter if we have selector\n    var elems = selector ? this.filter(selector) : this;\n    utils_1.domEach(elems, function (el) {\n        htmlparser2_1.DomUtils.removeElement(el);\n        el.prev = el.next = el.parent = null;\n    });\n    return this;\n}\nexports.remove = remove;\n/**\n * Replaces matched elements with `content`.\n *\n * @category Manipulation\n * @example\n *\n * ```js\n * const plum = $('<li class=\"plum\">Plum</li>');\n * $('.pear').replaceWith(plum);\n * $.html();\n * //=> <ul id=\"fruits\">\n * //     <li class=\"apple\">Apple</li>\n * //     <li class=\"orange\">Orange</li>\n * //     <li class=\"plum\">Plum</li>\n * //   </ul>\n * ```\n *\n * @param content - Replacement for matched elements.\n * @returns The instance itself.\n * @see {@link https://api.jquery.com/replaceWith/}\n */\nfunction replaceWith(content) {\n    var _this = this;\n    return utils_1.domEach(this, function (el, i) {\n        var parent = el.parent;\n        if (!parent) {\n            return;\n        }\n        var siblings = parent.children;\n        var cont = typeof content === 'function' ? content.call(el, i, el) : content;\n        var dom = _this._makeDomArray(cont);\n        /*\n         * In the case that `dom` contains nodes that already exist in other\n         * structures, ensure those nodes are properly removed.\n         */\n        parse_1.update(dom, null);\n        var index = siblings.indexOf(el);\n        // Completely remove old element\n        uniqueSplice(siblings, index, 1, dom, parent);\n        if (!dom.includes(el)) {\n            el.parent = el.prev = el.next = null;\n        }\n    });\n}\nexports.replaceWith = replaceWith;\n/**\n * Empties an element, removing all its children.\n *\n * @category Manipulation\n * @example\n *\n * ```js\n * $('ul').empty();\n * $.html();\n * //=>  <ul id=\"fruits\"></ul>\n * ```\n *\n * @returns The instance itself.\n * @see {@link https://api.jquery.com/empty/}\n */\nfunction empty() {\n    return utils_1.domEach(this, function (el) {\n        if (!htmlparser2_1.DomUtils.hasChildren(el))\n            return;\n        el.children.forEach(function (child) {\n            child.next = child.prev = child.parent = null;\n        });\n        el.children.length = 0;\n    });\n}\nexports.empty = empty;\nfunction html(str) {\n    if (str === undefined) {\n        var el = this[0];\n        if (!el || !htmlparser2_1.DomUtils.hasChildren(el))\n            return null;\n        return static_1.html(el.children, this.options);\n    }\n    // Keep main options unchanged\n    var opts = tslib_1.__assign(tslib_1.__assign({}, this.options), { context: null });\n    return utils_1.domEach(this, function (el) {\n        if (!htmlparser2_1.DomUtils.hasChildren(el))\n            return;\n        el.children.forEach(function (child) {\n            child.next = child.prev = child.parent = null;\n        });\n        opts.context = el;\n        var content = utils_1.isCheerio(str)\n            ? str.toArray()\n            : parse_1.default(\"\" + str, opts, false).children;\n        parse_1.update(content, el);\n    });\n}\nexports.html = html;\n/**\n * Turns the collection to a string. Alias for `.html()`.\n *\n * @category Manipulation\n * @returns The rendered document.\n */\nfunction toString() {\n    return static_1.html(this, this.options);\n}\nexports.toString = toString;\nfunction text(str) {\n    var _this = this;\n    // If `str` is undefined, act as a \"getter\"\n    if (str === undefined) {\n        return static_1.text(this);\n    }\n    if (typeof str === 'function') {\n        // Function support\n        return utils_1.domEach(this, function (el, i) {\n            text.call(_this._make(el), str.call(el, i, static_1.text([el])));\n        });\n    }\n    // Append text node to each selected elements\n    return utils_1.domEach(this, function (el) {\n        if (!htmlparser2_1.DomUtils.hasChildren(el))\n            return;\n        el.children.forEach(function (child) {\n            child.next = child.prev = child.parent = null;\n        });\n        var textNode = new domhandler_2.Text(str);\n        parse_1.update(textNode, el);\n    });\n}\nexports.text = text;\n/**\n * Clone the cheerio object.\n *\n * @category Manipulation\n * @example\n *\n * ```js\n * const moreFruit = $('#fruits').clone();\n * ```\n *\n * @returns The cloned object.\n * @see {@link https://api.jquery.com/clone/}\n */\nfunction clone() {\n    return this._make(utils_1.cloneDom(this.get()));\n}\nexports.clone = clone;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/cheerio/lib/api/manipulation.js?");

/***/ }),

/***/ "./src/node_modules/cheerio/lib/api/traversing.js":
/*!********************************************************!*\
  !*** ./src/node_modules/cheerio/lib/api/traversing.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/**\n * Methods for traversing the DOM structure.\n *\n * @module cheerio/traversing\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.addBack = exports.add = exports.end = exports.slice = exports.index = exports.toArray = exports.get = exports.eq = exports.last = exports.first = exports.has = exports.not = exports.is = exports.filterArray = exports.filter = exports.map = exports.each = exports.contents = exports.children = exports.siblings = exports.prevUntil = exports.prevAll = exports.prev = exports.nextUntil = exports.nextAll = exports.next = exports.closest = exports.parentsUntil = exports.parents = exports.parent = exports.find = void 0;\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\nvar domhandler_1 = __webpack_require__(/*! domhandler */ \"./src/node_modules/domhandler/lib/index.js\");\nvar select = tslib_1.__importStar(__webpack_require__(/*! cheerio-select */ \"./src/node_modules/cheerio-select/lib/index.js\"));\nvar utils_1 = __webpack_require__(/*! ../utils */ \"./src/node_modules/cheerio/lib/utils.js\");\nvar static_1 = __webpack_require__(/*! ../static */ \"./src/node_modules/cheerio/lib/static.js\");\nvar htmlparser2_1 = __webpack_require__(/*! htmlparser2 */ \"./src/node_modules/htmlparser2/lib/index.js\");\nvar uniqueSort = htmlparser2_1.DomUtils.uniqueSort;\nvar reSiblingSelector = /^\\s*[~+]/;\n/**\n * Get the descendants of each element in the current set of matched elements,\n * filtered by a selector, jQuery object, or element.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('#fruits').find('li').length;\n * //=> 3\n * $('#fruits').find($('.apple')).length;\n * //=> 1\n * ```\n *\n * @param selectorOrHaystack - Element to look for.\n * @returns The found elements.\n * @see {@link https://api.jquery.com/find/}\n */\nfunction find(selectorOrHaystack) {\n    var _a;\n    if (!selectorOrHaystack) {\n        return this._make([]);\n    }\n    var context = this.toArray();\n    if (typeof selectorOrHaystack !== 'string') {\n        var haystack = utils_1.isCheerio(selectorOrHaystack)\n            ? selectorOrHaystack.toArray()\n            : [selectorOrHaystack];\n        return this._make(haystack.filter(function (elem) { return context.some(function (node) { return static_1.contains(node, elem); }); }));\n    }\n    var elems = reSiblingSelector.test(selectorOrHaystack)\n        ? context\n        : this.children().toArray();\n    var options = {\n        context: context,\n        root: (_a = this._root) === null || _a === void 0 ? void 0 : _a[0],\n        xmlMode: this.options.xmlMode,\n    };\n    return this._make(select.select(selectorOrHaystack, elems, options));\n}\nexports.find = find;\n/**\n * Creates a matcher, using a particular mapping function. Matchers provide a\n * function that finds elements using a generating function, supporting filtering.\n *\n * @private\n * @param matchMap - Mapping function.\n * @returns - Function for wrapping generating functions.\n */\nfunction _getMatcher(matchMap) {\n    return function (fn) {\n        var postFns = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            postFns[_i - 1] = arguments[_i];\n        }\n        return function (selector) {\n            var _a;\n            var matched = matchMap(fn, this);\n            if (selector) {\n                matched = filterArray(matched, selector, this.options.xmlMode, (_a = this._root) === null || _a === void 0 ? void 0 : _a[0]);\n            }\n            return this._make(\n            // Post processing is only necessary if there is more than one element.\n            this.length > 1 && matched.length > 1\n                ? postFns.reduce(function (elems, fn) { return fn(elems); }, matched)\n                : matched);\n        };\n    };\n}\n/** Matcher that adds multiple elements for each entry in the input. */\nvar _matcher = _getMatcher(function (fn, elems) {\n    var _a;\n    var ret = [];\n    for (var i = 0; i < elems.length; i++) {\n        var value = fn(elems[i]);\n        ret.push(value);\n    }\n    return (_a = new Array()).concat.apply(_a, ret);\n});\n/** Matcher that adds at most one element for each entry in the input. */\nvar _singleMatcher = _getMatcher(function (fn, elems) {\n    var ret = [];\n    for (var i = 0; i < elems.length; i++) {\n        var value = fn(elems[i]);\n        if (value !== null) {\n            ret.push(value);\n        }\n    }\n    return ret;\n});\n/**\n * Matcher that supports traversing until a condition is met.\n *\n * @returns A function usable for `*Until` methods.\n */\nfunction _matchUntil(nextElem) {\n    var postFns = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        postFns[_i - 1] = arguments[_i];\n    }\n    // We use a variable here that is used from within the matcher.\n    var matches = null;\n    var innerMatcher = _getMatcher(function (nextElem, elems) {\n        var matched = [];\n        utils_1.domEach(elems, function (elem) {\n            for (var next_1; (next_1 = nextElem(elem)); elem = next_1) {\n                // FIXME: `matched` might contain duplicates here and the index is too large.\n                if (matches === null || matches === void 0 ? void 0 : matches(next_1, matched.length))\n                    break;\n                matched.push(next_1);\n            }\n        });\n        return matched;\n    }).apply(void 0, tslib_1.__spreadArray([nextElem], postFns));\n    return function (selector, filterSelector) {\n        var _this = this;\n        // Override `matches` variable with the new target.\n        matches =\n            typeof selector === 'string'\n                ? function (elem) { return select.is(elem, selector, _this.options); }\n                : selector\n                    ? getFilterFn(selector)\n                    : null;\n        var ret = innerMatcher.call(this, filterSelector);\n        // Set `matches` to `null`, so we don't waste memory.\n        matches = null;\n        return ret;\n    };\n}\nfunction _removeDuplicates(elems) {\n    return Array.from(new Set(elems));\n}\n/**\n * Get the parent of each element in the current set of matched elements,\n * optionally filtered by a selector.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('.pear').parent().attr('id');\n * //=> fruits\n * ```\n *\n * @param selector - If specified filter for parent.\n * @returns The parents.\n * @see {@link https://api.jquery.com/parent/}\n */\nexports.parent = _singleMatcher(function (_a) {\n    var parent = _a.parent;\n    return (parent && !domhandler_1.isDocument(parent) ? parent : null);\n}, _removeDuplicates);\n/**\n * Get a set of parents filtered by `selector` of each element in the current\n * set of match elements.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('.orange').parents().length;\n * //=> 2\n * $('.orange').parents('#fruits').length;\n * //=> 1\n * ```\n *\n * @param selector - If specified filter for parents.\n * @returns The parents.\n * @see {@link https://api.jquery.com/parents/}\n */\nexports.parents = _matcher(function (elem) {\n    var matched = [];\n    while (elem.parent && !domhandler_1.isDocument(elem.parent)) {\n        matched.push(elem.parent);\n        elem = elem.parent;\n    }\n    return matched;\n}, uniqueSort, function (elems) { return elems.reverse(); });\n/**\n * Get the ancestors of each element in the current set of matched elements, up\n * to but not including the element matched by the selector, DOM node, or cheerio object.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('.orange').parentsUntil('#food').length;\n * //=> 1\n * ```\n *\n * @param selector - Selector for element to stop at.\n * @param filterSelector - Optional filter for parents.\n * @returns The parents.\n * @see {@link https://api.jquery.com/parentsUntil/}\n */\nexports.parentsUntil = _matchUntil(function (_a) {\n    var parent = _a.parent;\n    return (parent && !domhandler_1.isDocument(parent) ? parent : null);\n}, uniqueSort, function (elems) { return elems.reverse(); });\n/**\n * For each element in the set, get the first element that matches the selector\n * by testing the element itself and traversing up through its ancestors in the DOM tree.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('.orange').closest();\n * //=> []\n *\n * $('.orange').closest('.apple');\n * // => []\n *\n * $('.orange').closest('li');\n * //=> [<li class=\"orange\">Orange</li>]\n *\n * $('.orange').closest('#fruits');\n * //=> [<ul id=\"fruits\"> ... </ul>]\n * ```\n *\n * @param selector - Selector for the element to find.\n * @returns The closest nodes.\n * @see {@link https://api.jquery.com/closest/}\n */\nfunction closest(selector) {\n    var _this = this;\n    var set = [];\n    if (!selector) {\n        return this._make(set);\n    }\n    utils_1.domEach(this, function (elem) {\n        var _a;\n        while (elem && elem.type !== 'root') {\n            if (!selector ||\n                filterArray([elem], selector, _this.options.xmlMode, (_a = _this._root) === null || _a === void 0 ? void 0 : _a[0])\n                    .length) {\n                // Do not add duplicate elements to the set\n                if (elem && !set.includes(elem)) {\n                    set.push(elem);\n                }\n                break;\n            }\n            elem = elem.parent;\n        }\n    });\n    return this._make(set);\n}\nexports.closest = closest;\n/**\n * Gets the next sibling of the first selected element, optionally filtered by a selector.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('.apple').next().hasClass('orange');\n * //=> true\n * ```\n *\n * @param selector - If specified filter for sibling.\n * @returns The next nodes.\n * @see {@link https://api.jquery.com/next/}\n */\nexports.next = _singleMatcher(function (elem) { return htmlparser2_1.DomUtils.nextElementSibling(elem); });\n/**\n * Gets all the following siblings of the first selected element, optionally\n * filtered by a selector.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('.apple').nextAll();\n * //=> [<li class=\"orange\">Orange</li>, <li class=\"pear\">Pear</li>]\n * $('.apple').nextAll('.orange');\n * //=> [<li class=\"orange\">Orange</li>]\n * ```\n *\n * @param selector - If specified filter for siblings.\n * @returns The next nodes.\n * @see {@link https://api.jquery.com/nextAll/}\n */\nexports.nextAll = _matcher(function (elem) {\n    var matched = [];\n    while (elem.next) {\n        elem = elem.next;\n        if (utils_1.isTag(elem))\n            matched.push(elem);\n    }\n    return matched;\n}, _removeDuplicates);\n/**\n * Gets all the following siblings up to but not including the element matched\n * by the selector, optionally filtered by another selector.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('.apple').nextUntil('.pear');\n * //=> [<li class=\"orange\">Orange</li>]\n * ```\n *\n * @param selector - Selector for element to stop at.\n * @param filterSelector - If specified filter for siblings.\n * @returns The next nodes.\n * @see {@link https://api.jquery.com/nextUntil/}\n */\nexports.nextUntil = _matchUntil(function (el) { return htmlparser2_1.DomUtils.nextElementSibling(el); }, _removeDuplicates);\n/**\n * Gets the previous sibling of the first selected element optionally filtered\n * by a selector.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('.orange').prev().hasClass('apple');\n * //=> true\n * ```\n *\n * @param selector - If specified filter for siblings.\n * @returns The previous nodes.\n * @see {@link https://api.jquery.com/prev/}\n */\nexports.prev = _singleMatcher(function (elem) { return htmlparser2_1.DomUtils.prevElementSibling(elem); });\n/**\n * Gets all the preceding siblings of the first selected element, optionally\n * filtered by a selector.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('.pear').prevAll();\n * //=> [<li class=\"orange\">Orange</li>, <li class=\"apple\">Apple</li>]\n *\n * $('.pear').prevAll('.orange');\n * //=> [<li class=\"orange\">Orange</li>]\n * ```\n *\n * @param selector - If specified filter for siblings.\n * @returns The previous nodes.\n * @see {@link https://api.jquery.com/prevAll/}\n */\nexports.prevAll = _matcher(function (elem) {\n    var matched = [];\n    while (elem.prev) {\n        elem = elem.prev;\n        if (utils_1.isTag(elem))\n            matched.push(elem);\n    }\n    return matched;\n}, _removeDuplicates);\n/**\n * Gets all the preceding siblings up to but not including the element matched\n * by the selector, optionally filtered by another selector.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('.pear').prevUntil('.apple');\n * //=> [<li class=\"orange\">Orange</li>]\n * ```\n *\n * @param selector - Selector for element to stop at.\n * @param filterSelector - If specified filter for siblings.\n * @returns The previous nodes.\n * @see {@link https://api.jquery.com/prevUntil/}\n */\nexports.prevUntil = _matchUntil(function (el) { return htmlparser2_1.DomUtils.prevElementSibling(el); }, _removeDuplicates);\n/**\n * Get the siblings of each element (excluding the element) in the set of\n * matched elements, optionally filtered by a selector.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('.pear').siblings().length;\n * //=> 2\n *\n * $('.pear').siblings('.orange').length;\n * //=> 1\n * ```\n *\n * @param selector - If specified filter for siblings.\n * @returns The siblings.\n * @see {@link https://api.jquery.com/siblings/}\n */\nexports.siblings = _matcher(function (elem) {\n    return htmlparser2_1.DomUtils.getSiblings(elem).filter(function (el) { return utils_1.isTag(el) && el !== elem; });\n}, uniqueSort);\n/**\n * Gets the children of the first selected element.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('#fruits').children().length;\n * //=> 3\n *\n * $('#fruits').children('.pear').text();\n * //=> Pear\n * ```\n *\n * @param selector - If specified filter for children.\n * @returns The children.\n * @see {@link https://api.jquery.com/children/}\n */\nexports.children = _matcher(function (elem) { return htmlparser2_1.DomUtils.getChildren(elem).filter(utils_1.isTag); }, _removeDuplicates);\n/**\n * Gets the children of each element in the set of matched elements, including\n * text and comment nodes.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('#fruits').contents().length;\n * //=> 3\n * ```\n *\n * @returns The children.\n * @see {@link https://api.jquery.com/contents/}\n */\nfunction contents() {\n    var elems = this.toArray().reduce(function (newElems, elem) {\n        return domhandler_1.hasChildren(elem) ? newElems.concat(elem.children) : newElems;\n    }, []);\n    return this._make(elems);\n}\nexports.contents = contents;\n/**\n * Iterates over a cheerio object, executing a function for each matched\n * element. When the callback is fired, the function is fired in the context of\n * the DOM element, so `this` refers to the current element, which is equivalent\n * to the function parameter `element`. To break out of the `each` loop early,\n * return with `false`.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * const fruits = [];\n *\n * $('li').each(function (i, elem) {\n *   fruits[i] = $(this).text();\n * });\n *\n * fruits.join(', ');\n * //=> Apple, Orange, Pear\n * ```\n *\n * @param fn - Function to execute.\n * @returns The instance itself, useful for chaining.\n * @see {@link https://api.jquery.com/each/}\n */\nfunction each(fn) {\n    var i = 0;\n    var len = this.length;\n    while (i < len && fn.call(this[i], i, this[i]) !== false)\n        ++i;\n    return this;\n}\nexports.each = each;\n/**\n * Pass each element in the current matched set through a function, producing a\n * new Cheerio object containing the return values. The function can return an\n * individual data item or an array of data items to be inserted into the\n * resulting set. If an array is returned, the elements inside the array are\n * inserted into the set. If the function returns null or undefined, no element\n * will be inserted.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('li')\n *   .map(function (i, el) {\n *     // this === el\n *     return $(this).text();\n *   })\n *   .toArray()\n *   .join(' ');\n * //=> \"apple orange pear\"\n * ```\n *\n * @param fn - Function to execute.\n * @returns The mapped elements, wrapped in a Cheerio collection.\n * @see {@link https://api.jquery.com/map/}\n */\nfunction map(fn) {\n    var elems = [];\n    for (var i = 0; i < this.length; i++) {\n        var el = this[i];\n        var val = fn.call(el, i, el);\n        if (val != null) {\n            elems = elems.concat(val);\n        }\n    }\n    return this._make(elems);\n}\nexports.map = map;\n/**\n * Creates a function to test if a filter is matched.\n *\n * @param match - A filter.\n * @returns A function that determines if a filter has been matched.\n */\nfunction getFilterFn(match) {\n    if (typeof match === 'function') {\n        return function (el, i) { return match.call(el, i, el); };\n    }\n    if (utils_1.isCheerio(match)) {\n        return function (el) { return Array.prototype.includes.call(match, el); };\n    }\n    return function (el) {\n        return match === el;\n    };\n}\nfunction filter(match) {\n    var _a;\n    return this._make(filterArray(this.toArray(), match, this.options.xmlMode, (_a = this._root) === null || _a === void 0 ? void 0 : _a[0]));\n}\nexports.filter = filter;\nfunction filterArray(nodes, match, xmlMode, root) {\n    return typeof match === 'string'\n        ? select.filter(match, nodes, { xmlMode: xmlMode, root: root })\n        : nodes.filter(getFilterFn(match));\n}\nexports.filterArray = filterArray;\n/**\n * Checks the current list of elements and returns `true` if *any* of the\n * elements match the selector. If using an element or Cheerio selection,\n * returns `true` if *any* of the elements match. If using a predicate function,\n * the function is executed in the context of the selected element, so `this`\n * refers to the current element.\n *\n * @category Attributes\n * @param selector - Selector for the selection.\n * @returns Whether or not the selector matches an element of the instance.\n * @see {@link https://api.jquery.com/is/}\n */\nfunction is(selector) {\n    var nodes = this.toArray();\n    return typeof selector === 'string'\n        ? select.some(nodes.filter(utils_1.isTag), selector, this.options)\n        : selector\n            ? nodes.some(getFilterFn(selector))\n            : false;\n}\nexports.is = is;\n/**\n * Remove elements from the set of matched elements. Given a Cheerio object that\n * represents a set of DOM elements, the `.not()` method constructs a new\n * Cheerio object from a subset of the matching elements. The supplied selector\n * is tested against each element; the elements that don't match the selector\n * will be included in the result.\n *\n * The `.not()` method can take a function as its argument in the same way that\n * `.filter()` does. Elements for which the function returns `true` are excluded\n * from the filtered set; all other elements are included.\n *\n * @category Traversing\n * @example <caption>Selector</caption>\n *\n * ```js\n * $('li').not('.apple').length;\n * //=> 2\n * ```\n *\n * @example <caption>Function</caption>\n *\n * ```js\n * $('li').not(function (i, el) {\n *   // this === el\n *   return $(this).attr('class') === 'orange';\n * }).length; //=> 2\n * ```\n *\n * @param match - Value to look for, following the rules above.\n * @param container - Optional node to filter instead.\n * @returns The filtered collection.\n * @see {@link https://api.jquery.com/not/}\n */\nfunction not(match) {\n    var nodes = this.toArray();\n    if (typeof match === 'string') {\n        var matches_1 = new Set(select.filter(match, nodes, this.options));\n        nodes = nodes.filter(function (el) { return !matches_1.has(el); });\n    }\n    else {\n        var filterFn_1 = getFilterFn(match);\n        nodes = nodes.filter(function (el, i) { return !filterFn_1(el, i); });\n    }\n    return this._make(nodes);\n}\nexports.not = not;\n/**\n * Filters the set of matched elements to only those which have the given DOM\n * element as a descendant or which have a descendant that matches the given\n * selector. Equivalent to `.filter(':has(selector)')`.\n *\n * @category Traversing\n * @example <caption>Selector</caption>\n *\n * ```js\n * $('ul').has('.pear').attr('id');\n * //=> fruits\n * ```\n *\n * @example <caption>Element</caption>\n *\n * ```js\n * $('ul').has($('.pear')[0]).attr('id');\n * //=> fruits\n * ```\n *\n * @param selectorOrHaystack - Element to look for.\n * @returns The filtered collection.\n * @see {@link https://api.jquery.com/has/}\n */\nfunction has(selectorOrHaystack) {\n    var _this = this;\n    return this.filter(typeof selectorOrHaystack === 'string'\n        ? // Using the `:has` selector here short-circuits searches.\n            \":has(\" + selectorOrHaystack + \")\"\n        : function (_, el) { return _this._make(el).find(selectorOrHaystack).length > 0; });\n}\nexports.has = has;\n/**\n * Will select the first element of a cheerio object.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('#fruits').children().first().text();\n * //=> Apple\n * ```\n *\n * @returns The first element.\n * @see {@link https://api.jquery.com/first/}\n */\nfunction first() {\n    return this.length > 1 ? this._make(this[0]) : this;\n}\nexports.first = first;\n/**\n * Will select the last element of a cheerio object.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('#fruits').children().last().text();\n * //=> Pear\n * ```\n *\n * @returns The last element.\n * @see {@link https://api.jquery.com/last/}\n */\nfunction last() {\n    return this.length > 0 ? this._make(this[this.length - 1]) : this;\n}\nexports.last = last;\n/**\n * Reduce the set of matched elements to the one at the specified index. Use\n * `.eq(-i)` to count backwards from the last selected element.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('li').eq(0).text();\n * //=> Apple\n *\n * $('li').eq(-1).text();\n * //=> Pear\n * ```\n *\n * @param i - Index of the element to select.\n * @returns The element at the `i`th position.\n * @see {@link https://api.jquery.com/eq/}\n */\nfunction eq(i) {\n    var _a;\n    i = +i;\n    // Use the first identity optimization if possible\n    if (i === 0 && this.length <= 1)\n        return this;\n    if (i < 0)\n        i = this.length + i;\n    return this._make((_a = this[i]) !== null && _a !== void 0 ? _a : []);\n}\nexports.eq = eq;\nfunction get(i) {\n    if (i == null) {\n        return this.toArray();\n    }\n    return this[i < 0 ? this.length + i : i];\n}\nexports.get = get;\n/**\n * Retrieve all the DOM elements contained in the jQuery set as an array.\n *\n * @example\n *\n * ```js\n * $('li').toArray();\n * //=> [ {...}, {...}, {...} ]\n * ```\n *\n * @returns The contained items.\n */\nfunction toArray() {\n    return Array.prototype.slice.call(this);\n}\nexports.toArray = toArray;\n/**\n * Search for a given element from among the matched elements.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('.pear').index();\n * //=> 2 $('.orange').index('li');\n * //=> 1\n * $('.apple').index($('#fruit, li'));\n * //=> 1\n * ```\n *\n * @param selectorOrNeedle - Element to look for.\n * @returns The index of the element.\n * @see {@link https://api.jquery.com/index/}\n */\nfunction index(selectorOrNeedle) {\n    var $haystack;\n    var needle;\n    if (selectorOrNeedle == null) {\n        $haystack = this.parent().children();\n        needle = this[0];\n    }\n    else if (typeof selectorOrNeedle === 'string') {\n        $haystack = this._make(selectorOrNeedle);\n        needle = this[0];\n    }\n    else {\n        $haystack = this;\n        needle = utils_1.isCheerio(selectorOrNeedle)\n            ? selectorOrNeedle[0]\n            : selectorOrNeedle;\n    }\n    return Array.prototype.indexOf.call($haystack, needle);\n}\nexports.index = index;\n/**\n * Gets the elements matching the specified range (0-based position).\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('li').slice(1).eq(0).text();\n * //=> 'Orange'\n *\n * $('li').slice(1, 2).length;\n * //=> 1\n * ```\n *\n * @param start - An position at which the elements begin to be selected. If\n *   negative, it indicates an offset from the end of the set.\n * @param end - An position at which the elements stop being selected. If\n *   negative, it indicates an offset from the end of the set. If omitted, the\n *   range continues until the end of the set.\n * @returns The elements matching the specified range.\n * @see {@link https://api.jquery.com/slice/}\n */\nfunction slice(start, end) {\n    return this._make(Array.prototype.slice.call(this, start, end));\n}\nexports.slice = slice;\n/**\n * End the most recent filtering operation in the current chain and return the\n * set of matched elements to its previous state.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('li').eq(0).end().length;\n * //=> 3\n * ```\n *\n * @returns The previous state of the set of matched elements.\n * @see {@link https://api.jquery.com/end/}\n */\nfunction end() {\n    var _a;\n    return (_a = this.prevObject) !== null && _a !== void 0 ? _a : this._make([]);\n}\nexports.end = end;\n/**\n * Add elements to the set of matched elements.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('.apple').add('.orange').length;\n * //=> 2\n * ```\n *\n * @param other - Elements to add.\n * @param context - Optionally the context of the new selection.\n * @returns The combined set.\n * @see {@link https://api.jquery.com/add/}\n */\nfunction add(other, context) {\n    var selection = this._make(other, context);\n    var contents = uniqueSort(tslib_1.__spreadArray(tslib_1.__spreadArray([], this.get()), selection.get()));\n    return this._make(contents);\n}\nexports.add = add;\n/**\n * Add the previous set of elements on the stack to the current set, optionally\n * filtered by a selector.\n *\n * @category Traversing\n * @example\n *\n * ```js\n * $('li').eq(0).addBack('.orange').length;\n * //=> 2\n * ```\n *\n * @param selector - Selector for the elements to add.\n * @returns The combined set.\n * @see {@link https://api.jquery.com/addBack/}\n */\nfunction addBack(selector) {\n    return this.prevObject\n        ? this.add(selector ? this.prevObject.filter(selector) : this.prevObject)\n        : this;\n}\nexports.addBack = addBack;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/cheerio/lib/api/traversing.js?");

/***/ }),

/***/ "./src/node_modules/cheerio/lib/cheerio.js":
/*!*************************************************!*\
  !*** ./src/node_modules/cheerio/lib/cheerio.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Cheerio = void 0;\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\nvar parse_1 = tslib_1.__importDefault(__webpack_require__(/*! ./parse */ \"./src/node_modules/cheerio/lib/parse.js\"));\nvar options_1 = tslib_1.__importDefault(__webpack_require__(/*! ./options */ \"./src/node_modules/cheerio/lib/options.js\"));\nvar utils_1 = __webpack_require__(/*! ./utils */ \"./src/node_modules/cheerio/lib/utils.js\");\nvar Attributes = tslib_1.__importStar(__webpack_require__(/*! ./api/attributes */ \"./src/node_modules/cheerio/lib/api/attributes.js\"));\nvar Traversing = tslib_1.__importStar(__webpack_require__(/*! ./api/traversing */ \"./src/node_modules/cheerio/lib/api/traversing.js\"));\nvar Manipulation = tslib_1.__importStar(__webpack_require__(/*! ./api/manipulation */ \"./src/node_modules/cheerio/lib/api/manipulation.js\"));\nvar Css = tslib_1.__importStar(__webpack_require__(/*! ./api/css */ \"./src/node_modules/cheerio/lib/api/css.js\"));\nvar Forms = tslib_1.__importStar(__webpack_require__(/*! ./api/forms */ \"./src/node_modules/cheerio/lib/api/forms.js\"));\nvar Cheerio = /** @class */ (function () {\n    /**\n     * Instance of cheerio. Methods are specified in the modules. Usage of this\n     * constructor is not recommended. Please use $.load instead.\n     *\n     * @private\n     * @param selector - The new selection.\n     * @param context - Context of the selection.\n     * @param root - Sets the root node.\n     * @param options - Options for the instance.\n     */\n    function Cheerio(selector, context, root, options) {\n        var _this = this;\n        if (options === void 0) { options = options_1.default; }\n        this.length = 0;\n        this.options = options;\n        // $(), $(null), $(undefined), $(false)\n        if (!selector)\n            return this;\n        if (root) {\n            if (typeof root === 'string')\n                root = parse_1.default(root, this.options, false);\n            this._root = new this.constructor(root, null, null, this.options);\n            // Add a cyclic reference, so that calling methods on `_root` never fails.\n            this._root._root = this._root;\n        }\n        // $($)\n        if (utils_1.isCheerio(selector))\n            return selector;\n        var elements = typeof selector === 'string' && utils_1.isHtml(selector)\n            ? // $(<html>)\n                parse_1.default(selector, this.options, false).children\n            : isNode(selector)\n                ? // $(dom)\n                    [selector]\n                : Array.isArray(selector)\n                    ? // $([dom])\n                        selector\n                    : null;\n        if (elements) {\n            elements.forEach(function (elem, idx) {\n                _this[idx] = elem;\n            });\n            this.length = elements.length;\n            return this;\n        }\n        // We know that our selector is a string now.\n        var search = selector;\n        var searchContext = !context\n            ? // If we don't have a context, maybe we have a root, from loading\n                this._root\n            : typeof context === 'string'\n                ? utils_1.isHtml(context)\n                    ? // $('li', '<ul>...</ul>')\n                        this._make(parse_1.default(context, this.options, false))\n                    : // $('li', 'ul')\n                        ((search = context + \" \" + search), this._root)\n                : utils_1.isCheerio(context)\n                    ? // $('li', $)\n                        context\n                    : // $('li', node), $('li', [nodes])\n                        this._make(context);\n        // If we still don't have a context, return\n        if (!searchContext)\n            return this;\n        /*\n         * #id, .class, tag\n         */\n        // @ts-expect-error No good way to type this — we will always return `Cheerio<Element>` here.\n        return searchContext.find(search);\n    }\n    /**\n     * Make a cheerio object.\n     *\n     * @private\n     * @param dom - The contents of the new object.\n     * @param context - The context of the new object.\n     * @returns The new cheerio object.\n     */\n    Cheerio.prototype._make = function (dom, context) {\n        var cheerio = new this.constructor(dom, context, this._root, this.options);\n        cheerio.prevObject = this;\n        return cheerio;\n    };\n    return Cheerio;\n}());\nexports.Cheerio = Cheerio;\n/** Set a signature of the object. */\nCheerio.prototype.cheerio = '[cheerio object]';\n/*\n * Make cheerio an array-like object\n */\nCheerio.prototype.splice = Array.prototype.splice;\n// Support for (const element of $(...)) iteration:\nCheerio.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];\n// Plug in the API\nObject.assign(Cheerio.prototype, Attributes, Traversing, Manipulation, Css, Forms);\nfunction isNode(obj) {\n    return (!!obj.name ||\n        obj.type === 'root' ||\n        obj.type === 'text' ||\n        obj.type === 'comment');\n}\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/cheerio/lib/cheerio.js?");

/***/ }),

/***/ "./src/node_modules/cheerio/lib/index.js":
/*!***********************************************!*\
  !*** ./src/node_modules/cheerio/lib/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.root = exports.parseHTML = exports.merge = exports.contains = void 0;\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\n/**\n * Types used in signatures of Cheerio methods.\n *\n * @category Cheerio\n */\ntslib_1.__exportStar(__webpack_require__(/*! ./types */ \"./src/node_modules/cheerio/lib/types.js\"), exports);\ntslib_1.__exportStar(__webpack_require__(/*! ./load */ \"./src/node_modules/cheerio/lib/load.js\"), exports);\nvar load_1 = __webpack_require__(/*! ./load */ \"./src/node_modules/cheerio/lib/load.js\");\n/**\n * The default cheerio instance.\n *\n * @deprecated Use the function returned by `load` instead.\n */\nexports.default = load_1.load([]);\nvar staticMethods = tslib_1.__importStar(__webpack_require__(/*! ./static */ \"./src/node_modules/cheerio/lib/static.js\"));\n/**\n * In order to promote consistency with the jQuery library, users are encouraged\n * to instead use the static method of the same name.\n *\n * @deprecated\n * @example\n *\n * ```js\n * const $ = cheerio.load('<div><p></p></div>');\n *\n * $.contains($('div').get(0), $('p').get(0));\n * //=> true\n *\n * $.contains($('p').get(0), $('div').get(0));\n * //=> false\n * ```\n *\n * @returns {boolean}\n */\nexports.contains = staticMethods.contains;\n/**\n * In order to promote consistency with the jQuery library, users are encouraged\n * to instead use the static method of the same name.\n *\n * @deprecated\n * @example\n *\n * ```js\n * const $ = cheerio.load('');\n *\n * $.merge([1, 2], [3, 4]);\n * //=> [1, 2, 3, 4]\n * ```\n */\nexports.merge = staticMethods.merge;\n/**\n * In order to promote consistency with the jQuery library, users are encouraged\n * to instead use the static method of the same name as it is defined on the\n * \"loaded\" Cheerio factory function.\n *\n * @deprecated See {@link static/parseHTML}.\n * @example\n *\n * ```js\n * const $ = cheerio.load('');\n * $.parseHTML('<b>markup</b>');\n * ```\n */\nexports.parseHTML = staticMethods.parseHTML;\n/**\n * Users seeking to access the top-level element of a parsed document should\n * instead use the `root` static method of a \"loaded\" Cheerio function.\n *\n * @deprecated\n * @example\n *\n * ```js\n * const $ = cheerio.load('');\n * $.root();\n * ```\n */\nexports.root = staticMethods.root;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/cheerio/lib/index.js?");

/***/ }),

/***/ "./src/node_modules/cheerio/lib/load.js":
/*!**********************************************!*\
  !*** ./src/node_modules/cheerio/lib/load.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.load = void 0;\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\nvar options_1 = tslib_1.__importStar(__webpack_require__(/*! ./options */ \"./src/node_modules/cheerio/lib/options.js\"));\nvar staticMethods = tslib_1.__importStar(__webpack_require__(/*! ./static */ \"./src/node_modules/cheerio/lib/static.js\"));\nvar cheerio_1 = __webpack_require__(/*! ./cheerio */ \"./src/node_modules/cheerio/lib/cheerio.js\");\nvar parse_1 = tslib_1.__importDefault(__webpack_require__(/*! ./parse */ \"./src/node_modules/cheerio/lib/parse.js\"));\n/**\n * Create a querying function, bound to a document created from the provided\n * markup. Note that similar to web browser contexts, this operation may\n * introduce `<html>`, `<head>`, and `<body>` elements; set `isDocument` to\n * `false` to switch to fragment mode and disable this.\n *\n * @param content - Markup to be loaded.\n * @param options - Options for the created instance.\n * @param isDocument - Allows parser to be switched to fragment mode.\n * @returns The loaded document.\n * @see {@link https://cheerio.js.org#loading} for additional usage information.\n */\nfunction load(content, options, isDocument) {\n    if (isDocument === void 0) { isDocument = true; }\n    if (content == null) {\n        throw new Error('cheerio.load() expects a string');\n    }\n    var internalOpts = tslib_1.__assign(tslib_1.__assign({}, options_1.default), options_1.flatten(options));\n    var root = parse_1.default(content, internalOpts, isDocument);\n    /** Create an extended class here, so that extensions only live on one instance. */\n    var LoadedCheerio = /** @class */ (function (_super) {\n        tslib_1.__extends(LoadedCheerio, _super);\n        function LoadedCheerio() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        return LoadedCheerio;\n    }(cheerio_1.Cheerio));\n    function initialize(selector, context, r, opts) {\n        if (r === void 0) { r = root; }\n        return new LoadedCheerio(selector, context, r, tslib_1.__assign(tslib_1.__assign({}, internalOpts), options_1.flatten(opts)));\n    }\n    // Add in static methods & properties\n    Object.assign(initialize, staticMethods, {\n        load: load,\n        // `_root` and `_options` are used in static methods.\n        _root: root,\n        _options: internalOpts,\n        // Add `fn` for plugins\n        fn: LoadedCheerio.prototype,\n        // Add the prototype here to maintain `instanceof` behavior.\n        prototype: LoadedCheerio.prototype,\n    });\n    return initialize;\n}\nexports.load = load;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/cheerio/lib/load.js?");

/***/ }),

/***/ "./src/node_modules/cheerio/lib/options.js":
/*!*************************************************!*\
  !*** ./src/node_modules/cheerio/lib/options.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.flatten = void 0;\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\nvar defaultOpts = {\n    xml: false,\n    decodeEntities: true,\n};\n/** Cheerio default options. */\nexports.default = defaultOpts;\nvar xmlModeDefault = {\n    _useHtmlParser2: true,\n    xmlMode: true,\n};\nfunction flatten(options) {\n    return (options === null || options === void 0 ? void 0 : options.xml)\n        ? typeof options.xml === 'boolean'\n            ? xmlModeDefault\n            : tslib_1.__assign(tslib_1.__assign({}, xmlModeDefault), options.xml)\n        : options !== null && options !== void 0 ? options : undefined;\n}\nexports.flatten = flatten;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/cheerio/lib/options.js?");

/***/ }),

/***/ "./src/node_modules/cheerio/lib/parse.js":
/*!***********************************************!*\
  !*** ./src/node_modules/cheerio/lib/parse.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.update = void 0;\nvar htmlparser2_1 = __webpack_require__(/*! htmlparser2 */ \"./src/node_modules/htmlparser2/lib/index.js\");\nvar htmlparser2_adapter_1 = __webpack_require__(/*! ./parsers/htmlparser2-adapter */ \"./src/node_modules/cheerio/lib/parsers/htmlparser2-adapter.js\");\nvar parse5_adapter_1 = __webpack_require__(/*! ./parsers/parse5-adapter */ \"./src/node_modules/cheerio/lib/parsers/parse5-adapter.js\");\nvar domhandler_1 = __webpack_require__(/*! domhandler */ \"./src/node_modules/domhandler/lib/index.js\");\n/*\n * Parser\n */\nfunction parse(content, options, isDocument) {\n    if (typeof Buffer !== 'undefined' && Buffer.isBuffer(content)) {\n        content = content.toString();\n    }\n    if (typeof content === 'string') {\n        return options.xmlMode || options._useHtmlParser2\n            ? htmlparser2_adapter_1.parse(content, options)\n            : parse5_adapter_1.parse(content, options, isDocument);\n    }\n    var doc = content;\n    if (!Array.isArray(doc) && domhandler_1.isDocument(doc)) {\n        // If `doc` is already a root, just return it\n        return doc;\n    }\n    // Add conent to new root element\n    var root = new domhandler_1.Document([]);\n    // Update the DOM using the root\n    update(doc, root);\n    return root;\n}\nexports.default = parse;\n/**\n * Update the dom structure, for one changed layer.\n *\n * @param newChilds - The new children.\n * @param parent - The new parent.\n * @returns The parent node.\n */\nfunction update(newChilds, parent) {\n    // Normalize\n    var arr = Array.isArray(newChilds) ? newChilds : [newChilds];\n    // Update parent\n    if (parent) {\n        parent.children = arr;\n    }\n    else {\n        parent = null;\n    }\n    // Update neighbors\n    for (var i = 0; i < arr.length; i++) {\n        var node = arr[i];\n        // Cleanly remove existing nodes from their previous structures.\n        if (node.parent && node.parent.children !== arr) {\n            htmlparser2_1.DomUtils.removeElement(node);\n        }\n        if (parent) {\n            node.prev = arr[i - 1] || null;\n            node.next = arr[i + 1] || null;\n        }\n        else {\n            node.prev = node.next = null;\n        }\n        node.parent = parent;\n    }\n    return parent;\n}\nexports.update = update;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/cheerio/lib/parse.js?");

/***/ }),

/***/ "./src/node_modules/cheerio/lib/parsers/htmlparser2-adapter.js":
/*!*********************************************************************!*\
  !*** ./src/node_modules/cheerio/lib/parsers/htmlparser2-adapter.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.render = exports.parse = void 0;\nvar htmlparser2_1 = __webpack_require__(/*! htmlparser2 */ \"./src/node_modules/htmlparser2/lib/index.js\");\nObject.defineProperty(exports, \"parse\", ({ enumerable: true, get: function () { return htmlparser2_1.parseDocument; } }));\nvar dom_serializer_1 = __webpack_require__(/*! dom-serializer */ \"./src/node_modules/dom-serializer/lib/index.js\");\nObject.defineProperty(exports, \"render\", ({ enumerable: true, get: function () { return __importDefault(dom_serializer_1).default; } }));\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/cheerio/lib/parsers/htmlparser2-adapter.js?");

/***/ }),

/***/ "./src/node_modules/cheerio/lib/parsers/parse5-adapter.js":
/*!****************************************************************!*\
  !*** ./src/node_modules/cheerio/lib/parsers/parse5-adapter.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.render = exports.parse = void 0;\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\nvar domhandler_1 = __webpack_require__(/*! domhandler */ \"./src/node_modules/domhandler/lib/index.js\");\nvar parse5_1 = __webpack_require__(/*! parse5 */ \"./src/node_modules/parse5/lib/index.js\");\nvar parse5_htmlparser2_tree_adapter_1 = tslib_1.__importDefault(__webpack_require__(/*! parse5-htmlparser2-tree-adapter */ \"./src/node_modules/parse5-htmlparser2-tree-adapter/lib/index.js\"));\nfunction parse(content, options, isDocument) {\n    var opts = {\n        scriptingEnabled: typeof options.scriptingEnabled === 'boolean'\n            ? options.scriptingEnabled\n            : true,\n        treeAdapter: parse5_htmlparser2_tree_adapter_1.default,\n        sourceCodeLocationInfo: options.sourceCodeLocationInfo,\n    };\n    var context = options.context;\n    // @ts-expect-error The tree adapter unfortunately doesn't return the exact types.\n    return isDocument\n        ? parse5_1.parse(content, opts)\n        : // @ts-expect-error Same issue again.\n            parse5_1.parseFragment(context, content, opts);\n}\nexports.parse = parse;\nfunction render(dom) {\n    var _a;\n    /*\n     * `dom-serializer` passes over the special \"root\" node and renders the\n     * node's children in its place. To mimic this behavior with `parse5`, an\n     * equivalent operation must be applied to the input array.\n     */\n    var nodes = 'length' in dom ? dom : [dom];\n    for (var index = 0; index < nodes.length; index += 1) {\n        var node = nodes[index];\n        if (domhandler_1.isDocument(node)) {\n            (_a = Array.prototype.splice).call.apply(_a, tslib_1.__spreadArray([nodes, index, 1], node.children));\n        }\n    }\n    // @ts-expect-error Types don't align here either.\n    return parse5_1.serialize({ children: nodes }, { treeAdapter: parse5_htmlparser2_tree_adapter_1.default });\n}\nexports.render = render;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/cheerio/lib/parsers/parse5-adapter.js?");

/***/ }),

/***/ "./src/node_modules/cheerio/lib/static.js":
/*!************************************************!*\
  !*** ./src/node_modules/cheerio/lib/static.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.merge = exports.contains = exports.root = exports.parseHTML = exports.text = exports.xml = exports.html = void 0;\nvar tslib_1 = __webpack_require__(/*! tslib */ \"tslib\");\nvar options_1 = tslib_1.__importStar(__webpack_require__(/*! ./options */ \"./src/node_modules/cheerio/lib/options.js\"));\nvar cheerio_select_1 = __webpack_require__(/*! cheerio-select */ \"./src/node_modules/cheerio-select/lib/index.js\");\nvar htmlparser2_1 = __webpack_require__(/*! htmlparser2 */ \"./src/node_modules/htmlparser2/lib/index.js\");\nvar parse5_adapter_1 = __webpack_require__(/*! ./parsers/parse5-adapter */ \"./src/node_modules/cheerio/lib/parsers/parse5-adapter.js\");\nvar htmlparser2_adapter_1 = __webpack_require__(/*! ./parsers/htmlparser2-adapter */ \"./src/node_modules/cheerio/lib/parsers/htmlparser2-adapter.js\");\n/**\n * Helper function to render a DOM.\n *\n * @param that - Cheerio instance to render.\n * @param dom - The DOM to render. Defaults to `that`'s root.\n * @param options - Options for rendering.\n * @returns The rendered document.\n */\nfunction render(that, dom, options) {\n    var _a;\n    var toRender = dom\n        ? typeof dom === 'string'\n            ? cheerio_select_1.select(dom, (_a = that === null || that === void 0 ? void 0 : that._root) !== null && _a !== void 0 ? _a : [], options)\n            : dom\n        : that === null || that === void 0 ? void 0 : that._root.children;\n    if (!toRender)\n        return '';\n    return options.xmlMode || options._useHtmlParser2\n        ? htmlparser2_adapter_1.render(toRender, options)\n        : parse5_adapter_1.render(toRender);\n}\n/**\n * Checks if a passed object is an options object.\n *\n * @param dom - Object to check if it is an options object.\n * @returns Whether the object is an options object.\n */\nfunction isOptions(dom) {\n    return (typeof dom === 'object' &&\n        dom != null &&\n        !('length' in dom) &&\n        !('type' in dom));\n}\nfunction html(dom, options) {\n    /*\n     * Be flexible about parameters, sometimes we call html(),\n     * with options as only parameter\n     * check dom argument for dom element specific properties\n     * assume there is no 'length' or 'type' properties in the options object\n     */\n    if (!options && isOptions(dom)) {\n        options = dom;\n        dom = undefined;\n    }\n    /*\n     * Sometimes `$.html()` is used without preloading html,\n     * so fallback non-existing options to the default ones.\n     */\n    var opts = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, options_1.default), (this ? this._options : {})), options_1.flatten(options !== null && options !== void 0 ? options : {}));\n    return render(this || undefined, dom, opts);\n}\nexports.html = html;\n/**\n * Render the document as XML.\n *\n * @param dom - Element to render.\n * @returns THe rendered document.\n */\nfunction xml(dom) {\n    var options = tslib_1.__assign(tslib_1.__assign({}, this._options), { xmlMode: true });\n    return render(this, dom, options);\n}\nexports.xml = xml;\n/**\n * Render the document as text.\n *\n * @param elements - Elements to render.\n * @returns The rendered document.\n */\nfunction text(elements) {\n    var elems = elements ? elements : this ? this.root() : [];\n    var ret = '';\n    for (var i = 0; i < elems.length; i++) {\n        var elem = elems[i];\n        if (htmlparser2_1.DomUtils.isText(elem))\n            ret += elem.data;\n        else if (htmlparser2_1.DomUtils.hasChildren(elem) &&\n            elem.type !== htmlparser2_1.ElementType.Comment &&\n            elem.type !== htmlparser2_1.ElementType.Script &&\n            elem.type !== htmlparser2_1.ElementType.Style) {\n            ret += text(elem.children);\n        }\n    }\n    return ret;\n}\nexports.text = text;\nfunction parseHTML(data, context, keepScripts) {\n    if (keepScripts === void 0) { keepScripts = typeof context === 'boolean' ? context : false; }\n    if (!data || typeof data !== 'string') {\n        return null;\n    }\n    if (typeof context === 'boolean') {\n        keepScripts = context;\n    }\n    var parsed = this.load(data, options_1.default, false);\n    if (!keepScripts) {\n        parsed('script').remove();\n    }\n    /*\n     * The `children` array is used by Cheerio internally to group elements that\n     * share the same parents. When nodes created through `parseHTML` are\n     * inserted into previously-existing DOM structures, they will be removed\n     * from the `children` array. The results of `parseHTML` should remain\n     * constant across these operations, so a shallow copy should be returned.\n     */\n    return parsed.root()[0].children.slice();\n}\nexports.parseHTML = parseHTML;\n/**\n * Sometimes you need to work with the top-level root element. To query it, you\n * can use `$.root()`.\n *\n * @example\n *\n * ```js\n * $.root().append('<ul id=\"vegetables\"></ul>').html();\n * //=> <ul id=\"fruits\">...</ul><ul id=\"vegetables\"></ul>\n * ```\n *\n * @returns Cheerio instance wrapping the root node.\n * @alias Cheerio.root\n */\nfunction root() {\n    return this(this._root);\n}\nexports.root = root;\n/**\n * Checks to see if the `contained` DOM element is a descendant of the\n * `container` DOM element.\n *\n * @param container - Potential parent node.\n * @param contained - Potential child node.\n * @returns Indicates if the nodes contain one another.\n * @alias Cheerio.contains\n * @see {@link https://api.jquery.com/jQuery.contains/}\n */\nfunction contains(container, contained) {\n    // According to the jQuery API, an element does not \"contain\" itself\n    if (contained === container) {\n        return false;\n    }\n    /*\n     * Step up the descendants, stopping when the root element is reached\n     * (signaled by `.parent` returning a reference to the same object)\n     */\n    var next = contained;\n    while (next && next !== next.parent) {\n        next = next.parent;\n        if (next === container) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.contains = contains;\n/**\n * $.merge().\n *\n * @param arr1 - First array.\n * @param arr2 - Second array.\n * @returns `arr1`, with elements of `arr2` inserted.\n * @alias Cheerio.merge\n * @see {@link https://api.jquery.com/jQuery.merge/}\n */\nfunction merge(arr1, arr2) {\n    if (!isArrayLike(arr1) || !isArrayLike(arr2)) {\n        return;\n    }\n    var newLength = arr1.length;\n    var len = +arr2.length;\n    for (var i = 0; i < len; i++) {\n        arr1[newLength++] = arr2[i];\n    }\n    arr1.length = newLength;\n    return arr1;\n}\nexports.merge = merge;\n/**\n * @param item - Item to check.\n * @returns Indicates if the item is array-like.\n */\nfunction isArrayLike(item) {\n    if (Array.isArray(item)) {\n        return true;\n    }\n    if (typeof item !== 'object' ||\n        !Object.prototype.hasOwnProperty.call(item, 'length') ||\n        typeof item.length !== 'number' ||\n        item.length < 0) {\n        return false;\n    }\n    for (var i = 0; i < item.length; i++) {\n        if (!(i in item)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/cheerio/lib/static.js?");

/***/ }),

/***/ "./src/node_modules/cheerio/lib/types.js":
/*!***********************************************!*\
  !*** ./src/node_modules/cheerio/lib/types.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/cheerio/lib/types.js?");

/***/ }),

/***/ "./src/node_modules/cheerio/lib/utils.js":
/*!***********************************************!*\
  !*** ./src/node_modules/cheerio/lib/utils.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isHtml = exports.cloneDom = exports.domEach = exports.cssCase = exports.camelCase = exports.isCheerio = exports.isTag = void 0;\nvar htmlparser2_1 = __webpack_require__(/*! htmlparser2 */ \"./src/node_modules/htmlparser2/lib/index.js\");\nvar domhandler_1 = __webpack_require__(/*! domhandler */ \"./src/node_modules/domhandler/lib/index.js\");\n/**\n * Check if the DOM element is a tag.\n *\n * `isTag(type)` includes `<script>` and `<style>` tags.\n *\n * @private\n * @category Utils\n * @param type - DOM node to check.\n * @returns Whether the node is a tag.\n */\nexports.isTag = htmlparser2_1.DomUtils.isTag;\n/**\n * Checks if an object is a Cheerio instance.\n *\n * @category Utils\n * @param maybeCheerio - The object to check.\n * @returns Whether the object is a Cheerio instance.\n */\nfunction isCheerio(maybeCheerio) {\n    return maybeCheerio.cheerio != null;\n}\nexports.isCheerio = isCheerio;\n/**\n * Convert a string to camel case notation.\n *\n * @private\n * @category Utils\n * @param str - String to be converted.\n * @returns String in camel case notation.\n */\nfunction camelCase(str) {\n    return str.replace(/[_.-](\\w|$)/g, function (_, x) { return x.toUpperCase(); });\n}\nexports.camelCase = camelCase;\n/**\n * Convert a string from camel case to \"CSS case\", where word boundaries are\n * described by hyphens (\"-\") and all characters are lower-case.\n *\n * @private\n * @category Utils\n * @param str - String to be converted.\n * @returns String in \"CSS case\".\n */\nfunction cssCase(str) {\n    return str.replace(/[A-Z]/g, '-$&').toLowerCase();\n}\nexports.cssCase = cssCase;\n/**\n * Iterate over each DOM element without creating intermediary Cheerio instances.\n *\n * This is indented for use internally to avoid otherwise unnecessary memory\n * pressure introduced by _make.\n *\n * @category Utils\n * @param array - Array to iterate over.\n * @param fn - Function to call.\n * @returns The original instance.\n */\nfunction domEach(array, fn) {\n    var len = array.length;\n    for (var i = 0; i < len; i++)\n        fn(array[i], i);\n    return array;\n}\nexports.domEach = domEach;\n/**\n * Create a deep copy of the given DOM structure. Sets the parents of the copies\n * of the passed nodes to `null`.\n *\n * @private\n * @category Utils\n * @param dom - The htmlparser2-compliant DOM structure.\n * @returns - The cloned DOM.\n */\nfunction cloneDom(dom) {\n    var clone = 'length' in dom\n        ? Array.prototype.map.call(dom, function (el) { return domhandler_1.cloneNode(el, true); })\n        : [domhandler_1.cloneNode(dom, true)];\n    // Add a root node around the cloned nodes\n    var root = new domhandler_1.Document(clone);\n    clone.forEach(function (node) {\n        node.parent = root;\n    });\n    return clone;\n}\nexports.cloneDom = cloneDom;\n/**\n * A simple way to check for HTML strings. Tests for a `<` within a string,\n * immediate followed by a letter and eventually followed by a `>`.\n *\n * @private\n */\nvar quickExpr = /<[a-zA-Z][^]*>/;\n/**\n * Check if string is HTML.\n *\n * @private\n * @category Utils\n * @param str - String to check.\n * @returns Indicates if `str` is HTML.\n */\nfunction isHtml(str) {\n    // Run the regex\n    return quickExpr.test(str);\n}\nexports.isHtml = isHtml;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/cheerio/lib/utils.js?");

/***/ }),

/***/ "./src/node_modules/css-select/lib/attributes.js":
/*!*******************************************************!*\
  !*** ./src/node_modules/css-select/lib/attributes.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.attributeRules = void 0;\nvar boolbase_1 = __webpack_require__(/*! boolbase */ \"./src/node_modules/boolbase/index.js\");\n/**\n * All reserved characters in a regex, used for escaping.\n *\n * Taken from XRegExp, (c) 2007-2020 Steven Levithan under the MIT license\n * https://github.com/slevithan/xregexp/blob/95eeebeb8fac8754d54eafe2b4743661ac1cf028/src/xregexp.js#L794\n */\nvar reChars = /[-[\\]{}()*+?.,\\\\^$|#\\s]/g;\nfunction escapeRegex(value) {\n    return value.replace(reChars, \"\\\\$&\");\n}\n/**\n * Attribute selectors\n */\nexports.attributeRules = {\n    equals: function (next, data, _a) {\n        var adapter = _a.adapter;\n        var name = data.name;\n        var value = data.value;\n        if (data.ignoreCase) {\n            value = value.toLowerCase();\n            return function (elem) {\n                var attr = adapter.getAttributeValue(elem, name);\n                return (attr != null &&\n                    attr.length === value.length &&\n                    attr.toLowerCase() === value &&\n                    next(elem));\n            };\n        }\n        return function (elem) {\n            return adapter.getAttributeValue(elem, name) === value && next(elem);\n        };\n    },\n    hyphen: function (next, data, _a) {\n        var adapter = _a.adapter;\n        var name = data.name;\n        var value = data.value;\n        var len = value.length;\n        if (data.ignoreCase) {\n            value = value.toLowerCase();\n            return function hyphenIC(elem) {\n                var attr = adapter.getAttributeValue(elem, name);\n                return (attr != null &&\n                    (attr.length === len || attr.charAt(len) === \"-\") &&\n                    attr.substr(0, len).toLowerCase() === value &&\n                    next(elem));\n            };\n        }\n        return function hyphen(elem) {\n            var attr = adapter.getAttributeValue(elem, name);\n            return (attr != null &&\n                (attr.length === len || attr.charAt(len) === \"-\") &&\n                attr.substr(0, len) === value &&\n                next(elem));\n        };\n    },\n    element: function (next, _a, _b) {\n        var name = _a.name, value = _a.value, ignoreCase = _a.ignoreCase;\n        var adapter = _b.adapter;\n        if (/\\s/.test(value)) {\n            return boolbase_1.falseFunc;\n        }\n        var regex = new RegExp(\"(?:^|\\\\s)\" + escapeRegex(value) + \"(?:$|\\\\s)\", ignoreCase ? \"i\" : \"\");\n        return function element(elem) {\n            var attr = adapter.getAttributeValue(elem, name);\n            return (attr != null &&\n                attr.length >= value.length &&\n                regex.test(attr) &&\n                next(elem));\n        };\n    },\n    exists: function (next, _a, _b) {\n        var name = _a.name;\n        var adapter = _b.adapter;\n        return function (elem) { return adapter.hasAttrib(elem, name) && next(elem); };\n    },\n    start: function (next, data, _a) {\n        var adapter = _a.adapter;\n        var name = data.name;\n        var value = data.value;\n        var len = value.length;\n        if (len === 0) {\n            return boolbase_1.falseFunc;\n        }\n        if (data.ignoreCase) {\n            value = value.toLowerCase();\n            return function (elem) {\n                var attr = adapter.getAttributeValue(elem, name);\n                return (attr != null &&\n                    attr.length >= len &&\n                    attr.substr(0, len).toLowerCase() === value &&\n                    next(elem));\n            };\n        }\n        return function (elem) {\n            var _a;\n            return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.startsWith(value)) &&\n                next(elem);\n        };\n    },\n    end: function (next, data, _a) {\n        var adapter = _a.adapter;\n        var name = data.name;\n        var value = data.value;\n        var len = -value.length;\n        if (len === 0) {\n            return boolbase_1.falseFunc;\n        }\n        if (data.ignoreCase) {\n            value = value.toLowerCase();\n            return function (elem) {\n                var _a;\n                return ((_a = adapter\n                    .getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.substr(len).toLowerCase()) === value && next(elem);\n            };\n        }\n        return function (elem) {\n            var _a;\n            return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.endsWith(value)) &&\n                next(elem);\n        };\n    },\n    any: function (next, data, _a) {\n        var adapter = _a.adapter;\n        var name = data.name, value = data.value;\n        if (value === \"\") {\n            return boolbase_1.falseFunc;\n        }\n        if (data.ignoreCase) {\n            var regex_1 = new RegExp(escapeRegex(value), \"i\");\n            return function anyIC(elem) {\n                var attr = adapter.getAttributeValue(elem, name);\n                return (attr != null &&\n                    attr.length >= value.length &&\n                    regex_1.test(attr) &&\n                    next(elem));\n            };\n        }\n        return function (elem) {\n            var _a;\n            return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.includes(value)) &&\n                next(elem);\n        };\n    },\n    not: function (next, data, _a) {\n        var adapter = _a.adapter;\n        var name = data.name;\n        var value = data.value;\n        if (value === \"\") {\n            return function (elem) {\n                return !!adapter.getAttributeValue(elem, name) && next(elem);\n            };\n        }\n        else if (data.ignoreCase) {\n            value = value.toLowerCase();\n            return function (elem) {\n                var attr = adapter.getAttributeValue(elem, name);\n                return ((attr == null ||\n                    attr.length !== value.length ||\n                    attr.toLowerCase() !== value) &&\n                    next(elem));\n            };\n        }\n        return function (elem) {\n            return adapter.getAttributeValue(elem, name) !== value && next(elem);\n        };\n    },\n};\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/css-select/lib/attributes.js?");

/***/ }),

/***/ "./src/node_modules/css-select/lib/compile.js":
/*!****************************************************!*\
  !*** ./src/node_modules/css-select/lib/compile.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.compileToken = exports.compileUnsafe = exports.compile = void 0;\nvar css_what_1 = __webpack_require__(/*! css-what */ \"./src/node_modules/css-what/lib/index.js\");\nvar boolbase_1 = __webpack_require__(/*! boolbase */ \"./src/node_modules/boolbase/index.js\");\nvar sort_1 = __importDefault(__webpack_require__(/*! ./sort */ \"./src/node_modules/css-select/lib/sort.js\"));\nvar procedure_1 = __webpack_require__(/*! ./procedure */ \"./src/node_modules/css-select/lib/procedure.js\");\nvar general_1 = __webpack_require__(/*! ./general */ \"./src/node_modules/css-select/lib/general.js\");\nvar subselects_1 = __webpack_require__(/*! ./pseudo-selectors/subselects */ \"./src/node_modules/css-select/lib/pseudo-selectors/subselects.js\");\n/**\n * Compiles a selector to an executable function.\n *\n * @param selector Selector to compile.\n * @param options Compilation options.\n * @param context Optional context for the selector.\n */\nfunction compile(selector, options, context) {\n    var next = compileUnsafe(selector, options, context);\n    return subselects_1.ensureIsTag(next, options.adapter);\n}\nexports.compile = compile;\nfunction compileUnsafe(selector, options, context) {\n    var token = typeof selector === \"string\" ? css_what_1.parse(selector, options) : selector;\n    return compileToken(token, options, context);\n}\nexports.compileUnsafe = compileUnsafe;\nfunction includesScopePseudo(t) {\n    return (t.type === \"pseudo\" &&\n        (t.name === \"scope\" ||\n            (Array.isArray(t.data) &&\n                t.data.some(function (data) { return data.some(includesScopePseudo); }))));\n}\nvar DESCENDANT_TOKEN = { type: \"descendant\" };\nvar FLEXIBLE_DESCENDANT_TOKEN = {\n    type: \"_flexibleDescendant\",\n};\nvar SCOPE_TOKEN = { type: \"pseudo\", name: \"scope\", data: null };\n/*\n * CSS 4 Spec (Draft): 3.3.1. Absolutizing a Scope-relative Selector\n * http://www.w3.org/TR/selectors4/#absolutizing\n */\nfunction absolutize(token, _a, context) {\n    var adapter = _a.adapter;\n    // TODO Use better check if the context is a document\n    var hasContext = !!(context === null || context === void 0 ? void 0 : context.every(function (e) {\n        var parent = adapter.isTag(e) && adapter.getParent(e);\n        return e === subselects_1.PLACEHOLDER_ELEMENT || (parent && adapter.isTag(parent));\n    }));\n    for (var _i = 0, token_1 = token; _i < token_1.length; _i++) {\n        var t = token_1[_i];\n        if (t.length > 0 && procedure_1.isTraversal(t[0]) && t[0].type !== \"descendant\") {\n            // Don't continue in else branch\n        }\n        else if (hasContext && !t.some(includesScopePseudo)) {\n            t.unshift(DESCENDANT_TOKEN);\n        }\n        else {\n            continue;\n        }\n        t.unshift(SCOPE_TOKEN);\n    }\n}\nfunction compileToken(token, options, context) {\n    var _a;\n    token = token.filter(function (t) { return t.length > 0; });\n    token.forEach(sort_1.default);\n    context = (_a = options.context) !== null && _a !== void 0 ? _a : context;\n    var isArrayContext = Array.isArray(context);\n    var finalContext = context && (Array.isArray(context) ? context : [context]);\n    absolutize(token, options, finalContext);\n    var shouldTestNextSiblings = false;\n    var query = token\n        .map(function (rules) {\n        if (rules.length >= 2) {\n            var first = rules[0], second = rules[1];\n            if (first.type !== \"pseudo\" || first.name !== \"scope\") {\n                // Ignore\n            }\n            else if (isArrayContext && second.type === \"descendant\") {\n                rules[1] = FLEXIBLE_DESCENDANT_TOKEN;\n            }\n            else if (second.type === \"adjacent\" ||\n                second.type === \"sibling\") {\n                shouldTestNextSiblings = true;\n            }\n        }\n        return compileRules(rules, options, finalContext);\n    })\n        .reduce(reduceRules, boolbase_1.falseFunc);\n    query.shouldTestNextSiblings = shouldTestNextSiblings;\n    return query;\n}\nexports.compileToken = compileToken;\nfunction compileRules(rules, options, context) {\n    var _a;\n    return rules.reduce(function (previous, rule) {\n        return previous === boolbase_1.falseFunc\n            ? boolbase_1.falseFunc\n            : general_1.compileGeneralSelector(previous, rule, options, context, compileToken);\n    }, (_a = options.rootFunc) !== null && _a !== void 0 ? _a : boolbase_1.trueFunc);\n}\nfunction reduceRules(a, b) {\n    if (b === boolbase_1.falseFunc || a === boolbase_1.trueFunc) {\n        return a;\n    }\n    if (a === boolbase_1.falseFunc || b === boolbase_1.trueFunc) {\n        return b;\n    }\n    return function combine(elem) {\n        return a(elem) || b(elem);\n    };\n}\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/css-select/lib/compile.js?");

/***/ }),

/***/ "./src/node_modules/css-select/lib/general.js":
/*!****************************************************!*\
  !*** ./src/node_modules/css-select/lib/general.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.compileGeneralSelector = void 0;\nvar attributes_1 = __webpack_require__(/*! ./attributes */ \"./src/node_modules/css-select/lib/attributes.js\");\nvar pseudo_selectors_1 = __webpack_require__(/*! ./pseudo-selectors */ \"./src/node_modules/css-select/lib/pseudo-selectors/index.js\");\n/*\n * All available rules\n */\nfunction compileGeneralSelector(next, selector, options, context, compileToken) {\n    var adapter = options.adapter, equals = options.equals;\n    switch (selector.type) {\n        case \"pseudo-element\":\n            throw new Error(\"Pseudo-elements are not supported by css-select\");\n        case \"attribute\":\n            return attributes_1.attributeRules[selector.action](next, selector, options);\n        case \"pseudo\":\n            return pseudo_selectors_1.compilePseudoSelector(next, selector, options, context, compileToken);\n        // Tags\n        case \"tag\":\n            return function tag(elem) {\n                return adapter.getName(elem) === selector.name && next(elem);\n            };\n        // Traversal\n        case \"descendant\":\n            if (options.cacheResults === false ||\n                typeof WeakSet === \"undefined\") {\n                return function descendant(elem) {\n                    var current = elem;\n                    while ((current = adapter.getParent(current))) {\n                        if (adapter.isTag(current) && next(current)) {\n                            return true;\n                        }\n                    }\n                    return false;\n                };\n            }\n            // @ts-expect-error `ElementNode` is not extending object\n            // eslint-disable-next-line no-case-declarations\n            var isFalseCache_1 = new WeakSet();\n            return function cachedDescendant(elem) {\n                var current = elem;\n                while ((current = adapter.getParent(current))) {\n                    if (!isFalseCache_1.has(current)) {\n                        if (adapter.isTag(current) && next(current)) {\n                            return true;\n                        }\n                        isFalseCache_1.add(current);\n                    }\n                }\n                return false;\n            };\n        case \"_flexibleDescendant\":\n            // Include element itself, only used while querying an array\n            return function flexibleDescendant(elem) {\n                var current = elem;\n                do {\n                    if (adapter.isTag(current) && next(current))\n                        return true;\n                } while ((current = adapter.getParent(current)));\n                return false;\n            };\n        case \"parent\":\n            return function parent(elem) {\n                return adapter\n                    .getChildren(elem)\n                    .some(function (elem) { return adapter.isTag(elem) && next(elem); });\n            };\n        case \"child\":\n            return function child(elem) {\n                var parent = adapter.getParent(elem);\n                return parent != null && adapter.isTag(parent) && next(parent);\n            };\n        case \"sibling\":\n            return function sibling(elem) {\n                var siblings = adapter.getSiblings(elem);\n                for (var i = 0; i < siblings.length; i++) {\n                    var currentSibling = siblings[i];\n                    if (equals(elem, currentSibling))\n                        break;\n                    if (adapter.isTag(currentSibling) && next(currentSibling)) {\n                        return true;\n                    }\n                }\n                return false;\n            };\n        case \"adjacent\":\n            return function adjacent(elem) {\n                var siblings = adapter.getSiblings(elem);\n                var lastElement;\n                for (var i = 0; i < siblings.length; i++) {\n                    var currentSibling = siblings[i];\n                    if (equals(elem, currentSibling))\n                        break;\n                    if (adapter.isTag(currentSibling)) {\n                        lastElement = currentSibling;\n                    }\n                }\n                return !!lastElement && next(lastElement);\n            };\n        case \"universal\":\n            return next;\n    }\n}\nexports.compileGeneralSelector = compileGeneralSelector;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/css-select/lib/general.js?");

/***/ }),

/***/ "./src/node_modules/css-select/lib/index.js":
/*!**************************************************!*\
  !*** ./src/node_modules/css-select/lib/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.aliases = exports.pseudos = exports.filters = exports.is = exports.selectOne = exports.selectAll = exports.prepareContext = exports._compileToken = exports._compileUnsafe = exports.compile = void 0;\nvar DomUtils = __importStar(__webpack_require__(/*! domutils */ \"./src/node_modules/domutils/lib/index.js\"));\nvar boolbase_1 = __webpack_require__(/*! boolbase */ \"./src/node_modules/boolbase/index.js\");\nvar compile_1 = __webpack_require__(/*! ./compile */ \"./src/node_modules/css-select/lib/compile.js\");\nvar subselects_1 = __webpack_require__(/*! ./pseudo-selectors/subselects */ \"./src/node_modules/css-select/lib/pseudo-selectors/subselects.js\");\nvar defaultEquals = function (a, b) { return a === b; };\nvar defaultOptions = {\n    adapter: DomUtils,\n    equals: defaultEquals,\n};\nfunction convertOptionFormats(options) {\n    var _a, _b, _c, _d;\n    /*\n     * We force one format of options to the other one.\n     */\n    // @ts-expect-error Default options may have incompatible `Node` / `ElementNode`.\n    var opts = options !== null && options !== void 0 ? options : defaultOptions;\n    // @ts-expect-error Same as above.\n    (_a = opts.adapter) !== null && _a !== void 0 ? _a : (opts.adapter = DomUtils);\n    // @ts-expect-error `equals` does not exist on `Options`\n    (_b = opts.equals) !== null && _b !== void 0 ? _b : (opts.equals = (_d = (_c = opts.adapter) === null || _c === void 0 ? void 0 : _c.equals) !== null && _d !== void 0 ? _d : defaultEquals);\n    return opts;\n}\nfunction wrapCompile(func) {\n    return function addAdapter(selector, options, context) {\n        var opts = convertOptionFormats(options);\n        return func(selector, opts, context);\n    };\n}\n/**\n * Compiles the query, returns a function.\n */\nexports.compile = wrapCompile(compile_1.compile);\nexports._compileUnsafe = wrapCompile(compile_1.compileUnsafe);\nexports._compileToken = wrapCompile(compile_1.compileToken);\nfunction getSelectorFunc(searchFunc) {\n    return function select(query, elements, options) {\n        var opts = convertOptionFormats(options);\n        if (typeof query !== \"function\") {\n            query = compile_1.compileUnsafe(query, opts, elements);\n        }\n        var filteredElements = prepareContext(elements, opts.adapter, query.shouldTestNextSiblings);\n        return searchFunc(query, filteredElements, opts);\n    };\n}\nfunction prepareContext(elems, adapter, shouldTestNextSiblings) {\n    if (shouldTestNextSiblings === void 0) { shouldTestNextSiblings = false; }\n    /*\n     * Add siblings if the query requires them.\n     * See https://github.com/fb55/css-select/pull/43#issuecomment-225414692\n     */\n    if (shouldTestNextSiblings) {\n        elems = appendNextSiblings(elems, adapter);\n    }\n    return Array.isArray(elems)\n        ? adapter.removeSubsets(elems)\n        : adapter.getChildren(elems);\n}\nexports.prepareContext = prepareContext;\nfunction appendNextSiblings(elem, adapter) {\n    // Order matters because jQuery seems to check the children before the siblings\n    var elems = Array.isArray(elem) ? elem.slice(0) : [elem];\n    for (var i = 0; i < elems.length; i++) {\n        var nextSiblings = subselects_1.getNextSiblings(elems[i], adapter);\n        elems.push.apply(elems, nextSiblings);\n    }\n    return elems;\n}\n/**\n * @template Node The generic Node type for the DOM adapter being used.\n * @template ElementNode The Node type for elements for the DOM adapter being used.\n * @param elems Elements to query. If it is an element, its children will be queried..\n * @param query can be either a CSS selector string or a compiled query function.\n * @param [options] options for querying the document.\n * @see compile for supported selector queries.\n * @returns All matching elements.\n *\n */\nexports.selectAll = getSelectorFunc(function (query, elems, options) {\n    return query === boolbase_1.falseFunc || !elems || elems.length === 0\n        ? []\n        : options.adapter.findAll(query, elems);\n});\n/**\n * @template Node The generic Node type for the DOM adapter being used.\n * @template ElementNode The Node type for elements for the DOM adapter being used.\n * @param elems Elements to query. If it is an element, its children will be queried..\n * @param query can be either a CSS selector string or a compiled query function.\n * @param [options] options for querying the document.\n * @see compile for supported selector queries.\n * @returns the first match, or null if there was no match.\n */\nexports.selectOne = getSelectorFunc(function (query, elems, options) {\n    return query === boolbase_1.falseFunc || !elems || elems.length === 0\n        ? null\n        : options.adapter.findOne(query, elems);\n});\n/**\n * Tests whether or not an element is matched by query.\n *\n * @template Node The generic Node type for the DOM adapter being used.\n * @template ElementNode The Node type for elements for the DOM adapter being used.\n * @param elem The element to test if it matches the query.\n * @param query can be either a CSS selector string or a compiled query function.\n * @param [options] options for querying the document.\n * @see compile for supported selector queries.\n * @returns\n */\nfunction is(elem, query, options) {\n    var opts = convertOptionFormats(options);\n    return (typeof query === \"function\" ? query : compile_1.compile(query, opts))(elem);\n}\nexports.is = is;\n/**\n * Alias for selectAll(query, elems, options).\n * @see [compile] for supported selector queries.\n */\nexports.default = exports.selectAll;\n// Export filters, pseudos and aliases to allow users to supply their own.\nvar pseudo_selectors_1 = __webpack_require__(/*! ./pseudo-selectors */ \"./src/node_modules/css-select/lib/pseudo-selectors/index.js\");\nObject.defineProperty(exports, \"filters\", ({ enumerable: true, get: function () { return pseudo_selectors_1.filters; } }));\nObject.defineProperty(exports, \"pseudos\", ({ enumerable: true, get: function () { return pseudo_selectors_1.pseudos; } }));\nObject.defineProperty(exports, \"aliases\", ({ enumerable: true, get: function () { return pseudo_selectors_1.aliases; } }));\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/css-select/lib/index.js?");

/***/ }),

/***/ "./src/node_modules/css-select/lib/procedure.js":
/*!******************************************************!*\
  !*** ./src/node_modules/css-select/lib/procedure.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isTraversal = exports.procedure = void 0;\nexports.procedure = {\n    universal: 50,\n    tag: 30,\n    attribute: 1,\n    pseudo: 0,\n    \"pseudo-element\": 0,\n    descendant: -1,\n    child: -1,\n    parent: -1,\n    sibling: -1,\n    adjacent: -1,\n    _flexibleDescendant: -1,\n};\nfunction isTraversal(t) {\n    return exports.procedure[t.type] < 0;\n}\nexports.isTraversal = isTraversal;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/css-select/lib/procedure.js?");

/***/ }),

/***/ "./src/node_modules/css-select/lib/pseudo-selectors/aliases.js":
/*!*********************************************************************!*\
  !*** ./src/node_modules/css-select/lib/pseudo-selectors/aliases.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.aliases = void 0;\n/**\n * Aliases are pseudos that are expressed as selectors.\n */\nexports.aliases = {\n    // Links\n    \"any-link\": \":is(a, area, link)[href]\",\n    link: \":any-link:not(:visited)\",\n    // Forms\n    // https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements\n    disabled: \":is(\\n        :is(button, input, select, textarea, optgroup, option)[disabled],\\n        optgroup[disabled] > option,\\n        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)\\n    )\",\n    enabled: \":not(:disabled)\",\n    checked: \":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)\",\n    required: \":is(input, select, textarea)[required]\",\n    optional: \":is(input, select, textarea):not([required])\",\n    // JQuery extensions\n    // https://html.spec.whatwg.org/multipage/form-elements.html#concept-option-selectedness\n    selected: \"option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)\",\n    checkbox: \"[type=checkbox]\",\n    file: \"[type=file]\",\n    password: \"[type=password]\",\n    radio: \"[type=radio]\",\n    reset: \"[type=reset]\",\n    image: \"[type=image]\",\n    submit: \"[type=submit]\",\n    parent: \":not(:empty)\",\n    header: \":is(h1, h2, h3, h4, h5, h6)\",\n    button: \":is(button, input[type=button])\",\n    input: \":is(input, textarea, select, button)\",\n    text: \"input:is(:not([type!='']), [type=text])\",\n};\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/css-select/lib/pseudo-selectors/aliases.js?");

/***/ }),

/***/ "./src/node_modules/css-select/lib/pseudo-selectors/filters.js":
/*!*********************************************************************!*\
  !*** ./src/node_modules/css-select/lib/pseudo-selectors/filters.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.filters = void 0;\nvar nth_check_1 = __importDefault(__webpack_require__(/*! nth-check */ \"./src/node_modules/nth-check/lib/index.js\"));\nvar boolbase_1 = __webpack_require__(/*! boolbase */ \"./src/node_modules/boolbase/index.js\");\nfunction getChildFunc(next, adapter) {\n    return function (elem) {\n        var parent = adapter.getParent(elem);\n        return parent != null && adapter.isTag(parent) && next(elem);\n    };\n}\nexports.filters = {\n    contains: function (next, text, _a) {\n        var adapter = _a.adapter;\n        return function contains(elem) {\n            return next(elem) && adapter.getText(elem).includes(text);\n        };\n    },\n    icontains: function (next, text, _a) {\n        var adapter = _a.adapter;\n        var itext = text.toLowerCase();\n        return function icontains(elem) {\n            return (next(elem) &&\n                adapter.getText(elem).toLowerCase().includes(itext));\n        };\n    },\n    // Location specific methods\n    \"nth-child\": function (next, rule, _a) {\n        var adapter = _a.adapter, equals = _a.equals;\n        var func = nth_check_1.default(rule);\n        if (func === boolbase_1.falseFunc)\n            return boolbase_1.falseFunc;\n        if (func === boolbase_1.trueFunc)\n            return getChildFunc(next, adapter);\n        return function nthChild(elem) {\n            var siblings = adapter.getSiblings(elem);\n            var pos = 0;\n            for (var i = 0; i < siblings.length; i++) {\n                if (equals(elem, siblings[i]))\n                    break;\n                if (adapter.isTag(siblings[i])) {\n                    pos++;\n                }\n            }\n            return func(pos) && next(elem);\n        };\n    },\n    \"nth-last-child\": function (next, rule, _a) {\n        var adapter = _a.adapter, equals = _a.equals;\n        var func = nth_check_1.default(rule);\n        if (func === boolbase_1.falseFunc)\n            return boolbase_1.falseFunc;\n        if (func === boolbase_1.trueFunc)\n            return getChildFunc(next, adapter);\n        return function nthLastChild(elem) {\n            var siblings = adapter.getSiblings(elem);\n            var pos = 0;\n            for (var i = siblings.length - 1; i >= 0; i--) {\n                if (equals(elem, siblings[i]))\n                    break;\n                if (adapter.isTag(siblings[i])) {\n                    pos++;\n                }\n            }\n            return func(pos) && next(elem);\n        };\n    },\n    \"nth-of-type\": function (next, rule, _a) {\n        var adapter = _a.adapter, equals = _a.equals;\n        var func = nth_check_1.default(rule);\n        if (func === boolbase_1.falseFunc)\n            return boolbase_1.falseFunc;\n        if (func === boolbase_1.trueFunc)\n            return getChildFunc(next, adapter);\n        return function nthOfType(elem) {\n            var siblings = adapter.getSiblings(elem);\n            var pos = 0;\n            for (var i = 0; i < siblings.length; i++) {\n                var currentSibling = siblings[i];\n                if (equals(elem, currentSibling))\n                    break;\n                if (adapter.isTag(currentSibling) &&\n                    adapter.getName(currentSibling) === adapter.getName(elem)) {\n                    pos++;\n                }\n            }\n            return func(pos) && next(elem);\n        };\n    },\n    \"nth-last-of-type\": function (next, rule, _a) {\n        var adapter = _a.adapter, equals = _a.equals;\n        var func = nth_check_1.default(rule);\n        if (func === boolbase_1.falseFunc)\n            return boolbase_1.falseFunc;\n        if (func === boolbase_1.trueFunc)\n            return getChildFunc(next, adapter);\n        return function nthLastOfType(elem) {\n            var siblings = adapter.getSiblings(elem);\n            var pos = 0;\n            for (var i = siblings.length - 1; i >= 0; i--) {\n                var currentSibling = siblings[i];\n                if (equals(elem, currentSibling))\n                    break;\n                if (adapter.isTag(currentSibling) &&\n                    adapter.getName(currentSibling) === adapter.getName(elem)) {\n                    pos++;\n                }\n            }\n            return func(pos) && next(elem);\n        };\n    },\n    // TODO determine the actual root element\n    root: function (next, _rule, _a) {\n        var adapter = _a.adapter;\n        return function (elem) {\n            var parent = adapter.getParent(elem);\n            return (parent == null || !adapter.isTag(parent)) && next(elem);\n        };\n    },\n    scope: function (next, rule, options, context) {\n        var equals = options.equals;\n        if (!context || context.length === 0) {\n            // Equivalent to :root\n            return exports.filters.root(next, rule, options);\n        }\n        if (context.length === 1) {\n            // NOTE: can't be unpacked, as :has uses this for side-effects\n            return function (elem) { return equals(context[0], elem) && next(elem); };\n        }\n        return function (elem) { return context.includes(elem) && next(elem); };\n    },\n    hover: dynamicStatePseudo(\"isHovered\"),\n    visited: dynamicStatePseudo(\"isVisited\"),\n    active: dynamicStatePseudo(\"isActive\"),\n};\n/**\n * Dynamic state pseudos. These depend on optional Adapter methods.\n *\n * @param name The name of the adapter method to call.\n * @returns Pseudo for the `filters` object.\n */\nfunction dynamicStatePseudo(name) {\n    return function dynamicPseudo(next, _rule, _a) {\n        var adapter = _a.adapter;\n        var func = adapter[name];\n        if (typeof func !== \"function\") {\n            return boolbase_1.falseFunc;\n        }\n        return function active(elem) {\n            return func(elem) && next(elem);\n        };\n    };\n}\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/css-select/lib/pseudo-selectors/filters.js?");

/***/ }),

/***/ "./src/node_modules/css-select/lib/pseudo-selectors/index.js":
/*!*******************************************************************!*\
  !*** ./src/node_modules/css-select/lib/pseudo-selectors/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.compilePseudoSelector = exports.aliases = exports.pseudos = exports.filters = void 0;\n/*\n * Pseudo selectors\n *\n * Pseudo selectors are available in three forms:\n *\n * 1. Filters are called when the selector is compiled and return a function\n *  that has to return either false, or the results of `next()`.\n * 2. Pseudos are called on execution. They have to return a boolean.\n * 3. Subselects work like filters, but have an embedded selector that will be run separately.\n *\n * Filters are great if you want to do some pre-processing, or change the call order\n * of `next()` and your code.\n * Pseudos should be used to implement simple checks.\n */\nvar boolbase_1 = __webpack_require__(/*! boolbase */ \"./src/node_modules/boolbase/index.js\");\nvar css_what_1 = __webpack_require__(/*! css-what */ \"./src/node_modules/css-what/lib/index.js\");\nvar filters_1 = __webpack_require__(/*! ./filters */ \"./src/node_modules/css-select/lib/pseudo-selectors/filters.js\");\nObject.defineProperty(exports, \"filters\", ({ enumerable: true, get: function () { return filters_1.filters; } }));\nvar pseudos_1 = __webpack_require__(/*! ./pseudos */ \"./src/node_modules/css-select/lib/pseudo-selectors/pseudos.js\");\nObject.defineProperty(exports, \"pseudos\", ({ enumerable: true, get: function () { return pseudos_1.pseudos; } }));\nvar aliases_1 = __webpack_require__(/*! ./aliases */ \"./src/node_modules/css-select/lib/pseudo-selectors/aliases.js\");\nObject.defineProperty(exports, \"aliases\", ({ enumerable: true, get: function () { return aliases_1.aliases; } }));\nvar subselects_1 = __webpack_require__(/*! ./subselects */ \"./src/node_modules/css-select/lib/pseudo-selectors/subselects.js\");\nfunction compilePseudoSelector(next, selector, options, context, compileToken) {\n    var name = selector.name, data = selector.data;\n    if (Array.isArray(data)) {\n        return subselects_1.subselects[name](next, data, options, context, compileToken);\n    }\n    if (name in aliases_1.aliases) {\n        if (data != null) {\n            throw new Error(\"Pseudo \" + name + \" doesn't have any arguments\");\n        }\n        // The alias has to be parsed here, to make sure options are respected.\n        var alias = css_what_1.parse(aliases_1.aliases[name], options);\n        return subselects_1.subselects.is(next, alias, options, context, compileToken);\n    }\n    if (name in filters_1.filters) {\n        return filters_1.filters[name](next, data, options, context);\n    }\n    if (name in pseudos_1.pseudos) {\n        var pseudo_1 = pseudos_1.pseudos[name];\n        pseudos_1.verifyPseudoArgs(pseudo_1, name, data);\n        return pseudo_1 === boolbase_1.falseFunc\n            ? boolbase_1.falseFunc\n            : next === boolbase_1.trueFunc\n                ? function (elem) { return pseudo_1(elem, options, data); }\n                : function (elem) { return pseudo_1(elem, options, data) && next(elem); };\n    }\n    throw new Error(\"unmatched pseudo-class :\" + name);\n}\nexports.compilePseudoSelector = compilePseudoSelector;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/css-select/lib/pseudo-selectors/index.js?");

/***/ }),

/***/ "./src/node_modules/css-select/lib/pseudo-selectors/pseudos.js":
/*!*********************************************************************!*\
  !*** ./src/node_modules/css-select/lib/pseudo-selectors/pseudos.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.verifyPseudoArgs = exports.pseudos = void 0;\n// While filters are precompiled, pseudos get called when they are needed\nexports.pseudos = {\n    empty: function (elem, _a) {\n        var adapter = _a.adapter;\n        return !adapter.getChildren(elem).some(function (elem) {\n            // FIXME: `getText` call is potentially expensive.\n            return adapter.isTag(elem) || adapter.getText(elem) !== \"\";\n        });\n    },\n    \"first-child\": function (elem, _a) {\n        var adapter = _a.adapter, equals = _a.equals;\n        var firstChild = adapter\n            .getSiblings(elem)\n            .find(function (elem) { return adapter.isTag(elem); });\n        return firstChild != null && equals(elem, firstChild);\n    },\n    \"last-child\": function (elem, _a) {\n        var adapter = _a.adapter, equals = _a.equals;\n        var siblings = adapter.getSiblings(elem);\n        for (var i = siblings.length - 1; i >= 0; i--) {\n            if (equals(elem, siblings[i]))\n                return true;\n            if (adapter.isTag(siblings[i]))\n                break;\n        }\n        return false;\n    },\n    \"first-of-type\": function (elem, _a) {\n        var adapter = _a.adapter, equals = _a.equals;\n        var siblings = adapter.getSiblings(elem);\n        var elemName = adapter.getName(elem);\n        for (var i = 0; i < siblings.length; i++) {\n            var currentSibling = siblings[i];\n            if (equals(elem, currentSibling))\n                return true;\n            if (adapter.isTag(currentSibling) &&\n                adapter.getName(currentSibling) === elemName) {\n                break;\n            }\n        }\n        return false;\n    },\n    \"last-of-type\": function (elem, _a) {\n        var adapter = _a.adapter, equals = _a.equals;\n        var siblings = adapter.getSiblings(elem);\n        var elemName = adapter.getName(elem);\n        for (var i = siblings.length - 1; i >= 0; i--) {\n            var currentSibling = siblings[i];\n            if (equals(elem, currentSibling))\n                return true;\n            if (adapter.isTag(currentSibling) &&\n                adapter.getName(currentSibling) === elemName) {\n                break;\n            }\n        }\n        return false;\n    },\n    \"only-of-type\": function (elem, _a) {\n        var adapter = _a.adapter, equals = _a.equals;\n        var elemName = adapter.getName(elem);\n        return adapter\n            .getSiblings(elem)\n            .every(function (sibling) {\n            return equals(elem, sibling) ||\n                !adapter.isTag(sibling) ||\n                adapter.getName(sibling) !== elemName;\n        });\n    },\n    \"only-child\": function (elem, _a) {\n        var adapter = _a.adapter, equals = _a.equals;\n        return adapter\n            .getSiblings(elem)\n            .every(function (sibling) { return equals(elem, sibling) || !adapter.isTag(sibling); });\n    },\n};\nfunction verifyPseudoArgs(func, name, subselect) {\n    if (subselect === null) {\n        if (func.length > 2) {\n            throw new Error(\"pseudo-selector :\" + name + \" requires an argument\");\n        }\n    }\n    else if (func.length === 2) {\n        throw new Error(\"pseudo-selector :\" + name + \" doesn't have any arguments\");\n    }\n}\nexports.verifyPseudoArgs = verifyPseudoArgs;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/css-select/lib/pseudo-selectors/pseudos.js?");

/***/ }),

/***/ "./src/node_modules/css-select/lib/pseudo-selectors/subselects.js":
/*!************************************************************************!*\
  !*** ./src/node_modules/css-select/lib/pseudo-selectors/subselects.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.subselects = exports.getNextSiblings = exports.ensureIsTag = exports.PLACEHOLDER_ELEMENT = void 0;\nvar boolbase_1 = __webpack_require__(/*! boolbase */ \"./src/node_modules/boolbase/index.js\");\nvar procedure_1 = __webpack_require__(/*! ../procedure */ \"./src/node_modules/css-select/lib/procedure.js\");\n/** Used as a placeholder for :has. Will be replaced with the actual element. */\nexports.PLACEHOLDER_ELEMENT = {};\nfunction ensureIsTag(next, adapter) {\n    if (next === boolbase_1.falseFunc)\n        return boolbase_1.falseFunc;\n    return function (elem) { return adapter.isTag(elem) && next(elem); };\n}\nexports.ensureIsTag = ensureIsTag;\nfunction getNextSiblings(elem, adapter) {\n    var siblings = adapter.getSiblings(elem);\n    if (siblings.length <= 1)\n        return [];\n    var elemIndex = siblings.indexOf(elem);\n    if (elemIndex < 0 || elemIndex === siblings.length - 1)\n        return [];\n    return siblings.slice(elemIndex + 1).filter(adapter.isTag);\n}\nexports.getNextSiblings = getNextSiblings;\nvar is = function (next, token, options, context, compileToken) {\n    var opts = {\n        xmlMode: !!options.xmlMode,\n        adapter: options.adapter,\n        equals: options.equals,\n    };\n    var func = compileToken(token, opts, context);\n    return function (elem) { return func(elem) && next(elem); };\n};\n/*\n * :not, :has, :is and :matches have to compile selectors\n * doing this in src/pseudos.ts would lead to circular dependencies,\n * so we add them here\n */\nexports.subselects = {\n    is: is,\n    /**\n     * `:matches` is an alias for `:is`.\n     */\n    matches: is,\n    not: function (next, token, options, context, compileToken) {\n        var opts = {\n            xmlMode: !!options.xmlMode,\n            adapter: options.adapter,\n            equals: options.equals,\n        };\n        var func = compileToken(token, opts, context);\n        if (func === boolbase_1.falseFunc)\n            return next;\n        if (func === boolbase_1.trueFunc)\n            return boolbase_1.falseFunc;\n        return function not(elem) {\n            return !func(elem) && next(elem);\n        };\n    },\n    has: function (next, subselect, options, _context, compileToken) {\n        var adapter = options.adapter;\n        var opts = {\n            xmlMode: !!options.xmlMode,\n            adapter: adapter,\n            equals: options.equals,\n        };\n        // @ts-expect-error Uses an array as a pointer to the current element (side effects)\n        var context = subselect.some(function (s) {\n            return s.some(procedure_1.isTraversal);\n        })\n            ? [exports.PLACEHOLDER_ELEMENT]\n            : undefined;\n        var compiled = compileToken(subselect, opts, context);\n        if (compiled === boolbase_1.falseFunc)\n            return boolbase_1.falseFunc;\n        if (compiled === boolbase_1.trueFunc) {\n            return function (elem) {\n                return adapter.getChildren(elem).some(adapter.isTag) && next(elem);\n            };\n        }\n        var hasElement = ensureIsTag(compiled, adapter);\n        var _a = compiled.shouldTestNextSiblings, shouldTestNextSiblings = _a === void 0 ? false : _a;\n        /*\n         * `shouldTestNextSiblings` will only be true if the query starts with\n         * a traversal (sibling or adjacent). That means we will always have a context.\n         */\n        if (context) {\n            return function (elem) {\n                context[0] = elem;\n                var childs = adapter.getChildren(elem);\n                var nextElements = shouldTestNextSiblings\n                    ? __spreadArray(__spreadArray([], childs), getNextSiblings(elem, adapter)) : childs;\n                return (next(elem) && adapter.existsOne(hasElement, nextElements));\n            };\n        }\n        return function (elem) {\n            return next(elem) &&\n                adapter.existsOne(hasElement, adapter.getChildren(elem));\n        };\n    },\n};\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/css-select/lib/pseudo-selectors/subselects.js?");

/***/ }),

/***/ "./src/node_modules/css-select/lib/sort.js":
/*!*************************************************!*\
  !*** ./src/node_modules/css-select/lib/sort.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar procedure_1 = __webpack_require__(/*! ./procedure */ \"./src/node_modules/css-select/lib/procedure.js\");\nvar attributes = {\n    exists: 10,\n    equals: 8,\n    not: 7,\n    start: 6,\n    end: 6,\n    any: 5,\n    hyphen: 4,\n    element: 4,\n};\n/**\n * Sort the parts of the passed selector,\n * as there is potential for optimization\n * (some types of selectors are faster than others)\n *\n * @param arr Selector to sort\n */\nfunction sortByProcedure(arr) {\n    var procs = arr.map(getProcedure);\n    for (var i = 1; i < arr.length; i++) {\n        var procNew = procs[i];\n        if (procNew < 0)\n            continue;\n        for (var j = i - 1; j >= 0 && procNew < procs[j]; j--) {\n            var token = arr[j + 1];\n            arr[j + 1] = arr[j];\n            arr[j] = token;\n            procs[j + 1] = procs[j];\n            procs[j] = procNew;\n        }\n    }\n}\nexports.default = sortByProcedure;\nfunction getProcedure(token) {\n    var proc = procedure_1.procedure[token.type];\n    if (token.type === \"attribute\") {\n        proc = attributes[token.action];\n        if (proc === attributes.equals && token.name === \"id\") {\n            // Prefer ID selectors (eg. #ID)\n            proc = 9;\n        }\n        if (token.ignoreCase) {\n            /*\n             * IgnoreCase adds some overhead, prefer \"normal\" token\n             * this is a binary operation, to ensure it's still an int\n             */\n            proc >>= 1;\n        }\n    }\n    else if (token.type === \"pseudo\") {\n        if (!token.data) {\n            proc = 3;\n        }\n        else if (token.name === \"has\" || token.name === \"contains\") {\n            proc = 0; // Expensive in any case\n        }\n        else if (Array.isArray(token.data)) {\n            // \"matches\" and \"not\"\n            proc = 0;\n            for (var i = 0; i < token.data.length; i++) {\n                // TODO better handling of complex selectors\n                if (token.data[i].length !== 1)\n                    continue;\n                var cur = getProcedure(token.data[i][0]);\n                // Avoid executing :has or :contains\n                if (cur === 0) {\n                    proc = 0;\n                    break;\n                }\n                if (cur > proc)\n                    proc = cur;\n            }\n            if (token.data.length > 1 && proc > 0)\n                proc -= 1;\n        }\n        else {\n            proc = 1;\n        }\n    }\n    return proc;\n}\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/css-select/lib/sort.js?");

/***/ }),

/***/ "./src/node_modules/css-what/lib/index.js":
/*!************************************************!*\
  !*** ./src/node_modules/css-what/lib/index.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.stringify = exports.parse = void 0;\n__exportStar(__webpack_require__(/*! ./parse */ \"./src/node_modules/css-what/lib/parse.js\"), exports);\nvar parse_1 = __webpack_require__(/*! ./parse */ \"./src/node_modules/css-what/lib/parse.js\");\nObject.defineProperty(exports, \"parse\", ({ enumerable: true, get: function () { return __importDefault(parse_1).default; } }));\nvar stringify_1 = __webpack_require__(/*! ./stringify */ \"./src/node_modules/css-what/lib/stringify.js\");\nObject.defineProperty(exports, \"stringify\", ({ enumerable: true, get: function () { return __importDefault(stringify_1).default; } }));\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/css-what/lib/index.js?");

/***/ }),

/***/ "./src/node_modules/css-what/lib/parse.js":
/*!************************************************!*\
  !*** ./src/node_modules/css-what/lib/parse.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isTraversal = void 0;\nvar reName = /^[^\\\\#]?(?:\\\\(?:[\\da-f]{1,6}\\s?|.)|[\\w\\-\\u00b0-\\uFFFF])+/;\nvar reEscape = /\\\\([\\da-f]{1,6}\\s?|(\\s)|.)/gi;\nvar actionTypes = new Map([\n    [\"~\", \"element\"],\n    [\"^\", \"start\"],\n    [\"$\", \"end\"],\n    [\"*\", \"any\"],\n    [\"!\", \"not\"],\n    [\"|\", \"hyphen\"],\n]);\nvar Traversals = {\n    \">\": \"child\",\n    \"<\": \"parent\",\n    \"~\": \"sibling\",\n    \"+\": \"adjacent\",\n};\nvar attribSelectors = {\n    \"#\": [\"id\", \"equals\"],\n    \".\": [\"class\", \"element\"],\n};\n// Pseudos, whose data property is parsed as well.\nvar unpackPseudos = new Set([\n    \"has\",\n    \"not\",\n    \"matches\",\n    \"is\",\n    \"host\",\n    \"host-context\",\n]);\nvar traversalNames = new Set(__spreadArray([\n    \"descendant\"\n], Object.keys(Traversals).map(function (k) { return Traversals[k]; })));\n/**\n * Attributes that are case-insensitive in HTML.\n *\n * @private\n * @see https://html.spec.whatwg.org/multipage/semantics-other.html#case-sensitivity-of-selectors\n */\nvar caseInsensitiveAttributes = new Set([\n    \"accept\",\n    \"accept-charset\",\n    \"align\",\n    \"alink\",\n    \"axis\",\n    \"bgcolor\",\n    \"charset\",\n    \"checked\",\n    \"clear\",\n    \"codetype\",\n    \"color\",\n    \"compact\",\n    \"declare\",\n    \"defer\",\n    \"dir\",\n    \"direction\",\n    \"disabled\",\n    \"enctype\",\n    \"face\",\n    \"frame\",\n    \"hreflang\",\n    \"http-equiv\",\n    \"lang\",\n    \"language\",\n    \"link\",\n    \"media\",\n    \"method\",\n    \"multiple\",\n    \"nohref\",\n    \"noresize\",\n    \"noshade\",\n    \"nowrap\",\n    \"readonly\",\n    \"rel\",\n    \"rev\",\n    \"rules\",\n    \"scope\",\n    \"scrolling\",\n    \"selected\",\n    \"shape\",\n    \"target\",\n    \"text\",\n    \"type\",\n    \"valign\",\n    \"valuetype\",\n    \"vlink\",\n]);\n/**\n * Checks whether a specific selector is a traversal.\n * This is useful eg. in swapping the order of elements that\n * are not traversals.\n *\n * @param selector Selector to check.\n */\nfunction isTraversal(selector) {\n    return traversalNames.has(selector.type);\n}\nexports.isTraversal = isTraversal;\nvar stripQuotesFromPseudos = new Set([\"contains\", \"icontains\"]);\nvar quotes = new Set(['\"', \"'\"]);\n// Unescape function taken from https://github.com/jquery/sizzle/blob/master/src/sizzle.js#L152\nfunction funescape(_, escaped, escapedWhitespace) {\n    var high = parseInt(escaped, 16) - 0x10000;\n    // NaN means non-codepoint\n    return high !== high || escapedWhitespace\n        ? escaped\n        : high < 0\n            ? // BMP codepoint\n                String.fromCharCode(high + 0x10000)\n            : // Supplemental Plane codepoint (surrogate pair)\n                String.fromCharCode((high >> 10) | 0xd800, (high & 0x3ff) | 0xdc00);\n}\nfunction unescapeCSS(str) {\n    return str.replace(reEscape, funescape);\n}\nfunction isWhitespace(c) {\n    return c === \" \" || c === \"\\n\" || c === \"\\t\" || c === \"\\f\" || c === \"\\r\";\n}\n/**\n * Parses `selector`, optionally with the passed `options`.\n *\n * @param selector Selector to parse.\n * @param options Options for parsing.\n * @returns Returns a two-dimensional array.\n * The first dimension represents selectors separated by commas (eg. `sub1, sub2`),\n * the second contains the relevant tokens for that selector.\n */\nfunction parse(selector, options) {\n    var subselects = [];\n    var endIndex = parseSelector(subselects, \"\" + selector, options, 0);\n    if (endIndex < selector.length) {\n        throw new Error(\"Unmatched selector: \" + selector.slice(endIndex));\n    }\n    return subselects;\n}\nexports.default = parse;\nfunction parseSelector(subselects, selector, options, selectorIndex) {\n    var _a, _b;\n    if (options === void 0) { options = {}; }\n    var tokens = [];\n    var sawWS = false;\n    function getName(offset) {\n        var match = selector.slice(selectorIndex + offset).match(reName);\n        if (!match) {\n            throw new Error(\"Expected name, found \" + selector.slice(selectorIndex));\n        }\n        var name = match[0];\n        selectorIndex += offset + name.length;\n        return unescapeCSS(name);\n    }\n    function stripWhitespace(offset) {\n        while (isWhitespace(selector.charAt(selectorIndex + offset)))\n            offset++;\n        selectorIndex += offset;\n    }\n    function isEscaped(pos) {\n        var slashCount = 0;\n        while (selector.charAt(--pos) === \"\\\\\")\n            slashCount++;\n        return (slashCount & 1) === 1;\n    }\n    function ensureNotTraversal() {\n        if (tokens.length > 0 && isTraversal(tokens[tokens.length - 1])) {\n            throw new Error(\"Did not expect successive traversals.\");\n        }\n    }\n    stripWhitespace(0);\n    while (selector !== \"\") {\n        var firstChar = selector.charAt(selectorIndex);\n        if (isWhitespace(firstChar)) {\n            sawWS = true;\n            stripWhitespace(1);\n        }\n        else if (firstChar in Traversals) {\n            ensureNotTraversal();\n            tokens.push({ type: Traversals[firstChar] });\n            sawWS = false;\n            stripWhitespace(1);\n        }\n        else if (firstChar === \",\") {\n            if (tokens.length === 0) {\n                throw new Error(\"Empty sub-selector\");\n            }\n            subselects.push(tokens);\n            tokens = [];\n            sawWS = false;\n            stripWhitespace(1);\n        }\n        else if (selector.startsWith(\"/*\", selectorIndex)) {\n            var endIndex = selector.indexOf(\"*/\", selectorIndex + 2);\n            if (endIndex < 0) {\n                throw new Error(\"Comment was not terminated\");\n            }\n            selectorIndex = endIndex + 2;\n        }\n        else {\n            if (sawWS) {\n                ensureNotTraversal();\n                tokens.push({ type: \"descendant\" });\n                sawWS = false;\n            }\n            if (firstChar in attribSelectors) {\n                var _c = attribSelectors[firstChar], name_1 = _c[0], action = _c[1];\n                tokens.push({\n                    type: \"attribute\",\n                    name: name_1,\n                    action: action,\n                    value: getName(1),\n                    namespace: null,\n                    // TODO: Add quirksMode option, which makes `ignoreCase` `true` for HTML.\n                    ignoreCase: options.xmlMode ? null : false,\n                });\n            }\n            else if (firstChar === \"[\") {\n                stripWhitespace(1);\n                // Determine attribute name and namespace\n                var name_2 = void 0;\n                var namespace = null;\n                if (selector.charAt(selectorIndex) === \"|\") {\n                    namespace = \"\";\n                    selectorIndex += 1;\n                }\n                if (selector.startsWith(\"*|\", selectorIndex)) {\n                    namespace = \"*\";\n                    selectorIndex += 2;\n                }\n                name_2 = getName(0);\n                if (namespace === null &&\n                    selector.charAt(selectorIndex) === \"|\" &&\n                    selector.charAt(selectorIndex + 1) !== \"=\") {\n                    namespace = name_2;\n                    name_2 = getName(1);\n                }\n                if ((_a = options.lowerCaseAttributeNames) !== null && _a !== void 0 ? _a : !options.xmlMode) {\n                    name_2 = name_2.toLowerCase();\n                }\n                stripWhitespace(0);\n                // Determine comparison operation\n                var action = \"exists\";\n                var possibleAction = actionTypes.get(selector.charAt(selectorIndex));\n                if (possibleAction) {\n                    action = possibleAction;\n                    if (selector.charAt(selectorIndex + 1) !== \"=\") {\n                        throw new Error(\"Expected `=`\");\n                    }\n                    stripWhitespace(2);\n                }\n                else if (selector.charAt(selectorIndex) === \"=\") {\n                    action = \"equals\";\n                    stripWhitespace(1);\n                }\n                // Determine value\n                var value = \"\";\n                var ignoreCase = null;\n                if (action !== \"exists\") {\n                    if (quotes.has(selector.charAt(selectorIndex))) {\n                        var quote = selector.charAt(selectorIndex);\n                        var sectionEnd = selectorIndex + 1;\n                        while (sectionEnd < selector.length &&\n                            (selector.charAt(sectionEnd) !== quote ||\n                                isEscaped(sectionEnd))) {\n                            sectionEnd += 1;\n                        }\n                        if (selector.charAt(sectionEnd) !== quote) {\n                            throw new Error(\"Attribute value didn't end\");\n                        }\n                        value = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));\n                        selectorIndex = sectionEnd + 1;\n                    }\n                    else {\n                        var valueStart = selectorIndex;\n                        while (selectorIndex < selector.length &&\n                            ((!isWhitespace(selector.charAt(selectorIndex)) &&\n                                selector.charAt(selectorIndex) !== \"]\") ||\n                                isEscaped(selectorIndex))) {\n                            selectorIndex += 1;\n                        }\n                        value = unescapeCSS(selector.slice(valueStart, selectorIndex));\n                    }\n                    stripWhitespace(0);\n                    // See if we have a force ignore flag\n                    var forceIgnore = selector.charAt(selectorIndex);\n                    // If the forceIgnore flag is set (either `i` or `s`), use that value\n                    if (forceIgnore === \"s\" || forceIgnore === \"S\") {\n                        ignoreCase = false;\n                        stripWhitespace(1);\n                    }\n                    else if (forceIgnore === \"i\" || forceIgnore === \"I\") {\n                        ignoreCase = true;\n                        stripWhitespace(1);\n                    }\n                }\n                // If `xmlMode` is set, there are no rules; otherwise, use the `caseInsensitiveAttributes` list.\n                if (!options.xmlMode) {\n                    // TODO: Skip this for `exists`, as there is no value to compare to.\n                    ignoreCase !== null && ignoreCase !== void 0 ? ignoreCase : (ignoreCase = caseInsensitiveAttributes.has(name_2));\n                }\n                if (selector.charAt(selectorIndex) !== \"]\") {\n                    throw new Error(\"Attribute selector didn't terminate\");\n                }\n                selectorIndex += 1;\n                var attributeSelector = {\n                    type: \"attribute\",\n                    name: name_2,\n                    action: action,\n                    value: value,\n                    namespace: namespace,\n                    ignoreCase: ignoreCase,\n                };\n                tokens.push(attributeSelector);\n            }\n            else if (firstChar === \":\") {\n                if (selector.charAt(selectorIndex + 1) === \":\") {\n                    tokens.push({\n                        type: \"pseudo-element\",\n                        name: getName(2).toLowerCase(),\n                    });\n                    continue;\n                }\n                var name_3 = getName(1).toLowerCase();\n                var data = null;\n                if (selector.charAt(selectorIndex) === \"(\") {\n                    if (unpackPseudos.has(name_3)) {\n                        if (quotes.has(selector.charAt(selectorIndex + 1))) {\n                            throw new Error(\"Pseudo-selector \" + name_3 + \" cannot be quoted\");\n                        }\n                        data = [];\n                        selectorIndex = parseSelector(data, selector, options, selectorIndex + 1);\n                        if (selector.charAt(selectorIndex) !== \")\") {\n                            throw new Error(\"Missing closing parenthesis in :\" + name_3 + \" (\" + selector + \")\");\n                        }\n                        selectorIndex += 1;\n                    }\n                    else {\n                        selectorIndex += 1;\n                        var start = selectorIndex;\n                        var counter = 1;\n                        for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {\n                            if (selector.charAt(selectorIndex) === \"(\" &&\n                                !isEscaped(selectorIndex)) {\n                                counter++;\n                            }\n                            else if (selector.charAt(selectorIndex) === \")\" &&\n                                !isEscaped(selectorIndex)) {\n                                counter--;\n                            }\n                        }\n                        if (counter) {\n                            throw new Error(\"Parenthesis not matched\");\n                        }\n                        data = selector.slice(start, selectorIndex - 1);\n                        if (stripQuotesFromPseudos.has(name_3)) {\n                            var quot = data.charAt(0);\n                            if (quot === data.slice(-1) && quotes.has(quot)) {\n                                data = data.slice(1, -1);\n                            }\n                            data = unescapeCSS(data);\n                        }\n                    }\n                }\n                tokens.push({ type: \"pseudo\", name: name_3, data: data });\n            }\n            else {\n                var namespace = null;\n                var name_4 = void 0;\n                if (firstChar === \"*\") {\n                    selectorIndex += 1;\n                    name_4 = \"*\";\n                }\n                else if (reName.test(selector.slice(selectorIndex))) {\n                    if (selector.charAt(selectorIndex) === \"|\") {\n                        namespace = \"\";\n                        selectorIndex += 1;\n                    }\n                    name_4 = getName(0);\n                }\n                else {\n                    /*\n                     * We have finished parsing the selector.\n                     * Remove descendant tokens at the end if they exist,\n                     * and return the last index, so that parsing can be\n                     * picked up from here.\n                     */\n                    if (tokens.length &&\n                        tokens[tokens.length - 1].type === \"descendant\") {\n                        tokens.pop();\n                    }\n                    addToken(subselects, tokens);\n                    return selectorIndex;\n                }\n                if (selector.charAt(selectorIndex) === \"|\") {\n                    namespace = name_4;\n                    if (selector.charAt(selectorIndex + 1) === \"*\") {\n                        name_4 = \"*\";\n                        selectorIndex += 2;\n                    }\n                    else {\n                        name_4 = getName(1);\n                    }\n                }\n                if (name_4 === \"*\") {\n                    tokens.push({ type: \"universal\", namespace: namespace });\n                }\n                else {\n                    if ((_b = options.lowerCaseTags) !== null && _b !== void 0 ? _b : !options.xmlMode) {\n                        name_4 = name_4.toLowerCase();\n                    }\n                    tokens.push({ type: \"tag\", name: name_4, namespace: namespace });\n                }\n            }\n        }\n    }\n    addToken(subselects, tokens);\n    return selectorIndex;\n}\nfunction addToken(subselects, tokens) {\n    if (subselects.length > 0 && tokens.length === 0) {\n        throw new Error(\"Empty sub-selector\");\n    }\n    subselects.push(tokens);\n}\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/css-what/lib/parse.js?");

/***/ }),

/***/ "./src/node_modules/css-what/lib/stringify.js":
/*!****************************************************!*\
  !*** ./src/node_modules/css-what/lib/stringify.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar actionTypes = {\n    equals: \"\",\n    element: \"~\",\n    start: \"^\",\n    end: \"$\",\n    any: \"*\",\n    not: \"!\",\n    hyphen: \"|\",\n};\nvar charsToEscape = new Set(__spreadArray(__spreadArray([], Object.keys(actionTypes)\n    .map(function (typeKey) { return actionTypes[typeKey]; })\n    .filter(Boolean)), [\n    \":\",\n    \"[\",\n    \"]\",\n    \" \",\n    \"\\\\\",\n    \"(\",\n    \")\",\n    \"'\",\n]));\n/**\n * Turns `selector` back into a string.\n *\n * @param selector Selector to stringify.\n */\nfunction stringify(selector) {\n    return selector.map(stringifySubselector).join(\", \");\n}\nexports.default = stringify;\nfunction stringifySubselector(token) {\n    return token.map(stringifyToken).join(\"\");\n}\nfunction stringifyToken(token) {\n    switch (token.type) {\n        // Simple types\n        case \"child\":\n            return \" > \";\n        case \"parent\":\n            return \" < \";\n        case \"sibling\":\n            return \" ~ \";\n        case \"adjacent\":\n            return \" + \";\n        case \"descendant\":\n            return \" \";\n        case \"universal\":\n            return getNamespace(token.namespace) + \"*\";\n        case \"tag\":\n            return getNamespacedName(token);\n        case \"pseudo-element\":\n            return \"::\" + escapeName(token.name);\n        case \"pseudo\":\n            if (token.data === null)\n                return \":\" + escapeName(token.name);\n            if (typeof token.data === \"string\") {\n                return \":\" + escapeName(token.name) + \"(\" + escapeName(token.data) + \")\";\n            }\n            return \":\" + escapeName(token.name) + \"(\" + stringify(token.data) + \")\";\n        case \"attribute\": {\n            if (token.name === \"id\" &&\n                token.action === \"equals\" &&\n                !token.ignoreCase &&\n                !token.namespace) {\n                return \"#\" + escapeName(token.value);\n            }\n            if (token.name === \"class\" &&\n                token.action === \"element\" &&\n                !token.ignoreCase &&\n                !token.namespace) {\n                return \".\" + escapeName(token.value);\n            }\n            var name_1 = getNamespacedName(token);\n            if (token.action === \"exists\") {\n                return \"[\" + name_1 + \"]\";\n            }\n            return \"[\" + name_1 + actionTypes[token.action] + \"='\" + escapeName(token.value) + \"'\" + (token.ignoreCase ? \"i\" : token.ignoreCase === false ? \"s\" : \"\") + \"]\";\n        }\n    }\n}\nfunction getNamespacedName(token) {\n    return \"\" + getNamespace(token.namespace) + escapeName(token.name);\n}\nfunction getNamespace(namespace) {\n    return namespace !== null\n        ? (namespace === \"*\" ? \"*\" : escapeName(namespace)) + \"|\"\n        : \"\";\n}\nfunction escapeName(str) {\n    return str\n        .split(\"\")\n        .map(function (c) { return (charsToEscape.has(c) ? \"\\\\\" + c : c); })\n        .join(\"\");\n}\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/css-what/lib/stringify.js?");

/***/ }),

/***/ "./src/node_modules/date-and-time/date-and-time.js":
/*!*********************************************************!*\
  !*** ./src/node_modules/date-and-time/date-and-time.js ***!
  \*********************************************************/
/***/ (function(module, exports) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * @preserve date-and-time.js (c) KNOWLEDGECODE | MIT\n */\n(function (global) {\n    'use strict';\n\n    var date = {},\n        locales = {},\n        plugins = {},\n        lang = 'en',\n        _res = {\n            MMMM: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n            MMM: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n            dddd: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n            ddd: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],\n            dd: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],\n            A: ['AM', 'PM']\n        },\n        _formatter = {\n            YYYY: function (d/*, formatString*/) { return ('000' + d.getFullYear()).slice(-4); },\n            YY: function (d/*, formatString*/) { return ('0' + d.getFullYear()).slice(-2); },\n            Y: function (d/*, formatString*/) { return '' + d.getFullYear(); },\n            MMMM: function (d/*, formatString*/) { return this.res.MMMM[d.getMonth()]; },\n            MMM: function (d/*, formatString*/) { return this.res.MMM[d.getMonth()]; },\n            MM: function (d/*, formatString*/) { return ('0' + (d.getMonth() + 1)).slice(-2); },\n            M: function (d/*, formatString*/) { return '' + (d.getMonth() + 1); },\n            DD: function (d/*, formatString*/) { return ('0' + d.getDate()).slice(-2); },\n            D: function (d/*, formatString*/) { return '' + d.getDate(); },\n            HH: function (d/*, formatString*/) { return ('0' + d.getHours()).slice(-2); },\n            H: function (d/*, formatString*/) { return '' + d.getHours(); },\n            A: function (d/*, formatString*/) { return this.res.A[d.getHours() > 11 | 0]; },\n            hh: function (d/*, formatString*/) { return ('0' + (d.getHours() % 12 || 12)).slice(-2); },\n            h: function (d/*, formatString*/) { return '' + (d.getHours() % 12 || 12); },\n            mm: function (d/*, formatString*/) { return ('0' + d.getMinutes()).slice(-2); },\n            m: function (d/*, formatString*/) { return '' + d.getMinutes(); },\n            ss: function (d/*, formatString*/) { return ('0' + d.getSeconds()).slice(-2); },\n            s: function (d/*, formatString*/) { return '' + d.getSeconds(); },\n            SSS: function (d/*, formatString*/) { return ('00' + d.getMilliseconds()).slice(-3); },\n            SS: function (d/*, formatString*/) { return ('0' + (d.getMilliseconds() / 10 | 0)).slice(-2); },\n            S: function (d/*, formatString*/) { return '' + (d.getMilliseconds() / 100 | 0); },\n            dddd: function (d/*, formatString*/) { return this.res.dddd[d.getDay()]; },\n            ddd: function (d/*, formatString*/) { return this.res.ddd[d.getDay()]; },\n            dd: function (d/*, formatString*/) { return this.res.dd[d.getDay()]; },\n            Z: function (d/*, formatString*/) { return d.utc ? '+0000' : /[\\+-]\\d{4}/.exec(d.toTimeString())[0]; },\n            post: function (str) { return str; }\n        },\n        _parser = {\n            YYYY: function (str/*, formatString */) { return this.exec(/^\\d{4}/, str); },\n            Y: function (str/*, formatString */) { return this.exec(/^\\d{1,4}/, str); },\n            MMMM: function (str/*, formatString */) {\n                var result = this.find(this.res.MMMM, str);\n                result.value++;\n                return result;\n            },\n            MMM: function (str/*, formatString */) {\n                var result = this.find(this.res.MMM, str);\n                result.value++;\n                return result;\n            },\n            MM: function (str/*, formatString */) { return this.exec(/^\\d\\d/, str); },\n            M: function (str/*, formatString */) { return this.exec(/^\\d\\d?/, str); },\n            DD: function (str/*, formatString */) { return this.exec(/^\\d\\d/, str); },\n            D: function (str/*, formatString */) { return this.exec(/^\\d\\d?/, str); },\n            HH: function (str/*, formatString */) { return this.exec(/^\\d\\d/, str); },\n            H: function (str/*, formatString */) { return this.exec(/^\\d\\d?/, str); },\n            A: function (str/*, formatString */) { return this.find(this.res.A, str); },\n            hh: function (str/*, formatString */) { return this.exec(/^\\d\\d/, str); },\n            h: function (str/*, formatString */) { return this.exec(/^\\d\\d?/, str); },\n            mm: function (str/*, formatString */) { return this.exec(/^\\d\\d/, str); },\n            m: function (str/*, formatString */) { return this.exec(/^\\d\\d?/, str); },\n            ss: function (str/*, formatString */) { return this.exec(/^\\d\\d/, str); },\n            s: function (str/*, formatString */) { return this.exec(/^\\d\\d?/, str); },\n            SSS: function (str/*, formatString */) { return this.exec(/^\\d{1,3}/, str); },\n            SS: function (str/*, formatString */) {\n                var result = this.exec(/^\\d\\d?/, str);\n                result.value *= 10;\n                return result;\n            },\n            S: function (str/*, formatString */) {\n                var result = this.exec(/^\\d/, str);\n                result.value *= 100;\n                return result;\n            },\n            Z: function (str/*, formatString */) {\n                var result = this.exec(/^[\\+-]\\d{2}[0-5]\\d/, str);\n                result.value = (result.value / 100 | 0) * -60 - result.value % 100;\n                return result;\n            },\n            h12: function (h, a) { return (h === 12 ? 0 : h) + a * 12; },\n            exec: function (re, str) {\n                var result = (re.exec(str) || [''])[0];\n                return { value: result | 0, length: result.length };\n            },\n            find: function (array, str) {\n                var index = -1, length = 0;\n\n                for (var i = 0, len = array.length, item; i < len; i++) {\n                    item = array[i];\n                    if (!str.indexOf(item) && item.length > length) {\n                        index = i;\n                        length = item.length;\n                    }\n                }\n                return { value: index, length: length };\n            },\n            pre: function (str) { return str; }\n        },\n        customize = function (code, base, locale) {\n            var extend = function (proto, props, res) {\n                    var Locale = function (r) {\n                        if (r) { this.res = r; }\n                    };\n\n                    Locale.prototype = proto;\n                    Locale.prototype.constructor = Locale;\n\n                    var newLocale = new Locale(res),\n                        value;\n\n                    for (var key in props || {}) {\n                        value = props[key];\n                        newLocale[key] = value.slice ? value.slice() : value;\n                    }\n                    return newLocale;\n                },\n                loc = { res: extend(base.res, locale.res) };\n\n            loc.formatter = extend(base.formatter, locale.formatter, loc.res);\n            loc.parser = extend(base.parser, locale.parser, loc.res);\n            locales[code] = loc;\n        };\n\n    /**\n     * compiling a format string\n     * @param {string} formatString - a format string\n     * @returns {Array.<string>} a compiled object\n     */\n    date.compile = function (formatString) {\n        var re = /\\[([^\\[\\]]*|\\[[^\\[\\]]*\\])*\\]|([A-Za-z])\\2+|\\.{3}|./g, keys, pattern = [formatString];\n\n        while ((keys = re.exec(formatString))) {\n            pattern[pattern.length] = keys[0];\n        }\n        return pattern;\n    };\n\n    /**\n     * formatting a date\n     * @param {Date} dateObj - a Date object\n     * @param {string|Array.<string>} arg - a format string or a compiled object\n     * @param {boolean} [utc] - output as UTC\n     * @returns {string} a formatted string\n     */\n    date.format = function (dateObj, arg, utc) {\n        var pattern = typeof arg === 'string' ? date.compile(arg) : arg,\n            d = date.addMinutes(dateObj, utc ? dateObj.getTimezoneOffset() : 0),\n            formatter = locales[lang].formatter, str = '';\n\n        d.utc = utc || false;\n        for (var i = 1, len = pattern.length, token; i < len; i++) {\n            token = pattern[i];\n            str += formatter[token] ? formatter.post(formatter[token](d, pattern[0])) : token.replace(/\\[(.*)]/, '$1');\n        }\n        return str;\n    };\n\n    /**\n     * pre-parsing a date string\n     * @param {string} dateString - a date string\n     * @param {string|Array.<string>} arg - a format string or a compiled object\n     * @returns {Object} a date structure\n     */\n    date.preparse = function (dateString, arg) {\n        var pattern = typeof arg === 'string' ? date.compile(arg) : arg,\n            dt = { Y: 1970, M: 1, D: 1, H: 0, A: 0, h: 0, m: 0, s: 0, S: 0, Z: 0, _index: 0, _length: 0, _match: 0 },\n            parser = locales[lang].parser, offset = 0;\n\n        dateString = parser.pre(dateString);\n        for (var i = 1, len = pattern.length, token, result; i < len; i++) {\n            token = pattern[i];\n            if (parser[token]) {\n                result = parser[token](dateString.slice(offset), pattern[0]);\n                if (!result.length) {\n                    break;\n                }\n                offset += result.length;\n                dt[token.charAt(0)] = result.value;\n                dt._match++;\n            } else if (token === dateString.charAt(offset) || token === ' ') {\n                offset++;\n            } else if (/\\[.*]/.test(token)) {\n                offset += token.length - 2;\n            } else if (token === '...') {\n                offset = dateString.length;\n                break;\n            } else {\n                break;\n            }\n        }\n        dt.H = dt.H || parser.h12(dt.h, dt.A);\n        dt._index = offset;\n        dt._length = dateString.length;\n        return dt;\n    };\n\n    /**\n     * validation\n     * @param {Object|string} arg1 - a date structure or a date string\n     * @param {string|Array.<string>} [arg2] - a format string or a compiled object\n     * @returns {boolean} whether the date string is a valid date\n     */\n    date.isValid = function (arg1, arg2) {\n        var dt = typeof arg1 === 'string' ? date.preparse(arg1, arg2) : arg1,\n            last = [31, 28 + date.isLeapYear(dt.Y) | 0, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][dt.M - 1];\n\n        return !(\n            dt._index < 1 || dt._length < 1 || dt._index - dt._length || dt._match < 1 ||\n            dt.Y < 1 || dt.Y > 9999 || dt.M < 1 || dt.M > 12 || dt.D < 1 || dt.D > last ||\n            dt.H < 0 || dt.H > 23 || dt.m < 0 || dt.m > 59 || dt.s < 0 || dt.s > 59 || dt.S < 0 || dt.S > 999 ||\n            dt.Z < -720 || dt.Z > 840\n        );\n    };\n\n    /**\n     * parsing a date string\n     * @param {string} dateString - a date string\n     * @param {string|Array.<string>} arg - a format string or a compiled object\n     * @param {boolean} [utc] - input as UTC\n     * @returns {Date} a constructed date\n     */\n    date.parse = function (dateString, arg, utc) {\n        var dt = date.preparse(dateString, arg);\n\n        if (date.isValid(dt)) {\n            dt.M -= dt.Y < 100 ? 22801 : 1; // 22801 = 1900 * 12 + 1\n            if (utc || dt.Z) {\n                return new Date(Date.UTC(dt.Y, dt.M, dt.D, dt.H, dt.m + dt.Z, dt.s, dt.S));\n            }\n            return new Date(dt.Y, dt.M, dt.D, dt.H, dt.m, dt.s, dt.S);\n        }\n        return new Date(NaN);\n    };\n\n    /**\n     * adding years\n     * @param {Date} dateObj - a date object\n     * @param {number} years - number of years to add\n     * @returns {Date} a date after adding the value\n     */\n    date.addYears = function (dateObj, years) {\n        return date.addMonths(dateObj, years * 12);\n    };\n\n    /**\n     * adding months\n     * @param {Date} dateObj - a date object\n     * @param {number} months - number of months to add\n     * @returns {Date} a date after adding the value\n     */\n    date.addMonths = function (dateObj, months) {\n        var d = new Date(dateObj.getTime());\n\n        d.setMonth(d.getMonth() + months);\n        return d;\n    };\n\n    /**\n     * adding days\n     * @param {Date} dateObj - a date object\n     * @param {number} days - number of days to add\n     * @returns {Date} a date after adding the value\n     */\n    date.addDays = function (dateObj, days) {\n        var d = new Date(dateObj.getTime());\n\n        d.setDate(d.getDate() + days);\n        return d;\n    };\n\n    /**\n     * adding hours\n     * @param {Date} dateObj - a date object\n     * @param {number} hours - number of hours to add\n     * @returns {Date} a date after adding the value\n     */\n    date.addHours = function (dateObj, hours) {\n        return date.addMinutes(dateObj, hours * 60);\n    };\n\n    /**\n     * adding minutes\n     * @param {Date} dateObj - a date object\n     * @param {number} minutes - number of minutes to add\n     * @returns {Date} a date after adding the value\n     */\n    date.addMinutes = function (dateObj, minutes) {\n        return date.addSeconds(dateObj, minutes * 60);\n    };\n\n    /**\n     * adding seconds\n     * @param {Date} dateObj - a date object\n     * @param {number} seconds - number of seconds to add\n     * @returns {Date} a date after adding the value\n     */\n    date.addSeconds = function (dateObj, seconds) {\n        return date.addMilliseconds(dateObj, seconds * 1000);\n    };\n\n    /**\n     * adding milliseconds\n     * @param {Date} dateObj - a date object\n     * @param {number} milliseconds - number of milliseconds to add\n     * @returns {Date} a date after adding the value\n     */\n    date.addMilliseconds = function (dateObj, milliseconds) {\n        return new Date(dateObj.getTime() + milliseconds);\n    };\n\n    /**\n     * subtracting\n     * @param {Date} date1 - a Date object\n     * @param {Date} date2 - a Date object\n     * @returns {Object} a result object subtracting date2 from date1\n     */\n    date.subtract = function (date1, date2) {\n        var delta = date1.getTime() - date2.getTime();\n\n        return {\n            toMilliseconds: function () {\n                return delta;\n            },\n            toSeconds: function () {\n                return delta / 1000;\n            },\n            toMinutes: function () {\n                return delta / 60000;\n            },\n            toHours: function () {\n                return delta / 3600000;\n            },\n            toDays: function () {\n                return delta / 86400000;\n            }\n        };\n    };\n\n    /**\n     * leap year\n     * @param {number} y - year\n     * @returns {boolean} whether the year is a leap year\n     */\n    date.isLeapYear = function (y) {\n        return (!(y % 4) && !!(y % 100)) || !(y % 400);\n    };\n\n    /**\n     * comparison of two dates\n     * @param {Date} date1 - a Date object\n     * @param {Date} date2 - a Date object\n     * @returns {boolean} whether the dates are the same day (times are ignored)\n     */\n    date.isSameDay = function (date1, date2) {\n        return date1.toDateString() === date2.toDateString();\n    };\n\n    /**\n     * change locale or setting a new locale definition\n     * @param {string} [code] - language code\n     * @param {Object} [locale] - locale definition\n     * @returns {string} current language code\n     */\n    date.locale = function (code, locale) {\n        if (locale) {\n            customize(code, { res: _res, formatter: _formatter, parser: _parser }, locale);\n        } else if (code) {\n            lang = code;\n        }\n        return lang;\n    };\n\n    /**\n     * locale extension\n     * @param {Object} extension - locale extension\n     * @returns {void}\n     */\n    date.extend = function (extension) {\n        var extender = extension.extender || {};\n\n        for (var key in extender) {\n            if (!date[key]) {\n                date[key] = extender[key];\n            }\n        }\n        if (extension.formatter || extension.parser || extension.res) {\n            customize(lang, locales[lang], extension);\n        }\n    };\n\n    /**\n     * plugin import or definition\n     * @param {string} name - plugin name\n     * @param {Object} [extension] - locale extension\n     * @returns {void}\n     */\n    date.plugin = function (name, extension) {\n        plugins[name] = plugins[name] || extension;\n        if (!extension && plugins[name]) {\n            date.extend(plugins[name]);\n        }\n    };\n\n    // Create default locale (English)\n    date.locale(lang, {});\n\n    if ( true && typeof module.exports === 'object') {\n        module.exports = date;\n    } else if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n            return date;\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n\n}(this));\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/date-and-time/date-and-time.js?");

/***/ }),

/***/ "./src/node_modules/deep-equal/index.js":
/*!**********************************************!*\
  !*** ./src/node_modules/deep-equal/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar objectKeys = __webpack_require__(/*! object-keys */ \"object-keys\");\nvar isArguments = __webpack_require__(/*! is-arguments */ \"./src/node_modules/is-arguments/index.js\");\nvar is = __webpack_require__(/*! object-is */ \"./src/node_modules/object-is/index.js\");\nvar isRegex = __webpack_require__(/*! is-regex */ \"./src/node_modules/is-regex/index.js\");\nvar flags = __webpack_require__(/*! regexp.prototype.flags */ \"./src/node_modules/regexp.prototype.flags/index.js\");\nvar isArray = __webpack_require__(/*! isarray */ \"isarray\");\nvar isDate = __webpack_require__(/*! is-date-object */ \"./src/node_modules/is-date-object/index.js\");\nvar whichBoxedPrimitive = __webpack_require__(/*! which-boxed-primitive */ \"./src/node_modules/which-boxed-primitive/index.js\");\nvar GetIntrinsic = __webpack_require__(/*! get-intrinsic */ \"get-intrinsic\");\nvar callBound = __webpack_require__(/*! call-bind/callBound */ \"call-bind/callBound\");\nvar whichCollection = __webpack_require__(/*! which-collection */ \"./src/node_modules/which-collection/index.js\");\nvar getIterator = __webpack_require__(/*! es-get-iterator */ \"./src/node_modules/es-get-iterator/node.js\");\nvar getSideChannel = __webpack_require__(/*! side-channel */ \"side-channel\");\nvar whichTypedArray = __webpack_require__(/*! which-typed-array */ \"./src/node_modules/which-typed-array/index.js\");\nvar assign = __webpack_require__(/*! object.assign */ \"object.assign\");\n\nvar $getTime = callBound('Date.prototype.getTime');\nvar gPO = Object.getPrototypeOf;\nvar $objToString = callBound('Object.prototype.toString');\n\nvar $Set = GetIntrinsic('%Set%', true);\nvar $mapHas = callBound('Map.prototype.has', true);\nvar $mapGet = callBound('Map.prototype.get', true);\nvar $mapSize = callBound('Map.prototype.size', true);\nvar $setAdd = callBound('Set.prototype.add', true);\nvar $setDelete = callBound('Set.prototype.delete', true);\nvar $setHas = callBound('Set.prototype.has', true);\nvar $setSize = callBound('Set.prototype.size', true);\n\n// taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L401-L414\nfunction setHasEqualElement(set, val1, opts, channel) {\n  var i = getIterator(set);\n  var result;\n  while ((result = i.next()) && !result.done) {\n    if (internalDeepEqual(val1, result.value, opts, channel)) { // eslint-disable-line no-use-before-define\n      // Remove the matching element to make sure we do not check that again.\n      $setDelete(set, result.value);\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L416-L439\nfunction findLooseMatchingPrimitives(prim) {\n  if (typeof prim === 'undefined') {\n    return null;\n  }\n  if (typeof prim === 'object') { // Only pass in null as object!\n    return void 0;\n  }\n  if (typeof prim === 'symbol') {\n    return false;\n  }\n  if (typeof prim === 'string' || typeof prim === 'number') {\n    // Loose equal entries exist only if the string is possible to convert to a regular number and not NaN.\n    return +prim === +prim; // eslint-disable-line no-implicit-coercion\n  }\n  return true;\n}\n\n// taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L449-L460\nfunction mapMightHaveLoosePrim(a, b, prim, item, opts, channel) {\n  var altValue = findLooseMatchingPrimitives(prim);\n  if (altValue != null) {\n    return altValue;\n  }\n  var curB = $mapGet(b, altValue);\n  var looseOpts = assign({}, opts, { strict: false });\n  if (\n    (typeof curB === 'undefined' && !$mapHas(b, altValue))\n    // eslint-disable-next-line no-use-before-define\n    || !internalDeepEqual(item, curB, looseOpts, channel)\n  ) {\n    return false;\n  }\n  // eslint-disable-next-line no-use-before-define\n  return !$mapHas(a, altValue) && internalDeepEqual(item, curB, looseOpts, channel);\n}\n\n// taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L441-L447\nfunction setMightHaveLoosePrim(a, b, prim) {\n  var altValue = findLooseMatchingPrimitives(prim);\n  if (altValue != null) {\n    return altValue;\n  }\n\n  return $setHas(b, altValue) && !$setHas(a, altValue);\n}\n\n// taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L518-L533\nfunction mapHasEqualEntry(set, map, key1, item1, opts, channel) {\n  var i = getIterator(set);\n  var result;\n  var key2;\n  while ((result = i.next()) && !result.done) {\n    key2 = result.value;\n    if (\n      // eslint-disable-next-line no-use-before-define\n      internalDeepEqual(key1, key2, opts, channel)\n      // eslint-disable-next-line no-use-before-define\n      && internalDeepEqual(item1, $mapGet(map, key2), opts, channel)\n    ) {\n      $setDelete(set, key2);\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction internalDeepEqual(actual, expected, options, channel) {\n  var opts = options || {};\n\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (opts.strict ? is(actual, expected) : actual === expected) {\n    return true;\n  }\n\n  var actualBoxed = whichBoxedPrimitive(actual);\n  var expectedBoxed = whichBoxedPrimitive(expected);\n  if (actualBoxed !== expectedBoxed) {\n    return false;\n  }\n\n  // 7.3. Other pairs that do not both pass typeof value == 'object', equivalence is determined by ==.\n  if (!actual || !expected || (typeof actual !== 'object' && typeof expected !== 'object')) {\n    return opts.strict ? is(actual, expected) : actual == expected; // eslint-disable-line eqeqeq\n  }\n\n  /*\n   * 7.4. For all other Object pairs, including Array objects, equivalence is\n   * determined by having the same number of owned properties (as verified\n   * with Object.prototype.hasOwnProperty.call), the same set of keys\n   * (although not necessarily the same order), equivalent values for every\n   * corresponding key, and an identical 'prototype' property. Note: this\n   * accounts for both named and indexed properties on Arrays.\n   */\n  // see https://github.com/nodejs/node/commit/d3aafd02efd3a403d646a3044adcf14e63a88d32 for memos/channel inspiration\n\n  var hasActual = channel.has(actual);\n  var hasExpected = channel.has(expected);\n  var sentinel;\n  if (hasActual && hasExpected) {\n    if (channel.get(actual) === channel.get(expected)) {\n      return true;\n    }\n  } else {\n    sentinel = {};\n  }\n  if (!hasActual) { channel.set(actual, sentinel); }\n  if (!hasExpected) { channel.set(expected, sentinel); }\n\n  // eslint-disable-next-line no-use-before-define\n  return objEquiv(actual, expected, opts, channel);\n}\n\nfunction isBuffer(x) {\n  if (!x || typeof x !== 'object' || typeof x.length !== 'number') {\n    return false;\n  }\n  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {\n    return false;\n  }\n  if (x.length > 0 && typeof x[0] !== 'number') {\n    return false;\n  }\n\n  return !!(x.constructor && x.constructor.isBuffer && x.constructor.isBuffer(x));\n}\n\nfunction setEquiv(a, b, opts, channel) {\n  if ($setSize(a) !== $setSize(b)) {\n    return false;\n  }\n  var iA = getIterator(a);\n  var iB = getIterator(b);\n  var resultA;\n  var resultB;\n  var set;\n  while ((resultA = iA.next()) && !resultA.done) {\n    if (resultA.value && typeof resultA.value === 'object') {\n      if (!set) { set = new $Set(); }\n      $setAdd(set, resultA.value);\n    } else if (!$setHas(b, resultA.value)) {\n      if (opts.strict) { return false; }\n      if (!setMightHaveLoosePrim(a, b, resultA.value)) {\n        return false;\n      }\n      if (!set) { set = new $Set(); }\n      $setAdd(set, resultA.value);\n    }\n  }\n  if (set) {\n    while ((resultB = iB.next()) && !resultB.done) {\n      // We have to check if a primitive value is already matching and only if it's not, go hunting for it.\n      if (resultB.value && typeof resultB.value === 'object') {\n        if (!setHasEqualElement(set, resultB.value, opts.strict, channel)) {\n          return false;\n        }\n      } else if (\n        !opts.strict\n        && !$setHas(a, resultB.value)\n        && !setHasEqualElement(set, resultB.value, opts.strict, channel)\n      ) {\n        return false;\n      }\n    }\n    return $setSize(set) === 0;\n  }\n  return true;\n}\n\nfunction mapEquiv(a, b, opts, channel) {\n  if ($mapSize(a) !== $mapSize(b)) {\n    return false;\n  }\n  var iA = getIterator(a);\n  var iB = getIterator(b);\n  var resultA;\n  var resultB;\n  var set;\n  var key;\n  var item1;\n  var item2;\n  while ((resultA = iA.next()) && !resultA.done) {\n    key = resultA.value[0];\n    item1 = resultA.value[1];\n    if (key && typeof key === 'object') {\n      if (!set) { set = new $Set(); }\n      $setAdd(set, key);\n    } else {\n      item2 = $mapGet(b, key);\n      if ((typeof item2 === 'undefined' && !$mapHas(b, key)) || !internalDeepEqual(item1, item2, opts, channel)) {\n        if (opts.strict) {\n          return false;\n        }\n        if (!mapMightHaveLoosePrim(a, b, key, item1, opts, channel)) {\n          return false;\n        }\n        if (!set) { set = new $Set(); }\n        $setAdd(set, key);\n      }\n    }\n  }\n\n  if (set) {\n    while ((resultB = iB.next()) && !resultB.done) {\n      key = resultB.value[0];\n      item2 = resultB.value[1];\n      if (key && typeof key === 'object') {\n        if (!mapHasEqualEntry(set, a, key, item2, opts, channel)) {\n          return false;\n        }\n      } else if (\n        !opts.strict\n        && (!a.has(key) || !internalDeepEqual($mapGet(a, key), item2, opts, channel))\n        && !mapHasEqualEntry(set, a, key, item2, assign({}, opts, { strict: false }), channel)\n      ) {\n        return false;\n      }\n    }\n    return $setSize(set) === 0;\n  }\n  return true;\n}\n\nfunction objEquiv(a, b, opts, channel) {\n  /* eslint max-statements: [2, 100], max-lines-per-function: [2, 120], max-depth: [2, 5] */\n  var i, key;\n\n  if (typeof a !== typeof b) { return false; }\n  if (a == null || b == null) { return false; }\n\n  if ($objToString(a) !== $objToString(b)) { return false; }\n\n  if (isArguments(a) !== isArguments(b)) { return false; }\n\n  var aIsArray = isArray(a);\n  var bIsArray = isArray(b);\n  if (aIsArray !== bIsArray) { return false; }\n\n  // TODO: replace when a cross-realm brand check is available\n  var aIsError = a instanceof Error;\n  var bIsError = b instanceof Error;\n  if (aIsError !== bIsError) { return false; }\n  if (aIsError || bIsError) {\n    if (a.name !== b.name || a.message !== b.message) { return false; }\n  }\n\n  var aIsRegex = isRegex(a);\n  var bIsRegex = isRegex(b);\n  if (aIsRegex !== bIsRegex) { return false; }\n  if ((aIsRegex || bIsRegex) && (a.source !== b.source || flags(a) !== flags(b))) {\n    return false;\n  }\n\n  var aIsDate = isDate(a);\n  var bIsDate = isDate(b);\n  if (aIsDate !== bIsDate) { return false; }\n  if (aIsDate || bIsDate) { // && would work too, because both are true or both false here\n    if ($getTime(a) !== $getTime(b)) { return false; }\n  }\n  if (opts.strict && gPO && gPO(a) !== gPO(b)) { return false; }\n\n  if (whichTypedArray(a) !== whichTypedArray(b)) {\n    return false;\n  }\n\n  var aIsBuffer = isBuffer(a);\n  var bIsBuffer = isBuffer(b);\n  if (aIsBuffer !== bIsBuffer) { return false; }\n  if (aIsBuffer || bIsBuffer) { // && would work too, because both are true or both false here\n    if (a.length !== b.length) { return false; }\n    for (i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) { return false; }\n    }\n    return true;\n  }\n\n  if (typeof a !== typeof b) { return false; }\n\n  var ka = objectKeys(a);\n  var kb = objectKeys(b);\n  // having the same number of owned properties (keys incorporates hasOwnProperty)\n  if (ka.length !== kb.length) { return false; }\n\n  // the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  // ~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i]) { return false; } // eslint-disable-line eqeqeq\n  }\n\n  // equivalent values for every corresponding key, and ~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!internalDeepEqual(a[key], b[key], opts, channel)) { return false; }\n  }\n\n  var aCollection = whichCollection(a);\n  var bCollection = whichCollection(b);\n  if (aCollection !== bCollection) {\n    return false;\n  }\n  if (aCollection === 'Set' || bCollection === 'Set') { // aCollection === bCollection\n    return setEquiv(a, b, opts, channel);\n  }\n  if (aCollection === 'Map') { // aCollection === bCollection\n    return mapEquiv(a, b, opts, channel);\n  }\n\n  return true;\n}\n\nmodule.exports = function deepEqual(a, b, opts) {\n  return internalDeepEqual(a, b, opts, getSideChannel());\n};\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/deep-equal/index.js?");

/***/ }),

/***/ "./src/node_modules/dicer/lib/Dicer.js":
/*!*********************************************!*\
  !*** ./src/node_modules/dicer/lib/Dicer.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var WritableStream = __webpack_require__(/*! stream */ \"stream\").Writable,\n    inherits = __webpack_require__(/*! util */ \"util\").inherits;\n\nvar StreamSearch = __webpack_require__(/*! streamsearch */ \"./src/node_modules/streamsearch/lib/sbmh.js\");\n\nvar PartStream = __webpack_require__(/*! ./PartStream */ \"./src/node_modules/dicer/lib/PartStream.js\"),\n    HeaderParser = __webpack_require__(/*! ./HeaderParser */ \"./src/node_modules/dicer/lib/HeaderParser.js\");\n\nvar DASH = 45,\n    B_ONEDASH = Buffer.from('-'),\n    B_CRLF = Buffer.from('\\r\\n'),\n    EMPTY_FN = function() {};\n\nfunction Dicer(cfg) {\n  if (!(this instanceof Dicer))\n    return new Dicer(cfg);\n  WritableStream.call(this, cfg);\n\n  if (!cfg || (!cfg.headerFirst && typeof cfg.boundary !== 'string'))\n    throw new TypeError('Boundary required');\n\n  if (typeof cfg.boundary === 'string')\n    this.setBoundary(cfg.boundary);\n  else\n    this._bparser = undefined;\n\n  this._headerFirst = cfg.headerFirst;\n\n  var self = this;\n\n  this._dashes = 0;\n  this._parts = 0;\n  this._finished = false;\n  this._realFinish = false;\n  this._isPreamble = true;\n  this._justMatched = false;\n  this._firstWrite = true;\n  this._inHeader = true;\n  this._part = undefined;\n  this._cb = undefined;\n  this._ignoreData = false;\n  this._partOpts = (typeof cfg.partHwm === 'number'\n                    ? { highWaterMark: cfg.partHwm }\n                    : {});\n  this._pause = false;\n\n  this._hparser = new HeaderParser(cfg);\n  this._hparser.on('header', function(header) {\n    self._inHeader = false;\n    self._part.emit('header', header);\n  });\n\n}\ninherits(Dicer, WritableStream);\n\nDicer.prototype.emit = function(ev) {\n  if (ev === 'finish' && !this._realFinish) {\n    if (!this._finished) {\n      var self = this;\n      process.nextTick(function() {\n        self.emit('error', new Error('Unexpected end of multipart data'));\n        if (self._part && !self._ignoreData) {\n          var type = (self._isPreamble ? 'Preamble' : 'Part');\n          self._part.emit('error', new Error(type + ' terminated early due to unexpected end of multipart data'));\n          self._part.push(null);\n          process.nextTick(function() {\n            self._realFinish = true;\n            self.emit('finish');\n            self._realFinish = false;\n          });\n          return;\n        }\n        self._realFinish = true;\n        self.emit('finish');\n        self._realFinish = false;\n      });\n    }\n  } else\n    WritableStream.prototype.emit.apply(this, arguments);\n};\n\nDicer.prototype._write = function(data, encoding, cb) {\n  // ignore unexpected data (e.g. extra trailer data after finished)\n  if (!this._hparser && !this._bparser)\n    return cb();\n\n  if (this._headerFirst && this._isPreamble) {\n    if (!this._part) {\n      this._part = new PartStream(this._partOpts);\n      if (this._events.preamble)\n        this.emit('preamble', this._part);\n      else\n        this._ignore();\n    }\n    var r = this._hparser.push(data);\n    if (!this._inHeader && r !== undefined && r < data.length)\n      data = data.slice(r);\n    else\n      return cb();\n  }\n\n  // allows for \"easier\" testing\n  if (this._firstWrite) {\n    this._bparser.push(B_CRLF);\n    this._firstWrite = false;\n  }\n\n  this._bparser.push(data);\n\n  if (this._pause)\n    this._cb = cb;\n  else\n    cb();\n};\n\nDicer.prototype.reset = function() {\n  this._part = undefined;\n  this._bparser = undefined;\n  this._hparser = undefined;\n};\n\nDicer.prototype.setBoundary = function(boundary) {\n  var self = this;\n  this._bparser = new StreamSearch('\\r\\n--' + boundary);\n  this._bparser.on('info', function(isMatch, data, start, end) {\n    self._oninfo(isMatch, data, start, end);\n  });\n};\n\nDicer.prototype._ignore = function() {\n  if (this._part && !this._ignoreData) {\n    this._ignoreData = true;\n    this._part.on('error', EMPTY_FN);\n    // we must perform some kind of read on the stream even though we are\n    // ignoring the data, otherwise node's Readable stream will not emit 'end'\n    // after pushing null to the stream\n    this._part.resume();\n  }\n};\n\nDicer.prototype._oninfo = function(isMatch, data, start, end) {\n  var buf, self = this, i = 0, r, ev, shouldWriteMore = true;\n\n  if (!this._part && this._justMatched && data) {\n    while (this._dashes < 2 && (start + i) < end) {\n      if (data[start + i] === DASH) {\n        ++i;\n        ++this._dashes;\n      } else {\n        if (this._dashes)\n          buf = B_ONEDASH;\n        this._dashes = 0;\n        break;\n      }\n    }\n    if (this._dashes === 2) {\n      if ((start + i) < end && this._events.trailer)\n        this.emit('trailer', data.slice(start + i, end));\n      this.reset();\n      this._finished = true;\n      // no more parts will be added\n      if (self._parts === 0) {\n        self._realFinish = true;\n        self.emit('finish');\n        self._realFinish = false;\n      }\n    }\n    if (this._dashes)\n      return;\n  }\n  if (this._justMatched)\n    this._justMatched = false;\n  if (!this._part) {\n    this._part = new PartStream(this._partOpts);\n    this._part._read = function(n) {\n      self._unpause();\n    };\n    ev = this._isPreamble ? 'preamble' : 'part';\n    if (this._events[ev])\n      this.emit(ev, this._part);\n    else\n      this._ignore();\n    if (!this._isPreamble)\n      this._inHeader = true;\n  }\n  if (data && start < end && !this._ignoreData) {\n    if (this._isPreamble || !this._inHeader) {\n      if (buf)\n        shouldWriteMore = this._part.push(buf);\n      shouldWriteMore = this._part.push(data.slice(start, end));\n      if (!shouldWriteMore)\n        this._pause = true;\n    } else if (!this._isPreamble && this._inHeader) {\n      if (buf)\n        this._hparser.push(buf);\n      r = this._hparser.push(data.slice(start, end));\n      if (!this._inHeader && r !== undefined && r < end)\n        this._oninfo(false, data, start + r, end);\n    }\n  }\n  if (isMatch) {\n    this._hparser.reset();\n    if (this._isPreamble)\n      this._isPreamble = false;\n    else {\n      ++this._parts;\n      this._part.on('end', function() {\n        if (--self._parts === 0) {\n          if (self._finished) {\n            self._realFinish = true;\n            self.emit('finish');\n            self._realFinish = false;\n          } else {\n            self._unpause();\n          }\n        }\n      });\n    }\n    this._part.push(null);\n    this._part = undefined;\n    this._ignoreData = false;\n    this._justMatched = true;\n    this._dashes = 0;\n  }\n};\n\nDicer.prototype._unpause = function() {\n  if (!this._pause)\n    return;\n\n  this._pause = false;\n  if (this._cb) {\n    var cb = this._cb;\n    this._cb = undefined;\n    cb();\n  }\n};\n\nmodule.exports = Dicer;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/dicer/lib/Dicer.js?");

/***/ }),

/***/ "./src/node_modules/dicer/lib/HeaderParser.js":
/*!****************************************************!*\
  !*** ./src/node_modules/dicer/lib/HeaderParser.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter,\n    inherits = __webpack_require__(/*! util */ \"util\").inherits;\n\nvar StreamSearch = __webpack_require__(/*! streamsearch */ \"./src/node_modules/streamsearch/lib/sbmh.js\");\n\nvar B_DCRLF = Buffer.from('\\r\\n\\r\\n'),\n    RE_CRLF = /\\r\\n/g,\n    RE_HDR = /^([^:]+):[ \\t]?([\\x00-\\xFF]+)?$/,\n    MAX_HEADER_PAIRS = 2000, // from node's http.js\n    MAX_HEADER_SIZE = 80 * 1024; // from node's http_parser\n\nfunction HeaderParser(cfg) {\n  EventEmitter.call(this);\n\n  var self = this;\n  this.nread = 0;\n  this.maxed = false;\n  this.npairs = 0;\n  this.maxHeaderPairs = (cfg && typeof cfg.maxHeaderPairs === 'number'\n                         ? cfg.maxHeaderPairs\n                         : MAX_HEADER_PAIRS);\n  this.buffer = '';\n  this.header = {};\n  this.finished = false;\n  this.ss = new StreamSearch(B_DCRLF);\n  this.ss.on('info', function(isMatch, data, start, end) {\n    if (data && !self.maxed) {\n      if (self.nread + (end - start) > MAX_HEADER_SIZE) {\n        end = (MAX_HEADER_SIZE - self.nread);\n        self.nread = MAX_HEADER_SIZE;\n      } else\n        self.nread += (end - start);\n\n      if (self.nread === MAX_HEADER_SIZE)\n        self.maxed = true;\n\n      self.buffer += data.toString('binary', start, end);\n    }\n    if (isMatch)\n      self._finish();\n  });\n}\ninherits(HeaderParser, EventEmitter);\n\nHeaderParser.prototype.push = function(data) {\n  var r = this.ss.push(data);\n  if (this.finished)\n    return r;\n};\n\nHeaderParser.prototype.reset = function() {\n  this.finished = false;\n  this.buffer = '';\n  this.header = {};\n  this.ss.reset();\n};\n\nHeaderParser.prototype._finish = function() {\n  if (this.buffer)\n    this._parseHeader();\n  this.ss.matches = this.ss.maxMatches;\n  var header = this.header;\n  this.header = {};\n  this.buffer = '';\n  this.finished = true;\n  this.nread = this.npairs = 0;\n  this.maxed = false;\n  this.emit('header', header);\n};\n\nHeaderParser.prototype._parseHeader = function() {\n  if (this.npairs === this.maxHeaderPairs)\n    return;\n\n  var lines = this.buffer.split(RE_CRLF), len = lines.length, m, h,\n      modded = false;\n\n  for (var i = 0; i < len; ++i) {\n    if (lines[i].length === 0)\n      continue;\n    if (lines[i][0] === '\\t' || lines[i][0] === ' ') {\n      // folded header content\n      // RFC2822 says to just remove the CRLF and not the whitespace following\n      // it, so we follow the RFC and include the leading whitespace ...\n      this.header[h][this.header[h].length - 1] += lines[i];\n    } else {\n      m = RE_HDR.exec(lines[i]);\n      if (m) {\n        h = m[1].toLowerCase();\n        if (m[2]) {\n          if (this.header[h] === undefined)\n            this.header[h] = [m[2]];\n          else\n            this.header[h].push(m[2]);\n        } else\n          this.header[h] = [''];\n        if (++this.npairs === this.maxHeaderPairs)\n          break;\n      } else {\n        this.buffer = lines[i];\n        modded = true;\n        break;\n      }\n    }\n  }\n  if (!modded)\n    this.buffer = '';\n};\n\nmodule.exports = HeaderParser;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/dicer/lib/HeaderParser.js?");

/***/ }),

/***/ "./src/node_modules/dicer/lib/PartStream.js":
/*!**************************************************!*\
  !*** ./src/node_modules/dicer/lib/PartStream.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var inherits = __webpack_require__(/*! util */ \"util\").inherits,\n    ReadableStream = __webpack_require__(/*! stream */ \"stream\").Readable;\n\nfunction PartStream(opts) {\n  ReadableStream.call(this, opts);\n}\ninherits(PartStream, ReadableStream);\n\nPartStream.prototype._read = function(n) {};\n\nmodule.exports = PartStream;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/dicer/lib/PartStream.js?");

/***/ }),

/***/ "./src/node_modules/dom-serializer/lib/foreignNames.js":
/*!*************************************************************!*\
  !*** ./src/node_modules/dom-serializer/lib/foreignNames.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.attributeNames = exports.elementNames = void 0;\nexports.elementNames = new Map([\n    [\"altglyph\", \"altGlyph\"],\n    [\"altglyphdef\", \"altGlyphDef\"],\n    [\"altglyphitem\", \"altGlyphItem\"],\n    [\"animatecolor\", \"animateColor\"],\n    [\"animatemotion\", \"animateMotion\"],\n    [\"animatetransform\", \"animateTransform\"],\n    [\"clippath\", \"clipPath\"],\n    [\"feblend\", \"feBlend\"],\n    [\"fecolormatrix\", \"feColorMatrix\"],\n    [\"fecomponenttransfer\", \"feComponentTransfer\"],\n    [\"fecomposite\", \"feComposite\"],\n    [\"feconvolvematrix\", \"feConvolveMatrix\"],\n    [\"fediffuselighting\", \"feDiffuseLighting\"],\n    [\"fedisplacementmap\", \"feDisplacementMap\"],\n    [\"fedistantlight\", \"feDistantLight\"],\n    [\"fedropshadow\", \"feDropShadow\"],\n    [\"feflood\", \"feFlood\"],\n    [\"fefunca\", \"feFuncA\"],\n    [\"fefuncb\", \"feFuncB\"],\n    [\"fefuncg\", \"feFuncG\"],\n    [\"fefuncr\", \"feFuncR\"],\n    [\"fegaussianblur\", \"feGaussianBlur\"],\n    [\"feimage\", \"feImage\"],\n    [\"femerge\", \"feMerge\"],\n    [\"femergenode\", \"feMergeNode\"],\n    [\"femorphology\", \"feMorphology\"],\n    [\"feoffset\", \"feOffset\"],\n    [\"fepointlight\", \"fePointLight\"],\n    [\"fespecularlighting\", \"feSpecularLighting\"],\n    [\"fespotlight\", \"feSpotLight\"],\n    [\"fetile\", \"feTile\"],\n    [\"feturbulence\", \"feTurbulence\"],\n    [\"foreignobject\", \"foreignObject\"],\n    [\"glyphref\", \"glyphRef\"],\n    [\"lineargradient\", \"linearGradient\"],\n    [\"radialgradient\", \"radialGradient\"],\n    [\"textpath\", \"textPath\"],\n]);\nexports.attributeNames = new Map([\n    [\"definitionurl\", \"definitionURL\"],\n    [\"attributename\", \"attributeName\"],\n    [\"attributetype\", \"attributeType\"],\n    [\"basefrequency\", \"baseFrequency\"],\n    [\"baseprofile\", \"baseProfile\"],\n    [\"calcmode\", \"calcMode\"],\n    [\"clippathunits\", \"clipPathUnits\"],\n    [\"diffuseconstant\", \"diffuseConstant\"],\n    [\"edgemode\", \"edgeMode\"],\n    [\"filterunits\", \"filterUnits\"],\n    [\"glyphref\", \"glyphRef\"],\n    [\"gradienttransform\", \"gradientTransform\"],\n    [\"gradientunits\", \"gradientUnits\"],\n    [\"kernelmatrix\", \"kernelMatrix\"],\n    [\"kernelunitlength\", \"kernelUnitLength\"],\n    [\"keypoints\", \"keyPoints\"],\n    [\"keysplines\", \"keySplines\"],\n    [\"keytimes\", \"keyTimes\"],\n    [\"lengthadjust\", \"lengthAdjust\"],\n    [\"limitingconeangle\", \"limitingConeAngle\"],\n    [\"markerheight\", \"markerHeight\"],\n    [\"markerunits\", \"markerUnits\"],\n    [\"markerwidth\", \"markerWidth\"],\n    [\"maskcontentunits\", \"maskContentUnits\"],\n    [\"maskunits\", \"maskUnits\"],\n    [\"numoctaves\", \"numOctaves\"],\n    [\"pathlength\", \"pathLength\"],\n    [\"patterncontentunits\", \"patternContentUnits\"],\n    [\"patterntransform\", \"patternTransform\"],\n    [\"patternunits\", \"patternUnits\"],\n    [\"pointsatx\", \"pointsAtX\"],\n    [\"pointsaty\", \"pointsAtY\"],\n    [\"pointsatz\", \"pointsAtZ\"],\n    [\"preservealpha\", \"preserveAlpha\"],\n    [\"preserveaspectratio\", \"preserveAspectRatio\"],\n    [\"primitiveunits\", \"primitiveUnits\"],\n    [\"refx\", \"refX\"],\n    [\"refy\", \"refY\"],\n    [\"repeatcount\", \"repeatCount\"],\n    [\"repeatdur\", \"repeatDur\"],\n    [\"requiredextensions\", \"requiredExtensions\"],\n    [\"requiredfeatures\", \"requiredFeatures\"],\n    [\"specularconstant\", \"specularConstant\"],\n    [\"specularexponent\", \"specularExponent\"],\n    [\"spreadmethod\", \"spreadMethod\"],\n    [\"startoffset\", \"startOffset\"],\n    [\"stddeviation\", \"stdDeviation\"],\n    [\"stitchtiles\", \"stitchTiles\"],\n    [\"surfacescale\", \"surfaceScale\"],\n    [\"systemlanguage\", \"systemLanguage\"],\n    [\"tablevalues\", \"tableValues\"],\n    [\"targetx\", \"targetX\"],\n    [\"targety\", \"targetY\"],\n    [\"textlength\", \"textLength\"],\n    [\"viewbox\", \"viewBox\"],\n    [\"viewtarget\", \"viewTarget\"],\n    [\"xchannelselector\", \"xChannelSelector\"],\n    [\"ychannelselector\", \"yChannelSelector\"],\n    [\"zoomandpan\", \"zoomAndPan\"],\n]);\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/dom-serializer/lib/foreignNames.js?");

/***/ }),

/***/ "./src/node_modules/dom-serializer/lib/index.js":
/*!******************************************************!*\
  !*** ./src/node_modules/dom-serializer/lib/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*\n * Module dependencies\n */\nvar ElementType = __importStar(__webpack_require__(/*! domelementtype */ \"./src/node_modules/domelementtype/lib/index.js\"));\nvar entities_1 = __webpack_require__(/*! entities */ \"./src/node_modules/entities/lib/index.js\");\n/**\n * Mixed-case SVG and MathML tags & attributes\n * recognized by the HTML parser.\n *\n * @see https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-inforeign\n */\nvar foreignNames_1 = __webpack_require__(/*! ./foreignNames */ \"./src/node_modules/dom-serializer/lib/foreignNames.js\");\nvar unencodedElements = new Set([\n    \"style\",\n    \"script\",\n    \"xmp\",\n    \"iframe\",\n    \"noembed\",\n    \"noframes\",\n    \"plaintext\",\n    \"noscript\",\n]);\n/**\n * Format attributes\n */\nfunction formatAttributes(attributes, opts) {\n    if (!attributes)\n        return;\n    return Object.keys(attributes)\n        .map(function (key) {\n        var _a, _b;\n        var value = (_a = attributes[key]) !== null && _a !== void 0 ? _a : \"\";\n        if (opts.xmlMode === \"foreign\") {\n            /* Fix up mixed-case attribute names */\n            key = (_b = foreignNames_1.attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;\n        }\n        if (!opts.emptyAttrs && !opts.xmlMode && value === \"\") {\n            return key;\n        }\n        return key + \"=\\\"\" + (opts.decodeEntities !== false\n            ? entities_1.encodeXML(value)\n            : value.replace(/\"/g, \"&quot;\")) + \"\\\"\";\n    })\n        .join(\" \");\n}\n/**\n * Self-enclosing tags\n */\nvar singleTag = new Set([\n    \"area\",\n    \"base\",\n    \"basefont\",\n    \"br\",\n    \"col\",\n    \"command\",\n    \"embed\",\n    \"frame\",\n    \"hr\",\n    \"img\",\n    \"input\",\n    \"isindex\",\n    \"keygen\",\n    \"link\",\n    \"meta\",\n    \"param\",\n    \"source\",\n    \"track\",\n    \"wbr\",\n]);\n/**\n * Renders a DOM node or an array of DOM nodes to a string.\n *\n * Can be thought of as the equivalent of the `outerHTML` of the passed node(s).\n *\n * @param node Node to be rendered.\n * @param options Changes serialization behavior\n */\nfunction render(node, options) {\n    if (options === void 0) { options = {}; }\n    var nodes = \"length\" in node ? node : [node];\n    var output = \"\";\n    for (var i = 0; i < nodes.length; i++) {\n        output += renderNode(nodes[i], options);\n    }\n    return output;\n}\nexports.default = render;\nfunction renderNode(node, options) {\n    switch (node.type) {\n        case ElementType.Root:\n            return render(node.children, options);\n        case ElementType.Directive:\n        case ElementType.Doctype:\n            return renderDirective(node);\n        case ElementType.Comment:\n            return renderComment(node);\n        case ElementType.CDATA:\n            return renderCdata(node);\n        case ElementType.Script:\n        case ElementType.Style:\n        case ElementType.Tag:\n            return renderTag(node, options);\n        case ElementType.Text:\n            return renderText(node, options);\n    }\n}\nvar foreignModeIntegrationPoints = new Set([\n    \"mi\",\n    \"mo\",\n    \"mn\",\n    \"ms\",\n    \"mtext\",\n    \"annotation-xml\",\n    \"foreignObject\",\n    \"desc\",\n    \"title\",\n]);\nvar foreignElements = new Set([\"svg\", \"math\"]);\nfunction renderTag(elem, opts) {\n    var _a;\n    // Handle SVG / MathML in HTML\n    if (opts.xmlMode === \"foreign\") {\n        /* Fix up mixed-case element names */\n        elem.name = (_a = foreignNames_1.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;\n        /* Exit foreign mode at integration points */\n        if (elem.parent &&\n            foreignModeIntegrationPoints.has(elem.parent.name)) {\n            opts = __assign(__assign({}, opts), { xmlMode: false });\n        }\n    }\n    if (!opts.xmlMode && foreignElements.has(elem.name)) {\n        opts = __assign(__assign({}, opts), { xmlMode: \"foreign\" });\n    }\n    var tag = \"<\" + elem.name;\n    var attribs = formatAttributes(elem.attribs, opts);\n    if (attribs) {\n        tag += \" \" + attribs;\n    }\n    if (elem.children.length === 0 &&\n        (opts.xmlMode\n            ? // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags\n                opts.selfClosingTags !== false\n            : // User explicitly asked for self-closing tags, even in HTML mode\n                opts.selfClosingTags && singleTag.has(elem.name))) {\n        if (!opts.xmlMode)\n            tag += \" \";\n        tag += \"/>\";\n    }\n    else {\n        tag += \">\";\n        if (elem.children.length > 0) {\n            tag += render(elem.children, opts);\n        }\n        if (opts.xmlMode || !singleTag.has(elem.name)) {\n            tag += \"</\" + elem.name + \">\";\n        }\n    }\n    return tag;\n}\nfunction renderDirective(elem) {\n    return \"<\" + elem.data + \">\";\n}\nfunction renderText(elem, opts) {\n    var data = elem.data || \"\";\n    // If entities weren't decoded, no need to encode them back\n    if (opts.decodeEntities !== false &&\n        !(!opts.xmlMode &&\n            elem.parent &&\n            unencodedElements.has(elem.parent.name))) {\n        data = entities_1.encodeXML(data);\n    }\n    return data;\n}\nfunction renderCdata(elem) {\n    return \"<![CDATA[\" + elem.children[0].data + \"]]>\";\n}\nfunction renderComment(elem) {\n    return \"<!--\" + elem.data + \"-->\";\n}\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/dom-serializer/lib/index.js?");

/***/ }),

/***/ "./src/node_modules/domelementtype/lib/index.js":
/*!******************************************************!*\
  !*** ./src/node_modules/domelementtype/lib/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Doctype = exports.CDATA = exports.Tag = exports.Style = exports.Script = exports.Comment = exports.Directive = exports.Text = exports.Root = exports.isTag = exports.ElementType = void 0;\n/** Types of elements found in htmlparser2's DOM */\nvar ElementType;\n(function (ElementType) {\n    /** Type for the root element of a document */\n    ElementType[\"Root\"] = \"root\";\n    /** Type for Text */\n    ElementType[\"Text\"] = \"text\";\n    /** Type for <? ... ?> */\n    ElementType[\"Directive\"] = \"directive\";\n    /** Type for <!-- ... --> */\n    ElementType[\"Comment\"] = \"comment\";\n    /** Type for <script> tags */\n    ElementType[\"Script\"] = \"script\";\n    /** Type for <style> tags */\n    ElementType[\"Style\"] = \"style\";\n    /** Type for Any tag */\n    ElementType[\"Tag\"] = \"tag\";\n    /** Type for <![CDATA[ ... ]]> */\n    ElementType[\"CDATA\"] = \"cdata\";\n    /** Type for <!doctype ...> */\n    ElementType[\"Doctype\"] = \"doctype\";\n})(ElementType = exports.ElementType || (exports.ElementType = {}));\n/**\n * Tests whether an element is a tag or not.\n *\n * @param elem Element to test\n */\nfunction isTag(elem) {\n    return (elem.type === ElementType.Tag ||\n        elem.type === ElementType.Script ||\n        elem.type === ElementType.Style);\n}\nexports.isTag = isTag;\n// Exports for backwards compatibility\n/** Type for the root element of a document */\nexports.Root = ElementType.Root;\n/** Type for Text */\nexports.Text = ElementType.Text;\n/** Type for <? ... ?> */\nexports.Directive = ElementType.Directive;\n/** Type for <!-- ... --> */\nexports.Comment = ElementType.Comment;\n/** Type for <script> tags */\nexports.Script = ElementType.Script;\n/** Type for <style> tags */\nexports.Style = ElementType.Style;\n/** Type for Any tag */\nexports.Tag = ElementType.Tag;\n/** Type for <![CDATA[ ... ]]> */\nexports.CDATA = ElementType.CDATA;\n/** Type for <!doctype ...> */\nexports.Doctype = ElementType.Doctype;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/domelementtype/lib/index.js?");

/***/ }),

/***/ "./src/node_modules/domhandler/lib/index.js":
/*!**************************************************!*\
  !*** ./src/node_modules/domhandler/lib/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DomHandler = void 0;\nvar domelementtype_1 = __webpack_require__(/*! domelementtype */ \"./src/node_modules/domelementtype/lib/index.js\");\nvar node_1 = __webpack_require__(/*! ./node */ \"./src/node_modules/domhandler/lib/node.js\");\n__exportStar(__webpack_require__(/*! ./node */ \"./src/node_modules/domhandler/lib/node.js\"), exports);\nvar reWhitespace = /\\s+/g;\n// Default options\nvar defaultOpts = {\n    normalizeWhitespace: false,\n    withStartIndices: false,\n    withEndIndices: false,\n};\nvar DomHandler = /** @class */ (function () {\n    /**\n     * @param callback Called once parsing has completed.\n     * @param options Settings for the handler.\n     * @param elementCB Callback whenever a tag is closed.\n     */\n    function DomHandler(callback, options, elementCB) {\n        /** The elements of the DOM */\n        this.dom = [];\n        /** The root element for the DOM */\n        this.root = new node_1.Document(this.dom);\n        /** Indicated whether parsing has been completed. */\n        this.done = false;\n        /** Stack of open tags. */\n        this.tagStack = [this.root];\n        /** A data node that is still being written to. */\n        this.lastNode = null;\n        /** Reference to the parser instance. Used for location information. */\n        this.parser = null;\n        // Make it possible to skip arguments, for backwards-compatibility\n        if (typeof options === \"function\") {\n            elementCB = options;\n            options = defaultOpts;\n        }\n        if (typeof callback === \"object\") {\n            options = callback;\n            callback = undefined;\n        }\n        this.callback = callback !== null && callback !== void 0 ? callback : null;\n        this.options = options !== null && options !== void 0 ? options : defaultOpts;\n        this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;\n    }\n    DomHandler.prototype.onparserinit = function (parser) {\n        this.parser = parser;\n    };\n    // Resets the handler back to starting state\n    DomHandler.prototype.onreset = function () {\n        var _a;\n        this.dom = [];\n        this.root = new node_1.Document(this.dom);\n        this.done = false;\n        this.tagStack = [this.root];\n        this.lastNode = null;\n        this.parser = (_a = this.parser) !== null && _a !== void 0 ? _a : null;\n    };\n    // Signals the handler that parsing is done\n    DomHandler.prototype.onend = function () {\n        if (this.done)\n            return;\n        this.done = true;\n        this.parser = null;\n        this.handleCallback(null);\n    };\n    DomHandler.prototype.onerror = function (error) {\n        this.handleCallback(error);\n    };\n    DomHandler.prototype.onclosetag = function () {\n        this.lastNode = null;\n        var elem = this.tagStack.pop();\n        if (this.options.withEndIndices) {\n            elem.endIndex = this.parser.endIndex;\n        }\n        if (this.elementCB)\n            this.elementCB(elem);\n    };\n    DomHandler.prototype.onopentag = function (name, attribs) {\n        var type = this.options.xmlMode ? domelementtype_1.ElementType.Tag : undefined;\n        var element = new node_1.Element(name, attribs, undefined, type);\n        this.addNode(element);\n        this.tagStack.push(element);\n    };\n    DomHandler.prototype.ontext = function (data) {\n        var normalizeWhitespace = this.options.normalizeWhitespace;\n        var lastNode = this.lastNode;\n        if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {\n            if (normalizeWhitespace) {\n                lastNode.data = (lastNode.data + data).replace(reWhitespace, \" \");\n            }\n            else {\n                lastNode.data += data;\n            }\n        }\n        else {\n            if (normalizeWhitespace) {\n                data = data.replace(reWhitespace, \" \");\n            }\n            var node = new node_1.Text(data);\n            this.addNode(node);\n            this.lastNode = node;\n        }\n    };\n    DomHandler.prototype.oncomment = function (data) {\n        if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {\n            this.lastNode.data += data;\n            return;\n        }\n        var node = new node_1.Comment(data);\n        this.addNode(node);\n        this.lastNode = node;\n    };\n    DomHandler.prototype.oncommentend = function () {\n        this.lastNode = null;\n    };\n    DomHandler.prototype.oncdatastart = function () {\n        var text = new node_1.Text(\"\");\n        var node = new node_1.NodeWithChildren(domelementtype_1.ElementType.CDATA, [text]);\n        this.addNode(node);\n        text.parent = node;\n        this.lastNode = text;\n    };\n    DomHandler.prototype.oncdataend = function () {\n        this.lastNode = null;\n    };\n    DomHandler.prototype.onprocessinginstruction = function (name, data) {\n        var node = new node_1.ProcessingInstruction(name, data);\n        this.addNode(node);\n    };\n    DomHandler.prototype.handleCallback = function (error) {\n        if (typeof this.callback === \"function\") {\n            this.callback(error, this.dom);\n        }\n        else if (error) {\n            throw error;\n        }\n    };\n    DomHandler.prototype.addNode = function (node) {\n        var parent = this.tagStack[this.tagStack.length - 1];\n        var previousSibling = parent.children[parent.children.length - 1];\n        if (this.options.withStartIndices) {\n            node.startIndex = this.parser.startIndex;\n        }\n        if (this.options.withEndIndices) {\n            node.endIndex = this.parser.endIndex;\n        }\n        parent.children.push(node);\n        if (previousSibling) {\n            node.prev = previousSibling;\n            previousSibling.next = node;\n        }\n        node.parent = parent;\n        this.lastNode = null;\n    };\n    return DomHandler;\n}());\nexports.DomHandler = DomHandler;\nexports.default = DomHandler;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/domhandler/lib/index.js?");

/***/ }),

/***/ "./src/node_modules/domhandler/lib/node.js":
/*!*************************************************!*\
  !*** ./src/node_modules/domhandler/lib/node.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.cloneNode = exports.hasChildren = exports.isDocument = exports.isDirective = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = exports.Element = exports.Document = exports.NodeWithChildren = exports.ProcessingInstruction = exports.Comment = exports.Text = exports.DataNode = exports.Node = void 0;\nvar domelementtype_1 = __webpack_require__(/*! domelementtype */ \"./src/node_modules/domelementtype/lib/index.js\");\nvar nodeTypes = new Map([\n    [domelementtype_1.ElementType.Tag, 1],\n    [domelementtype_1.ElementType.Script, 1],\n    [domelementtype_1.ElementType.Style, 1],\n    [domelementtype_1.ElementType.Directive, 1],\n    [domelementtype_1.ElementType.Text, 3],\n    [domelementtype_1.ElementType.CDATA, 4],\n    [domelementtype_1.ElementType.Comment, 8],\n    [domelementtype_1.ElementType.Root, 9],\n]);\n/**\n * This object will be used as the prototype for Nodes when creating a\n * DOM-Level-1-compliant structure.\n */\nvar Node = /** @class */ (function () {\n    /**\n     *\n     * @param type The type of the node.\n     */\n    function Node(type) {\n        this.type = type;\n        /** Parent of the node */\n        this.parent = null;\n        /** Previous sibling */\n        this.prev = null;\n        /** Next sibling */\n        this.next = null;\n        /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */\n        this.startIndex = null;\n        /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */\n        this.endIndex = null;\n    }\n    Object.defineProperty(Node.prototype, \"nodeType\", {\n        // Read-only aliases\n        get: function () {\n            var _a;\n            return (_a = nodeTypes.get(this.type)) !== null && _a !== void 0 ? _a : 1;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"parentNode\", {\n        // Read-write aliases for properties\n        get: function () {\n            return this.parent;\n        },\n        set: function (parent) {\n            this.parent = parent;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"previousSibling\", {\n        get: function () {\n            return this.prev;\n        },\n        set: function (prev) {\n            this.prev = prev;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"nextSibling\", {\n        get: function () {\n            return this.next;\n        },\n        set: function (next) {\n            this.next = next;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Clone this node, and optionally its children.\n     *\n     * @param recursive Clone child nodes as well.\n     * @returns A clone of the node.\n     */\n    Node.prototype.cloneNode = function (recursive) {\n        if (recursive === void 0) { recursive = false; }\n        return cloneNode(this, recursive);\n    };\n    return Node;\n}());\nexports.Node = Node;\nvar DataNode = /** @class */ (function (_super) {\n    __extends(DataNode, _super);\n    /**\n     * @param type The type of the node\n     * @param data The content of the data node\n     */\n    function DataNode(type, data) {\n        var _this = _super.call(this, type) || this;\n        _this.data = data;\n        return _this;\n    }\n    Object.defineProperty(DataNode.prototype, \"nodeValue\", {\n        get: function () {\n            return this.data;\n        },\n        set: function (data) {\n            this.data = data;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return DataNode;\n}(Node));\nexports.DataNode = DataNode;\nvar Text = /** @class */ (function (_super) {\n    __extends(Text, _super);\n    function Text(data) {\n        return _super.call(this, domelementtype_1.ElementType.Text, data) || this;\n    }\n    return Text;\n}(DataNode));\nexports.Text = Text;\nvar Comment = /** @class */ (function (_super) {\n    __extends(Comment, _super);\n    function Comment(data) {\n        return _super.call(this, domelementtype_1.ElementType.Comment, data) || this;\n    }\n    return Comment;\n}(DataNode));\nexports.Comment = Comment;\nvar ProcessingInstruction = /** @class */ (function (_super) {\n    __extends(ProcessingInstruction, _super);\n    function ProcessingInstruction(name, data) {\n        var _this = _super.call(this, domelementtype_1.ElementType.Directive, data) || this;\n        _this.name = name;\n        return _this;\n    }\n    return ProcessingInstruction;\n}(DataNode));\nexports.ProcessingInstruction = ProcessingInstruction;\n/**\n * A `Node` that can have children.\n */\nvar NodeWithChildren = /** @class */ (function (_super) {\n    __extends(NodeWithChildren, _super);\n    /**\n     * @param type Type of the node.\n     * @param children Children of the node. Only certain node types can have children.\n     */\n    function NodeWithChildren(type, children) {\n        var _this = _super.call(this, type) || this;\n        _this.children = children;\n        return _this;\n    }\n    Object.defineProperty(NodeWithChildren.prototype, \"firstChild\", {\n        // Aliases\n        get: function () {\n            var _a;\n            return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(NodeWithChildren.prototype, \"lastChild\", {\n        get: function () {\n            return this.children.length > 0\n                ? this.children[this.children.length - 1]\n                : null;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(NodeWithChildren.prototype, \"childNodes\", {\n        get: function () {\n            return this.children;\n        },\n        set: function (children) {\n            this.children = children;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return NodeWithChildren;\n}(Node));\nexports.NodeWithChildren = NodeWithChildren;\nvar Document = /** @class */ (function (_super) {\n    __extends(Document, _super);\n    function Document(children) {\n        return _super.call(this, domelementtype_1.ElementType.Root, children) || this;\n    }\n    return Document;\n}(NodeWithChildren));\nexports.Document = Document;\nvar Element = /** @class */ (function (_super) {\n    __extends(Element, _super);\n    /**\n     * @param name Name of the tag, eg. `div`, `span`.\n     * @param attribs Object mapping attribute names to attribute values.\n     * @param children Children of the node.\n     */\n    function Element(name, attribs, children, type) {\n        if (children === void 0) { children = []; }\n        if (type === void 0) { type = name === \"script\"\n            ? domelementtype_1.ElementType.Script\n            : name === \"style\"\n                ? domelementtype_1.ElementType.Style\n                : domelementtype_1.ElementType.Tag; }\n        var _this = _super.call(this, type, children) || this;\n        _this.name = name;\n        _this.attribs = attribs;\n        return _this;\n    }\n    Object.defineProperty(Element.prototype, \"tagName\", {\n        // DOM Level 1 aliases\n        get: function () {\n            return this.name;\n        },\n        set: function (name) {\n            this.name = name;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Element.prototype, \"attributes\", {\n        get: function () {\n            var _this = this;\n            return Object.keys(this.attribs).map(function (name) {\n                var _a, _b;\n                return ({\n                    name: name,\n                    value: _this.attribs[name],\n                    namespace: (_a = _this[\"x-attribsNamespace\"]) === null || _a === void 0 ? void 0 : _a[name],\n                    prefix: (_b = _this[\"x-attribsPrefix\"]) === null || _b === void 0 ? void 0 : _b[name],\n                });\n            });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Element;\n}(NodeWithChildren));\nexports.Element = Element;\n/**\n * @param node Node to check.\n * @returns `true` if the node is a `Element`, `false` otherwise.\n */\nfunction isTag(node) {\n    return domelementtype_1.isTag(node);\n}\nexports.isTag = isTag;\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `CDATA`, `false` otherwise.\n */\nfunction isCDATA(node) {\n    return node.type === domelementtype_1.ElementType.CDATA;\n}\nexports.isCDATA = isCDATA;\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `Text`, `false` otherwise.\n */\nfunction isText(node) {\n    return node.type === domelementtype_1.ElementType.Text;\n}\nexports.isText = isText;\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `Comment`, `false` otherwise.\n */\nfunction isComment(node) {\n    return node.type === domelementtype_1.ElementType.Comment;\n}\nexports.isComment = isComment;\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.\n */\nfunction isDirective(node) {\n    return node.type === domelementtype_1.ElementType.Directive;\n}\nexports.isDirective = isDirective;\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.\n */\nfunction isDocument(node) {\n    return node.type === domelementtype_1.ElementType.Root;\n}\nexports.isDocument = isDocument;\n/**\n * @param node Node to check.\n * @returns `true` if the node is a `NodeWithChildren` (has children), `false` otherwise.\n */\nfunction hasChildren(node) {\n    return Object.prototype.hasOwnProperty.call(node, \"children\");\n}\nexports.hasChildren = hasChildren;\n/**\n * Clone a node, and optionally its children.\n *\n * @param recursive Clone child nodes as well.\n * @returns A clone of the node.\n */\nfunction cloneNode(node, recursive) {\n    if (recursive === void 0) { recursive = false; }\n    var result;\n    if (isText(node)) {\n        result = new Text(node.data);\n    }\n    else if (isComment(node)) {\n        result = new Comment(node.data);\n    }\n    else if (isTag(node)) {\n        var children = recursive ? cloneChildren(node.children) : [];\n        var clone_1 = new Element(node.name, __assign({}, node.attribs), children);\n        children.forEach(function (child) { return (child.parent = clone_1); });\n        if (node[\"x-attribsNamespace\"]) {\n            clone_1[\"x-attribsNamespace\"] = __assign({}, node[\"x-attribsNamespace\"]);\n        }\n        if (node[\"x-attribsPrefix\"]) {\n            clone_1[\"x-attribsPrefix\"] = __assign({}, node[\"x-attribsPrefix\"]);\n        }\n        result = clone_1;\n    }\n    else if (isCDATA(node)) {\n        var children = recursive ? cloneChildren(node.children) : [];\n        var clone_2 = new NodeWithChildren(domelementtype_1.ElementType.CDATA, children);\n        children.forEach(function (child) { return (child.parent = clone_2); });\n        result = clone_2;\n    }\n    else if (isDocument(node)) {\n        var children = recursive ? cloneChildren(node.children) : [];\n        var clone_3 = new Document(children);\n        children.forEach(function (child) { return (child.parent = clone_3); });\n        if (node[\"x-mode\"]) {\n            clone_3[\"x-mode\"] = node[\"x-mode\"];\n        }\n        result = clone_3;\n    }\n    else if (isDirective(node)) {\n        var instruction = new ProcessingInstruction(node.name, node.data);\n        if (node[\"x-name\"] != null) {\n            instruction[\"x-name\"] = node[\"x-name\"];\n            instruction[\"x-publicId\"] = node[\"x-publicId\"];\n            instruction[\"x-systemId\"] = node[\"x-systemId\"];\n        }\n        result = instruction;\n    }\n    else {\n        throw new Error(\"Not implemented yet: \" + node.type);\n    }\n    result.startIndex = node.startIndex;\n    result.endIndex = node.endIndex;\n    return result;\n}\nexports.cloneNode = cloneNode;\nfunction cloneChildren(childs) {\n    var children = childs.map(function (child) { return cloneNode(child, true); });\n    for (var i = 1; i < children.length; i++) {\n        children[i].prev = children[i - 1];\n        children[i - 1].next = children[i];\n    }\n    return children;\n}\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/domhandler/lib/node.js?");

/***/ }),

/***/ "./src/node_modules/domutils/lib/helpers.js":
/*!**************************************************!*\
  !*** ./src/node_modules/domutils/lib/helpers.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.uniqueSort = exports.compareDocumentPosition = exports.removeSubsets = void 0;\nvar domhandler_1 = __webpack_require__(/*! domhandler */ \"./src/node_modules/domhandler/lib/index.js\");\n/**\n * Given an array of nodes, remove any member that is contained by another.\n *\n * @param nodes Nodes to filter.\n * @returns Remaining nodes that aren't subtrees of each other.\n */\nfunction removeSubsets(nodes) {\n    var idx = nodes.length;\n    /*\n     * Check if each node (or one of its ancestors) is already contained in the\n     * array.\n     */\n    while (--idx >= 0) {\n        var node = nodes[idx];\n        /*\n         * Remove the node if it is not unique.\n         * We are going through the array from the end, so we only\n         * have to check nodes that preceed the node under consideration in the array.\n         */\n        if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {\n            nodes.splice(idx, 1);\n            continue;\n        }\n        for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {\n            if (nodes.includes(ancestor)) {\n                nodes.splice(idx, 1);\n                break;\n            }\n        }\n    }\n    return nodes;\n}\nexports.removeSubsets = removeSubsets;\n/**\n * Compare the position of one node against another node in any other document.\n * The return value is a bitmask with the following values:\n *\n * Document order:\n * > There is an ordering, document order, defined on all the nodes in the\n * > document corresponding to the order in which the first character of the\n * > XML representation of each node occurs in the XML representation of the\n * > document after expansion of general entities. Thus, the document element\n * > node will be the first node. Element nodes occur before their children.\n * > Thus, document order orders element nodes in order of the occurrence of\n * > their start-tag in the XML (after expansion of entities). The attribute\n * > nodes of an element occur after the element and before its children. The\n * > relative order of attribute nodes is implementation-dependent./\n *\n * Source:\n * http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order\n *\n * @param nodeA The first node to use in the comparison\n * @param nodeB The second node to use in the comparison\n * @returns A bitmask describing the input nodes' relative position.\n *\n * See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for\n * a description of these values.\n */\nfunction compareDocumentPosition(nodeA, nodeB) {\n    var aParents = [];\n    var bParents = [];\n    if (nodeA === nodeB) {\n        return 0;\n    }\n    var current = domhandler_1.hasChildren(nodeA) ? nodeA : nodeA.parent;\n    while (current) {\n        aParents.unshift(current);\n        current = current.parent;\n    }\n    current = domhandler_1.hasChildren(nodeB) ? nodeB : nodeB.parent;\n    while (current) {\n        bParents.unshift(current);\n        current = current.parent;\n    }\n    var maxIdx = Math.min(aParents.length, bParents.length);\n    var idx = 0;\n    while (idx < maxIdx && aParents[idx] === bParents[idx]) {\n        idx++;\n    }\n    if (idx === 0) {\n        return 1 /* DISCONNECTED */;\n    }\n    var sharedParent = aParents[idx - 1];\n    var siblings = sharedParent.children;\n    var aSibling = aParents[idx];\n    var bSibling = bParents[idx];\n    if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {\n        if (sharedParent === nodeB) {\n            return 4 /* FOLLOWING */ | 16 /* CONTAINED_BY */;\n        }\n        return 4 /* FOLLOWING */;\n    }\n    if (sharedParent === nodeA) {\n        return 2 /* PRECEDING */ | 8 /* CONTAINS */;\n    }\n    return 2 /* PRECEDING */;\n}\nexports.compareDocumentPosition = compareDocumentPosition;\n/**\n * Sort an array of nodes based on their relative position in the document and\n * remove any duplicate nodes. If the array contains nodes that do not belong\n * to the same document, sort order is unspecified.\n *\n * @param nodes Array of DOM nodes.\n * @returns Collection of unique nodes, sorted in document order.\n */\nfunction uniqueSort(nodes) {\n    nodes = nodes.filter(function (node, i, arr) { return !arr.includes(node, i + 1); });\n    nodes.sort(function (a, b) {\n        var relative = compareDocumentPosition(a, b);\n        if (relative & 2 /* PRECEDING */) {\n            return -1;\n        }\n        else if (relative & 4 /* FOLLOWING */) {\n            return 1;\n        }\n        return 0;\n    });\n    return nodes;\n}\nexports.uniqueSort = uniqueSort;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/domutils/lib/helpers.js?");

/***/ }),

/***/ "./src/node_modules/domutils/lib/index.js":
/*!************************************************!*\
  !*** ./src/node_modules/domutils/lib/index.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.hasChildren = exports.isDocument = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = void 0;\n__exportStar(__webpack_require__(/*! ./stringify */ \"./src/node_modules/domutils/lib/stringify.js\"), exports);\n__exportStar(__webpack_require__(/*! ./traversal */ \"./src/node_modules/domutils/lib/traversal.js\"), exports);\n__exportStar(__webpack_require__(/*! ./manipulation */ \"./src/node_modules/domutils/lib/manipulation.js\"), exports);\n__exportStar(__webpack_require__(/*! ./querying */ \"./src/node_modules/domutils/lib/querying.js\"), exports);\n__exportStar(__webpack_require__(/*! ./legacy */ \"./src/node_modules/domutils/lib/legacy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./helpers */ \"./src/node_modules/domutils/lib/helpers.js\"), exports);\nvar domhandler_1 = __webpack_require__(/*! domhandler */ \"./src/node_modules/domhandler/lib/index.js\");\nObject.defineProperty(exports, \"isTag\", ({ enumerable: true, get: function () { return domhandler_1.isTag; } }));\nObject.defineProperty(exports, \"isCDATA\", ({ enumerable: true, get: function () { return domhandler_1.isCDATA; } }));\nObject.defineProperty(exports, \"isText\", ({ enumerable: true, get: function () { return domhandler_1.isText; } }));\nObject.defineProperty(exports, \"isComment\", ({ enumerable: true, get: function () { return domhandler_1.isComment; } }));\nObject.defineProperty(exports, \"isDocument\", ({ enumerable: true, get: function () { return domhandler_1.isDocument; } }));\nObject.defineProperty(exports, \"hasChildren\", ({ enumerable: true, get: function () { return domhandler_1.hasChildren; } }));\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/domutils/lib/index.js?");

/***/ }),

/***/ "./src/node_modules/domutils/lib/legacy.js":
/*!*************************************************!*\
  !*** ./src/node_modules/domutils/lib/legacy.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getElementsByTagType = exports.getElementsByTagName = exports.getElementById = exports.getElements = exports.testElement = void 0;\nvar domhandler_1 = __webpack_require__(/*! domhandler */ \"./src/node_modules/domhandler/lib/index.js\");\nvar querying_1 = __webpack_require__(/*! ./querying */ \"./src/node_modules/domutils/lib/querying.js\");\nvar Checks = {\n    tag_name: function (name) {\n        if (typeof name === \"function\") {\n            return function (elem) { return domhandler_1.isTag(elem) && name(elem.name); };\n        }\n        else if (name === \"*\") {\n            return domhandler_1.isTag;\n        }\n        return function (elem) { return domhandler_1.isTag(elem) && elem.name === name; };\n    },\n    tag_type: function (type) {\n        if (typeof type === \"function\") {\n            return function (elem) { return type(elem.type); };\n        }\n        return function (elem) { return elem.type === type; };\n    },\n    tag_contains: function (data) {\n        if (typeof data === \"function\") {\n            return function (elem) { return domhandler_1.isText(elem) && data(elem.data); };\n        }\n        return function (elem) { return domhandler_1.isText(elem) && elem.data === data; };\n    },\n};\n/**\n * @param attrib Attribute to check.\n * @param value Attribute value to look for.\n * @returns A function to check whether the a node has an attribute with a particular value.\n */\nfunction getAttribCheck(attrib, value) {\n    if (typeof value === \"function\") {\n        return function (elem) { return domhandler_1.isTag(elem) && value(elem.attribs[attrib]); };\n    }\n    return function (elem) { return domhandler_1.isTag(elem) && elem.attribs[attrib] === value; };\n}\n/**\n * @param a First function to combine.\n * @param b Second function to combine.\n * @returns A function taking a node and returning `true` if either\n * of the input functions returns `true` for the node.\n */\nfunction combineFuncs(a, b) {\n    return function (elem) { return a(elem) || b(elem); };\n}\n/**\n * @param options An object describing nodes to look for.\n * @returns A function executing all checks in `options` and returning `true`\n * if any of them match a node.\n */\nfunction compileTest(options) {\n    var funcs = Object.keys(options).map(function (key) {\n        var value = options[key];\n        return key in Checks\n            ? Checks[key](value)\n            : getAttribCheck(key, value);\n    });\n    return funcs.length === 0 ? null : funcs.reduce(combineFuncs);\n}\n/**\n * @param options An object describing nodes to look for.\n * @param node The element to test.\n * @returns Whether the element matches the description in `options`.\n */\nfunction testElement(options, node) {\n    var test = compileTest(options);\n    return test ? test(node) : true;\n}\nexports.testElement = testElement;\n/**\n * @param options An object describing nodes to look for.\n * @param nodes Nodes to search through.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n * @returns All nodes that match `options`.\n */\nfunction getElements(options, nodes, recurse, limit) {\n    if (limit === void 0) { limit = Infinity; }\n    var test = compileTest(options);\n    return test ? querying_1.filter(test, nodes, recurse, limit) : [];\n}\nexports.getElements = getElements;\n/**\n * @param id The unique ID attribute value to look for.\n * @param nodes Nodes to search through.\n * @param recurse Also consider child nodes.\n * @returns The node with the supplied ID.\n */\nfunction getElementById(id, nodes, recurse) {\n    if (recurse === void 0) { recurse = true; }\n    if (!Array.isArray(nodes))\n        nodes = [nodes];\n    return querying_1.findOne(getAttribCheck(\"id\", id), nodes, recurse);\n}\nexports.getElementById = getElementById;\n/**\n * @param tagName Tag name to search for.\n * @param nodes Nodes to search through.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n * @returns All nodes with the supplied `tagName`.\n */\nfunction getElementsByTagName(tagName, nodes, recurse, limit) {\n    if (recurse === void 0) { recurse = true; }\n    if (limit === void 0) { limit = Infinity; }\n    return querying_1.filter(Checks.tag_name(tagName), nodes, recurse, limit);\n}\nexports.getElementsByTagName = getElementsByTagName;\n/**\n * @param type Element type to look for.\n * @param nodes Nodes to search through.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n * @returns All nodes with the supplied `type`.\n */\nfunction getElementsByTagType(type, nodes, recurse, limit) {\n    if (recurse === void 0) { recurse = true; }\n    if (limit === void 0) { limit = Infinity; }\n    return querying_1.filter(Checks.tag_type(type), nodes, recurse, limit);\n}\nexports.getElementsByTagType = getElementsByTagType;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/domutils/lib/legacy.js?");

/***/ }),

/***/ "./src/node_modules/domutils/lib/manipulation.js":
/*!*******************************************************!*\
  !*** ./src/node_modules/domutils/lib/manipulation.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.prepend = exports.prependChild = exports.append = exports.appendChild = exports.replaceElement = exports.removeElement = void 0;\n/**\n * Remove an element from the dom\n *\n * @param elem The element to be removed\n */\nfunction removeElement(elem) {\n    if (elem.prev)\n        elem.prev.next = elem.next;\n    if (elem.next)\n        elem.next.prev = elem.prev;\n    if (elem.parent) {\n        var childs = elem.parent.children;\n        childs.splice(childs.lastIndexOf(elem), 1);\n    }\n}\nexports.removeElement = removeElement;\n/**\n * Replace an element in the dom\n *\n * @param elem The element to be replaced\n * @param replacement The element to be added\n */\nfunction replaceElement(elem, replacement) {\n    var prev = (replacement.prev = elem.prev);\n    if (prev) {\n        prev.next = replacement;\n    }\n    var next = (replacement.next = elem.next);\n    if (next) {\n        next.prev = replacement;\n    }\n    var parent = (replacement.parent = elem.parent);\n    if (parent) {\n        var childs = parent.children;\n        childs[childs.lastIndexOf(elem)] = replacement;\n    }\n}\nexports.replaceElement = replaceElement;\n/**\n * Append a child to an element.\n *\n * @param elem The element to append to.\n * @param child The element to be added as a child.\n */\nfunction appendChild(elem, child) {\n    removeElement(child);\n    child.next = null;\n    child.parent = elem;\n    if (elem.children.push(child) > 1) {\n        var sibling = elem.children[elem.children.length - 2];\n        sibling.next = child;\n        child.prev = sibling;\n    }\n    else {\n        child.prev = null;\n    }\n}\nexports.appendChild = appendChild;\n/**\n * Append an element after another.\n *\n * @param elem The element to append after.\n * @param next The element be added.\n */\nfunction append(elem, next) {\n    removeElement(next);\n    var parent = elem.parent;\n    var currNext = elem.next;\n    next.next = currNext;\n    next.prev = elem;\n    elem.next = next;\n    next.parent = parent;\n    if (currNext) {\n        currNext.prev = next;\n        if (parent) {\n            var childs = parent.children;\n            childs.splice(childs.lastIndexOf(currNext), 0, next);\n        }\n    }\n    else if (parent) {\n        parent.children.push(next);\n    }\n}\nexports.append = append;\n/**\n * Prepend a child to an element.\n *\n * @param elem The element to prepend before.\n * @param child The element to be added as a child.\n */\nfunction prependChild(elem, child) {\n    removeElement(child);\n    child.parent = elem;\n    child.prev = null;\n    if (elem.children.unshift(child) !== 1) {\n        var sibling = elem.children[1];\n        sibling.prev = child;\n        child.next = sibling;\n    }\n    else {\n        child.next = null;\n    }\n}\nexports.prependChild = prependChild;\n/**\n * Prepend an element before another.\n *\n * @param elem The element to prepend before.\n * @param prev The element be added.\n */\nfunction prepend(elem, prev) {\n    removeElement(prev);\n    var parent = elem.parent;\n    if (parent) {\n        var childs = parent.children;\n        childs.splice(childs.indexOf(elem), 0, prev);\n    }\n    if (elem.prev) {\n        elem.prev.next = prev;\n    }\n    prev.parent = parent;\n    prev.prev = elem.prev;\n    prev.next = elem;\n    elem.prev = prev;\n}\nexports.prepend = prepend;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/domutils/lib/manipulation.js?");

/***/ }),

/***/ "./src/node_modules/domutils/lib/querying.js":
/*!***************************************************!*\
  !*** ./src/node_modules/domutils/lib/querying.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.findAll = exports.existsOne = exports.findOne = exports.findOneChild = exports.find = exports.filter = void 0;\nvar domhandler_1 = __webpack_require__(/*! domhandler */ \"./src/node_modules/domhandler/lib/index.js\");\n/**\n * Search a node and its children for nodes passing a test function.\n *\n * @param test Function to test nodes on.\n * @param node Node to search. Will be included in the result set if it matches.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n * @returns All nodes passing `test`.\n */\nfunction filter(test, node, recurse, limit) {\n    if (recurse === void 0) { recurse = true; }\n    if (limit === void 0) { limit = Infinity; }\n    if (!Array.isArray(node))\n        node = [node];\n    return find(test, node, recurse, limit);\n}\nexports.filter = filter;\n/**\n * Search an array of node and its children for nodes passing a test function.\n *\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n * @returns All nodes passing `test`.\n */\nfunction find(test, nodes, recurse, limit) {\n    var result = [];\n    for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n        var elem = nodes_1[_i];\n        if (test(elem)) {\n            result.push(elem);\n            if (--limit <= 0)\n                break;\n        }\n        if (recurse && domhandler_1.hasChildren(elem) && elem.children.length > 0) {\n            var children = find(test, elem.children, recurse, limit);\n            result.push.apply(result, children);\n            limit -= children.length;\n            if (limit <= 0)\n                break;\n        }\n    }\n    return result;\n}\nexports.find = find;\n/**\n * Finds the first element inside of an array that matches a test function.\n *\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @returns The first node in the array that passes `test`.\n */\nfunction findOneChild(test, nodes) {\n    return nodes.find(test);\n}\nexports.findOneChild = findOneChild;\n/**\n * Finds one element in a tree that passes a test.\n *\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @param recurse Also consider child nodes.\n * @returns The first child node that passes `test`.\n */\nfunction findOne(test, nodes, recurse) {\n    if (recurse === void 0) { recurse = true; }\n    var elem = null;\n    for (var i = 0; i < nodes.length && !elem; i++) {\n        var checked = nodes[i];\n        if (!domhandler_1.isTag(checked)) {\n            continue;\n        }\n        else if (test(checked)) {\n            elem = checked;\n        }\n        else if (recurse && checked.children.length > 0) {\n            elem = findOne(test, checked.children);\n        }\n    }\n    return elem;\n}\nexports.findOne = findOne;\n/**\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @returns Whether a tree of nodes contains at least one node passing a test.\n */\nfunction existsOne(test, nodes) {\n    return nodes.some(function (checked) {\n        return domhandler_1.isTag(checked) &&\n            (test(checked) ||\n                (checked.children.length > 0 &&\n                    existsOne(test, checked.children)));\n    });\n}\nexports.existsOne = existsOne;\n/**\n * Search and array of nodes and its children for nodes passing a test function.\n *\n * Same as `find`, only with less options, leading to reduced complexity.\n *\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @returns All nodes passing `test`.\n */\nfunction findAll(test, nodes) {\n    var _a;\n    var result = [];\n    var stack = nodes.filter(domhandler_1.isTag);\n    var elem;\n    while ((elem = stack.shift())) {\n        var children = (_a = elem.children) === null || _a === void 0 ? void 0 : _a.filter(domhandler_1.isTag);\n        if (children && children.length > 0) {\n            stack.unshift.apply(stack, children);\n        }\n        if (test(elem))\n            result.push(elem);\n    }\n    return result;\n}\nexports.findAll = findAll;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/domutils/lib/querying.js?");

/***/ }),

/***/ "./src/node_modules/domutils/lib/stringify.js":
/*!****************************************************!*\
  !*** ./src/node_modules/domutils/lib/stringify.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.innerText = exports.textContent = exports.getText = exports.getInnerHTML = exports.getOuterHTML = void 0;\nvar domhandler_1 = __webpack_require__(/*! domhandler */ \"./src/node_modules/domhandler/lib/index.js\");\nvar dom_serializer_1 = __importDefault(__webpack_require__(/*! dom-serializer */ \"./src/node_modules/dom-serializer/lib/index.js\"));\nvar domelementtype_1 = __webpack_require__(/*! domelementtype */ \"./src/node_modules/domelementtype/lib/index.js\");\n/**\n * @param node Node to get the outer HTML of.\n * @param options Options for serialization.\n * @deprecated Use the `dom-serializer` module directly.\n * @returns `node`'s outer HTML.\n */\nfunction getOuterHTML(node, options) {\n    return dom_serializer_1.default(node, options);\n}\nexports.getOuterHTML = getOuterHTML;\n/**\n * @param node Node to get the inner HTML of.\n * @param options Options for serialization.\n * @deprecated Use the `dom-serializer` module directly.\n * @returns `node`'s inner HTML.\n */\nfunction getInnerHTML(node, options) {\n    return domhandler_1.hasChildren(node)\n        ? node.children.map(function (node) { return getOuterHTML(node, options); }).join(\"\")\n        : \"\";\n}\nexports.getInnerHTML = getInnerHTML;\n/**\n * Get a node's inner text. Same as `textContent`, but inserts newlines for `<br>` tags.\n *\n * @deprecated Use `textContent` instead.\n * @param node Node to get the inner text of.\n * @returns `node`'s inner text.\n */\nfunction getText(node) {\n    if (Array.isArray(node))\n        return node.map(getText).join(\"\");\n    if (domhandler_1.isTag(node))\n        return node.name === \"br\" ? \"\\n\" : getText(node.children);\n    if (domhandler_1.isCDATA(node))\n        return getText(node.children);\n    if (domhandler_1.isText(node))\n        return node.data;\n    return \"\";\n}\nexports.getText = getText;\n/**\n * Get a node's text content.\n *\n * @param node Node to get the text content of.\n * @returns `node`'s text content.\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent}\n */\nfunction textContent(node) {\n    if (Array.isArray(node))\n        return node.map(textContent).join(\"\");\n    if (domhandler_1.isTag(node))\n        return textContent(node.children);\n    if (domhandler_1.isCDATA(node))\n        return textContent(node.children);\n    if (domhandler_1.isText(node))\n        return node.data;\n    return \"\";\n}\nexports.textContent = textContent;\n/**\n * Get a node's inner text.\n *\n * @param node Node to get the inner text of.\n * @returns `node`'s inner text.\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/innerText}\n */\nfunction innerText(node) {\n    if (Array.isArray(node))\n        return node.map(innerText).join(\"\");\n    if (domhandler_1.hasChildren(node) && node.type === domelementtype_1.ElementType.Tag) {\n        return innerText(node.children);\n    }\n    if (domhandler_1.isCDATA(node))\n        return innerText(node.children);\n    if (domhandler_1.isText(node))\n        return node.data;\n    return \"\";\n}\nexports.innerText = innerText;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/domutils/lib/stringify.js?");

/***/ }),

/***/ "./src/node_modules/domutils/lib/traversal.js":
/*!****************************************************!*\
  !*** ./src/node_modules/domutils/lib/traversal.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.prevElementSibling = exports.nextElementSibling = exports.getName = exports.hasAttrib = exports.getAttributeValue = exports.getSiblings = exports.getParent = exports.getChildren = void 0;\nvar domhandler_1 = __webpack_require__(/*! domhandler */ \"./src/node_modules/domhandler/lib/index.js\");\nvar emptyArray = [];\n/**\n * Get a node's children.\n *\n * @param elem Node to get the children of.\n * @returns `elem`'s children, or an empty array.\n */\nfunction getChildren(elem) {\n    var _a;\n    return (_a = elem.children) !== null && _a !== void 0 ? _a : emptyArray;\n}\nexports.getChildren = getChildren;\n/**\n * Get a node's parent.\n *\n * @param elem Node to get the parent of.\n * @returns `elem`'s parent node.\n */\nfunction getParent(elem) {\n    return elem.parent || null;\n}\nexports.getParent = getParent;\n/**\n * Gets an elements siblings, including the element itself.\n *\n * Attempts to get the children through the element's parent first.\n * If we don't have a parent (the element is a root node),\n * we walk the element's `prev` & `next` to get all remaining nodes.\n *\n * @param elem Element to get the siblings of.\n * @returns `elem`'s siblings.\n */\nfunction getSiblings(elem) {\n    var _a, _b;\n    var parent = getParent(elem);\n    if (parent != null)\n        return getChildren(parent);\n    var siblings = [elem];\n    var prev = elem.prev, next = elem.next;\n    while (prev != null) {\n        siblings.unshift(prev);\n        (_a = prev, prev = _a.prev);\n    }\n    while (next != null) {\n        siblings.push(next);\n        (_b = next, next = _b.next);\n    }\n    return siblings;\n}\nexports.getSiblings = getSiblings;\n/**\n * Gets an attribute from an element.\n *\n * @param elem Element to check.\n * @param name Attribute name to retrieve.\n * @returns The element's attribute value, or `undefined`.\n */\nfunction getAttributeValue(elem, name) {\n    var _a;\n    return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];\n}\nexports.getAttributeValue = getAttributeValue;\n/**\n * Checks whether an element has an attribute.\n *\n * @param elem Element to check.\n * @param name Attribute name to look for.\n * @returns Returns whether `elem` has the attribute `name`.\n */\nfunction hasAttrib(elem, name) {\n    return (elem.attribs != null &&\n        Object.prototype.hasOwnProperty.call(elem.attribs, name) &&\n        elem.attribs[name] != null);\n}\nexports.hasAttrib = hasAttrib;\n/**\n * Get the tag name of an element.\n *\n * @param elem The element to get the name for.\n * @returns The tag name of `elem`.\n */\nfunction getName(elem) {\n    return elem.name;\n}\nexports.getName = getName;\n/**\n * Returns the next element sibling of a node.\n *\n * @param elem The element to get the next sibling of.\n * @returns `elem`'s next sibling that is a tag.\n */\nfunction nextElementSibling(elem) {\n    var _a;\n    var next = elem.next;\n    while (next !== null && !domhandler_1.isTag(next))\n        (_a = next, next = _a.next);\n    return next;\n}\nexports.nextElementSibling = nextElementSibling;\n/**\n * Returns the previous element sibling of a node.\n *\n * @param elem The element to get the previous sibling of.\n * @returns `elem`'s previous sibling that is a tag.\n */\nfunction prevElementSibling(elem) {\n    var _a;\n    var prev = elem.prev;\n    while (prev !== null && !domhandler_1.isTag(prev))\n        (_a = prev, prev = _a.prev);\n    return prev;\n}\nexports.prevElementSibling = prevElementSibling;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/domutils/lib/traversal.js?");

/***/ }),

/***/ "./src/node_modules/ent/decode.js":
/*!****************************************!*\
  !*** ./src/node_modules/ent/decode.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var punycode = __webpack_require__(/*! punycode */ \"punycode\");\nvar entities = __webpack_require__(/*! ./entities.json */ \"./src/node_modules/ent/entities.json\");\n\nmodule.exports = decode;\n\nfunction decode (str) {\n    if (typeof str !== 'string') {\n        throw new TypeError('Expected a String');\n    }\n\n    return str.replace(/&(#?[^;\\W]+;?)/g, function (_, match) {\n        var m;\n        if (m = /^#(\\d+);?$/.exec(match)) {\n            return punycode.ucs2.encode([ parseInt(m[1], 10) ]);\n        } else if (m = /^#[Xx]([A-Fa-f0-9]+);?/.exec(match)) {\n            return punycode.ucs2.encode([ parseInt(m[1], 16) ]);\n        } else {\n            // named entity\n            var hasSemi = /;$/.test(match);\n            var withoutSemi = hasSemi ? match.replace(/;$/, '') : match;\n            var target = entities[withoutSemi] || (hasSemi && entities[match]);\n\n            if (typeof target === 'number') {\n                return punycode.ucs2.encode([ target ]);\n            } else if (typeof target === 'string') {\n                return target;\n            } else {\n                return '&' + match;\n            }\n        }\n    });\n}\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/ent/decode.js?");

/***/ }),

/***/ "./src/node_modules/ent/encode.js":
/*!****************************************!*\
  !*** ./src/node_modules/ent/encode.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var punycode = __webpack_require__(/*! punycode */ \"punycode\");\nvar revEntities = __webpack_require__(/*! ./reversed.json */ \"./src/node_modules/ent/reversed.json\");\n\nmodule.exports = encode;\n\nfunction encode (str, opts) {\n    if (typeof str !== 'string') {\n        throw new TypeError('Expected a String');\n    }\n    if (!opts) opts = {};\n\n    var numeric = true;\n    if (opts.named) numeric = false;\n    if (opts.numeric !== undefined) numeric = opts.numeric;\n\n    var special = opts.special || {\n        '\"': true, \"'\": true,\n        '<': true, '>': true,\n        '&': true\n    };\n\n    var codePoints = punycode.ucs2.decode(str);\n    var chars = [];\n    for (var i = 0; i < codePoints.length; i++) {\n        var cc = codePoints[i];\n        var c = punycode.ucs2.encode([ cc ]);\n        var e = revEntities[cc];\n        if (e && (cc >= 127 || special[c]) && !numeric) {\n            chars.push('&' + (/;$/.test(e) ? e : e + ';'));\n        }\n        else if (cc < 32 || cc >= 127 || special[c]) {\n            chars.push('&#' + cc + ';');\n        }\n        else {\n            chars.push(c);\n        }\n    }\n    return chars.join('');\n}\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/ent/encode.js?");

/***/ }),

/***/ "./src/node_modules/ent/entities.json":
/*!********************************************!*\
  !*** ./src/node_modules/ent/entities.json ***!
  \********************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"Aacute;\":\"Á\",\"Aacute\":\"Á\",\"aacute;\":\"á\",\"aacute\":\"á\",\"Abreve;\":\"Ă\",\"abreve;\":\"ă\",\"ac;\":\"∾\",\"acd;\":\"∿\",\"acE;\":\"∾̳\",\"Acirc;\":\"Â\",\"Acirc\":\"Â\",\"acirc;\":\"â\",\"acirc\":\"â\",\"acute;\":\"´\",\"acute\":\"´\",\"Acy;\":\"А\",\"acy;\":\"а\",\"AElig;\":\"Æ\",\"AElig\":\"Æ\",\"aelig;\":\"æ\",\"aelig\":\"æ\",\"af;\":\"⁡\",\"Afr;\":\"𝔄\",\"afr;\":\"𝔞\",\"Agrave;\":\"À\",\"Agrave\":\"À\",\"agrave;\":\"à\",\"agrave\":\"à\",\"alefsym;\":\"ℵ\",\"aleph;\":\"ℵ\",\"Alpha;\":\"Α\",\"alpha;\":\"α\",\"Amacr;\":\"Ā\",\"amacr;\":\"ā\",\"amalg;\":\"⨿\",\"AMP;\":\"&\",\"AMP\":\"&\",\"amp;\":\"&\",\"amp\":\"&\",\"And;\":\"⩓\",\"and;\":\"∧\",\"andand;\":\"⩕\",\"andd;\":\"⩜\",\"andslope;\":\"⩘\",\"andv;\":\"⩚\",\"ang;\":\"∠\",\"ange;\":\"⦤\",\"angle;\":\"∠\",\"angmsd;\":\"∡\",\"angmsdaa;\":\"⦨\",\"angmsdab;\":\"⦩\",\"angmsdac;\":\"⦪\",\"angmsdad;\":\"⦫\",\"angmsdae;\":\"⦬\",\"angmsdaf;\":\"⦭\",\"angmsdag;\":\"⦮\",\"angmsdah;\":\"⦯\",\"angrt;\":\"∟\",\"angrtvb;\":\"⊾\",\"angrtvbd;\":\"⦝\",\"angsph;\":\"∢\",\"angst;\":\"Å\",\"angzarr;\":\"⍼\",\"Aogon;\":\"Ą\",\"aogon;\":\"ą\",\"Aopf;\":\"𝔸\",\"aopf;\":\"𝕒\",\"ap;\":\"≈\",\"apacir;\":\"⩯\",\"apE;\":\"⩰\",\"ape;\":\"≊\",\"apid;\":\"≋\",\"apos;\":\"\\'\",\"ApplyFunction;\":\"⁡\",\"approx;\":\"≈\",\"approxeq;\":\"≊\",\"Aring;\":\"Å\",\"Aring\":\"Å\",\"aring;\":\"å\",\"aring\":\"å\",\"Ascr;\":\"𝒜\",\"ascr;\":\"𝒶\",\"Assign;\":\"≔\",\"ast;\":\"*\",\"asymp;\":\"≈\",\"asympeq;\":\"≍\",\"Atilde;\":\"Ã\",\"Atilde\":\"Ã\",\"atilde;\":\"ã\",\"atilde\":\"ã\",\"Auml;\":\"Ä\",\"Auml\":\"Ä\",\"auml;\":\"ä\",\"auml\":\"ä\",\"awconint;\":\"∳\",\"awint;\":\"⨑\",\"backcong;\":\"≌\",\"backepsilon;\":\"϶\",\"backprime;\":\"‵\",\"backsim;\":\"∽\",\"backsimeq;\":\"⋍\",\"Backslash;\":\"∖\",\"Barv;\":\"⫧\",\"barvee;\":\"⊽\",\"Barwed;\":\"⌆\",\"barwed;\":\"⌅\",\"barwedge;\":\"⌅\",\"bbrk;\":\"⎵\",\"bbrktbrk;\":\"⎶\",\"bcong;\":\"≌\",\"Bcy;\":\"Б\",\"bcy;\":\"б\",\"bdquo;\":\"„\",\"becaus;\":\"∵\",\"Because;\":\"∵\",\"because;\":\"∵\",\"bemptyv;\":\"⦰\",\"bepsi;\":\"϶\",\"bernou;\":\"ℬ\",\"Bernoullis;\":\"ℬ\",\"Beta;\":\"Β\",\"beta;\":\"β\",\"beth;\":\"ℶ\",\"between;\":\"≬\",\"Bfr;\":\"𝔅\",\"bfr;\":\"𝔟\",\"bigcap;\":\"⋂\",\"bigcirc;\":\"◯\",\"bigcup;\":\"⋃\",\"bigodot;\":\"⨀\",\"bigoplus;\":\"⨁\",\"bigotimes;\":\"⨂\",\"bigsqcup;\":\"⨆\",\"bigstar;\":\"★\",\"bigtriangledown;\":\"▽\",\"bigtriangleup;\":\"△\",\"biguplus;\":\"⨄\",\"bigvee;\":\"⋁\",\"bigwedge;\":\"⋀\",\"bkarow;\":\"⤍\",\"blacklozenge;\":\"⧫\",\"blacksquare;\":\"▪\",\"blacktriangle;\":\"▴\",\"blacktriangledown;\":\"▾\",\"blacktriangleleft;\":\"◂\",\"blacktriangleright;\":\"▸\",\"blank;\":\"␣\",\"blk12;\":\"▒\",\"blk14;\":\"░\",\"blk34;\":\"▓\",\"block;\":\"█\",\"bne;\":\"=⃥\",\"bnequiv;\":\"≡⃥\",\"bNot;\":\"⫭\",\"bnot;\":\"⌐\",\"Bopf;\":\"𝔹\",\"bopf;\":\"𝕓\",\"bot;\":\"⊥\",\"bottom;\":\"⊥\",\"bowtie;\":\"⋈\",\"boxbox;\":\"⧉\",\"boxDL;\":\"╗\",\"boxDl;\":\"╖\",\"boxdL;\":\"╕\",\"boxdl;\":\"┐\",\"boxDR;\":\"╔\",\"boxDr;\":\"╓\",\"boxdR;\":\"╒\",\"boxdr;\":\"┌\",\"boxH;\":\"═\",\"boxh;\":\"─\",\"boxHD;\":\"╦\",\"boxHd;\":\"╤\",\"boxhD;\":\"╥\",\"boxhd;\":\"┬\",\"boxHU;\":\"╩\",\"boxHu;\":\"╧\",\"boxhU;\":\"╨\",\"boxhu;\":\"┴\",\"boxminus;\":\"⊟\",\"boxplus;\":\"⊞\",\"boxtimes;\":\"⊠\",\"boxUL;\":\"╝\",\"boxUl;\":\"╜\",\"boxuL;\":\"╛\",\"boxul;\":\"┘\",\"boxUR;\":\"╚\",\"boxUr;\":\"╙\",\"boxuR;\":\"╘\",\"boxur;\":\"└\",\"boxV;\":\"║\",\"boxv;\":\"│\",\"boxVH;\":\"╬\",\"boxVh;\":\"╫\",\"boxvH;\":\"╪\",\"boxvh;\":\"┼\",\"boxVL;\":\"╣\",\"boxVl;\":\"╢\",\"boxvL;\":\"╡\",\"boxvl;\":\"┤\",\"boxVR;\":\"╠\",\"boxVr;\":\"╟\",\"boxvR;\":\"╞\",\"boxvr;\":\"├\",\"bprime;\":\"‵\",\"Breve;\":\"˘\",\"breve;\":\"˘\",\"brvbar;\":\"¦\",\"brvbar\":\"¦\",\"Bscr;\":\"ℬ\",\"bscr;\":\"𝒷\",\"bsemi;\":\"⁏\",\"bsim;\":\"∽\",\"bsime;\":\"⋍\",\"bsol;\":\"\\\\\\\\\",\"bsolb;\":\"⧅\",\"bsolhsub;\":\"⟈\",\"bull;\":\"•\",\"bullet;\":\"•\",\"bump;\":\"≎\",\"bumpE;\":\"⪮\",\"bumpe;\":\"≏\",\"Bumpeq;\":\"≎\",\"bumpeq;\":\"≏\",\"Cacute;\":\"Ć\",\"cacute;\":\"ć\",\"Cap;\":\"⋒\",\"cap;\":\"∩\",\"capand;\":\"⩄\",\"capbrcup;\":\"⩉\",\"capcap;\":\"⩋\",\"capcup;\":\"⩇\",\"capdot;\":\"⩀\",\"CapitalDifferentialD;\":\"ⅅ\",\"caps;\":\"∩︀\",\"caret;\":\"⁁\",\"caron;\":\"ˇ\",\"Cayleys;\":\"ℭ\",\"ccaps;\":\"⩍\",\"Ccaron;\":\"Č\",\"ccaron;\":\"č\",\"Ccedil;\":\"Ç\",\"Ccedil\":\"Ç\",\"ccedil;\":\"ç\",\"ccedil\":\"ç\",\"Ccirc;\":\"Ĉ\",\"ccirc;\":\"ĉ\",\"Cconint;\":\"∰\",\"ccups;\":\"⩌\",\"ccupssm;\":\"⩐\",\"Cdot;\":\"Ċ\",\"cdot;\":\"ċ\",\"cedil;\":\"¸\",\"cedil\":\"¸\",\"Cedilla;\":\"¸\",\"cemptyv;\":\"⦲\",\"cent;\":\"¢\",\"cent\":\"¢\",\"CenterDot;\":\"·\",\"centerdot;\":\"·\",\"Cfr;\":\"ℭ\",\"cfr;\":\"𝔠\",\"CHcy;\":\"Ч\",\"chcy;\":\"ч\",\"check;\":\"✓\",\"checkmark;\":\"✓\",\"Chi;\":\"Χ\",\"chi;\":\"χ\",\"cir;\":\"○\",\"circ;\":\"ˆ\",\"circeq;\":\"≗\",\"circlearrowleft;\":\"↺\",\"circlearrowright;\":\"↻\",\"circledast;\":\"⊛\",\"circledcirc;\":\"⊚\",\"circleddash;\":\"⊝\",\"CircleDot;\":\"⊙\",\"circledR;\":\"®\",\"circledS;\":\"Ⓢ\",\"CircleMinus;\":\"⊖\",\"CirclePlus;\":\"⊕\",\"CircleTimes;\":\"⊗\",\"cirE;\":\"⧃\",\"cire;\":\"≗\",\"cirfnint;\":\"⨐\",\"cirmid;\":\"⫯\",\"cirscir;\":\"⧂\",\"ClockwiseContourIntegral;\":\"∲\",\"CloseCurlyDoubleQuote;\":\"”\",\"CloseCurlyQuote;\":\"’\",\"clubs;\":\"♣\",\"clubsuit;\":\"♣\",\"Colon;\":\"∷\",\"colon;\":\":\",\"Colone;\":\"⩴\",\"colone;\":\"≔\",\"coloneq;\":\"≔\",\"comma;\":\",\",\"commat;\":\"@\",\"comp;\":\"∁\",\"compfn;\":\"∘\",\"complement;\":\"∁\",\"complexes;\":\"ℂ\",\"cong;\":\"≅\",\"congdot;\":\"⩭\",\"Congruent;\":\"≡\",\"Conint;\":\"∯\",\"conint;\":\"∮\",\"ContourIntegral;\":\"∮\",\"Copf;\":\"ℂ\",\"copf;\":\"𝕔\",\"coprod;\":\"∐\",\"Coproduct;\":\"∐\",\"COPY;\":\"©\",\"COPY\":\"©\",\"copy;\":\"©\",\"copy\":\"©\",\"copysr;\":\"℗\",\"CounterClockwiseContourIntegral;\":\"∳\",\"crarr;\":\"↵\",\"Cross;\":\"⨯\",\"cross;\":\"✗\",\"Cscr;\":\"𝒞\",\"cscr;\":\"𝒸\",\"csub;\":\"⫏\",\"csube;\":\"⫑\",\"csup;\":\"⫐\",\"csupe;\":\"⫒\",\"ctdot;\":\"⋯\",\"cudarrl;\":\"⤸\",\"cudarrr;\":\"⤵\",\"cuepr;\":\"⋞\",\"cuesc;\":\"⋟\",\"cularr;\":\"↶\",\"cularrp;\":\"⤽\",\"Cup;\":\"⋓\",\"cup;\":\"∪\",\"cupbrcap;\":\"⩈\",\"CupCap;\":\"≍\",\"cupcap;\":\"⩆\",\"cupcup;\":\"⩊\",\"cupdot;\":\"⊍\",\"cupor;\":\"⩅\",\"cups;\":\"∪︀\",\"curarr;\":\"↷\",\"curarrm;\":\"⤼\",\"curlyeqprec;\":\"⋞\",\"curlyeqsucc;\":\"⋟\",\"curlyvee;\":\"⋎\",\"curlywedge;\":\"⋏\",\"curren;\":\"¤\",\"curren\":\"¤\",\"curvearrowleft;\":\"↶\",\"curvearrowright;\":\"↷\",\"cuvee;\":\"⋎\",\"cuwed;\":\"⋏\",\"cwconint;\":\"∲\",\"cwint;\":\"∱\",\"cylcty;\":\"⌭\",\"Dagger;\":\"‡\",\"dagger;\":\"†\",\"daleth;\":\"ℸ\",\"Darr;\":\"↡\",\"dArr;\":\"⇓\",\"darr;\":\"↓\",\"dash;\":\"‐\",\"Dashv;\":\"⫤\",\"dashv;\":\"⊣\",\"dbkarow;\":\"⤏\",\"dblac;\":\"˝\",\"Dcaron;\":\"Ď\",\"dcaron;\":\"ď\",\"Dcy;\":\"Д\",\"dcy;\":\"д\",\"DD;\":\"ⅅ\",\"dd;\":\"ⅆ\",\"ddagger;\":\"‡\",\"ddarr;\":\"⇊\",\"DDotrahd;\":\"⤑\",\"ddotseq;\":\"⩷\",\"deg;\":\"°\",\"deg\":\"°\",\"Del;\":\"∇\",\"Delta;\":\"Δ\",\"delta;\":\"δ\",\"demptyv;\":\"⦱\",\"dfisht;\":\"⥿\",\"Dfr;\":\"𝔇\",\"dfr;\":\"𝔡\",\"dHar;\":\"⥥\",\"dharl;\":\"⇃\",\"dharr;\":\"⇂\",\"DiacriticalAcute;\":\"´\",\"DiacriticalDot;\":\"˙\",\"DiacriticalDoubleAcute;\":\"˝\",\"DiacriticalGrave;\":\"`\",\"DiacriticalTilde;\":\"˜\",\"diam;\":\"⋄\",\"Diamond;\":\"⋄\",\"diamond;\":\"⋄\",\"diamondsuit;\":\"♦\",\"diams;\":\"♦\",\"die;\":\"¨\",\"DifferentialD;\":\"ⅆ\",\"digamma;\":\"ϝ\",\"disin;\":\"⋲\",\"div;\":\"÷\",\"divide;\":\"÷\",\"divide\":\"÷\",\"divideontimes;\":\"⋇\",\"divonx;\":\"⋇\",\"DJcy;\":\"Ђ\",\"djcy;\":\"ђ\",\"dlcorn;\":\"⌞\",\"dlcrop;\":\"⌍\",\"dollar;\":\"$\",\"Dopf;\":\"𝔻\",\"dopf;\":\"𝕕\",\"Dot;\":\"¨\",\"dot;\":\"˙\",\"DotDot;\":\"⃜\",\"doteq;\":\"≐\",\"doteqdot;\":\"≑\",\"DotEqual;\":\"≐\",\"dotminus;\":\"∸\",\"dotplus;\":\"∔\",\"dotsquare;\":\"⊡\",\"doublebarwedge;\":\"⌆\",\"DoubleContourIntegral;\":\"∯\",\"DoubleDot;\":\"¨\",\"DoubleDownArrow;\":\"⇓\",\"DoubleLeftArrow;\":\"⇐\",\"DoubleLeftRightArrow;\":\"⇔\",\"DoubleLeftTee;\":\"⫤\",\"DoubleLongLeftArrow;\":\"⟸\",\"DoubleLongLeftRightArrow;\":\"⟺\",\"DoubleLongRightArrow;\":\"⟹\",\"DoubleRightArrow;\":\"⇒\",\"DoubleRightTee;\":\"⊨\",\"DoubleUpArrow;\":\"⇑\",\"DoubleUpDownArrow;\":\"⇕\",\"DoubleVerticalBar;\":\"∥\",\"DownArrow;\":\"↓\",\"Downarrow;\":\"⇓\",\"downarrow;\":\"↓\",\"DownArrowBar;\":\"⤓\",\"DownArrowUpArrow;\":\"⇵\",\"DownBreve;\":\"̑\",\"downdownarrows;\":\"⇊\",\"downharpoonleft;\":\"⇃\",\"downharpoonright;\":\"⇂\",\"DownLeftRightVector;\":\"⥐\",\"DownLeftTeeVector;\":\"⥞\",\"DownLeftVector;\":\"↽\",\"DownLeftVectorBar;\":\"⥖\",\"DownRightTeeVector;\":\"⥟\",\"DownRightVector;\":\"⇁\",\"DownRightVectorBar;\":\"⥗\",\"DownTee;\":\"⊤\",\"DownTeeArrow;\":\"↧\",\"drbkarow;\":\"⤐\",\"drcorn;\":\"⌟\",\"drcrop;\":\"⌌\",\"Dscr;\":\"𝒟\",\"dscr;\":\"𝒹\",\"DScy;\":\"Ѕ\",\"dscy;\":\"ѕ\",\"dsol;\":\"⧶\",\"Dstrok;\":\"Đ\",\"dstrok;\":\"đ\",\"dtdot;\":\"⋱\",\"dtri;\":\"▿\",\"dtrif;\":\"▾\",\"duarr;\":\"⇵\",\"duhar;\":\"⥯\",\"dwangle;\":\"⦦\",\"DZcy;\":\"Џ\",\"dzcy;\":\"џ\",\"dzigrarr;\":\"⟿\",\"Eacute;\":\"É\",\"Eacute\":\"É\",\"eacute;\":\"é\",\"eacute\":\"é\",\"easter;\":\"⩮\",\"Ecaron;\":\"Ě\",\"ecaron;\":\"ě\",\"ecir;\":\"≖\",\"Ecirc;\":\"Ê\",\"Ecirc\":\"Ê\",\"ecirc;\":\"ê\",\"ecirc\":\"ê\",\"ecolon;\":\"≕\",\"Ecy;\":\"Э\",\"ecy;\":\"э\",\"eDDot;\":\"⩷\",\"Edot;\":\"Ė\",\"eDot;\":\"≑\",\"edot;\":\"ė\",\"ee;\":\"ⅇ\",\"efDot;\":\"≒\",\"Efr;\":\"𝔈\",\"efr;\":\"𝔢\",\"eg;\":\"⪚\",\"Egrave;\":\"È\",\"Egrave\":\"È\",\"egrave;\":\"è\",\"egrave\":\"è\",\"egs;\":\"⪖\",\"egsdot;\":\"⪘\",\"el;\":\"⪙\",\"Element;\":\"∈\",\"elinters;\":\"⏧\",\"ell;\":\"ℓ\",\"els;\":\"⪕\",\"elsdot;\":\"⪗\",\"Emacr;\":\"Ē\",\"emacr;\":\"ē\",\"empty;\":\"∅\",\"emptyset;\":\"∅\",\"EmptySmallSquare;\":\"◻\",\"emptyv;\":\"∅\",\"EmptyVerySmallSquare;\":\"▫\",\"emsp;\":\" \",\"emsp13;\":\" \",\"emsp14;\":\" \",\"ENG;\":\"Ŋ\",\"eng;\":\"ŋ\",\"ensp;\":\" \",\"Eogon;\":\"Ę\",\"eogon;\":\"ę\",\"Eopf;\":\"𝔼\",\"eopf;\":\"𝕖\",\"epar;\":\"⋕\",\"eparsl;\":\"⧣\",\"eplus;\":\"⩱\",\"epsi;\":\"ε\",\"Epsilon;\":\"Ε\",\"epsilon;\":\"ε\",\"epsiv;\":\"ϵ\",\"eqcirc;\":\"≖\",\"eqcolon;\":\"≕\",\"eqsim;\":\"≂\",\"eqslantgtr;\":\"⪖\",\"eqslantless;\":\"⪕\",\"Equal;\":\"⩵\",\"equals;\":\"=\",\"EqualTilde;\":\"≂\",\"equest;\":\"≟\",\"Equilibrium;\":\"⇌\",\"equiv;\":\"≡\",\"equivDD;\":\"⩸\",\"eqvparsl;\":\"⧥\",\"erarr;\":\"⥱\",\"erDot;\":\"≓\",\"Escr;\":\"ℰ\",\"escr;\":\"ℯ\",\"esdot;\":\"≐\",\"Esim;\":\"⩳\",\"esim;\":\"≂\",\"Eta;\":\"Η\",\"eta;\":\"η\",\"ETH;\":\"Ð\",\"ETH\":\"Ð\",\"eth;\":\"ð\",\"eth\":\"ð\",\"Euml;\":\"Ë\",\"Euml\":\"Ë\",\"euml;\":\"ë\",\"euml\":\"ë\",\"euro;\":\"€\",\"excl;\":\"!\",\"exist;\":\"∃\",\"Exists;\":\"∃\",\"expectation;\":\"ℰ\",\"ExponentialE;\":\"ⅇ\",\"exponentiale;\":\"ⅇ\",\"fallingdotseq;\":\"≒\",\"Fcy;\":\"Ф\",\"fcy;\":\"ф\",\"female;\":\"♀\",\"ffilig;\":\"ﬃ\",\"fflig;\":\"ﬀ\",\"ffllig;\":\"ﬄ\",\"Ffr;\":\"𝔉\",\"ffr;\":\"𝔣\",\"filig;\":\"ﬁ\",\"FilledSmallSquare;\":\"◼\",\"FilledVerySmallSquare;\":\"▪\",\"fjlig;\":\"fj\",\"flat;\":\"♭\",\"fllig;\":\"ﬂ\",\"fltns;\":\"▱\",\"fnof;\":\"ƒ\",\"Fopf;\":\"𝔽\",\"fopf;\":\"𝕗\",\"ForAll;\":\"∀\",\"forall;\":\"∀\",\"fork;\":\"⋔\",\"forkv;\":\"⫙\",\"Fouriertrf;\":\"ℱ\",\"fpartint;\":\"⨍\",\"frac12;\":\"½\",\"frac12\":\"½\",\"frac13;\":\"⅓\",\"frac14;\":\"¼\",\"frac14\":\"¼\",\"frac15;\":\"⅕\",\"frac16;\":\"⅙\",\"frac18;\":\"⅛\",\"frac23;\":\"⅔\",\"frac25;\":\"⅖\",\"frac34;\":\"¾\",\"frac34\":\"¾\",\"frac35;\":\"⅗\",\"frac38;\":\"⅜\",\"frac45;\":\"⅘\",\"frac56;\":\"⅚\",\"frac58;\":\"⅝\",\"frac78;\":\"⅞\",\"frasl;\":\"⁄\",\"frown;\":\"⌢\",\"Fscr;\":\"ℱ\",\"fscr;\":\"𝒻\",\"gacute;\":\"ǵ\",\"Gamma;\":\"Γ\",\"gamma;\":\"γ\",\"Gammad;\":\"Ϝ\",\"gammad;\":\"ϝ\",\"gap;\":\"⪆\",\"Gbreve;\":\"Ğ\",\"gbreve;\":\"ğ\",\"Gcedil;\":\"Ģ\",\"Gcirc;\":\"Ĝ\",\"gcirc;\":\"ĝ\",\"Gcy;\":\"Г\",\"gcy;\":\"г\",\"Gdot;\":\"Ġ\",\"gdot;\":\"ġ\",\"gE;\":\"≧\",\"ge;\":\"≥\",\"gEl;\":\"⪌\",\"gel;\":\"⋛\",\"geq;\":\"≥\",\"geqq;\":\"≧\",\"geqslant;\":\"⩾\",\"ges;\":\"⩾\",\"gescc;\":\"⪩\",\"gesdot;\":\"⪀\",\"gesdoto;\":\"⪂\",\"gesdotol;\":\"⪄\",\"gesl;\":\"⋛︀\",\"gesles;\":\"⪔\",\"Gfr;\":\"𝔊\",\"gfr;\":\"𝔤\",\"Gg;\":\"⋙\",\"gg;\":\"≫\",\"ggg;\":\"⋙\",\"gimel;\":\"ℷ\",\"GJcy;\":\"Ѓ\",\"gjcy;\":\"ѓ\",\"gl;\":\"≷\",\"gla;\":\"⪥\",\"glE;\":\"⪒\",\"glj;\":\"⪤\",\"gnap;\":\"⪊\",\"gnapprox;\":\"⪊\",\"gnE;\":\"≩\",\"gne;\":\"⪈\",\"gneq;\":\"⪈\",\"gneqq;\":\"≩\",\"gnsim;\":\"⋧\",\"Gopf;\":\"𝔾\",\"gopf;\":\"𝕘\",\"grave;\":\"`\",\"GreaterEqual;\":\"≥\",\"GreaterEqualLess;\":\"⋛\",\"GreaterFullEqual;\":\"≧\",\"GreaterGreater;\":\"⪢\",\"GreaterLess;\":\"≷\",\"GreaterSlantEqual;\":\"⩾\",\"GreaterTilde;\":\"≳\",\"Gscr;\":\"𝒢\",\"gscr;\":\"ℊ\",\"gsim;\":\"≳\",\"gsime;\":\"⪎\",\"gsiml;\":\"⪐\",\"GT;\":\">\",\"GT\":\">\",\"Gt;\":\"≫\",\"gt;\":\">\",\"gt\":\">\",\"gtcc;\":\"⪧\",\"gtcir;\":\"⩺\",\"gtdot;\":\"⋗\",\"gtlPar;\":\"⦕\",\"gtquest;\":\"⩼\",\"gtrapprox;\":\"⪆\",\"gtrarr;\":\"⥸\",\"gtrdot;\":\"⋗\",\"gtreqless;\":\"⋛\",\"gtreqqless;\":\"⪌\",\"gtrless;\":\"≷\",\"gtrsim;\":\"≳\",\"gvertneqq;\":\"≩︀\",\"gvnE;\":\"≩︀\",\"Hacek;\":\"ˇ\",\"hairsp;\":\" \",\"half;\":\"½\",\"hamilt;\":\"ℋ\",\"HARDcy;\":\"Ъ\",\"hardcy;\":\"ъ\",\"hArr;\":\"⇔\",\"harr;\":\"↔\",\"harrcir;\":\"⥈\",\"harrw;\":\"↭\",\"Hat;\":\"^\",\"hbar;\":\"ℏ\",\"Hcirc;\":\"Ĥ\",\"hcirc;\":\"ĥ\",\"hearts;\":\"♥\",\"heartsuit;\":\"♥\",\"hellip;\":\"…\",\"hercon;\":\"⊹\",\"Hfr;\":\"ℌ\",\"hfr;\":\"𝔥\",\"HilbertSpace;\":\"ℋ\",\"hksearow;\":\"⤥\",\"hkswarow;\":\"⤦\",\"hoarr;\":\"⇿\",\"homtht;\":\"∻\",\"hookleftarrow;\":\"↩\",\"hookrightarrow;\":\"↪\",\"Hopf;\":\"ℍ\",\"hopf;\":\"𝕙\",\"horbar;\":\"―\",\"HorizontalLine;\":\"─\",\"Hscr;\":\"ℋ\",\"hscr;\":\"𝒽\",\"hslash;\":\"ℏ\",\"Hstrok;\":\"Ħ\",\"hstrok;\":\"ħ\",\"HumpDownHump;\":\"≎\",\"HumpEqual;\":\"≏\",\"hybull;\":\"⁃\",\"hyphen;\":\"‐\",\"Iacute;\":\"Í\",\"Iacute\":\"Í\",\"iacute;\":\"í\",\"iacute\":\"í\",\"ic;\":\"⁣\",\"Icirc;\":\"Î\",\"Icirc\":\"Î\",\"icirc;\":\"î\",\"icirc\":\"î\",\"Icy;\":\"И\",\"icy;\":\"и\",\"Idot;\":\"İ\",\"IEcy;\":\"Е\",\"iecy;\":\"е\",\"iexcl;\":\"¡\",\"iexcl\":\"¡\",\"iff;\":\"⇔\",\"Ifr;\":\"ℑ\",\"ifr;\":\"𝔦\",\"Igrave;\":\"Ì\",\"Igrave\":\"Ì\",\"igrave;\":\"ì\",\"igrave\":\"ì\",\"ii;\":\"ⅈ\",\"iiiint;\":\"⨌\",\"iiint;\":\"∭\",\"iinfin;\":\"⧜\",\"iiota;\":\"℩\",\"IJlig;\":\"Ĳ\",\"ijlig;\":\"ĳ\",\"Im;\":\"ℑ\",\"Imacr;\":\"Ī\",\"imacr;\":\"ī\",\"image;\":\"ℑ\",\"ImaginaryI;\":\"ⅈ\",\"imagline;\":\"ℐ\",\"imagpart;\":\"ℑ\",\"imath;\":\"ı\",\"imof;\":\"⊷\",\"imped;\":\"Ƶ\",\"Implies;\":\"⇒\",\"in;\":\"∈\",\"incare;\":\"℅\",\"infin;\":\"∞\",\"infintie;\":\"⧝\",\"inodot;\":\"ı\",\"Int;\":\"∬\",\"int;\":\"∫\",\"intcal;\":\"⊺\",\"integers;\":\"ℤ\",\"Integral;\":\"∫\",\"intercal;\":\"⊺\",\"Intersection;\":\"⋂\",\"intlarhk;\":\"⨗\",\"intprod;\":\"⨼\",\"InvisibleComma;\":\"⁣\",\"InvisibleTimes;\":\"⁢\",\"IOcy;\":\"Ё\",\"iocy;\":\"ё\",\"Iogon;\":\"Į\",\"iogon;\":\"į\",\"Iopf;\":\"𝕀\",\"iopf;\":\"𝕚\",\"Iota;\":\"Ι\",\"iota;\":\"ι\",\"iprod;\":\"⨼\",\"iquest;\":\"¿\",\"iquest\":\"¿\",\"Iscr;\":\"ℐ\",\"iscr;\":\"𝒾\",\"isin;\":\"∈\",\"isindot;\":\"⋵\",\"isinE;\":\"⋹\",\"isins;\":\"⋴\",\"isinsv;\":\"⋳\",\"isinv;\":\"∈\",\"it;\":\"⁢\",\"Itilde;\":\"Ĩ\",\"itilde;\":\"ĩ\",\"Iukcy;\":\"І\",\"iukcy;\":\"і\",\"Iuml;\":\"Ï\",\"Iuml\":\"Ï\",\"iuml;\":\"ï\",\"iuml\":\"ï\",\"Jcirc;\":\"Ĵ\",\"jcirc;\":\"ĵ\",\"Jcy;\":\"Й\",\"jcy;\":\"й\",\"Jfr;\":\"𝔍\",\"jfr;\":\"𝔧\",\"jmath;\":\"ȷ\",\"Jopf;\":\"𝕁\",\"jopf;\":\"𝕛\",\"Jscr;\":\"𝒥\",\"jscr;\":\"𝒿\",\"Jsercy;\":\"Ј\",\"jsercy;\":\"ј\",\"Jukcy;\":\"Є\",\"jukcy;\":\"є\",\"Kappa;\":\"Κ\",\"kappa;\":\"κ\",\"kappav;\":\"ϰ\",\"Kcedil;\":\"Ķ\",\"kcedil;\":\"ķ\",\"Kcy;\":\"К\",\"kcy;\":\"к\",\"Kfr;\":\"𝔎\",\"kfr;\":\"𝔨\",\"kgreen;\":\"ĸ\",\"KHcy;\":\"Х\",\"khcy;\":\"х\",\"KJcy;\":\"Ќ\",\"kjcy;\":\"ќ\",\"Kopf;\":\"𝕂\",\"kopf;\":\"𝕜\",\"Kscr;\":\"𝒦\",\"kscr;\":\"𝓀\",\"lAarr;\":\"⇚\",\"Lacute;\":\"Ĺ\",\"lacute;\":\"ĺ\",\"laemptyv;\":\"⦴\",\"lagran;\":\"ℒ\",\"Lambda;\":\"Λ\",\"lambda;\":\"λ\",\"Lang;\":\"⟪\",\"lang;\":\"⟨\",\"langd;\":\"⦑\",\"langle;\":\"⟨\",\"lap;\":\"⪅\",\"Laplacetrf;\":\"ℒ\",\"laquo;\":\"«\",\"laquo\":\"«\",\"Larr;\":\"↞\",\"lArr;\":\"⇐\",\"larr;\":\"←\",\"larrb;\":\"⇤\",\"larrbfs;\":\"⤟\",\"larrfs;\":\"⤝\",\"larrhk;\":\"↩\",\"larrlp;\":\"↫\",\"larrpl;\":\"⤹\",\"larrsim;\":\"⥳\",\"larrtl;\":\"↢\",\"lat;\":\"⪫\",\"lAtail;\":\"⤛\",\"latail;\":\"⤙\",\"late;\":\"⪭\",\"lates;\":\"⪭︀\",\"lBarr;\":\"⤎\",\"lbarr;\":\"⤌\",\"lbbrk;\":\"❲\",\"lbrace;\":\"{\",\"lbrack;\":\"[\",\"lbrke;\":\"⦋\",\"lbrksld;\":\"⦏\",\"lbrkslu;\":\"⦍\",\"Lcaron;\":\"Ľ\",\"lcaron;\":\"ľ\",\"Lcedil;\":\"Ļ\",\"lcedil;\":\"ļ\",\"lceil;\":\"⌈\",\"lcub;\":\"{\",\"Lcy;\":\"Л\",\"lcy;\":\"л\",\"ldca;\":\"⤶\",\"ldquo;\":\"“\",\"ldquor;\":\"„\",\"ldrdhar;\":\"⥧\",\"ldrushar;\":\"⥋\",\"ldsh;\":\"↲\",\"lE;\":\"≦\",\"le;\":\"≤\",\"LeftAngleBracket;\":\"⟨\",\"LeftArrow;\":\"←\",\"Leftarrow;\":\"⇐\",\"leftarrow;\":\"←\",\"LeftArrowBar;\":\"⇤\",\"LeftArrowRightArrow;\":\"⇆\",\"leftarrowtail;\":\"↢\",\"LeftCeiling;\":\"⌈\",\"LeftDoubleBracket;\":\"⟦\",\"LeftDownTeeVector;\":\"⥡\",\"LeftDownVector;\":\"⇃\",\"LeftDownVectorBar;\":\"⥙\",\"LeftFloor;\":\"⌊\",\"leftharpoondown;\":\"↽\",\"leftharpoonup;\":\"↼\",\"leftleftarrows;\":\"⇇\",\"LeftRightArrow;\":\"↔\",\"Leftrightarrow;\":\"⇔\",\"leftrightarrow;\":\"↔\",\"leftrightarrows;\":\"⇆\",\"leftrightharpoons;\":\"⇋\",\"leftrightsquigarrow;\":\"↭\",\"LeftRightVector;\":\"⥎\",\"LeftTee;\":\"⊣\",\"LeftTeeArrow;\":\"↤\",\"LeftTeeVector;\":\"⥚\",\"leftthreetimes;\":\"⋋\",\"LeftTriangle;\":\"⊲\",\"LeftTriangleBar;\":\"⧏\",\"LeftTriangleEqual;\":\"⊴\",\"LeftUpDownVector;\":\"⥑\",\"LeftUpTeeVector;\":\"⥠\",\"LeftUpVector;\":\"↿\",\"LeftUpVectorBar;\":\"⥘\",\"LeftVector;\":\"↼\",\"LeftVectorBar;\":\"⥒\",\"lEg;\":\"⪋\",\"leg;\":\"⋚\",\"leq;\":\"≤\",\"leqq;\":\"≦\",\"leqslant;\":\"⩽\",\"les;\":\"⩽\",\"lescc;\":\"⪨\",\"lesdot;\":\"⩿\",\"lesdoto;\":\"⪁\",\"lesdotor;\":\"⪃\",\"lesg;\":\"⋚︀\",\"lesges;\":\"⪓\",\"lessapprox;\":\"⪅\",\"lessdot;\":\"⋖\",\"lesseqgtr;\":\"⋚\",\"lesseqqgtr;\":\"⪋\",\"LessEqualGreater;\":\"⋚\",\"LessFullEqual;\":\"≦\",\"LessGreater;\":\"≶\",\"lessgtr;\":\"≶\",\"LessLess;\":\"⪡\",\"lesssim;\":\"≲\",\"LessSlantEqual;\":\"⩽\",\"LessTilde;\":\"≲\",\"lfisht;\":\"⥼\",\"lfloor;\":\"⌊\",\"Lfr;\":\"𝔏\",\"lfr;\":\"𝔩\",\"lg;\":\"≶\",\"lgE;\":\"⪑\",\"lHar;\":\"⥢\",\"lhard;\":\"↽\",\"lharu;\":\"↼\",\"lharul;\":\"⥪\",\"lhblk;\":\"▄\",\"LJcy;\":\"Љ\",\"ljcy;\":\"љ\",\"Ll;\":\"⋘\",\"ll;\":\"≪\",\"llarr;\":\"⇇\",\"llcorner;\":\"⌞\",\"Lleftarrow;\":\"⇚\",\"llhard;\":\"⥫\",\"lltri;\":\"◺\",\"Lmidot;\":\"Ŀ\",\"lmidot;\":\"ŀ\",\"lmoust;\":\"⎰\",\"lmoustache;\":\"⎰\",\"lnap;\":\"⪉\",\"lnapprox;\":\"⪉\",\"lnE;\":\"≨\",\"lne;\":\"⪇\",\"lneq;\":\"⪇\",\"lneqq;\":\"≨\",\"lnsim;\":\"⋦\",\"loang;\":\"⟬\",\"loarr;\":\"⇽\",\"lobrk;\":\"⟦\",\"LongLeftArrow;\":\"⟵\",\"Longleftarrow;\":\"⟸\",\"longleftarrow;\":\"⟵\",\"LongLeftRightArrow;\":\"⟷\",\"Longleftrightarrow;\":\"⟺\",\"longleftrightarrow;\":\"⟷\",\"longmapsto;\":\"⟼\",\"LongRightArrow;\":\"⟶\",\"Longrightarrow;\":\"⟹\",\"longrightarrow;\":\"⟶\",\"looparrowleft;\":\"↫\",\"looparrowright;\":\"↬\",\"lopar;\":\"⦅\",\"Lopf;\":\"𝕃\",\"lopf;\":\"𝕝\",\"loplus;\":\"⨭\",\"lotimes;\":\"⨴\",\"lowast;\":\"∗\",\"lowbar;\":\"_\",\"LowerLeftArrow;\":\"↙\",\"LowerRightArrow;\":\"↘\",\"loz;\":\"◊\",\"lozenge;\":\"◊\",\"lozf;\":\"⧫\",\"lpar;\":\"(\",\"lparlt;\":\"⦓\",\"lrarr;\":\"⇆\",\"lrcorner;\":\"⌟\",\"lrhar;\":\"⇋\",\"lrhard;\":\"⥭\",\"lrm;\":\"‎\",\"lrtri;\":\"⊿\",\"lsaquo;\":\"‹\",\"Lscr;\":\"ℒ\",\"lscr;\":\"𝓁\",\"Lsh;\":\"↰\",\"lsh;\":\"↰\",\"lsim;\":\"≲\",\"lsime;\":\"⪍\",\"lsimg;\":\"⪏\",\"lsqb;\":\"[\",\"lsquo;\":\"‘\",\"lsquor;\":\"‚\",\"Lstrok;\":\"Ł\",\"lstrok;\":\"ł\",\"LT;\":\"<\",\"LT\":\"<\",\"Lt;\":\"≪\",\"lt;\":\"<\",\"lt\":\"<\",\"ltcc;\":\"⪦\",\"ltcir;\":\"⩹\",\"ltdot;\":\"⋖\",\"lthree;\":\"⋋\",\"ltimes;\":\"⋉\",\"ltlarr;\":\"⥶\",\"ltquest;\":\"⩻\",\"ltri;\":\"◃\",\"ltrie;\":\"⊴\",\"ltrif;\":\"◂\",\"ltrPar;\":\"⦖\",\"lurdshar;\":\"⥊\",\"luruhar;\":\"⥦\",\"lvertneqq;\":\"≨︀\",\"lvnE;\":\"≨︀\",\"macr;\":\"¯\",\"macr\":\"¯\",\"male;\":\"♂\",\"malt;\":\"✠\",\"maltese;\":\"✠\",\"Map;\":\"⤅\",\"map;\":\"↦\",\"mapsto;\":\"↦\",\"mapstodown;\":\"↧\",\"mapstoleft;\":\"↤\",\"mapstoup;\":\"↥\",\"marker;\":\"▮\",\"mcomma;\":\"⨩\",\"Mcy;\":\"М\",\"mcy;\":\"м\",\"mdash;\":\"—\",\"mDDot;\":\"∺\",\"measuredangle;\":\"∡\",\"MediumSpace;\":\" \",\"Mellintrf;\":\"ℳ\",\"Mfr;\":\"𝔐\",\"mfr;\":\"𝔪\",\"mho;\":\"℧\",\"micro;\":\"µ\",\"micro\":\"µ\",\"mid;\":\"∣\",\"midast;\":\"*\",\"midcir;\":\"⫰\",\"middot;\":\"·\",\"middot\":\"·\",\"minus;\":\"−\",\"minusb;\":\"⊟\",\"minusd;\":\"∸\",\"minusdu;\":\"⨪\",\"MinusPlus;\":\"∓\",\"mlcp;\":\"⫛\",\"mldr;\":\"…\",\"mnplus;\":\"∓\",\"models;\":\"⊧\",\"Mopf;\":\"𝕄\",\"mopf;\":\"𝕞\",\"mp;\":\"∓\",\"Mscr;\":\"ℳ\",\"mscr;\":\"𝓂\",\"mstpos;\":\"∾\",\"Mu;\":\"Μ\",\"mu;\":\"μ\",\"multimap;\":\"⊸\",\"mumap;\":\"⊸\",\"nabla;\":\"∇\",\"Nacute;\":\"Ń\",\"nacute;\":\"ń\",\"nang;\":\"∠⃒\",\"nap;\":\"≉\",\"napE;\":\"⩰̸\",\"napid;\":\"≋̸\",\"napos;\":\"ŉ\",\"napprox;\":\"≉\",\"natur;\":\"♮\",\"natural;\":\"♮\",\"naturals;\":\"ℕ\",\"nbsp;\":\" \",\"nbsp\":\" \",\"nbump;\":\"≎̸\",\"nbumpe;\":\"≏̸\",\"ncap;\":\"⩃\",\"Ncaron;\":\"Ň\",\"ncaron;\":\"ň\",\"Ncedil;\":\"Ņ\",\"ncedil;\":\"ņ\",\"ncong;\":\"≇\",\"ncongdot;\":\"⩭̸\",\"ncup;\":\"⩂\",\"Ncy;\":\"Н\",\"ncy;\":\"н\",\"ndash;\":\"–\",\"ne;\":\"≠\",\"nearhk;\":\"⤤\",\"neArr;\":\"⇗\",\"nearr;\":\"↗\",\"nearrow;\":\"↗\",\"nedot;\":\"≐̸\",\"NegativeMediumSpace;\":\"​\",\"NegativeThickSpace;\":\"​\",\"NegativeThinSpace;\":\"​\",\"NegativeVeryThinSpace;\":\"​\",\"nequiv;\":\"≢\",\"nesear;\":\"⤨\",\"nesim;\":\"≂̸\",\"NestedGreaterGreater;\":\"≫\",\"NestedLessLess;\":\"≪\",\"NewLine;\":\"\\\\n\",\"nexist;\":\"∄\",\"nexists;\":\"∄\",\"Nfr;\":\"𝔑\",\"nfr;\":\"𝔫\",\"ngE;\":\"≧̸\",\"nge;\":\"≱\",\"ngeq;\":\"≱\",\"ngeqq;\":\"≧̸\",\"ngeqslant;\":\"⩾̸\",\"nges;\":\"⩾̸\",\"nGg;\":\"⋙̸\",\"ngsim;\":\"≵\",\"nGt;\":\"≫⃒\",\"ngt;\":\"≯\",\"ngtr;\":\"≯\",\"nGtv;\":\"≫̸\",\"nhArr;\":\"⇎\",\"nharr;\":\"↮\",\"nhpar;\":\"⫲\",\"ni;\":\"∋\",\"nis;\":\"⋼\",\"nisd;\":\"⋺\",\"niv;\":\"∋\",\"NJcy;\":\"Њ\",\"njcy;\":\"њ\",\"nlArr;\":\"⇍\",\"nlarr;\":\"↚\",\"nldr;\":\"‥\",\"nlE;\":\"≦̸\",\"nle;\":\"≰\",\"nLeftarrow;\":\"⇍\",\"nleftarrow;\":\"↚\",\"nLeftrightarrow;\":\"⇎\",\"nleftrightarrow;\":\"↮\",\"nleq;\":\"≰\",\"nleqq;\":\"≦̸\",\"nleqslant;\":\"⩽̸\",\"nles;\":\"⩽̸\",\"nless;\":\"≮\",\"nLl;\":\"⋘̸\",\"nlsim;\":\"≴\",\"nLt;\":\"≪⃒\",\"nlt;\":\"≮\",\"nltri;\":\"⋪\",\"nltrie;\":\"⋬\",\"nLtv;\":\"≪̸\",\"nmid;\":\"∤\",\"NoBreak;\":\"⁠\",\"NonBreakingSpace;\":\" \",\"Nopf;\":\"ℕ\",\"nopf;\":\"𝕟\",\"Not;\":\"⫬\",\"not;\":\"¬\",\"not\":\"¬\",\"NotCongruent;\":\"≢\",\"NotCupCap;\":\"≭\",\"NotDoubleVerticalBar;\":\"∦\",\"NotElement;\":\"∉\",\"NotEqual;\":\"≠\",\"NotEqualTilde;\":\"≂̸\",\"NotExists;\":\"∄\",\"NotGreater;\":\"≯\",\"NotGreaterEqual;\":\"≱\",\"NotGreaterFullEqual;\":\"≧̸\",\"NotGreaterGreater;\":\"≫̸\",\"NotGreaterLess;\":\"≹\",\"NotGreaterSlantEqual;\":\"⩾̸\",\"NotGreaterTilde;\":\"≵\",\"NotHumpDownHump;\":\"≎̸\",\"NotHumpEqual;\":\"≏̸\",\"notin;\":\"∉\",\"notindot;\":\"⋵̸\",\"notinE;\":\"⋹̸\",\"notinva;\":\"∉\",\"notinvb;\":\"⋷\",\"notinvc;\":\"⋶\",\"NotLeftTriangle;\":\"⋪\",\"NotLeftTriangleBar;\":\"⧏̸\",\"NotLeftTriangleEqual;\":\"⋬\",\"NotLess;\":\"≮\",\"NotLessEqual;\":\"≰\",\"NotLessGreater;\":\"≸\",\"NotLessLess;\":\"≪̸\",\"NotLessSlantEqual;\":\"⩽̸\",\"NotLessTilde;\":\"≴\",\"NotNestedGreaterGreater;\":\"⪢̸\",\"NotNestedLessLess;\":\"⪡̸\",\"notni;\":\"∌\",\"notniva;\":\"∌\",\"notnivb;\":\"⋾\",\"notnivc;\":\"⋽\",\"NotPrecedes;\":\"⊀\",\"NotPrecedesEqual;\":\"⪯̸\",\"NotPrecedesSlantEqual;\":\"⋠\",\"NotReverseElement;\":\"∌\",\"NotRightTriangle;\":\"⋫\",\"NotRightTriangleBar;\":\"⧐̸\",\"NotRightTriangleEqual;\":\"⋭\",\"NotSquareSubset;\":\"⊏̸\",\"NotSquareSubsetEqual;\":\"⋢\",\"NotSquareSuperset;\":\"⊐̸\",\"NotSquareSupersetEqual;\":\"⋣\",\"NotSubset;\":\"⊂⃒\",\"NotSubsetEqual;\":\"⊈\",\"NotSucceeds;\":\"⊁\",\"NotSucceedsEqual;\":\"⪰̸\",\"NotSucceedsSlantEqual;\":\"⋡\",\"NotSucceedsTilde;\":\"≿̸\",\"NotSuperset;\":\"⊃⃒\",\"NotSupersetEqual;\":\"⊉\",\"NotTilde;\":\"≁\",\"NotTildeEqual;\":\"≄\",\"NotTildeFullEqual;\":\"≇\",\"NotTildeTilde;\":\"≉\",\"NotVerticalBar;\":\"∤\",\"npar;\":\"∦\",\"nparallel;\":\"∦\",\"nparsl;\":\"⫽⃥\",\"npart;\":\"∂̸\",\"npolint;\":\"⨔\",\"npr;\":\"⊀\",\"nprcue;\":\"⋠\",\"npre;\":\"⪯̸\",\"nprec;\":\"⊀\",\"npreceq;\":\"⪯̸\",\"nrArr;\":\"⇏\",\"nrarr;\":\"↛\",\"nrarrc;\":\"⤳̸\",\"nrarrw;\":\"↝̸\",\"nRightarrow;\":\"⇏\",\"nrightarrow;\":\"↛\",\"nrtri;\":\"⋫\",\"nrtrie;\":\"⋭\",\"nsc;\":\"⊁\",\"nsccue;\":\"⋡\",\"nsce;\":\"⪰̸\",\"Nscr;\":\"𝒩\",\"nscr;\":\"𝓃\",\"nshortmid;\":\"∤\",\"nshortparallel;\":\"∦\",\"nsim;\":\"≁\",\"nsime;\":\"≄\",\"nsimeq;\":\"≄\",\"nsmid;\":\"∤\",\"nspar;\":\"∦\",\"nsqsube;\":\"⋢\",\"nsqsupe;\":\"⋣\",\"nsub;\":\"⊄\",\"nsubE;\":\"⫅̸\",\"nsube;\":\"⊈\",\"nsubset;\":\"⊂⃒\",\"nsubseteq;\":\"⊈\",\"nsubseteqq;\":\"⫅̸\",\"nsucc;\":\"⊁\",\"nsucceq;\":\"⪰̸\",\"nsup;\":\"⊅\",\"nsupE;\":\"⫆̸\",\"nsupe;\":\"⊉\",\"nsupset;\":\"⊃⃒\",\"nsupseteq;\":\"⊉\",\"nsupseteqq;\":\"⫆̸\",\"ntgl;\":\"≹\",\"Ntilde;\":\"Ñ\",\"Ntilde\":\"Ñ\",\"ntilde;\":\"ñ\",\"ntilde\":\"ñ\",\"ntlg;\":\"≸\",\"ntriangleleft;\":\"⋪\",\"ntrianglelefteq;\":\"⋬\",\"ntriangleright;\":\"⋫\",\"ntrianglerighteq;\":\"⋭\",\"Nu;\":\"Ν\",\"nu;\":\"ν\",\"num;\":\"#\",\"numero;\":\"№\",\"numsp;\":\" \",\"nvap;\":\"≍⃒\",\"nVDash;\":\"⊯\",\"nVdash;\":\"⊮\",\"nvDash;\":\"⊭\",\"nvdash;\":\"⊬\",\"nvge;\":\"≥⃒\",\"nvgt;\":\">⃒\",\"nvHarr;\":\"⤄\",\"nvinfin;\":\"⧞\",\"nvlArr;\":\"⤂\",\"nvle;\":\"≤⃒\",\"nvlt;\":\"<⃒\",\"nvltrie;\":\"⊴⃒\",\"nvrArr;\":\"⤃\",\"nvrtrie;\":\"⊵⃒\",\"nvsim;\":\"∼⃒\",\"nwarhk;\":\"⤣\",\"nwArr;\":\"⇖\",\"nwarr;\":\"↖\",\"nwarrow;\":\"↖\",\"nwnear;\":\"⤧\",\"Oacute;\":\"Ó\",\"Oacute\":\"Ó\",\"oacute;\":\"ó\",\"oacute\":\"ó\",\"oast;\":\"⊛\",\"ocir;\":\"⊚\",\"Ocirc;\":\"Ô\",\"Ocirc\":\"Ô\",\"ocirc;\":\"ô\",\"ocirc\":\"ô\",\"Ocy;\":\"О\",\"ocy;\":\"о\",\"odash;\":\"⊝\",\"Odblac;\":\"Ő\",\"odblac;\":\"ő\",\"odiv;\":\"⨸\",\"odot;\":\"⊙\",\"odsold;\":\"⦼\",\"OElig;\":\"Œ\",\"oelig;\":\"œ\",\"ofcir;\":\"⦿\",\"Ofr;\":\"𝔒\",\"ofr;\":\"𝔬\",\"ogon;\":\"˛\",\"Ograve;\":\"Ò\",\"Ograve\":\"Ò\",\"ograve;\":\"ò\",\"ograve\":\"ò\",\"ogt;\":\"⧁\",\"ohbar;\":\"⦵\",\"ohm;\":\"Ω\",\"oint;\":\"∮\",\"olarr;\":\"↺\",\"olcir;\":\"⦾\",\"olcross;\":\"⦻\",\"oline;\":\"‾\",\"olt;\":\"⧀\",\"Omacr;\":\"Ō\",\"omacr;\":\"ō\",\"Omega;\":\"Ω\",\"omega;\":\"ω\",\"Omicron;\":\"Ο\",\"omicron;\":\"ο\",\"omid;\":\"⦶\",\"ominus;\":\"⊖\",\"Oopf;\":\"𝕆\",\"oopf;\":\"𝕠\",\"opar;\":\"⦷\",\"OpenCurlyDoubleQuote;\":\"“\",\"OpenCurlyQuote;\":\"‘\",\"operp;\":\"⦹\",\"oplus;\":\"⊕\",\"Or;\":\"⩔\",\"or;\":\"∨\",\"orarr;\":\"↻\",\"ord;\":\"⩝\",\"order;\":\"ℴ\",\"orderof;\":\"ℴ\",\"ordf;\":\"ª\",\"ordf\":\"ª\",\"ordm;\":\"º\",\"ordm\":\"º\",\"origof;\":\"⊶\",\"oror;\":\"⩖\",\"orslope;\":\"⩗\",\"orv;\":\"⩛\",\"oS;\":\"Ⓢ\",\"Oscr;\":\"𝒪\",\"oscr;\":\"ℴ\",\"Oslash;\":\"Ø\",\"Oslash\":\"Ø\",\"oslash;\":\"ø\",\"oslash\":\"ø\",\"osol;\":\"⊘\",\"Otilde;\":\"Õ\",\"Otilde\":\"Õ\",\"otilde;\":\"õ\",\"otilde\":\"õ\",\"Otimes;\":\"⨷\",\"otimes;\":\"⊗\",\"otimesas;\":\"⨶\",\"Ouml;\":\"Ö\",\"Ouml\":\"Ö\",\"ouml;\":\"ö\",\"ouml\":\"ö\",\"ovbar;\":\"⌽\",\"OverBar;\":\"‾\",\"OverBrace;\":\"⏞\",\"OverBracket;\":\"⎴\",\"OverParenthesis;\":\"⏜\",\"par;\":\"∥\",\"para;\":\"¶\",\"para\":\"¶\",\"parallel;\":\"∥\",\"parsim;\":\"⫳\",\"parsl;\":\"⫽\",\"part;\":\"∂\",\"PartialD;\":\"∂\",\"Pcy;\":\"П\",\"pcy;\":\"п\",\"percnt;\":\"%\",\"period;\":\".\",\"permil;\":\"‰\",\"perp;\":\"⊥\",\"pertenk;\":\"‱\",\"Pfr;\":\"𝔓\",\"pfr;\":\"𝔭\",\"Phi;\":\"Φ\",\"phi;\":\"φ\",\"phiv;\":\"ϕ\",\"phmmat;\":\"ℳ\",\"phone;\":\"☎\",\"Pi;\":\"Π\",\"pi;\":\"π\",\"pitchfork;\":\"⋔\",\"piv;\":\"ϖ\",\"planck;\":\"ℏ\",\"planckh;\":\"ℎ\",\"plankv;\":\"ℏ\",\"plus;\":\"+\",\"plusacir;\":\"⨣\",\"plusb;\":\"⊞\",\"pluscir;\":\"⨢\",\"plusdo;\":\"∔\",\"plusdu;\":\"⨥\",\"pluse;\":\"⩲\",\"PlusMinus;\":\"±\",\"plusmn;\":\"±\",\"plusmn\":\"±\",\"plussim;\":\"⨦\",\"plustwo;\":\"⨧\",\"pm;\":\"±\",\"Poincareplane;\":\"ℌ\",\"pointint;\":\"⨕\",\"Popf;\":\"ℙ\",\"popf;\":\"𝕡\",\"pound;\":\"£\",\"pound\":\"£\",\"Pr;\":\"⪻\",\"pr;\":\"≺\",\"prap;\":\"⪷\",\"prcue;\":\"≼\",\"prE;\":\"⪳\",\"pre;\":\"⪯\",\"prec;\":\"≺\",\"precapprox;\":\"⪷\",\"preccurlyeq;\":\"≼\",\"Precedes;\":\"≺\",\"PrecedesEqual;\":\"⪯\",\"PrecedesSlantEqual;\":\"≼\",\"PrecedesTilde;\":\"≾\",\"preceq;\":\"⪯\",\"precnapprox;\":\"⪹\",\"precneqq;\":\"⪵\",\"precnsim;\":\"⋨\",\"precsim;\":\"≾\",\"Prime;\":\"″\",\"prime;\":\"′\",\"primes;\":\"ℙ\",\"prnap;\":\"⪹\",\"prnE;\":\"⪵\",\"prnsim;\":\"⋨\",\"prod;\":\"∏\",\"Product;\":\"∏\",\"profalar;\":\"⌮\",\"profline;\":\"⌒\",\"profsurf;\":\"⌓\",\"prop;\":\"∝\",\"Proportion;\":\"∷\",\"Proportional;\":\"∝\",\"propto;\":\"∝\",\"prsim;\":\"≾\",\"prurel;\":\"⊰\",\"Pscr;\":\"𝒫\",\"pscr;\":\"𝓅\",\"Psi;\":\"Ψ\",\"psi;\":\"ψ\",\"puncsp;\":\" \",\"Qfr;\":\"𝔔\",\"qfr;\":\"𝔮\",\"qint;\":\"⨌\",\"Qopf;\":\"ℚ\",\"qopf;\":\"𝕢\",\"qprime;\":\"⁗\",\"Qscr;\":\"𝒬\",\"qscr;\":\"𝓆\",\"quaternions;\":\"ℍ\",\"quatint;\":\"⨖\",\"quest;\":\"?\",\"questeq;\":\"≟\",\"QUOT;\":\"\\\\\"\",\"QUOT\":\"\\\\\"\",\"quot;\":\"\\\\\"\",\"quot\":\"\\\\\"\",\"rAarr;\":\"⇛\",\"race;\":\"∽̱\",\"Racute;\":\"Ŕ\",\"racute;\":\"ŕ\",\"radic;\":\"√\",\"raemptyv;\":\"⦳\",\"Rang;\":\"⟫\",\"rang;\":\"⟩\",\"rangd;\":\"⦒\",\"range;\":\"⦥\",\"rangle;\":\"⟩\",\"raquo;\":\"»\",\"raquo\":\"»\",\"Rarr;\":\"↠\",\"rArr;\":\"⇒\",\"rarr;\":\"→\",\"rarrap;\":\"⥵\",\"rarrb;\":\"⇥\",\"rarrbfs;\":\"⤠\",\"rarrc;\":\"⤳\",\"rarrfs;\":\"⤞\",\"rarrhk;\":\"↪\",\"rarrlp;\":\"↬\",\"rarrpl;\":\"⥅\",\"rarrsim;\":\"⥴\",\"Rarrtl;\":\"⤖\",\"rarrtl;\":\"↣\",\"rarrw;\":\"↝\",\"rAtail;\":\"⤜\",\"ratail;\":\"⤚\",\"ratio;\":\"∶\",\"rationals;\":\"ℚ\",\"RBarr;\":\"⤐\",\"rBarr;\":\"⤏\",\"rbarr;\":\"⤍\",\"rbbrk;\":\"❳\",\"rbrace;\":\"}\",\"rbrack;\":\"]\",\"rbrke;\":\"⦌\",\"rbrksld;\":\"⦎\",\"rbrkslu;\":\"⦐\",\"Rcaron;\":\"Ř\",\"rcaron;\":\"ř\",\"Rcedil;\":\"Ŗ\",\"rcedil;\":\"ŗ\",\"rceil;\":\"⌉\",\"rcub;\":\"}\",\"Rcy;\":\"Р\",\"rcy;\":\"р\",\"rdca;\":\"⤷\",\"rdldhar;\":\"⥩\",\"rdquo;\":\"”\",\"rdquor;\":\"”\",\"rdsh;\":\"↳\",\"Re;\":\"ℜ\",\"real;\":\"ℜ\",\"realine;\":\"ℛ\",\"realpart;\":\"ℜ\",\"reals;\":\"ℝ\",\"rect;\":\"▭\",\"REG;\":\"®\",\"REG\":\"®\",\"reg;\":\"®\",\"reg\":\"®\",\"ReverseElement;\":\"∋\",\"ReverseEquilibrium;\":\"⇋\",\"ReverseUpEquilibrium;\":\"⥯\",\"rfisht;\":\"⥽\",\"rfloor;\":\"⌋\",\"Rfr;\":\"ℜ\",\"rfr;\":\"𝔯\",\"rHar;\":\"⥤\",\"rhard;\":\"⇁\",\"rharu;\":\"⇀\",\"rharul;\":\"⥬\",\"Rho;\":\"Ρ\",\"rho;\":\"ρ\",\"rhov;\":\"ϱ\",\"RightAngleBracket;\":\"⟩\",\"RightArrow;\":\"→\",\"Rightarrow;\":\"⇒\",\"rightarrow;\":\"→\",\"RightArrowBar;\":\"⇥\",\"RightArrowLeftArrow;\":\"⇄\",\"rightarrowtail;\":\"↣\",\"RightCeiling;\":\"⌉\",\"RightDoubleBracket;\":\"⟧\",\"RightDownTeeVector;\":\"⥝\",\"RightDownVector;\":\"⇂\",\"RightDownVectorBar;\":\"⥕\",\"RightFloor;\":\"⌋\",\"rightharpoondown;\":\"⇁\",\"rightharpoonup;\":\"⇀\",\"rightleftarrows;\":\"⇄\",\"rightleftharpoons;\":\"⇌\",\"rightrightarrows;\":\"⇉\",\"rightsquigarrow;\":\"↝\",\"RightTee;\":\"⊢\",\"RightTeeArrow;\":\"↦\",\"RightTeeVector;\":\"⥛\",\"rightthreetimes;\":\"⋌\",\"RightTriangle;\":\"⊳\",\"RightTriangleBar;\":\"⧐\",\"RightTriangleEqual;\":\"⊵\",\"RightUpDownVector;\":\"⥏\",\"RightUpTeeVector;\":\"⥜\",\"RightUpVector;\":\"↾\",\"RightUpVectorBar;\":\"⥔\",\"RightVector;\":\"⇀\",\"RightVectorBar;\":\"⥓\",\"ring;\":\"˚\",\"risingdotseq;\":\"≓\",\"rlarr;\":\"⇄\",\"rlhar;\":\"⇌\",\"rlm;\":\"‏\",\"rmoust;\":\"⎱\",\"rmoustache;\":\"⎱\",\"rnmid;\":\"⫮\",\"roang;\":\"⟭\",\"roarr;\":\"⇾\",\"robrk;\":\"⟧\",\"ropar;\":\"⦆\",\"Ropf;\":\"ℝ\",\"ropf;\":\"𝕣\",\"roplus;\":\"⨮\",\"rotimes;\":\"⨵\",\"RoundImplies;\":\"⥰\",\"rpar;\":\")\",\"rpargt;\":\"⦔\",\"rppolint;\":\"⨒\",\"rrarr;\":\"⇉\",\"Rrightarrow;\":\"⇛\",\"rsaquo;\":\"›\",\"Rscr;\":\"ℛ\",\"rscr;\":\"𝓇\",\"Rsh;\":\"↱\",\"rsh;\":\"↱\",\"rsqb;\":\"]\",\"rsquo;\":\"’\",\"rsquor;\":\"’\",\"rthree;\":\"⋌\",\"rtimes;\":\"⋊\",\"rtri;\":\"▹\",\"rtrie;\":\"⊵\",\"rtrif;\":\"▸\",\"rtriltri;\":\"⧎\",\"RuleDelayed;\":\"⧴\",\"ruluhar;\":\"⥨\",\"rx;\":\"℞\",\"Sacute;\":\"Ś\",\"sacute;\":\"ś\",\"sbquo;\":\"‚\",\"Sc;\":\"⪼\",\"sc;\":\"≻\",\"scap;\":\"⪸\",\"Scaron;\":\"Š\",\"scaron;\":\"š\",\"sccue;\":\"≽\",\"scE;\":\"⪴\",\"sce;\":\"⪰\",\"Scedil;\":\"Ş\",\"scedil;\":\"ş\",\"Scirc;\":\"Ŝ\",\"scirc;\":\"ŝ\",\"scnap;\":\"⪺\",\"scnE;\":\"⪶\",\"scnsim;\":\"⋩\",\"scpolint;\":\"⨓\",\"scsim;\":\"≿\",\"Scy;\":\"С\",\"scy;\":\"с\",\"sdot;\":\"⋅\",\"sdotb;\":\"⊡\",\"sdote;\":\"⩦\",\"searhk;\":\"⤥\",\"seArr;\":\"⇘\",\"searr;\":\"↘\",\"searrow;\":\"↘\",\"sect;\":\"§\",\"sect\":\"§\",\"semi;\":\";\",\"seswar;\":\"⤩\",\"setminus;\":\"∖\",\"setmn;\":\"∖\",\"sext;\":\"✶\",\"Sfr;\":\"𝔖\",\"sfr;\":\"𝔰\",\"sfrown;\":\"⌢\",\"sharp;\":\"♯\",\"SHCHcy;\":\"Щ\",\"shchcy;\":\"щ\",\"SHcy;\":\"Ш\",\"shcy;\":\"ш\",\"ShortDownArrow;\":\"↓\",\"ShortLeftArrow;\":\"←\",\"shortmid;\":\"∣\",\"shortparallel;\":\"∥\",\"ShortRightArrow;\":\"→\",\"ShortUpArrow;\":\"↑\",\"shy;\":\"­\",\"shy\":\"­\",\"Sigma;\":\"Σ\",\"sigma;\":\"σ\",\"sigmaf;\":\"ς\",\"sigmav;\":\"ς\",\"sim;\":\"∼\",\"simdot;\":\"⩪\",\"sime;\":\"≃\",\"simeq;\":\"≃\",\"simg;\":\"⪞\",\"simgE;\":\"⪠\",\"siml;\":\"⪝\",\"simlE;\":\"⪟\",\"simne;\":\"≆\",\"simplus;\":\"⨤\",\"simrarr;\":\"⥲\",\"slarr;\":\"←\",\"SmallCircle;\":\"∘\",\"smallsetminus;\":\"∖\",\"smashp;\":\"⨳\",\"smeparsl;\":\"⧤\",\"smid;\":\"∣\",\"smile;\":\"⌣\",\"smt;\":\"⪪\",\"smte;\":\"⪬\",\"smtes;\":\"⪬︀\",\"SOFTcy;\":\"Ь\",\"softcy;\":\"ь\",\"sol;\":\"/\",\"solb;\":\"⧄\",\"solbar;\":\"⌿\",\"Sopf;\":\"𝕊\",\"sopf;\":\"𝕤\",\"spades;\":\"♠\",\"spadesuit;\":\"♠\",\"spar;\":\"∥\",\"sqcap;\":\"⊓\",\"sqcaps;\":\"⊓︀\",\"sqcup;\":\"⊔\",\"sqcups;\":\"⊔︀\",\"Sqrt;\":\"√\",\"sqsub;\":\"⊏\",\"sqsube;\":\"⊑\",\"sqsubset;\":\"⊏\",\"sqsubseteq;\":\"⊑\",\"sqsup;\":\"⊐\",\"sqsupe;\":\"⊒\",\"sqsupset;\":\"⊐\",\"sqsupseteq;\":\"⊒\",\"squ;\":\"□\",\"Square;\":\"□\",\"square;\":\"□\",\"SquareIntersection;\":\"⊓\",\"SquareSubset;\":\"⊏\",\"SquareSubsetEqual;\":\"⊑\",\"SquareSuperset;\":\"⊐\",\"SquareSupersetEqual;\":\"⊒\",\"SquareUnion;\":\"⊔\",\"squarf;\":\"▪\",\"squf;\":\"▪\",\"srarr;\":\"→\",\"Sscr;\":\"𝒮\",\"sscr;\":\"𝓈\",\"ssetmn;\":\"∖\",\"ssmile;\":\"⌣\",\"sstarf;\":\"⋆\",\"Star;\":\"⋆\",\"star;\":\"☆\",\"starf;\":\"★\",\"straightepsilon;\":\"ϵ\",\"straightphi;\":\"ϕ\",\"strns;\":\"¯\",\"Sub;\":\"⋐\",\"sub;\":\"⊂\",\"subdot;\":\"⪽\",\"subE;\":\"⫅\",\"sube;\":\"⊆\",\"subedot;\":\"⫃\",\"submult;\":\"⫁\",\"subnE;\":\"⫋\",\"subne;\":\"⊊\",\"subplus;\":\"⪿\",\"subrarr;\":\"⥹\",\"Subset;\":\"⋐\",\"subset;\":\"⊂\",\"subseteq;\":\"⊆\",\"subseteqq;\":\"⫅\",\"SubsetEqual;\":\"⊆\",\"subsetneq;\":\"⊊\",\"subsetneqq;\":\"⫋\",\"subsim;\":\"⫇\",\"subsub;\":\"⫕\",\"subsup;\":\"⫓\",\"succ;\":\"≻\",\"succapprox;\":\"⪸\",\"succcurlyeq;\":\"≽\",\"Succeeds;\":\"≻\",\"SucceedsEqual;\":\"⪰\",\"SucceedsSlantEqual;\":\"≽\",\"SucceedsTilde;\":\"≿\",\"succeq;\":\"⪰\",\"succnapprox;\":\"⪺\",\"succneqq;\":\"⪶\",\"succnsim;\":\"⋩\",\"succsim;\":\"≿\",\"SuchThat;\":\"∋\",\"Sum;\":\"∑\",\"sum;\":\"∑\",\"sung;\":\"♪\",\"Sup;\":\"⋑\",\"sup;\":\"⊃\",\"sup1;\":\"¹\",\"sup1\":\"¹\",\"sup2;\":\"²\",\"sup2\":\"²\",\"sup3;\":\"³\",\"sup3\":\"³\",\"supdot;\":\"⪾\",\"supdsub;\":\"⫘\",\"supE;\":\"⫆\",\"supe;\":\"⊇\",\"supedot;\":\"⫄\",\"Superset;\":\"⊃\",\"SupersetEqual;\":\"⊇\",\"suphsol;\":\"⟉\",\"suphsub;\":\"⫗\",\"suplarr;\":\"⥻\",\"supmult;\":\"⫂\",\"supnE;\":\"⫌\",\"supne;\":\"⊋\",\"supplus;\":\"⫀\",\"Supset;\":\"⋑\",\"supset;\":\"⊃\",\"supseteq;\":\"⊇\",\"supseteqq;\":\"⫆\",\"supsetneq;\":\"⊋\",\"supsetneqq;\":\"⫌\",\"supsim;\":\"⫈\",\"supsub;\":\"⫔\",\"supsup;\":\"⫖\",\"swarhk;\":\"⤦\",\"swArr;\":\"⇙\",\"swarr;\":\"↙\",\"swarrow;\":\"↙\",\"swnwar;\":\"⤪\",\"szlig;\":\"ß\",\"szlig\":\"ß\",\"Tab;\":\"\\\\t\",\"target;\":\"⌖\",\"Tau;\":\"Τ\",\"tau;\":\"τ\",\"tbrk;\":\"⎴\",\"Tcaron;\":\"Ť\",\"tcaron;\":\"ť\",\"Tcedil;\":\"Ţ\",\"tcedil;\":\"ţ\",\"Tcy;\":\"Т\",\"tcy;\":\"т\",\"tdot;\":\"⃛\",\"telrec;\":\"⌕\",\"Tfr;\":\"𝔗\",\"tfr;\":\"𝔱\",\"there4;\":\"∴\",\"Therefore;\":\"∴\",\"therefore;\":\"∴\",\"Theta;\":\"Θ\",\"theta;\":\"θ\",\"thetasym;\":\"ϑ\",\"thetav;\":\"ϑ\",\"thickapprox;\":\"≈\",\"thicksim;\":\"∼\",\"ThickSpace;\":\"  \",\"thinsp;\":\" \",\"ThinSpace;\":\" \",\"thkap;\":\"≈\",\"thksim;\":\"∼\",\"THORN;\":\"Þ\",\"THORN\":\"Þ\",\"thorn;\":\"þ\",\"thorn\":\"þ\",\"Tilde;\":\"∼\",\"tilde;\":\"˜\",\"TildeEqual;\":\"≃\",\"TildeFullEqual;\":\"≅\",\"TildeTilde;\":\"≈\",\"times;\":\"×\",\"times\":\"×\",\"timesb;\":\"⊠\",\"timesbar;\":\"⨱\",\"timesd;\":\"⨰\",\"tint;\":\"∭\",\"toea;\":\"⤨\",\"top;\":\"⊤\",\"topbot;\":\"⌶\",\"topcir;\":\"⫱\",\"Topf;\":\"𝕋\",\"topf;\":\"𝕥\",\"topfork;\":\"⫚\",\"tosa;\":\"⤩\",\"tprime;\":\"‴\",\"TRADE;\":\"™\",\"trade;\":\"™\",\"triangle;\":\"▵\",\"triangledown;\":\"▿\",\"triangleleft;\":\"◃\",\"trianglelefteq;\":\"⊴\",\"triangleq;\":\"≜\",\"triangleright;\":\"▹\",\"trianglerighteq;\":\"⊵\",\"tridot;\":\"◬\",\"trie;\":\"≜\",\"triminus;\":\"⨺\",\"TripleDot;\":\"⃛\",\"triplus;\":\"⨹\",\"trisb;\":\"⧍\",\"tritime;\":\"⨻\",\"trpezium;\":\"⏢\",\"Tscr;\":\"𝒯\",\"tscr;\":\"𝓉\",\"TScy;\":\"Ц\",\"tscy;\":\"ц\",\"TSHcy;\":\"Ћ\",\"tshcy;\":\"ћ\",\"Tstrok;\":\"Ŧ\",\"tstrok;\":\"ŧ\",\"twixt;\":\"≬\",\"twoheadleftarrow;\":\"↞\",\"twoheadrightarrow;\":\"↠\",\"Uacute;\":\"Ú\",\"Uacute\":\"Ú\",\"uacute;\":\"ú\",\"uacute\":\"ú\",\"Uarr;\":\"↟\",\"uArr;\":\"⇑\",\"uarr;\":\"↑\",\"Uarrocir;\":\"⥉\",\"Ubrcy;\":\"Ў\",\"ubrcy;\":\"ў\",\"Ubreve;\":\"Ŭ\",\"ubreve;\":\"ŭ\",\"Ucirc;\":\"Û\",\"Ucirc\":\"Û\",\"ucirc;\":\"û\",\"ucirc\":\"û\",\"Ucy;\":\"У\",\"ucy;\":\"у\",\"udarr;\":\"⇅\",\"Udblac;\":\"Ű\",\"udblac;\":\"ű\",\"udhar;\":\"⥮\",\"ufisht;\":\"⥾\",\"Ufr;\":\"𝔘\",\"ufr;\":\"𝔲\",\"Ugrave;\":\"Ù\",\"Ugrave\":\"Ù\",\"ugrave;\":\"ù\",\"ugrave\":\"ù\",\"uHar;\":\"⥣\",\"uharl;\":\"↿\",\"uharr;\":\"↾\",\"uhblk;\":\"▀\",\"ulcorn;\":\"⌜\",\"ulcorner;\":\"⌜\",\"ulcrop;\":\"⌏\",\"ultri;\":\"◸\",\"Umacr;\":\"Ū\",\"umacr;\":\"ū\",\"uml;\":\"¨\",\"uml\":\"¨\",\"UnderBar;\":\"_\",\"UnderBrace;\":\"⏟\",\"UnderBracket;\":\"⎵\",\"UnderParenthesis;\":\"⏝\",\"Union;\":\"⋃\",\"UnionPlus;\":\"⊎\",\"Uogon;\":\"Ų\",\"uogon;\":\"ų\",\"Uopf;\":\"𝕌\",\"uopf;\":\"𝕦\",\"UpArrow;\":\"↑\",\"Uparrow;\":\"⇑\",\"uparrow;\":\"↑\",\"UpArrowBar;\":\"⤒\",\"UpArrowDownArrow;\":\"⇅\",\"UpDownArrow;\":\"↕\",\"Updownarrow;\":\"⇕\",\"updownarrow;\":\"↕\",\"UpEquilibrium;\":\"⥮\",\"upharpoonleft;\":\"↿\",\"upharpoonright;\":\"↾\",\"uplus;\":\"⊎\",\"UpperLeftArrow;\":\"↖\",\"UpperRightArrow;\":\"↗\",\"Upsi;\":\"ϒ\",\"upsi;\":\"υ\",\"upsih;\":\"ϒ\",\"Upsilon;\":\"Υ\",\"upsilon;\":\"υ\",\"UpTee;\":\"⊥\",\"UpTeeArrow;\":\"↥\",\"upuparrows;\":\"⇈\",\"urcorn;\":\"⌝\",\"urcorner;\":\"⌝\",\"urcrop;\":\"⌎\",\"Uring;\":\"Ů\",\"uring;\":\"ů\",\"urtri;\":\"◹\",\"Uscr;\":\"𝒰\",\"uscr;\":\"𝓊\",\"utdot;\":\"⋰\",\"Utilde;\":\"Ũ\",\"utilde;\":\"ũ\",\"utri;\":\"▵\",\"utrif;\":\"▴\",\"uuarr;\":\"⇈\",\"Uuml;\":\"Ü\",\"Uuml\":\"Ü\",\"uuml;\":\"ü\",\"uuml\":\"ü\",\"uwangle;\":\"⦧\",\"vangrt;\":\"⦜\",\"varepsilon;\":\"ϵ\",\"varkappa;\":\"ϰ\",\"varnothing;\":\"∅\",\"varphi;\":\"ϕ\",\"varpi;\":\"ϖ\",\"varpropto;\":\"∝\",\"vArr;\":\"⇕\",\"varr;\":\"↕\",\"varrho;\":\"ϱ\",\"varsigma;\":\"ς\",\"varsubsetneq;\":\"⊊︀\",\"varsubsetneqq;\":\"⫋︀\",\"varsupsetneq;\":\"⊋︀\",\"varsupsetneqq;\":\"⫌︀\",\"vartheta;\":\"ϑ\",\"vartriangleleft;\":\"⊲\",\"vartriangleright;\":\"⊳\",\"Vbar;\":\"⫫\",\"vBar;\":\"⫨\",\"vBarv;\":\"⫩\",\"Vcy;\":\"В\",\"vcy;\":\"в\",\"VDash;\":\"⊫\",\"Vdash;\":\"⊩\",\"vDash;\":\"⊨\",\"vdash;\":\"⊢\",\"Vdashl;\":\"⫦\",\"Vee;\":\"⋁\",\"vee;\":\"∨\",\"veebar;\":\"⊻\",\"veeeq;\":\"≚\",\"vellip;\":\"⋮\",\"Verbar;\":\"‖\",\"verbar;\":\"|\",\"Vert;\":\"‖\",\"vert;\":\"|\",\"VerticalBar;\":\"∣\",\"VerticalLine;\":\"|\",\"VerticalSeparator;\":\"❘\",\"VerticalTilde;\":\"≀\",\"VeryThinSpace;\":\" \",\"Vfr;\":\"𝔙\",\"vfr;\":\"𝔳\",\"vltri;\":\"⊲\",\"vnsub;\":\"⊂⃒\",\"vnsup;\":\"⊃⃒\",\"Vopf;\":\"𝕍\",\"vopf;\":\"𝕧\",\"vprop;\":\"∝\",\"vrtri;\":\"⊳\",\"Vscr;\":\"𝒱\",\"vscr;\":\"𝓋\",\"vsubnE;\":\"⫋︀\",\"vsubne;\":\"⊊︀\",\"vsupnE;\":\"⫌︀\",\"vsupne;\":\"⊋︀\",\"Vvdash;\":\"⊪\",\"vzigzag;\":\"⦚\",\"Wcirc;\":\"Ŵ\",\"wcirc;\":\"ŵ\",\"wedbar;\":\"⩟\",\"Wedge;\":\"⋀\",\"wedge;\":\"∧\",\"wedgeq;\":\"≙\",\"weierp;\":\"℘\",\"Wfr;\":\"𝔚\",\"wfr;\":\"𝔴\",\"Wopf;\":\"𝕎\",\"wopf;\":\"𝕨\",\"wp;\":\"℘\",\"wr;\":\"≀\",\"wreath;\":\"≀\",\"Wscr;\":\"𝒲\",\"wscr;\":\"𝓌\",\"xcap;\":\"⋂\",\"xcirc;\":\"◯\",\"xcup;\":\"⋃\",\"xdtri;\":\"▽\",\"Xfr;\":\"𝔛\",\"xfr;\":\"𝔵\",\"xhArr;\":\"⟺\",\"xharr;\":\"⟷\",\"Xi;\":\"Ξ\",\"xi;\":\"ξ\",\"xlArr;\":\"⟸\",\"xlarr;\":\"⟵\",\"xmap;\":\"⟼\",\"xnis;\":\"⋻\",\"xodot;\":\"⨀\",\"Xopf;\":\"𝕏\",\"xopf;\":\"𝕩\",\"xoplus;\":\"⨁\",\"xotime;\":\"⨂\",\"xrArr;\":\"⟹\",\"xrarr;\":\"⟶\",\"Xscr;\":\"𝒳\",\"xscr;\":\"𝓍\",\"xsqcup;\":\"⨆\",\"xuplus;\":\"⨄\",\"xutri;\":\"△\",\"xvee;\":\"⋁\",\"xwedge;\":\"⋀\",\"Yacute;\":\"Ý\",\"Yacute\":\"Ý\",\"yacute;\":\"ý\",\"yacute\":\"ý\",\"YAcy;\":\"Я\",\"yacy;\":\"я\",\"Ycirc;\":\"Ŷ\",\"ycirc;\":\"ŷ\",\"Ycy;\":\"Ы\",\"ycy;\":\"ы\",\"yen;\":\"¥\",\"yen\":\"¥\",\"Yfr;\":\"𝔜\",\"yfr;\":\"𝔶\",\"YIcy;\":\"Ї\",\"yicy;\":\"ї\",\"Yopf;\":\"𝕐\",\"yopf;\":\"𝕪\",\"Yscr;\":\"𝒴\",\"yscr;\":\"𝓎\",\"YUcy;\":\"Ю\",\"yucy;\":\"ю\",\"Yuml;\":\"Ÿ\",\"yuml;\":\"ÿ\",\"yuml\":\"ÿ\",\"Zacute;\":\"Ź\",\"zacute;\":\"ź\",\"Zcaron;\":\"Ž\",\"zcaron;\":\"ž\",\"Zcy;\":\"З\",\"zcy;\":\"з\",\"Zdot;\":\"Ż\",\"zdot;\":\"ż\",\"zeetrf;\":\"ℨ\",\"ZeroWidthSpace;\":\"​\",\"Zeta;\":\"Ζ\",\"zeta;\":\"ζ\",\"Zfr;\":\"ℨ\",\"zfr;\":\"𝔷\",\"ZHcy;\":\"Ж\",\"zhcy;\":\"ж\",\"zigrarr;\":\"⇝\",\"Zopf;\":\"ℤ\",\"zopf;\":\"𝕫\",\"Zscr;\":\"𝒵\",\"zscr;\":\"𝓏\",\"zwj;\":\"‍\",\"zwnj;\":\"‌\"}');\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/ent/entities.json?");

/***/ }),

/***/ "./src/node_modules/ent/index.js":
/*!***************************************!*\
  !*** ./src/node_modules/ent/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("exports.encode = __webpack_require__(/*! ./encode */ \"./src/node_modules/ent/encode.js\");\nexports.decode = __webpack_require__(/*! ./decode */ \"./src/node_modules/ent/decode.js\");\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/ent/index.js?");

/***/ }),

/***/ "./src/node_modules/ent/reversed.json":
/*!********************************************!*\
  !*** ./src/node_modules/ent/reversed.json ***!
  \********************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"9\":\"Tab;\",\"10\":\"NewLine;\",\"33\":\"excl;\",\"34\":\"quot;\",\"35\":\"num;\",\"36\":\"dollar;\",\"37\":\"percnt;\",\"38\":\"amp;\",\"39\":\"apos;\",\"40\":\"lpar;\",\"41\":\"rpar;\",\"42\":\"midast;\",\"43\":\"plus;\",\"44\":\"comma;\",\"46\":\"period;\",\"47\":\"sol;\",\"58\":\"colon;\",\"59\":\"semi;\",\"60\":\"lt;\",\"61\":\"equals;\",\"62\":\"gt;\",\"63\":\"quest;\",\"64\":\"commat;\",\"91\":\"lsqb;\",\"92\":\"bsol;\",\"93\":\"rsqb;\",\"94\":\"Hat;\",\"95\":\"UnderBar;\",\"96\":\"grave;\",\"123\":\"lcub;\",\"124\":\"VerticalLine;\",\"125\":\"rcub;\",\"160\":\"NonBreakingSpace;\",\"161\":\"iexcl;\",\"162\":\"cent;\",\"163\":\"pound;\",\"164\":\"curren;\",\"165\":\"yen;\",\"166\":\"brvbar;\",\"167\":\"sect;\",\"168\":\"uml;\",\"169\":\"copy;\",\"170\":\"ordf;\",\"171\":\"laquo;\",\"172\":\"not;\",\"173\":\"shy;\",\"174\":\"reg;\",\"175\":\"strns;\",\"176\":\"deg;\",\"177\":\"pm;\",\"178\":\"sup2;\",\"179\":\"sup3;\",\"180\":\"DiacriticalAcute;\",\"181\":\"micro;\",\"182\":\"para;\",\"183\":\"middot;\",\"184\":\"Cedilla;\",\"185\":\"sup1;\",\"186\":\"ordm;\",\"187\":\"raquo;\",\"188\":\"frac14;\",\"189\":\"half;\",\"190\":\"frac34;\",\"191\":\"iquest;\",\"192\":\"Agrave;\",\"193\":\"Aacute;\",\"194\":\"Acirc;\",\"195\":\"Atilde;\",\"196\":\"Auml;\",\"197\":\"Aring;\",\"198\":\"AElig;\",\"199\":\"Ccedil;\",\"200\":\"Egrave;\",\"201\":\"Eacute;\",\"202\":\"Ecirc;\",\"203\":\"Euml;\",\"204\":\"Igrave;\",\"205\":\"Iacute;\",\"206\":\"Icirc;\",\"207\":\"Iuml;\",\"208\":\"ETH;\",\"209\":\"Ntilde;\",\"210\":\"Ograve;\",\"211\":\"Oacute;\",\"212\":\"Ocirc;\",\"213\":\"Otilde;\",\"214\":\"Ouml;\",\"215\":\"times;\",\"216\":\"Oslash;\",\"217\":\"Ugrave;\",\"218\":\"Uacute;\",\"219\":\"Ucirc;\",\"220\":\"Uuml;\",\"221\":\"Yacute;\",\"222\":\"THORN;\",\"223\":\"szlig;\",\"224\":\"agrave;\",\"225\":\"aacute;\",\"226\":\"acirc;\",\"227\":\"atilde;\",\"228\":\"auml;\",\"229\":\"aring;\",\"230\":\"aelig;\",\"231\":\"ccedil;\",\"232\":\"egrave;\",\"233\":\"eacute;\",\"234\":\"ecirc;\",\"235\":\"euml;\",\"236\":\"igrave;\",\"237\":\"iacute;\",\"238\":\"icirc;\",\"239\":\"iuml;\",\"240\":\"eth;\",\"241\":\"ntilde;\",\"242\":\"ograve;\",\"243\":\"oacute;\",\"244\":\"ocirc;\",\"245\":\"otilde;\",\"246\":\"ouml;\",\"247\":\"divide;\",\"248\":\"oslash;\",\"249\":\"ugrave;\",\"250\":\"uacute;\",\"251\":\"ucirc;\",\"252\":\"uuml;\",\"253\":\"yacute;\",\"254\":\"thorn;\",\"255\":\"yuml;\",\"256\":\"Amacr;\",\"257\":\"amacr;\",\"258\":\"Abreve;\",\"259\":\"abreve;\",\"260\":\"Aogon;\",\"261\":\"aogon;\",\"262\":\"Cacute;\",\"263\":\"cacute;\",\"264\":\"Ccirc;\",\"265\":\"ccirc;\",\"266\":\"Cdot;\",\"267\":\"cdot;\",\"268\":\"Ccaron;\",\"269\":\"ccaron;\",\"270\":\"Dcaron;\",\"271\":\"dcaron;\",\"272\":\"Dstrok;\",\"273\":\"dstrok;\",\"274\":\"Emacr;\",\"275\":\"emacr;\",\"278\":\"Edot;\",\"279\":\"edot;\",\"280\":\"Eogon;\",\"281\":\"eogon;\",\"282\":\"Ecaron;\",\"283\":\"ecaron;\",\"284\":\"Gcirc;\",\"285\":\"gcirc;\",\"286\":\"Gbreve;\",\"287\":\"gbreve;\",\"288\":\"Gdot;\",\"289\":\"gdot;\",\"290\":\"Gcedil;\",\"292\":\"Hcirc;\",\"293\":\"hcirc;\",\"294\":\"Hstrok;\",\"295\":\"hstrok;\",\"296\":\"Itilde;\",\"297\":\"itilde;\",\"298\":\"Imacr;\",\"299\":\"imacr;\",\"302\":\"Iogon;\",\"303\":\"iogon;\",\"304\":\"Idot;\",\"305\":\"inodot;\",\"306\":\"IJlig;\",\"307\":\"ijlig;\",\"308\":\"Jcirc;\",\"309\":\"jcirc;\",\"310\":\"Kcedil;\",\"311\":\"kcedil;\",\"312\":\"kgreen;\",\"313\":\"Lacute;\",\"314\":\"lacute;\",\"315\":\"Lcedil;\",\"316\":\"lcedil;\",\"317\":\"Lcaron;\",\"318\":\"lcaron;\",\"319\":\"Lmidot;\",\"320\":\"lmidot;\",\"321\":\"Lstrok;\",\"322\":\"lstrok;\",\"323\":\"Nacute;\",\"324\":\"nacute;\",\"325\":\"Ncedil;\",\"326\":\"ncedil;\",\"327\":\"Ncaron;\",\"328\":\"ncaron;\",\"329\":\"napos;\",\"330\":\"ENG;\",\"331\":\"eng;\",\"332\":\"Omacr;\",\"333\":\"omacr;\",\"336\":\"Odblac;\",\"337\":\"odblac;\",\"338\":\"OElig;\",\"339\":\"oelig;\",\"340\":\"Racute;\",\"341\":\"racute;\",\"342\":\"Rcedil;\",\"343\":\"rcedil;\",\"344\":\"Rcaron;\",\"345\":\"rcaron;\",\"346\":\"Sacute;\",\"347\":\"sacute;\",\"348\":\"Scirc;\",\"349\":\"scirc;\",\"350\":\"Scedil;\",\"351\":\"scedil;\",\"352\":\"Scaron;\",\"353\":\"scaron;\",\"354\":\"Tcedil;\",\"355\":\"tcedil;\",\"356\":\"Tcaron;\",\"357\":\"tcaron;\",\"358\":\"Tstrok;\",\"359\":\"tstrok;\",\"360\":\"Utilde;\",\"361\":\"utilde;\",\"362\":\"Umacr;\",\"363\":\"umacr;\",\"364\":\"Ubreve;\",\"365\":\"ubreve;\",\"366\":\"Uring;\",\"367\":\"uring;\",\"368\":\"Udblac;\",\"369\":\"udblac;\",\"370\":\"Uogon;\",\"371\":\"uogon;\",\"372\":\"Wcirc;\",\"373\":\"wcirc;\",\"374\":\"Ycirc;\",\"375\":\"ycirc;\",\"376\":\"Yuml;\",\"377\":\"Zacute;\",\"378\":\"zacute;\",\"379\":\"Zdot;\",\"380\":\"zdot;\",\"381\":\"Zcaron;\",\"382\":\"zcaron;\",\"402\":\"fnof;\",\"437\":\"imped;\",\"501\":\"gacute;\",\"567\":\"jmath;\",\"710\":\"circ;\",\"711\":\"Hacek;\",\"728\":\"breve;\",\"729\":\"dot;\",\"730\":\"ring;\",\"731\":\"ogon;\",\"732\":\"tilde;\",\"733\":\"DiacriticalDoubleAcute;\",\"785\":\"DownBreve;\",\"913\":\"Alpha;\",\"914\":\"Beta;\",\"915\":\"Gamma;\",\"916\":\"Delta;\",\"917\":\"Epsilon;\",\"918\":\"Zeta;\",\"919\":\"Eta;\",\"920\":\"Theta;\",\"921\":\"Iota;\",\"922\":\"Kappa;\",\"923\":\"Lambda;\",\"924\":\"Mu;\",\"925\":\"Nu;\",\"926\":\"Xi;\",\"927\":\"Omicron;\",\"928\":\"Pi;\",\"929\":\"Rho;\",\"931\":\"Sigma;\",\"932\":\"Tau;\",\"933\":\"Upsilon;\",\"934\":\"Phi;\",\"935\":\"Chi;\",\"936\":\"Psi;\",\"937\":\"Omega;\",\"945\":\"alpha;\",\"946\":\"beta;\",\"947\":\"gamma;\",\"948\":\"delta;\",\"949\":\"epsilon;\",\"950\":\"zeta;\",\"951\":\"eta;\",\"952\":\"theta;\",\"953\":\"iota;\",\"954\":\"kappa;\",\"955\":\"lambda;\",\"956\":\"mu;\",\"957\":\"nu;\",\"958\":\"xi;\",\"959\":\"omicron;\",\"960\":\"pi;\",\"961\":\"rho;\",\"962\":\"varsigma;\",\"963\":\"sigma;\",\"964\":\"tau;\",\"965\":\"upsilon;\",\"966\":\"phi;\",\"967\":\"chi;\",\"968\":\"psi;\",\"969\":\"omega;\",\"977\":\"vartheta;\",\"978\":\"upsih;\",\"981\":\"varphi;\",\"982\":\"varpi;\",\"988\":\"Gammad;\",\"989\":\"gammad;\",\"1008\":\"varkappa;\",\"1009\":\"varrho;\",\"1013\":\"varepsilon;\",\"1014\":\"bepsi;\",\"1025\":\"IOcy;\",\"1026\":\"DJcy;\",\"1027\":\"GJcy;\",\"1028\":\"Jukcy;\",\"1029\":\"DScy;\",\"1030\":\"Iukcy;\",\"1031\":\"YIcy;\",\"1032\":\"Jsercy;\",\"1033\":\"LJcy;\",\"1034\":\"NJcy;\",\"1035\":\"TSHcy;\",\"1036\":\"KJcy;\",\"1038\":\"Ubrcy;\",\"1039\":\"DZcy;\",\"1040\":\"Acy;\",\"1041\":\"Bcy;\",\"1042\":\"Vcy;\",\"1043\":\"Gcy;\",\"1044\":\"Dcy;\",\"1045\":\"IEcy;\",\"1046\":\"ZHcy;\",\"1047\":\"Zcy;\",\"1048\":\"Icy;\",\"1049\":\"Jcy;\",\"1050\":\"Kcy;\",\"1051\":\"Lcy;\",\"1052\":\"Mcy;\",\"1053\":\"Ncy;\",\"1054\":\"Ocy;\",\"1055\":\"Pcy;\",\"1056\":\"Rcy;\",\"1057\":\"Scy;\",\"1058\":\"Tcy;\",\"1059\":\"Ucy;\",\"1060\":\"Fcy;\",\"1061\":\"KHcy;\",\"1062\":\"TScy;\",\"1063\":\"CHcy;\",\"1064\":\"SHcy;\",\"1065\":\"SHCHcy;\",\"1066\":\"HARDcy;\",\"1067\":\"Ycy;\",\"1068\":\"SOFTcy;\",\"1069\":\"Ecy;\",\"1070\":\"YUcy;\",\"1071\":\"YAcy;\",\"1072\":\"acy;\",\"1073\":\"bcy;\",\"1074\":\"vcy;\",\"1075\":\"gcy;\",\"1076\":\"dcy;\",\"1077\":\"iecy;\",\"1078\":\"zhcy;\",\"1079\":\"zcy;\",\"1080\":\"icy;\",\"1081\":\"jcy;\",\"1082\":\"kcy;\",\"1083\":\"lcy;\",\"1084\":\"mcy;\",\"1085\":\"ncy;\",\"1086\":\"ocy;\",\"1087\":\"pcy;\",\"1088\":\"rcy;\",\"1089\":\"scy;\",\"1090\":\"tcy;\",\"1091\":\"ucy;\",\"1092\":\"fcy;\",\"1093\":\"khcy;\",\"1094\":\"tscy;\",\"1095\":\"chcy;\",\"1096\":\"shcy;\",\"1097\":\"shchcy;\",\"1098\":\"hardcy;\",\"1099\":\"ycy;\",\"1100\":\"softcy;\",\"1101\":\"ecy;\",\"1102\":\"yucy;\",\"1103\":\"yacy;\",\"1105\":\"iocy;\",\"1106\":\"djcy;\",\"1107\":\"gjcy;\",\"1108\":\"jukcy;\",\"1109\":\"dscy;\",\"1110\":\"iukcy;\",\"1111\":\"yicy;\",\"1112\":\"jsercy;\",\"1113\":\"ljcy;\",\"1114\":\"njcy;\",\"1115\":\"tshcy;\",\"1116\":\"kjcy;\",\"1118\":\"ubrcy;\",\"1119\":\"dzcy;\",\"8194\":\"ensp;\",\"8195\":\"emsp;\",\"8196\":\"emsp13;\",\"8197\":\"emsp14;\",\"8199\":\"numsp;\",\"8200\":\"puncsp;\",\"8201\":\"ThinSpace;\",\"8202\":\"VeryThinSpace;\",\"8203\":\"ZeroWidthSpace;\",\"8204\":\"zwnj;\",\"8205\":\"zwj;\",\"8206\":\"lrm;\",\"8207\":\"rlm;\",\"8208\":\"hyphen;\",\"8211\":\"ndash;\",\"8212\":\"mdash;\",\"8213\":\"horbar;\",\"8214\":\"Vert;\",\"8216\":\"OpenCurlyQuote;\",\"8217\":\"rsquor;\",\"8218\":\"sbquo;\",\"8220\":\"OpenCurlyDoubleQuote;\",\"8221\":\"rdquor;\",\"8222\":\"ldquor;\",\"8224\":\"dagger;\",\"8225\":\"ddagger;\",\"8226\":\"bullet;\",\"8229\":\"nldr;\",\"8230\":\"mldr;\",\"8240\":\"permil;\",\"8241\":\"pertenk;\",\"8242\":\"prime;\",\"8243\":\"Prime;\",\"8244\":\"tprime;\",\"8245\":\"bprime;\",\"8249\":\"lsaquo;\",\"8250\":\"rsaquo;\",\"8254\":\"OverBar;\",\"8257\":\"caret;\",\"8259\":\"hybull;\",\"8260\":\"frasl;\",\"8271\":\"bsemi;\",\"8279\":\"qprime;\",\"8287\":\"MediumSpace;\",\"8288\":\"NoBreak;\",\"8289\":\"ApplyFunction;\",\"8290\":\"it;\",\"8291\":\"InvisibleComma;\",\"8364\":\"euro;\",\"8411\":\"TripleDot;\",\"8412\":\"DotDot;\",\"8450\":\"Copf;\",\"8453\":\"incare;\",\"8458\":\"gscr;\",\"8459\":\"Hscr;\",\"8460\":\"Poincareplane;\",\"8461\":\"quaternions;\",\"8462\":\"planckh;\",\"8463\":\"plankv;\",\"8464\":\"Iscr;\",\"8465\":\"imagpart;\",\"8466\":\"Lscr;\",\"8467\":\"ell;\",\"8469\":\"Nopf;\",\"8470\":\"numero;\",\"8471\":\"copysr;\",\"8472\":\"wp;\",\"8473\":\"primes;\",\"8474\":\"rationals;\",\"8475\":\"Rscr;\",\"8476\":\"Rfr;\",\"8477\":\"Ropf;\",\"8478\":\"rx;\",\"8482\":\"trade;\",\"8484\":\"Zopf;\",\"8487\":\"mho;\",\"8488\":\"Zfr;\",\"8489\":\"iiota;\",\"8492\":\"Bscr;\",\"8493\":\"Cfr;\",\"8495\":\"escr;\",\"8496\":\"expectation;\",\"8497\":\"Fscr;\",\"8499\":\"phmmat;\",\"8500\":\"oscr;\",\"8501\":\"aleph;\",\"8502\":\"beth;\",\"8503\":\"gimel;\",\"8504\":\"daleth;\",\"8517\":\"DD;\",\"8518\":\"DifferentialD;\",\"8519\":\"exponentiale;\",\"8520\":\"ImaginaryI;\",\"8531\":\"frac13;\",\"8532\":\"frac23;\",\"8533\":\"frac15;\",\"8534\":\"frac25;\",\"8535\":\"frac35;\",\"8536\":\"frac45;\",\"8537\":\"frac16;\",\"8538\":\"frac56;\",\"8539\":\"frac18;\",\"8540\":\"frac38;\",\"8541\":\"frac58;\",\"8542\":\"frac78;\",\"8592\":\"slarr;\",\"8593\":\"uparrow;\",\"8594\":\"srarr;\",\"8595\":\"ShortDownArrow;\",\"8596\":\"leftrightarrow;\",\"8597\":\"varr;\",\"8598\":\"UpperLeftArrow;\",\"8599\":\"UpperRightArrow;\",\"8600\":\"searrow;\",\"8601\":\"swarrow;\",\"8602\":\"nleftarrow;\",\"8603\":\"nrightarrow;\",\"8605\":\"rightsquigarrow;\",\"8606\":\"twoheadleftarrow;\",\"8607\":\"Uarr;\",\"8608\":\"twoheadrightarrow;\",\"8609\":\"Darr;\",\"8610\":\"leftarrowtail;\",\"8611\":\"rightarrowtail;\",\"8612\":\"mapstoleft;\",\"8613\":\"UpTeeArrow;\",\"8614\":\"RightTeeArrow;\",\"8615\":\"mapstodown;\",\"8617\":\"larrhk;\",\"8618\":\"rarrhk;\",\"8619\":\"looparrowleft;\",\"8620\":\"rarrlp;\",\"8621\":\"leftrightsquigarrow;\",\"8622\":\"nleftrightarrow;\",\"8624\":\"lsh;\",\"8625\":\"rsh;\",\"8626\":\"ldsh;\",\"8627\":\"rdsh;\",\"8629\":\"crarr;\",\"8630\":\"curvearrowleft;\",\"8631\":\"curvearrowright;\",\"8634\":\"olarr;\",\"8635\":\"orarr;\",\"8636\":\"lharu;\",\"8637\":\"lhard;\",\"8638\":\"upharpoonright;\",\"8639\":\"upharpoonleft;\",\"8640\":\"RightVector;\",\"8641\":\"rightharpoondown;\",\"8642\":\"RightDownVector;\",\"8643\":\"LeftDownVector;\",\"8644\":\"rlarr;\",\"8645\":\"UpArrowDownArrow;\",\"8646\":\"lrarr;\",\"8647\":\"llarr;\",\"8648\":\"uuarr;\",\"8649\":\"rrarr;\",\"8650\":\"downdownarrows;\",\"8651\":\"ReverseEquilibrium;\",\"8652\":\"rlhar;\",\"8653\":\"nLeftarrow;\",\"8654\":\"nLeftrightarrow;\",\"8655\":\"nRightarrow;\",\"8656\":\"Leftarrow;\",\"8657\":\"Uparrow;\",\"8658\":\"Rightarrow;\",\"8659\":\"Downarrow;\",\"8660\":\"Leftrightarrow;\",\"8661\":\"vArr;\",\"8662\":\"nwArr;\",\"8663\":\"neArr;\",\"8664\":\"seArr;\",\"8665\":\"swArr;\",\"8666\":\"Lleftarrow;\",\"8667\":\"Rrightarrow;\",\"8669\":\"zigrarr;\",\"8676\":\"LeftArrowBar;\",\"8677\":\"RightArrowBar;\",\"8693\":\"duarr;\",\"8701\":\"loarr;\",\"8702\":\"roarr;\",\"8703\":\"hoarr;\",\"8704\":\"forall;\",\"8705\":\"complement;\",\"8706\":\"PartialD;\",\"8707\":\"Exists;\",\"8708\":\"NotExists;\",\"8709\":\"varnothing;\",\"8711\":\"nabla;\",\"8712\":\"isinv;\",\"8713\":\"notinva;\",\"8715\":\"SuchThat;\",\"8716\":\"NotReverseElement;\",\"8719\":\"Product;\",\"8720\":\"Coproduct;\",\"8721\":\"sum;\",\"8722\":\"minus;\",\"8723\":\"mp;\",\"8724\":\"plusdo;\",\"8726\":\"ssetmn;\",\"8727\":\"lowast;\",\"8728\":\"SmallCircle;\",\"8730\":\"Sqrt;\",\"8733\":\"vprop;\",\"8734\":\"infin;\",\"8735\":\"angrt;\",\"8736\":\"angle;\",\"8737\":\"measuredangle;\",\"8738\":\"angsph;\",\"8739\":\"VerticalBar;\",\"8740\":\"nsmid;\",\"8741\":\"spar;\",\"8742\":\"nspar;\",\"8743\":\"wedge;\",\"8744\":\"vee;\",\"8745\":\"cap;\",\"8746\":\"cup;\",\"8747\":\"Integral;\",\"8748\":\"Int;\",\"8749\":\"tint;\",\"8750\":\"oint;\",\"8751\":\"DoubleContourIntegral;\",\"8752\":\"Cconint;\",\"8753\":\"cwint;\",\"8754\":\"cwconint;\",\"8755\":\"CounterClockwiseContourIntegral;\",\"8756\":\"therefore;\",\"8757\":\"because;\",\"8758\":\"ratio;\",\"8759\":\"Proportion;\",\"8760\":\"minusd;\",\"8762\":\"mDDot;\",\"8763\":\"homtht;\",\"8764\":\"Tilde;\",\"8765\":\"bsim;\",\"8766\":\"mstpos;\",\"8767\":\"acd;\",\"8768\":\"wreath;\",\"8769\":\"nsim;\",\"8770\":\"esim;\",\"8771\":\"TildeEqual;\",\"8772\":\"nsimeq;\",\"8773\":\"TildeFullEqual;\",\"8774\":\"simne;\",\"8775\":\"NotTildeFullEqual;\",\"8776\":\"TildeTilde;\",\"8777\":\"NotTildeTilde;\",\"8778\":\"approxeq;\",\"8779\":\"apid;\",\"8780\":\"bcong;\",\"8781\":\"CupCap;\",\"8782\":\"HumpDownHump;\",\"8783\":\"HumpEqual;\",\"8784\":\"esdot;\",\"8785\":\"eDot;\",\"8786\":\"fallingdotseq;\",\"8787\":\"risingdotseq;\",\"8788\":\"coloneq;\",\"8789\":\"eqcolon;\",\"8790\":\"eqcirc;\",\"8791\":\"cire;\",\"8793\":\"wedgeq;\",\"8794\":\"veeeq;\",\"8796\":\"trie;\",\"8799\":\"questeq;\",\"8800\":\"NotEqual;\",\"8801\":\"equiv;\",\"8802\":\"NotCongruent;\",\"8804\":\"leq;\",\"8805\":\"GreaterEqual;\",\"8806\":\"LessFullEqual;\",\"8807\":\"GreaterFullEqual;\",\"8808\":\"lneqq;\",\"8809\":\"gneqq;\",\"8810\":\"NestedLessLess;\",\"8811\":\"NestedGreaterGreater;\",\"8812\":\"twixt;\",\"8813\":\"NotCupCap;\",\"8814\":\"NotLess;\",\"8815\":\"NotGreater;\",\"8816\":\"NotLessEqual;\",\"8817\":\"NotGreaterEqual;\",\"8818\":\"lsim;\",\"8819\":\"gtrsim;\",\"8820\":\"NotLessTilde;\",\"8821\":\"NotGreaterTilde;\",\"8822\":\"lg;\",\"8823\":\"gtrless;\",\"8824\":\"ntlg;\",\"8825\":\"ntgl;\",\"8826\":\"Precedes;\",\"8827\":\"Succeeds;\",\"8828\":\"PrecedesSlantEqual;\",\"8829\":\"SucceedsSlantEqual;\",\"8830\":\"prsim;\",\"8831\":\"succsim;\",\"8832\":\"nprec;\",\"8833\":\"nsucc;\",\"8834\":\"subset;\",\"8835\":\"supset;\",\"8836\":\"nsub;\",\"8837\":\"nsup;\",\"8838\":\"SubsetEqual;\",\"8839\":\"supseteq;\",\"8840\":\"nsubseteq;\",\"8841\":\"nsupseteq;\",\"8842\":\"subsetneq;\",\"8843\":\"supsetneq;\",\"8845\":\"cupdot;\",\"8846\":\"uplus;\",\"8847\":\"SquareSubset;\",\"8848\":\"SquareSuperset;\",\"8849\":\"SquareSubsetEqual;\",\"8850\":\"SquareSupersetEqual;\",\"8851\":\"SquareIntersection;\",\"8852\":\"SquareUnion;\",\"8853\":\"oplus;\",\"8854\":\"ominus;\",\"8855\":\"otimes;\",\"8856\":\"osol;\",\"8857\":\"odot;\",\"8858\":\"ocir;\",\"8859\":\"oast;\",\"8861\":\"odash;\",\"8862\":\"plusb;\",\"8863\":\"minusb;\",\"8864\":\"timesb;\",\"8865\":\"sdotb;\",\"8866\":\"vdash;\",\"8867\":\"LeftTee;\",\"8868\":\"top;\",\"8869\":\"UpTee;\",\"8871\":\"models;\",\"8872\":\"vDash;\",\"8873\":\"Vdash;\",\"8874\":\"Vvdash;\",\"8875\":\"VDash;\",\"8876\":\"nvdash;\",\"8877\":\"nvDash;\",\"8878\":\"nVdash;\",\"8879\":\"nVDash;\",\"8880\":\"prurel;\",\"8882\":\"vltri;\",\"8883\":\"vrtri;\",\"8884\":\"trianglelefteq;\",\"8885\":\"trianglerighteq;\",\"8886\":\"origof;\",\"8887\":\"imof;\",\"8888\":\"mumap;\",\"8889\":\"hercon;\",\"8890\":\"intercal;\",\"8891\":\"veebar;\",\"8893\":\"barvee;\",\"8894\":\"angrtvb;\",\"8895\":\"lrtri;\",\"8896\":\"xwedge;\",\"8897\":\"xvee;\",\"8898\":\"xcap;\",\"8899\":\"xcup;\",\"8900\":\"diamond;\",\"8901\":\"sdot;\",\"8902\":\"Star;\",\"8903\":\"divonx;\",\"8904\":\"bowtie;\",\"8905\":\"ltimes;\",\"8906\":\"rtimes;\",\"8907\":\"lthree;\",\"8908\":\"rthree;\",\"8909\":\"bsime;\",\"8910\":\"cuvee;\",\"8911\":\"cuwed;\",\"8912\":\"Subset;\",\"8913\":\"Supset;\",\"8914\":\"Cap;\",\"8915\":\"Cup;\",\"8916\":\"pitchfork;\",\"8917\":\"epar;\",\"8918\":\"ltdot;\",\"8919\":\"gtrdot;\",\"8920\":\"Ll;\",\"8921\":\"ggg;\",\"8922\":\"LessEqualGreater;\",\"8923\":\"gtreqless;\",\"8926\":\"curlyeqprec;\",\"8927\":\"curlyeqsucc;\",\"8928\":\"nprcue;\",\"8929\":\"nsccue;\",\"8930\":\"nsqsube;\",\"8931\":\"nsqsupe;\",\"8934\":\"lnsim;\",\"8935\":\"gnsim;\",\"8936\":\"prnsim;\",\"8937\":\"succnsim;\",\"8938\":\"ntriangleleft;\",\"8939\":\"ntriangleright;\",\"8940\":\"ntrianglelefteq;\",\"8941\":\"ntrianglerighteq;\",\"8942\":\"vellip;\",\"8943\":\"ctdot;\",\"8944\":\"utdot;\",\"8945\":\"dtdot;\",\"8946\":\"disin;\",\"8947\":\"isinsv;\",\"8948\":\"isins;\",\"8949\":\"isindot;\",\"8950\":\"notinvc;\",\"8951\":\"notinvb;\",\"8953\":\"isinE;\",\"8954\":\"nisd;\",\"8955\":\"xnis;\",\"8956\":\"nis;\",\"8957\":\"notnivc;\",\"8958\":\"notnivb;\",\"8965\":\"barwedge;\",\"8966\":\"doublebarwedge;\",\"8968\":\"LeftCeiling;\",\"8969\":\"RightCeiling;\",\"8970\":\"lfloor;\",\"8971\":\"RightFloor;\",\"8972\":\"drcrop;\",\"8973\":\"dlcrop;\",\"8974\":\"urcrop;\",\"8975\":\"ulcrop;\",\"8976\":\"bnot;\",\"8978\":\"profline;\",\"8979\":\"profsurf;\",\"8981\":\"telrec;\",\"8982\":\"target;\",\"8988\":\"ulcorner;\",\"8989\":\"urcorner;\",\"8990\":\"llcorner;\",\"8991\":\"lrcorner;\",\"8994\":\"sfrown;\",\"8995\":\"ssmile;\",\"9005\":\"cylcty;\",\"9006\":\"profalar;\",\"9014\":\"topbot;\",\"9021\":\"ovbar;\",\"9023\":\"solbar;\",\"9084\":\"angzarr;\",\"9136\":\"lmoustache;\",\"9137\":\"rmoustache;\",\"9140\":\"tbrk;\",\"9141\":\"UnderBracket;\",\"9142\":\"bbrktbrk;\",\"9180\":\"OverParenthesis;\",\"9181\":\"UnderParenthesis;\",\"9182\":\"OverBrace;\",\"9183\":\"UnderBrace;\",\"9186\":\"trpezium;\",\"9191\":\"elinters;\",\"9251\":\"blank;\",\"9416\":\"oS;\",\"9472\":\"HorizontalLine;\",\"9474\":\"boxv;\",\"9484\":\"boxdr;\",\"9488\":\"boxdl;\",\"9492\":\"boxur;\",\"9496\":\"boxul;\",\"9500\":\"boxvr;\",\"9508\":\"boxvl;\",\"9516\":\"boxhd;\",\"9524\":\"boxhu;\",\"9532\":\"boxvh;\",\"9552\":\"boxH;\",\"9553\":\"boxV;\",\"9554\":\"boxdR;\",\"9555\":\"boxDr;\",\"9556\":\"boxDR;\",\"9557\":\"boxdL;\",\"9558\":\"boxDl;\",\"9559\":\"boxDL;\",\"9560\":\"boxuR;\",\"9561\":\"boxUr;\",\"9562\":\"boxUR;\",\"9563\":\"boxuL;\",\"9564\":\"boxUl;\",\"9565\":\"boxUL;\",\"9566\":\"boxvR;\",\"9567\":\"boxVr;\",\"9568\":\"boxVR;\",\"9569\":\"boxvL;\",\"9570\":\"boxVl;\",\"9571\":\"boxVL;\",\"9572\":\"boxHd;\",\"9573\":\"boxhD;\",\"9574\":\"boxHD;\",\"9575\":\"boxHu;\",\"9576\":\"boxhU;\",\"9577\":\"boxHU;\",\"9578\":\"boxvH;\",\"9579\":\"boxVh;\",\"9580\":\"boxVH;\",\"9600\":\"uhblk;\",\"9604\":\"lhblk;\",\"9608\":\"block;\",\"9617\":\"blk14;\",\"9618\":\"blk12;\",\"9619\":\"blk34;\",\"9633\":\"square;\",\"9642\":\"squf;\",\"9643\":\"EmptyVerySmallSquare;\",\"9645\":\"rect;\",\"9646\":\"marker;\",\"9649\":\"fltns;\",\"9651\":\"xutri;\",\"9652\":\"utrif;\",\"9653\":\"utri;\",\"9656\":\"rtrif;\",\"9657\":\"triangleright;\",\"9661\":\"xdtri;\",\"9662\":\"dtrif;\",\"9663\":\"triangledown;\",\"9666\":\"ltrif;\",\"9667\":\"triangleleft;\",\"9674\":\"lozenge;\",\"9675\":\"cir;\",\"9708\":\"tridot;\",\"9711\":\"xcirc;\",\"9720\":\"ultri;\",\"9721\":\"urtri;\",\"9722\":\"lltri;\",\"9723\":\"EmptySmallSquare;\",\"9724\":\"FilledSmallSquare;\",\"9733\":\"starf;\",\"9734\":\"star;\",\"9742\":\"phone;\",\"9792\":\"female;\",\"9794\":\"male;\",\"9824\":\"spadesuit;\",\"9827\":\"clubsuit;\",\"9829\":\"heartsuit;\",\"9830\":\"diams;\",\"9834\":\"sung;\",\"9837\":\"flat;\",\"9838\":\"natural;\",\"9839\":\"sharp;\",\"10003\":\"checkmark;\",\"10007\":\"cross;\",\"10016\":\"maltese;\",\"10038\":\"sext;\",\"10072\":\"VerticalSeparator;\",\"10098\":\"lbbrk;\",\"10099\":\"rbbrk;\",\"10184\":\"bsolhsub;\",\"10185\":\"suphsol;\",\"10214\":\"lobrk;\",\"10215\":\"robrk;\",\"10216\":\"LeftAngleBracket;\",\"10217\":\"RightAngleBracket;\",\"10218\":\"Lang;\",\"10219\":\"Rang;\",\"10220\":\"loang;\",\"10221\":\"roang;\",\"10229\":\"xlarr;\",\"10230\":\"xrarr;\",\"10231\":\"xharr;\",\"10232\":\"xlArr;\",\"10233\":\"xrArr;\",\"10234\":\"xhArr;\",\"10236\":\"xmap;\",\"10239\":\"dzigrarr;\",\"10498\":\"nvlArr;\",\"10499\":\"nvrArr;\",\"10500\":\"nvHarr;\",\"10501\":\"Map;\",\"10508\":\"lbarr;\",\"10509\":\"rbarr;\",\"10510\":\"lBarr;\",\"10511\":\"rBarr;\",\"10512\":\"RBarr;\",\"10513\":\"DDotrahd;\",\"10514\":\"UpArrowBar;\",\"10515\":\"DownArrowBar;\",\"10518\":\"Rarrtl;\",\"10521\":\"latail;\",\"10522\":\"ratail;\",\"10523\":\"lAtail;\",\"10524\":\"rAtail;\",\"10525\":\"larrfs;\",\"10526\":\"rarrfs;\",\"10527\":\"larrbfs;\",\"10528\":\"rarrbfs;\",\"10531\":\"nwarhk;\",\"10532\":\"nearhk;\",\"10533\":\"searhk;\",\"10534\":\"swarhk;\",\"10535\":\"nwnear;\",\"10536\":\"toea;\",\"10537\":\"tosa;\",\"10538\":\"swnwar;\",\"10547\":\"rarrc;\",\"10549\":\"cudarrr;\",\"10550\":\"ldca;\",\"10551\":\"rdca;\",\"10552\":\"cudarrl;\",\"10553\":\"larrpl;\",\"10556\":\"curarrm;\",\"10557\":\"cularrp;\",\"10565\":\"rarrpl;\",\"10568\":\"harrcir;\",\"10569\":\"Uarrocir;\",\"10570\":\"lurdshar;\",\"10571\":\"ldrushar;\",\"10574\":\"LeftRightVector;\",\"10575\":\"RightUpDownVector;\",\"10576\":\"DownLeftRightVector;\",\"10577\":\"LeftUpDownVector;\",\"10578\":\"LeftVectorBar;\",\"10579\":\"RightVectorBar;\",\"10580\":\"RightUpVectorBar;\",\"10581\":\"RightDownVectorBar;\",\"10582\":\"DownLeftVectorBar;\",\"10583\":\"DownRightVectorBar;\",\"10584\":\"LeftUpVectorBar;\",\"10585\":\"LeftDownVectorBar;\",\"10586\":\"LeftTeeVector;\",\"10587\":\"RightTeeVector;\",\"10588\":\"RightUpTeeVector;\",\"10589\":\"RightDownTeeVector;\",\"10590\":\"DownLeftTeeVector;\",\"10591\":\"DownRightTeeVector;\",\"10592\":\"LeftUpTeeVector;\",\"10593\":\"LeftDownTeeVector;\",\"10594\":\"lHar;\",\"10595\":\"uHar;\",\"10596\":\"rHar;\",\"10597\":\"dHar;\",\"10598\":\"luruhar;\",\"10599\":\"ldrdhar;\",\"10600\":\"ruluhar;\",\"10601\":\"rdldhar;\",\"10602\":\"lharul;\",\"10603\":\"llhard;\",\"10604\":\"rharul;\",\"10605\":\"lrhard;\",\"10606\":\"UpEquilibrium;\",\"10607\":\"ReverseUpEquilibrium;\",\"10608\":\"RoundImplies;\",\"10609\":\"erarr;\",\"10610\":\"simrarr;\",\"10611\":\"larrsim;\",\"10612\":\"rarrsim;\",\"10613\":\"rarrap;\",\"10614\":\"ltlarr;\",\"10616\":\"gtrarr;\",\"10617\":\"subrarr;\",\"10619\":\"suplarr;\",\"10620\":\"lfisht;\",\"10621\":\"rfisht;\",\"10622\":\"ufisht;\",\"10623\":\"dfisht;\",\"10629\":\"lopar;\",\"10630\":\"ropar;\",\"10635\":\"lbrke;\",\"10636\":\"rbrke;\",\"10637\":\"lbrkslu;\",\"10638\":\"rbrksld;\",\"10639\":\"lbrksld;\",\"10640\":\"rbrkslu;\",\"10641\":\"langd;\",\"10642\":\"rangd;\",\"10643\":\"lparlt;\",\"10644\":\"rpargt;\",\"10645\":\"gtlPar;\",\"10646\":\"ltrPar;\",\"10650\":\"vzigzag;\",\"10652\":\"vangrt;\",\"10653\":\"angrtvbd;\",\"10660\":\"ange;\",\"10661\":\"range;\",\"10662\":\"dwangle;\",\"10663\":\"uwangle;\",\"10664\":\"angmsdaa;\",\"10665\":\"angmsdab;\",\"10666\":\"angmsdac;\",\"10667\":\"angmsdad;\",\"10668\":\"angmsdae;\",\"10669\":\"angmsdaf;\",\"10670\":\"angmsdag;\",\"10671\":\"angmsdah;\",\"10672\":\"bemptyv;\",\"10673\":\"demptyv;\",\"10674\":\"cemptyv;\",\"10675\":\"raemptyv;\",\"10676\":\"laemptyv;\",\"10677\":\"ohbar;\",\"10678\":\"omid;\",\"10679\":\"opar;\",\"10681\":\"operp;\",\"10683\":\"olcross;\",\"10684\":\"odsold;\",\"10686\":\"olcir;\",\"10687\":\"ofcir;\",\"10688\":\"olt;\",\"10689\":\"ogt;\",\"10690\":\"cirscir;\",\"10691\":\"cirE;\",\"10692\":\"solb;\",\"10693\":\"bsolb;\",\"10697\":\"boxbox;\",\"10701\":\"trisb;\",\"10702\":\"rtriltri;\",\"10703\":\"LeftTriangleBar;\",\"10704\":\"RightTriangleBar;\",\"10716\":\"iinfin;\",\"10717\":\"infintie;\",\"10718\":\"nvinfin;\",\"10723\":\"eparsl;\",\"10724\":\"smeparsl;\",\"10725\":\"eqvparsl;\",\"10731\":\"lozf;\",\"10740\":\"RuleDelayed;\",\"10742\":\"dsol;\",\"10752\":\"xodot;\",\"10753\":\"xoplus;\",\"10754\":\"xotime;\",\"10756\":\"xuplus;\",\"10758\":\"xsqcup;\",\"10764\":\"qint;\",\"10765\":\"fpartint;\",\"10768\":\"cirfnint;\",\"10769\":\"awint;\",\"10770\":\"rppolint;\",\"10771\":\"scpolint;\",\"10772\":\"npolint;\",\"10773\":\"pointint;\",\"10774\":\"quatint;\",\"10775\":\"intlarhk;\",\"10786\":\"pluscir;\",\"10787\":\"plusacir;\",\"10788\":\"simplus;\",\"10789\":\"plusdu;\",\"10790\":\"plussim;\",\"10791\":\"plustwo;\",\"10793\":\"mcomma;\",\"10794\":\"minusdu;\",\"10797\":\"loplus;\",\"10798\":\"roplus;\",\"10799\":\"Cross;\",\"10800\":\"timesd;\",\"10801\":\"timesbar;\",\"10803\":\"smashp;\",\"10804\":\"lotimes;\",\"10805\":\"rotimes;\",\"10806\":\"otimesas;\",\"10807\":\"Otimes;\",\"10808\":\"odiv;\",\"10809\":\"triplus;\",\"10810\":\"triminus;\",\"10811\":\"tritime;\",\"10812\":\"iprod;\",\"10815\":\"amalg;\",\"10816\":\"capdot;\",\"10818\":\"ncup;\",\"10819\":\"ncap;\",\"10820\":\"capand;\",\"10821\":\"cupor;\",\"10822\":\"cupcap;\",\"10823\":\"capcup;\",\"10824\":\"cupbrcap;\",\"10825\":\"capbrcup;\",\"10826\":\"cupcup;\",\"10827\":\"capcap;\",\"10828\":\"ccups;\",\"10829\":\"ccaps;\",\"10832\":\"ccupssm;\",\"10835\":\"And;\",\"10836\":\"Or;\",\"10837\":\"andand;\",\"10838\":\"oror;\",\"10839\":\"orslope;\",\"10840\":\"andslope;\",\"10842\":\"andv;\",\"10843\":\"orv;\",\"10844\":\"andd;\",\"10845\":\"ord;\",\"10847\":\"wedbar;\",\"10854\":\"sdote;\",\"10858\":\"simdot;\",\"10861\":\"congdot;\",\"10862\":\"easter;\",\"10863\":\"apacir;\",\"10864\":\"apE;\",\"10865\":\"eplus;\",\"10866\":\"pluse;\",\"10867\":\"Esim;\",\"10868\":\"Colone;\",\"10869\":\"Equal;\",\"10871\":\"eDDot;\",\"10872\":\"equivDD;\",\"10873\":\"ltcir;\",\"10874\":\"gtcir;\",\"10875\":\"ltquest;\",\"10876\":\"gtquest;\",\"10877\":\"LessSlantEqual;\",\"10878\":\"GreaterSlantEqual;\",\"10879\":\"lesdot;\",\"10880\":\"gesdot;\",\"10881\":\"lesdoto;\",\"10882\":\"gesdoto;\",\"10883\":\"lesdotor;\",\"10884\":\"gesdotol;\",\"10885\":\"lessapprox;\",\"10886\":\"gtrapprox;\",\"10887\":\"lneq;\",\"10888\":\"gneq;\",\"10889\":\"lnapprox;\",\"10890\":\"gnapprox;\",\"10891\":\"lesseqqgtr;\",\"10892\":\"gtreqqless;\",\"10893\":\"lsime;\",\"10894\":\"gsime;\",\"10895\":\"lsimg;\",\"10896\":\"gsiml;\",\"10897\":\"lgE;\",\"10898\":\"glE;\",\"10899\":\"lesges;\",\"10900\":\"gesles;\",\"10901\":\"eqslantless;\",\"10902\":\"eqslantgtr;\",\"10903\":\"elsdot;\",\"10904\":\"egsdot;\",\"10905\":\"el;\",\"10906\":\"eg;\",\"10909\":\"siml;\",\"10910\":\"simg;\",\"10911\":\"simlE;\",\"10912\":\"simgE;\",\"10913\":\"LessLess;\",\"10914\":\"GreaterGreater;\",\"10916\":\"glj;\",\"10917\":\"gla;\",\"10918\":\"ltcc;\",\"10919\":\"gtcc;\",\"10920\":\"lescc;\",\"10921\":\"gescc;\",\"10922\":\"smt;\",\"10923\":\"lat;\",\"10924\":\"smte;\",\"10925\":\"late;\",\"10926\":\"bumpE;\",\"10927\":\"preceq;\",\"10928\":\"succeq;\",\"10931\":\"prE;\",\"10932\":\"scE;\",\"10933\":\"prnE;\",\"10934\":\"succneqq;\",\"10935\":\"precapprox;\",\"10936\":\"succapprox;\",\"10937\":\"prnap;\",\"10938\":\"succnapprox;\",\"10939\":\"Pr;\",\"10940\":\"Sc;\",\"10941\":\"subdot;\",\"10942\":\"supdot;\",\"10943\":\"subplus;\",\"10944\":\"supplus;\",\"10945\":\"submult;\",\"10946\":\"supmult;\",\"10947\":\"subedot;\",\"10948\":\"supedot;\",\"10949\":\"subseteqq;\",\"10950\":\"supseteqq;\",\"10951\":\"subsim;\",\"10952\":\"supsim;\",\"10955\":\"subsetneqq;\",\"10956\":\"supsetneqq;\",\"10959\":\"csub;\",\"10960\":\"csup;\",\"10961\":\"csube;\",\"10962\":\"csupe;\",\"10963\":\"subsup;\",\"10964\":\"supsub;\",\"10965\":\"subsub;\",\"10966\":\"supsup;\",\"10967\":\"suphsub;\",\"10968\":\"supdsub;\",\"10969\":\"forkv;\",\"10970\":\"topfork;\",\"10971\":\"mlcp;\",\"10980\":\"DoubleLeftTee;\",\"10982\":\"Vdashl;\",\"10983\":\"Barv;\",\"10984\":\"vBar;\",\"10985\":\"vBarv;\",\"10987\":\"Vbar;\",\"10988\":\"Not;\",\"10989\":\"bNot;\",\"10990\":\"rnmid;\",\"10991\":\"cirmid;\",\"10992\":\"midcir;\",\"10993\":\"topcir;\",\"10994\":\"nhpar;\",\"10995\":\"parsim;\",\"11005\":\"parsl;\",\"64256\":\"fflig;\",\"64257\":\"filig;\",\"64258\":\"fllig;\",\"64259\":\"ffilig;\",\"64260\":\"ffllig;\"}');\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/ent/reversed.json?");

/***/ }),

/***/ "./src/node_modules/entities/lib/decode.js":
/*!*************************************************!*\
  !*** ./src/node_modules/entities/lib/decode.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decodeHTML = exports.decodeHTMLStrict = exports.decodeXML = void 0;\nvar entities_json_1 = __importDefault(__webpack_require__(/*! ./maps/entities.json */ \"./src/node_modules/entities/lib/maps/entities.json\"));\nvar legacy_json_1 = __importDefault(__webpack_require__(/*! ./maps/legacy.json */ \"./src/node_modules/entities/lib/maps/legacy.json\"));\nvar xml_json_1 = __importDefault(__webpack_require__(/*! ./maps/xml.json */ \"./src/node_modules/entities/lib/maps/xml.json\"));\nvar decode_codepoint_1 = __importDefault(__webpack_require__(/*! ./decode_codepoint */ \"./src/node_modules/entities/lib/decode_codepoint.js\"));\nvar strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\\da-fA-F]+|#\\d+);/g;\nexports.decodeXML = getStrictDecoder(xml_json_1.default);\nexports.decodeHTMLStrict = getStrictDecoder(entities_json_1.default);\nfunction getStrictDecoder(map) {\n    var replace = getReplacer(map);\n    return function (str) { return String(str).replace(strictEntityRe, replace); };\n}\nvar sorter = function (a, b) { return (a < b ? 1 : -1); };\nexports.decodeHTML = (function () {\n    var legacy = Object.keys(legacy_json_1.default).sort(sorter);\n    var keys = Object.keys(entities_json_1.default).sort(sorter);\n    for (var i = 0, j = 0; i < keys.length; i++) {\n        if (legacy[j] === keys[i]) {\n            keys[i] += \";?\";\n            j++;\n        }\n        else {\n            keys[i] += \";\";\n        }\n    }\n    var re = new RegExp(\"&(?:\" + keys.join(\"|\") + \"|#[xX][\\\\da-fA-F]+;?|#\\\\d+;?)\", \"g\");\n    var replace = getReplacer(entities_json_1.default);\n    function replacer(str) {\n        if (str.substr(-1) !== \";\")\n            str += \";\";\n        return replace(str);\n    }\n    // TODO consider creating a merged map\n    return function (str) { return String(str).replace(re, replacer); };\n})();\nfunction getReplacer(map) {\n    return function replace(str) {\n        if (str.charAt(1) === \"#\") {\n            var secondChar = str.charAt(2);\n            if (secondChar === \"X\" || secondChar === \"x\") {\n                return decode_codepoint_1.default(parseInt(str.substr(3), 16));\n            }\n            return decode_codepoint_1.default(parseInt(str.substr(2), 10));\n        }\n        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n        return map[str.slice(1, -1)] || str;\n    };\n}\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/entities/lib/decode.js?");

/***/ }),

/***/ "./src/node_modules/entities/lib/decode_codepoint.js":
/*!***********************************************************!*\
  !*** ./src/node_modules/entities/lib/decode_codepoint.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar decode_json_1 = __importDefault(__webpack_require__(/*! ./maps/decode.json */ \"./src/node_modules/entities/lib/maps/decode.json\"));\n// Adapted from https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119\nvar fromCodePoint = \n// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\nString.fromCodePoint ||\n    function (codePoint) {\n        var output = \"\";\n        if (codePoint > 0xffff) {\n            codePoint -= 0x10000;\n            output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);\n            codePoint = 0xdc00 | (codePoint & 0x3ff);\n        }\n        output += String.fromCharCode(codePoint);\n        return output;\n    };\nfunction decodeCodePoint(codePoint) {\n    if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {\n        return \"\\uFFFD\";\n    }\n    if (codePoint in decode_json_1.default) {\n        codePoint = decode_json_1.default[codePoint];\n    }\n    return fromCodePoint(codePoint);\n}\nexports.default = decodeCodePoint;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/entities/lib/decode_codepoint.js?");

/***/ }),

/***/ "./src/node_modules/entities/lib/encode.js":
/*!*************************************************!*\
  !*** ./src/node_modules/entities/lib/encode.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = void 0;\nvar xml_json_1 = __importDefault(__webpack_require__(/*! ./maps/xml.json */ \"./src/node_modules/entities/lib/maps/xml.json\"));\nvar inverseXML = getInverseObj(xml_json_1.default);\nvar xmlReplacer = getInverseReplacer(inverseXML);\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in XML\n * documents using XML entities.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\nexports.encodeXML = getASCIIEncoder(inverseXML);\nvar entities_json_1 = __importDefault(__webpack_require__(/*! ./maps/entities.json */ \"./src/node_modules/entities/lib/maps/entities.json\"));\nvar inverseHTML = getInverseObj(entities_json_1.default);\nvar htmlReplacer = getInverseReplacer(inverseHTML);\n/**\n * Encodes all entities and non-ASCII characters in the input.\n *\n * This includes characters that are valid ASCII characters in HTML documents.\n * For example `#` will be encoded as `&num;`. To get a more compact output,\n * consider using the `encodeNonAsciiHTML` function.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\nexports.encodeHTML = getInverse(inverseHTML, htmlReplacer);\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in HTML\n * documents using HTML entities.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\nexports.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);\nfunction getInverseObj(obj) {\n    return Object.keys(obj)\n        .sort()\n        .reduce(function (inverse, name) {\n        inverse[obj[name]] = \"&\" + name + \";\";\n        return inverse;\n    }, {});\n}\nfunction getInverseReplacer(inverse) {\n    var single = [];\n    var multiple = [];\n    for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {\n        var k = _a[_i];\n        if (k.length === 1) {\n            // Add value to single array\n            single.push(\"\\\\\" + k);\n        }\n        else {\n            // Add value to multiple array\n            multiple.push(k);\n        }\n    }\n    // Add ranges to single characters.\n    single.sort();\n    for (var start = 0; start < single.length - 1; start++) {\n        // Find the end of a run of characters\n        var end = start;\n        while (end < single.length - 1 &&\n            single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {\n            end += 1;\n        }\n        var count = 1 + end - start;\n        // We want to replace at least three characters\n        if (count < 3)\n            continue;\n        single.splice(start, count, single[start] + \"-\" + single[end]);\n    }\n    multiple.unshift(\"[\" + single.join(\"\") + \"]\");\n    return new RegExp(multiple.join(\"|\"), \"g\");\n}\n// /[^\\0-\\x7F]/gu\nvar reNonASCII = /(?:[\\x80-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])/g;\nvar getCodePoint = \n// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\nString.prototype.codePointAt != null\n    ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        function (str) { return str.codePointAt(0); }\n    : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n        function (c) {\n            return (c.charCodeAt(0) - 0xd800) * 0x400 +\n                c.charCodeAt(1) -\n                0xdc00 +\n                0x10000;\n        };\nfunction singleCharReplacer(c) {\n    return \"&#x\" + (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0))\n        .toString(16)\n        .toUpperCase() + \";\";\n}\nfunction getInverse(inverse, re) {\n    return function (data) {\n        return data\n            .replace(re, function (name) { return inverse[name]; })\n            .replace(reNonASCII, singleCharReplacer);\n    };\n}\nvar reEscapeChars = new RegExp(xmlReplacer.source + \"|\" + reNonASCII.source, \"g\");\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in XML\n * documents using numeric hexadecimal reference (eg. `&#xfc;`).\n *\n * Have a look at `escapeUTF8` if you want a more concise output at the expense\n * of reduced transportability.\n *\n * @param data String to escape.\n */\nfunction escape(data) {\n    return data.replace(reEscapeChars, singleCharReplacer);\n}\nexports.escape = escape;\n/**\n * Encodes all characters not valid in XML documents using numeric hexadecimal\n * reference (eg. `&#xfc;`).\n *\n * Note that the output will be character-set dependent.\n *\n * @param data String to escape.\n */\nfunction escapeUTF8(data) {\n    return data.replace(xmlReplacer, singleCharReplacer);\n}\nexports.escapeUTF8 = escapeUTF8;\nfunction getASCIIEncoder(obj) {\n    return function (data) {\n        return data.replace(reEscapeChars, function (c) { return obj[c] || singleCharReplacer(c); });\n    };\n}\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/entities/lib/encode.js?");

/***/ }),

/***/ "./src/node_modules/entities/lib/index.js":
/*!************************************************!*\
  !*** ./src/node_modules/entities/lib/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;\nvar decode_1 = __webpack_require__(/*! ./decode */ \"./src/node_modules/entities/lib/decode.js\");\nvar encode_1 = __webpack_require__(/*! ./encode */ \"./src/node_modules/entities/lib/encode.js\");\n/**\n * Decodes a string with entities.\n *\n * @param data String to decode.\n * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.\n * @deprecated Use `decodeXML` or `decodeHTML` directly.\n */\nfunction decode(data, level) {\n    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);\n}\nexports.decode = decode;\n/**\n * Decodes a string with entities. Does not allow missing trailing semicolons for entities.\n *\n * @param data String to decode.\n * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.\n * @deprecated Use `decodeHTMLStrict` or `decodeXML` directly.\n */\nfunction decodeStrict(data, level) {\n    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);\n}\nexports.decodeStrict = decodeStrict;\n/**\n * Encodes a string with entities.\n *\n * @param data String to encode.\n * @param level Optional level to encode at. 0 = XML, 1 = HTML. Default is 0.\n * @deprecated Use `encodeHTML`, `encodeXML` or `encodeNonAsciiHTML` directly.\n */\nfunction encode(data, level) {\n    return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);\n}\nexports.encode = encode;\nvar encode_2 = __webpack_require__(/*! ./encode */ \"./src/node_modules/entities/lib/encode.js\");\nObject.defineProperty(exports, \"encodeXML\", ({ enumerable: true, get: function () { return encode_2.encodeXML; } }));\nObject.defineProperty(exports, \"encodeHTML\", ({ enumerable: true, get: function () { return encode_2.encodeHTML; } }));\nObject.defineProperty(exports, \"encodeNonAsciiHTML\", ({ enumerable: true, get: function () { return encode_2.encodeNonAsciiHTML; } }));\nObject.defineProperty(exports, \"escape\", ({ enumerable: true, get: function () { return encode_2.escape; } }));\nObject.defineProperty(exports, \"escapeUTF8\", ({ enumerable: true, get: function () { return encode_2.escapeUTF8; } }));\n// Legacy aliases (deprecated)\nObject.defineProperty(exports, \"encodeHTML4\", ({ enumerable: true, get: function () { return encode_2.encodeHTML; } }));\nObject.defineProperty(exports, \"encodeHTML5\", ({ enumerable: true, get: function () { return encode_2.encodeHTML; } }));\nvar decode_2 = __webpack_require__(/*! ./decode */ \"./src/node_modules/entities/lib/decode.js\");\nObject.defineProperty(exports, \"decodeXML\", ({ enumerable: true, get: function () { return decode_2.decodeXML; } }));\nObject.defineProperty(exports, \"decodeHTML\", ({ enumerable: true, get: function () { return decode_2.decodeHTML; } }));\nObject.defineProperty(exports, \"decodeHTMLStrict\", ({ enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } }));\n// Legacy aliases (deprecated)\nObject.defineProperty(exports, \"decodeHTML4\", ({ enumerable: true, get: function () { return decode_2.decodeHTML; } }));\nObject.defineProperty(exports, \"decodeHTML5\", ({ enumerable: true, get: function () { return decode_2.decodeHTML; } }));\nObject.defineProperty(exports, \"decodeHTML4Strict\", ({ enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } }));\nObject.defineProperty(exports, \"decodeHTML5Strict\", ({ enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } }));\nObject.defineProperty(exports, \"decodeXMLStrict\", ({ enumerable: true, get: function () { return decode_2.decodeXML; } }));\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/entities/lib/index.js?");

/***/ }),

/***/ "./src/node_modules/entities/lib/maps/decode.json":
/*!********************************************************!*\
  !*** ./src/node_modules/entities/lib/maps/decode.json ***!
  \********************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"0\":65533,\"128\":8364,\"130\":8218,\"131\":402,\"132\":8222,\"133\":8230,\"134\":8224,\"135\":8225,\"136\":710,\"137\":8240,\"138\":352,\"139\":8249,\"140\":338,\"142\":381,\"145\":8216,\"146\":8217,\"147\":8220,\"148\":8221,\"149\":8226,\"150\":8211,\"151\":8212,\"152\":732,\"153\":8482,\"154\":353,\"155\":8250,\"156\":339,\"158\":382,\"159\":376}');\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/entities/lib/maps/decode.json?");

/***/ }),

/***/ "./src/node_modules/entities/lib/maps/entities.json":
/*!**********************************************************!*\
  !*** ./src/node_modules/entities/lib/maps/entities.json ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"Aacute\":\"Á\",\"aacute\":\"á\",\"Abreve\":\"Ă\",\"abreve\":\"ă\",\"ac\":\"∾\",\"acd\":\"∿\",\"acE\":\"∾̳\",\"Acirc\":\"Â\",\"acirc\":\"â\",\"acute\":\"´\",\"Acy\":\"А\",\"acy\":\"а\",\"AElig\":\"Æ\",\"aelig\":\"æ\",\"af\":\"⁡\",\"Afr\":\"𝔄\",\"afr\":\"𝔞\",\"Agrave\":\"À\",\"agrave\":\"à\",\"alefsym\":\"ℵ\",\"aleph\":\"ℵ\",\"Alpha\":\"Α\",\"alpha\":\"α\",\"Amacr\":\"Ā\",\"amacr\":\"ā\",\"amalg\":\"⨿\",\"amp\":\"&\",\"AMP\":\"&\",\"andand\":\"⩕\",\"And\":\"⩓\",\"and\":\"∧\",\"andd\":\"⩜\",\"andslope\":\"⩘\",\"andv\":\"⩚\",\"ang\":\"∠\",\"ange\":\"⦤\",\"angle\":\"∠\",\"angmsdaa\":\"⦨\",\"angmsdab\":\"⦩\",\"angmsdac\":\"⦪\",\"angmsdad\":\"⦫\",\"angmsdae\":\"⦬\",\"angmsdaf\":\"⦭\",\"angmsdag\":\"⦮\",\"angmsdah\":\"⦯\",\"angmsd\":\"∡\",\"angrt\":\"∟\",\"angrtvb\":\"⊾\",\"angrtvbd\":\"⦝\",\"angsph\":\"∢\",\"angst\":\"Å\",\"angzarr\":\"⍼\",\"Aogon\":\"Ą\",\"aogon\":\"ą\",\"Aopf\":\"𝔸\",\"aopf\":\"𝕒\",\"apacir\":\"⩯\",\"ap\":\"≈\",\"apE\":\"⩰\",\"ape\":\"≊\",\"apid\":\"≋\",\"apos\":\"\\'\",\"ApplyFunction\":\"⁡\",\"approx\":\"≈\",\"approxeq\":\"≊\",\"Aring\":\"Å\",\"aring\":\"å\",\"Ascr\":\"𝒜\",\"ascr\":\"𝒶\",\"Assign\":\"≔\",\"ast\":\"*\",\"asymp\":\"≈\",\"asympeq\":\"≍\",\"Atilde\":\"Ã\",\"atilde\":\"ã\",\"Auml\":\"Ä\",\"auml\":\"ä\",\"awconint\":\"∳\",\"awint\":\"⨑\",\"backcong\":\"≌\",\"backepsilon\":\"϶\",\"backprime\":\"‵\",\"backsim\":\"∽\",\"backsimeq\":\"⋍\",\"Backslash\":\"∖\",\"Barv\":\"⫧\",\"barvee\":\"⊽\",\"barwed\":\"⌅\",\"Barwed\":\"⌆\",\"barwedge\":\"⌅\",\"bbrk\":\"⎵\",\"bbrktbrk\":\"⎶\",\"bcong\":\"≌\",\"Bcy\":\"Б\",\"bcy\":\"б\",\"bdquo\":\"„\",\"becaus\":\"∵\",\"because\":\"∵\",\"Because\":\"∵\",\"bemptyv\":\"⦰\",\"bepsi\":\"϶\",\"bernou\":\"ℬ\",\"Bernoullis\":\"ℬ\",\"Beta\":\"Β\",\"beta\":\"β\",\"beth\":\"ℶ\",\"between\":\"≬\",\"Bfr\":\"𝔅\",\"bfr\":\"𝔟\",\"bigcap\":\"⋂\",\"bigcirc\":\"◯\",\"bigcup\":\"⋃\",\"bigodot\":\"⨀\",\"bigoplus\":\"⨁\",\"bigotimes\":\"⨂\",\"bigsqcup\":\"⨆\",\"bigstar\":\"★\",\"bigtriangledown\":\"▽\",\"bigtriangleup\":\"△\",\"biguplus\":\"⨄\",\"bigvee\":\"⋁\",\"bigwedge\":\"⋀\",\"bkarow\":\"⤍\",\"blacklozenge\":\"⧫\",\"blacksquare\":\"▪\",\"blacktriangle\":\"▴\",\"blacktriangledown\":\"▾\",\"blacktriangleleft\":\"◂\",\"blacktriangleright\":\"▸\",\"blank\":\"␣\",\"blk12\":\"▒\",\"blk14\":\"░\",\"blk34\":\"▓\",\"block\":\"█\",\"bne\":\"=⃥\",\"bnequiv\":\"≡⃥\",\"bNot\":\"⫭\",\"bnot\":\"⌐\",\"Bopf\":\"𝔹\",\"bopf\":\"𝕓\",\"bot\":\"⊥\",\"bottom\":\"⊥\",\"bowtie\":\"⋈\",\"boxbox\":\"⧉\",\"boxdl\":\"┐\",\"boxdL\":\"╕\",\"boxDl\":\"╖\",\"boxDL\":\"╗\",\"boxdr\":\"┌\",\"boxdR\":\"╒\",\"boxDr\":\"╓\",\"boxDR\":\"╔\",\"boxh\":\"─\",\"boxH\":\"═\",\"boxhd\":\"┬\",\"boxHd\":\"╤\",\"boxhD\":\"╥\",\"boxHD\":\"╦\",\"boxhu\":\"┴\",\"boxHu\":\"╧\",\"boxhU\":\"╨\",\"boxHU\":\"╩\",\"boxminus\":\"⊟\",\"boxplus\":\"⊞\",\"boxtimes\":\"⊠\",\"boxul\":\"┘\",\"boxuL\":\"╛\",\"boxUl\":\"╜\",\"boxUL\":\"╝\",\"boxur\":\"└\",\"boxuR\":\"╘\",\"boxUr\":\"╙\",\"boxUR\":\"╚\",\"boxv\":\"│\",\"boxV\":\"║\",\"boxvh\":\"┼\",\"boxvH\":\"╪\",\"boxVh\":\"╫\",\"boxVH\":\"╬\",\"boxvl\":\"┤\",\"boxvL\":\"╡\",\"boxVl\":\"╢\",\"boxVL\":\"╣\",\"boxvr\":\"├\",\"boxvR\":\"╞\",\"boxVr\":\"╟\",\"boxVR\":\"╠\",\"bprime\":\"‵\",\"breve\":\"˘\",\"Breve\":\"˘\",\"brvbar\":\"¦\",\"bscr\":\"𝒷\",\"Bscr\":\"ℬ\",\"bsemi\":\"⁏\",\"bsim\":\"∽\",\"bsime\":\"⋍\",\"bsolb\":\"⧅\",\"bsol\":\"\\\\\\\\\",\"bsolhsub\":\"⟈\",\"bull\":\"•\",\"bullet\":\"•\",\"bump\":\"≎\",\"bumpE\":\"⪮\",\"bumpe\":\"≏\",\"Bumpeq\":\"≎\",\"bumpeq\":\"≏\",\"Cacute\":\"Ć\",\"cacute\":\"ć\",\"capand\":\"⩄\",\"capbrcup\":\"⩉\",\"capcap\":\"⩋\",\"cap\":\"∩\",\"Cap\":\"⋒\",\"capcup\":\"⩇\",\"capdot\":\"⩀\",\"CapitalDifferentialD\":\"ⅅ\",\"caps\":\"∩︀\",\"caret\":\"⁁\",\"caron\":\"ˇ\",\"Cayleys\":\"ℭ\",\"ccaps\":\"⩍\",\"Ccaron\":\"Č\",\"ccaron\":\"č\",\"Ccedil\":\"Ç\",\"ccedil\":\"ç\",\"Ccirc\":\"Ĉ\",\"ccirc\":\"ĉ\",\"Cconint\":\"∰\",\"ccups\":\"⩌\",\"ccupssm\":\"⩐\",\"Cdot\":\"Ċ\",\"cdot\":\"ċ\",\"cedil\":\"¸\",\"Cedilla\":\"¸\",\"cemptyv\":\"⦲\",\"cent\":\"¢\",\"centerdot\":\"·\",\"CenterDot\":\"·\",\"cfr\":\"𝔠\",\"Cfr\":\"ℭ\",\"CHcy\":\"Ч\",\"chcy\":\"ч\",\"check\":\"✓\",\"checkmark\":\"✓\",\"Chi\":\"Χ\",\"chi\":\"χ\",\"circ\":\"ˆ\",\"circeq\":\"≗\",\"circlearrowleft\":\"↺\",\"circlearrowright\":\"↻\",\"circledast\":\"⊛\",\"circledcirc\":\"⊚\",\"circleddash\":\"⊝\",\"CircleDot\":\"⊙\",\"circledR\":\"®\",\"circledS\":\"Ⓢ\",\"CircleMinus\":\"⊖\",\"CirclePlus\":\"⊕\",\"CircleTimes\":\"⊗\",\"cir\":\"○\",\"cirE\":\"⧃\",\"cire\":\"≗\",\"cirfnint\":\"⨐\",\"cirmid\":\"⫯\",\"cirscir\":\"⧂\",\"ClockwiseContourIntegral\":\"∲\",\"CloseCurlyDoubleQuote\":\"”\",\"CloseCurlyQuote\":\"’\",\"clubs\":\"♣\",\"clubsuit\":\"♣\",\"colon\":\":\",\"Colon\":\"∷\",\"Colone\":\"⩴\",\"colone\":\"≔\",\"coloneq\":\"≔\",\"comma\":\",\",\"commat\":\"@\",\"comp\":\"∁\",\"compfn\":\"∘\",\"complement\":\"∁\",\"complexes\":\"ℂ\",\"cong\":\"≅\",\"congdot\":\"⩭\",\"Congruent\":\"≡\",\"conint\":\"∮\",\"Conint\":\"∯\",\"ContourIntegral\":\"∮\",\"copf\":\"𝕔\",\"Copf\":\"ℂ\",\"coprod\":\"∐\",\"Coproduct\":\"∐\",\"copy\":\"©\",\"COPY\":\"©\",\"copysr\":\"℗\",\"CounterClockwiseContourIntegral\":\"∳\",\"crarr\":\"↵\",\"cross\":\"✗\",\"Cross\":\"⨯\",\"Cscr\":\"𝒞\",\"cscr\":\"𝒸\",\"csub\":\"⫏\",\"csube\":\"⫑\",\"csup\":\"⫐\",\"csupe\":\"⫒\",\"ctdot\":\"⋯\",\"cudarrl\":\"⤸\",\"cudarrr\":\"⤵\",\"cuepr\":\"⋞\",\"cuesc\":\"⋟\",\"cularr\":\"↶\",\"cularrp\":\"⤽\",\"cupbrcap\":\"⩈\",\"cupcap\":\"⩆\",\"CupCap\":\"≍\",\"cup\":\"∪\",\"Cup\":\"⋓\",\"cupcup\":\"⩊\",\"cupdot\":\"⊍\",\"cupor\":\"⩅\",\"cups\":\"∪︀\",\"curarr\":\"↷\",\"curarrm\":\"⤼\",\"curlyeqprec\":\"⋞\",\"curlyeqsucc\":\"⋟\",\"curlyvee\":\"⋎\",\"curlywedge\":\"⋏\",\"curren\":\"¤\",\"curvearrowleft\":\"↶\",\"curvearrowright\":\"↷\",\"cuvee\":\"⋎\",\"cuwed\":\"⋏\",\"cwconint\":\"∲\",\"cwint\":\"∱\",\"cylcty\":\"⌭\",\"dagger\":\"†\",\"Dagger\":\"‡\",\"daleth\":\"ℸ\",\"darr\":\"↓\",\"Darr\":\"↡\",\"dArr\":\"⇓\",\"dash\":\"‐\",\"Dashv\":\"⫤\",\"dashv\":\"⊣\",\"dbkarow\":\"⤏\",\"dblac\":\"˝\",\"Dcaron\":\"Ď\",\"dcaron\":\"ď\",\"Dcy\":\"Д\",\"dcy\":\"д\",\"ddagger\":\"‡\",\"ddarr\":\"⇊\",\"DD\":\"ⅅ\",\"dd\":\"ⅆ\",\"DDotrahd\":\"⤑\",\"ddotseq\":\"⩷\",\"deg\":\"°\",\"Del\":\"∇\",\"Delta\":\"Δ\",\"delta\":\"δ\",\"demptyv\":\"⦱\",\"dfisht\":\"⥿\",\"Dfr\":\"𝔇\",\"dfr\":\"𝔡\",\"dHar\":\"⥥\",\"dharl\":\"⇃\",\"dharr\":\"⇂\",\"DiacriticalAcute\":\"´\",\"DiacriticalDot\":\"˙\",\"DiacriticalDoubleAcute\":\"˝\",\"DiacriticalGrave\":\"`\",\"DiacriticalTilde\":\"˜\",\"diam\":\"⋄\",\"diamond\":\"⋄\",\"Diamond\":\"⋄\",\"diamondsuit\":\"♦\",\"diams\":\"♦\",\"die\":\"¨\",\"DifferentialD\":\"ⅆ\",\"digamma\":\"ϝ\",\"disin\":\"⋲\",\"div\":\"÷\",\"divide\":\"÷\",\"divideontimes\":\"⋇\",\"divonx\":\"⋇\",\"DJcy\":\"Ђ\",\"djcy\":\"ђ\",\"dlcorn\":\"⌞\",\"dlcrop\":\"⌍\",\"dollar\":\"$\",\"Dopf\":\"𝔻\",\"dopf\":\"𝕕\",\"Dot\":\"¨\",\"dot\":\"˙\",\"DotDot\":\"⃜\",\"doteq\":\"≐\",\"doteqdot\":\"≑\",\"DotEqual\":\"≐\",\"dotminus\":\"∸\",\"dotplus\":\"∔\",\"dotsquare\":\"⊡\",\"doublebarwedge\":\"⌆\",\"DoubleContourIntegral\":\"∯\",\"DoubleDot\":\"¨\",\"DoubleDownArrow\":\"⇓\",\"DoubleLeftArrow\":\"⇐\",\"DoubleLeftRightArrow\":\"⇔\",\"DoubleLeftTee\":\"⫤\",\"DoubleLongLeftArrow\":\"⟸\",\"DoubleLongLeftRightArrow\":\"⟺\",\"DoubleLongRightArrow\":\"⟹\",\"DoubleRightArrow\":\"⇒\",\"DoubleRightTee\":\"⊨\",\"DoubleUpArrow\":\"⇑\",\"DoubleUpDownArrow\":\"⇕\",\"DoubleVerticalBar\":\"∥\",\"DownArrowBar\":\"⤓\",\"downarrow\":\"↓\",\"DownArrow\":\"↓\",\"Downarrow\":\"⇓\",\"DownArrowUpArrow\":\"⇵\",\"DownBreve\":\"̑\",\"downdownarrows\":\"⇊\",\"downharpoonleft\":\"⇃\",\"downharpoonright\":\"⇂\",\"DownLeftRightVector\":\"⥐\",\"DownLeftTeeVector\":\"⥞\",\"DownLeftVectorBar\":\"⥖\",\"DownLeftVector\":\"↽\",\"DownRightTeeVector\":\"⥟\",\"DownRightVectorBar\":\"⥗\",\"DownRightVector\":\"⇁\",\"DownTeeArrow\":\"↧\",\"DownTee\":\"⊤\",\"drbkarow\":\"⤐\",\"drcorn\":\"⌟\",\"drcrop\":\"⌌\",\"Dscr\":\"𝒟\",\"dscr\":\"𝒹\",\"DScy\":\"Ѕ\",\"dscy\":\"ѕ\",\"dsol\":\"⧶\",\"Dstrok\":\"Đ\",\"dstrok\":\"đ\",\"dtdot\":\"⋱\",\"dtri\":\"▿\",\"dtrif\":\"▾\",\"duarr\":\"⇵\",\"duhar\":\"⥯\",\"dwangle\":\"⦦\",\"DZcy\":\"Џ\",\"dzcy\":\"џ\",\"dzigrarr\":\"⟿\",\"Eacute\":\"É\",\"eacute\":\"é\",\"easter\":\"⩮\",\"Ecaron\":\"Ě\",\"ecaron\":\"ě\",\"Ecirc\":\"Ê\",\"ecirc\":\"ê\",\"ecir\":\"≖\",\"ecolon\":\"≕\",\"Ecy\":\"Э\",\"ecy\":\"э\",\"eDDot\":\"⩷\",\"Edot\":\"Ė\",\"edot\":\"ė\",\"eDot\":\"≑\",\"ee\":\"ⅇ\",\"efDot\":\"≒\",\"Efr\":\"𝔈\",\"efr\":\"𝔢\",\"eg\":\"⪚\",\"Egrave\":\"È\",\"egrave\":\"è\",\"egs\":\"⪖\",\"egsdot\":\"⪘\",\"el\":\"⪙\",\"Element\":\"∈\",\"elinters\":\"⏧\",\"ell\":\"ℓ\",\"els\":\"⪕\",\"elsdot\":\"⪗\",\"Emacr\":\"Ē\",\"emacr\":\"ē\",\"empty\":\"∅\",\"emptyset\":\"∅\",\"EmptySmallSquare\":\"◻\",\"emptyv\":\"∅\",\"EmptyVerySmallSquare\":\"▫\",\"emsp13\":\" \",\"emsp14\":\" \",\"emsp\":\" \",\"ENG\":\"Ŋ\",\"eng\":\"ŋ\",\"ensp\":\" \",\"Eogon\":\"Ę\",\"eogon\":\"ę\",\"Eopf\":\"𝔼\",\"eopf\":\"𝕖\",\"epar\":\"⋕\",\"eparsl\":\"⧣\",\"eplus\":\"⩱\",\"epsi\":\"ε\",\"Epsilon\":\"Ε\",\"epsilon\":\"ε\",\"epsiv\":\"ϵ\",\"eqcirc\":\"≖\",\"eqcolon\":\"≕\",\"eqsim\":\"≂\",\"eqslantgtr\":\"⪖\",\"eqslantless\":\"⪕\",\"Equal\":\"⩵\",\"equals\":\"=\",\"EqualTilde\":\"≂\",\"equest\":\"≟\",\"Equilibrium\":\"⇌\",\"equiv\":\"≡\",\"equivDD\":\"⩸\",\"eqvparsl\":\"⧥\",\"erarr\":\"⥱\",\"erDot\":\"≓\",\"escr\":\"ℯ\",\"Escr\":\"ℰ\",\"esdot\":\"≐\",\"Esim\":\"⩳\",\"esim\":\"≂\",\"Eta\":\"Η\",\"eta\":\"η\",\"ETH\":\"Ð\",\"eth\":\"ð\",\"Euml\":\"Ë\",\"euml\":\"ë\",\"euro\":\"€\",\"excl\":\"!\",\"exist\":\"∃\",\"Exists\":\"∃\",\"expectation\":\"ℰ\",\"exponentiale\":\"ⅇ\",\"ExponentialE\":\"ⅇ\",\"fallingdotseq\":\"≒\",\"Fcy\":\"Ф\",\"fcy\":\"ф\",\"female\":\"♀\",\"ffilig\":\"ﬃ\",\"fflig\":\"ﬀ\",\"ffllig\":\"ﬄ\",\"Ffr\":\"𝔉\",\"ffr\":\"𝔣\",\"filig\":\"ﬁ\",\"FilledSmallSquare\":\"◼\",\"FilledVerySmallSquare\":\"▪\",\"fjlig\":\"fj\",\"flat\":\"♭\",\"fllig\":\"ﬂ\",\"fltns\":\"▱\",\"fnof\":\"ƒ\",\"Fopf\":\"𝔽\",\"fopf\":\"𝕗\",\"forall\":\"∀\",\"ForAll\":\"∀\",\"fork\":\"⋔\",\"forkv\":\"⫙\",\"Fouriertrf\":\"ℱ\",\"fpartint\":\"⨍\",\"frac12\":\"½\",\"frac13\":\"⅓\",\"frac14\":\"¼\",\"frac15\":\"⅕\",\"frac16\":\"⅙\",\"frac18\":\"⅛\",\"frac23\":\"⅔\",\"frac25\":\"⅖\",\"frac34\":\"¾\",\"frac35\":\"⅗\",\"frac38\":\"⅜\",\"frac45\":\"⅘\",\"frac56\":\"⅚\",\"frac58\":\"⅝\",\"frac78\":\"⅞\",\"frasl\":\"⁄\",\"frown\":\"⌢\",\"fscr\":\"𝒻\",\"Fscr\":\"ℱ\",\"gacute\":\"ǵ\",\"Gamma\":\"Γ\",\"gamma\":\"γ\",\"Gammad\":\"Ϝ\",\"gammad\":\"ϝ\",\"gap\":\"⪆\",\"Gbreve\":\"Ğ\",\"gbreve\":\"ğ\",\"Gcedil\":\"Ģ\",\"Gcirc\":\"Ĝ\",\"gcirc\":\"ĝ\",\"Gcy\":\"Г\",\"gcy\":\"г\",\"Gdot\":\"Ġ\",\"gdot\":\"ġ\",\"ge\":\"≥\",\"gE\":\"≧\",\"gEl\":\"⪌\",\"gel\":\"⋛\",\"geq\":\"≥\",\"geqq\":\"≧\",\"geqslant\":\"⩾\",\"gescc\":\"⪩\",\"ges\":\"⩾\",\"gesdot\":\"⪀\",\"gesdoto\":\"⪂\",\"gesdotol\":\"⪄\",\"gesl\":\"⋛︀\",\"gesles\":\"⪔\",\"Gfr\":\"𝔊\",\"gfr\":\"𝔤\",\"gg\":\"≫\",\"Gg\":\"⋙\",\"ggg\":\"⋙\",\"gimel\":\"ℷ\",\"GJcy\":\"Ѓ\",\"gjcy\":\"ѓ\",\"gla\":\"⪥\",\"gl\":\"≷\",\"glE\":\"⪒\",\"glj\":\"⪤\",\"gnap\":\"⪊\",\"gnapprox\":\"⪊\",\"gne\":\"⪈\",\"gnE\":\"≩\",\"gneq\":\"⪈\",\"gneqq\":\"≩\",\"gnsim\":\"⋧\",\"Gopf\":\"𝔾\",\"gopf\":\"𝕘\",\"grave\":\"`\",\"GreaterEqual\":\"≥\",\"GreaterEqualLess\":\"⋛\",\"GreaterFullEqual\":\"≧\",\"GreaterGreater\":\"⪢\",\"GreaterLess\":\"≷\",\"GreaterSlantEqual\":\"⩾\",\"GreaterTilde\":\"≳\",\"Gscr\":\"𝒢\",\"gscr\":\"ℊ\",\"gsim\":\"≳\",\"gsime\":\"⪎\",\"gsiml\":\"⪐\",\"gtcc\":\"⪧\",\"gtcir\":\"⩺\",\"gt\":\">\",\"GT\":\">\",\"Gt\":\"≫\",\"gtdot\":\"⋗\",\"gtlPar\":\"⦕\",\"gtquest\":\"⩼\",\"gtrapprox\":\"⪆\",\"gtrarr\":\"⥸\",\"gtrdot\":\"⋗\",\"gtreqless\":\"⋛\",\"gtreqqless\":\"⪌\",\"gtrless\":\"≷\",\"gtrsim\":\"≳\",\"gvertneqq\":\"≩︀\",\"gvnE\":\"≩︀\",\"Hacek\":\"ˇ\",\"hairsp\":\" \",\"half\":\"½\",\"hamilt\":\"ℋ\",\"HARDcy\":\"Ъ\",\"hardcy\":\"ъ\",\"harrcir\":\"⥈\",\"harr\":\"↔\",\"hArr\":\"⇔\",\"harrw\":\"↭\",\"Hat\":\"^\",\"hbar\":\"ℏ\",\"Hcirc\":\"Ĥ\",\"hcirc\":\"ĥ\",\"hearts\":\"♥\",\"heartsuit\":\"♥\",\"hellip\":\"…\",\"hercon\":\"⊹\",\"hfr\":\"𝔥\",\"Hfr\":\"ℌ\",\"HilbertSpace\":\"ℋ\",\"hksearow\":\"⤥\",\"hkswarow\":\"⤦\",\"hoarr\":\"⇿\",\"homtht\":\"∻\",\"hookleftarrow\":\"↩\",\"hookrightarrow\":\"↪\",\"hopf\":\"𝕙\",\"Hopf\":\"ℍ\",\"horbar\":\"―\",\"HorizontalLine\":\"─\",\"hscr\":\"𝒽\",\"Hscr\":\"ℋ\",\"hslash\":\"ℏ\",\"Hstrok\":\"Ħ\",\"hstrok\":\"ħ\",\"HumpDownHump\":\"≎\",\"HumpEqual\":\"≏\",\"hybull\":\"⁃\",\"hyphen\":\"‐\",\"Iacute\":\"Í\",\"iacute\":\"í\",\"ic\":\"⁣\",\"Icirc\":\"Î\",\"icirc\":\"î\",\"Icy\":\"И\",\"icy\":\"и\",\"Idot\":\"İ\",\"IEcy\":\"Е\",\"iecy\":\"е\",\"iexcl\":\"¡\",\"iff\":\"⇔\",\"ifr\":\"𝔦\",\"Ifr\":\"ℑ\",\"Igrave\":\"Ì\",\"igrave\":\"ì\",\"ii\":\"ⅈ\",\"iiiint\":\"⨌\",\"iiint\":\"∭\",\"iinfin\":\"⧜\",\"iiota\":\"℩\",\"IJlig\":\"Ĳ\",\"ijlig\":\"ĳ\",\"Imacr\":\"Ī\",\"imacr\":\"ī\",\"image\":\"ℑ\",\"ImaginaryI\":\"ⅈ\",\"imagline\":\"ℐ\",\"imagpart\":\"ℑ\",\"imath\":\"ı\",\"Im\":\"ℑ\",\"imof\":\"⊷\",\"imped\":\"Ƶ\",\"Implies\":\"⇒\",\"incare\":\"℅\",\"in\":\"∈\",\"infin\":\"∞\",\"infintie\":\"⧝\",\"inodot\":\"ı\",\"intcal\":\"⊺\",\"int\":\"∫\",\"Int\":\"∬\",\"integers\":\"ℤ\",\"Integral\":\"∫\",\"intercal\":\"⊺\",\"Intersection\":\"⋂\",\"intlarhk\":\"⨗\",\"intprod\":\"⨼\",\"InvisibleComma\":\"⁣\",\"InvisibleTimes\":\"⁢\",\"IOcy\":\"Ё\",\"iocy\":\"ё\",\"Iogon\":\"Į\",\"iogon\":\"į\",\"Iopf\":\"𝕀\",\"iopf\":\"𝕚\",\"Iota\":\"Ι\",\"iota\":\"ι\",\"iprod\":\"⨼\",\"iquest\":\"¿\",\"iscr\":\"𝒾\",\"Iscr\":\"ℐ\",\"isin\":\"∈\",\"isindot\":\"⋵\",\"isinE\":\"⋹\",\"isins\":\"⋴\",\"isinsv\":\"⋳\",\"isinv\":\"∈\",\"it\":\"⁢\",\"Itilde\":\"Ĩ\",\"itilde\":\"ĩ\",\"Iukcy\":\"І\",\"iukcy\":\"і\",\"Iuml\":\"Ï\",\"iuml\":\"ï\",\"Jcirc\":\"Ĵ\",\"jcirc\":\"ĵ\",\"Jcy\":\"Й\",\"jcy\":\"й\",\"Jfr\":\"𝔍\",\"jfr\":\"𝔧\",\"jmath\":\"ȷ\",\"Jopf\":\"𝕁\",\"jopf\":\"𝕛\",\"Jscr\":\"𝒥\",\"jscr\":\"𝒿\",\"Jsercy\":\"Ј\",\"jsercy\":\"ј\",\"Jukcy\":\"Є\",\"jukcy\":\"є\",\"Kappa\":\"Κ\",\"kappa\":\"κ\",\"kappav\":\"ϰ\",\"Kcedil\":\"Ķ\",\"kcedil\":\"ķ\",\"Kcy\":\"К\",\"kcy\":\"к\",\"Kfr\":\"𝔎\",\"kfr\":\"𝔨\",\"kgreen\":\"ĸ\",\"KHcy\":\"Х\",\"khcy\":\"х\",\"KJcy\":\"Ќ\",\"kjcy\":\"ќ\",\"Kopf\":\"𝕂\",\"kopf\":\"𝕜\",\"Kscr\":\"𝒦\",\"kscr\":\"𝓀\",\"lAarr\":\"⇚\",\"Lacute\":\"Ĺ\",\"lacute\":\"ĺ\",\"laemptyv\":\"⦴\",\"lagran\":\"ℒ\",\"Lambda\":\"Λ\",\"lambda\":\"λ\",\"lang\":\"⟨\",\"Lang\":\"⟪\",\"langd\":\"⦑\",\"langle\":\"⟨\",\"lap\":\"⪅\",\"Laplacetrf\":\"ℒ\",\"laquo\":\"«\",\"larrb\":\"⇤\",\"larrbfs\":\"⤟\",\"larr\":\"←\",\"Larr\":\"↞\",\"lArr\":\"⇐\",\"larrfs\":\"⤝\",\"larrhk\":\"↩\",\"larrlp\":\"↫\",\"larrpl\":\"⤹\",\"larrsim\":\"⥳\",\"larrtl\":\"↢\",\"latail\":\"⤙\",\"lAtail\":\"⤛\",\"lat\":\"⪫\",\"late\":\"⪭\",\"lates\":\"⪭︀\",\"lbarr\":\"⤌\",\"lBarr\":\"⤎\",\"lbbrk\":\"❲\",\"lbrace\":\"{\",\"lbrack\":\"[\",\"lbrke\":\"⦋\",\"lbrksld\":\"⦏\",\"lbrkslu\":\"⦍\",\"Lcaron\":\"Ľ\",\"lcaron\":\"ľ\",\"Lcedil\":\"Ļ\",\"lcedil\":\"ļ\",\"lceil\":\"⌈\",\"lcub\":\"{\",\"Lcy\":\"Л\",\"lcy\":\"л\",\"ldca\":\"⤶\",\"ldquo\":\"“\",\"ldquor\":\"„\",\"ldrdhar\":\"⥧\",\"ldrushar\":\"⥋\",\"ldsh\":\"↲\",\"le\":\"≤\",\"lE\":\"≦\",\"LeftAngleBracket\":\"⟨\",\"LeftArrowBar\":\"⇤\",\"leftarrow\":\"←\",\"LeftArrow\":\"←\",\"Leftarrow\":\"⇐\",\"LeftArrowRightArrow\":\"⇆\",\"leftarrowtail\":\"↢\",\"LeftCeiling\":\"⌈\",\"LeftDoubleBracket\":\"⟦\",\"LeftDownTeeVector\":\"⥡\",\"LeftDownVectorBar\":\"⥙\",\"LeftDownVector\":\"⇃\",\"LeftFloor\":\"⌊\",\"leftharpoondown\":\"↽\",\"leftharpoonup\":\"↼\",\"leftleftarrows\":\"⇇\",\"leftrightarrow\":\"↔\",\"LeftRightArrow\":\"↔\",\"Leftrightarrow\":\"⇔\",\"leftrightarrows\":\"⇆\",\"leftrightharpoons\":\"⇋\",\"leftrightsquigarrow\":\"↭\",\"LeftRightVector\":\"⥎\",\"LeftTeeArrow\":\"↤\",\"LeftTee\":\"⊣\",\"LeftTeeVector\":\"⥚\",\"leftthreetimes\":\"⋋\",\"LeftTriangleBar\":\"⧏\",\"LeftTriangle\":\"⊲\",\"LeftTriangleEqual\":\"⊴\",\"LeftUpDownVector\":\"⥑\",\"LeftUpTeeVector\":\"⥠\",\"LeftUpVectorBar\":\"⥘\",\"LeftUpVector\":\"↿\",\"LeftVectorBar\":\"⥒\",\"LeftVector\":\"↼\",\"lEg\":\"⪋\",\"leg\":\"⋚\",\"leq\":\"≤\",\"leqq\":\"≦\",\"leqslant\":\"⩽\",\"lescc\":\"⪨\",\"les\":\"⩽\",\"lesdot\":\"⩿\",\"lesdoto\":\"⪁\",\"lesdotor\":\"⪃\",\"lesg\":\"⋚︀\",\"lesges\":\"⪓\",\"lessapprox\":\"⪅\",\"lessdot\":\"⋖\",\"lesseqgtr\":\"⋚\",\"lesseqqgtr\":\"⪋\",\"LessEqualGreater\":\"⋚\",\"LessFullEqual\":\"≦\",\"LessGreater\":\"≶\",\"lessgtr\":\"≶\",\"LessLess\":\"⪡\",\"lesssim\":\"≲\",\"LessSlantEqual\":\"⩽\",\"LessTilde\":\"≲\",\"lfisht\":\"⥼\",\"lfloor\":\"⌊\",\"Lfr\":\"𝔏\",\"lfr\":\"𝔩\",\"lg\":\"≶\",\"lgE\":\"⪑\",\"lHar\":\"⥢\",\"lhard\":\"↽\",\"lharu\":\"↼\",\"lharul\":\"⥪\",\"lhblk\":\"▄\",\"LJcy\":\"Љ\",\"ljcy\":\"љ\",\"llarr\":\"⇇\",\"ll\":\"≪\",\"Ll\":\"⋘\",\"llcorner\":\"⌞\",\"Lleftarrow\":\"⇚\",\"llhard\":\"⥫\",\"lltri\":\"◺\",\"Lmidot\":\"Ŀ\",\"lmidot\":\"ŀ\",\"lmoustache\":\"⎰\",\"lmoust\":\"⎰\",\"lnap\":\"⪉\",\"lnapprox\":\"⪉\",\"lne\":\"⪇\",\"lnE\":\"≨\",\"lneq\":\"⪇\",\"lneqq\":\"≨\",\"lnsim\":\"⋦\",\"loang\":\"⟬\",\"loarr\":\"⇽\",\"lobrk\":\"⟦\",\"longleftarrow\":\"⟵\",\"LongLeftArrow\":\"⟵\",\"Longleftarrow\":\"⟸\",\"longleftrightarrow\":\"⟷\",\"LongLeftRightArrow\":\"⟷\",\"Longleftrightarrow\":\"⟺\",\"longmapsto\":\"⟼\",\"longrightarrow\":\"⟶\",\"LongRightArrow\":\"⟶\",\"Longrightarrow\":\"⟹\",\"looparrowleft\":\"↫\",\"looparrowright\":\"↬\",\"lopar\":\"⦅\",\"Lopf\":\"𝕃\",\"lopf\":\"𝕝\",\"loplus\":\"⨭\",\"lotimes\":\"⨴\",\"lowast\":\"∗\",\"lowbar\":\"_\",\"LowerLeftArrow\":\"↙\",\"LowerRightArrow\":\"↘\",\"loz\":\"◊\",\"lozenge\":\"◊\",\"lozf\":\"⧫\",\"lpar\":\"(\",\"lparlt\":\"⦓\",\"lrarr\":\"⇆\",\"lrcorner\":\"⌟\",\"lrhar\":\"⇋\",\"lrhard\":\"⥭\",\"lrm\":\"‎\",\"lrtri\":\"⊿\",\"lsaquo\":\"‹\",\"lscr\":\"𝓁\",\"Lscr\":\"ℒ\",\"lsh\":\"↰\",\"Lsh\":\"↰\",\"lsim\":\"≲\",\"lsime\":\"⪍\",\"lsimg\":\"⪏\",\"lsqb\":\"[\",\"lsquo\":\"‘\",\"lsquor\":\"‚\",\"Lstrok\":\"Ł\",\"lstrok\":\"ł\",\"ltcc\":\"⪦\",\"ltcir\":\"⩹\",\"lt\":\"<\",\"LT\":\"<\",\"Lt\":\"≪\",\"ltdot\":\"⋖\",\"lthree\":\"⋋\",\"ltimes\":\"⋉\",\"ltlarr\":\"⥶\",\"ltquest\":\"⩻\",\"ltri\":\"◃\",\"ltrie\":\"⊴\",\"ltrif\":\"◂\",\"ltrPar\":\"⦖\",\"lurdshar\":\"⥊\",\"luruhar\":\"⥦\",\"lvertneqq\":\"≨︀\",\"lvnE\":\"≨︀\",\"macr\":\"¯\",\"male\":\"♂\",\"malt\":\"✠\",\"maltese\":\"✠\",\"Map\":\"⤅\",\"map\":\"↦\",\"mapsto\":\"↦\",\"mapstodown\":\"↧\",\"mapstoleft\":\"↤\",\"mapstoup\":\"↥\",\"marker\":\"▮\",\"mcomma\":\"⨩\",\"Mcy\":\"М\",\"mcy\":\"м\",\"mdash\":\"—\",\"mDDot\":\"∺\",\"measuredangle\":\"∡\",\"MediumSpace\":\" \",\"Mellintrf\":\"ℳ\",\"Mfr\":\"𝔐\",\"mfr\":\"𝔪\",\"mho\":\"℧\",\"micro\":\"µ\",\"midast\":\"*\",\"midcir\":\"⫰\",\"mid\":\"∣\",\"middot\":\"·\",\"minusb\":\"⊟\",\"minus\":\"−\",\"minusd\":\"∸\",\"minusdu\":\"⨪\",\"MinusPlus\":\"∓\",\"mlcp\":\"⫛\",\"mldr\":\"…\",\"mnplus\":\"∓\",\"models\":\"⊧\",\"Mopf\":\"𝕄\",\"mopf\":\"𝕞\",\"mp\":\"∓\",\"mscr\":\"𝓂\",\"Mscr\":\"ℳ\",\"mstpos\":\"∾\",\"Mu\":\"Μ\",\"mu\":\"μ\",\"multimap\":\"⊸\",\"mumap\":\"⊸\",\"nabla\":\"∇\",\"Nacute\":\"Ń\",\"nacute\":\"ń\",\"nang\":\"∠⃒\",\"nap\":\"≉\",\"napE\":\"⩰̸\",\"napid\":\"≋̸\",\"napos\":\"ŉ\",\"napprox\":\"≉\",\"natural\":\"♮\",\"naturals\":\"ℕ\",\"natur\":\"♮\",\"nbsp\":\" \",\"nbump\":\"≎̸\",\"nbumpe\":\"≏̸\",\"ncap\":\"⩃\",\"Ncaron\":\"Ň\",\"ncaron\":\"ň\",\"Ncedil\":\"Ņ\",\"ncedil\":\"ņ\",\"ncong\":\"≇\",\"ncongdot\":\"⩭̸\",\"ncup\":\"⩂\",\"Ncy\":\"Н\",\"ncy\":\"н\",\"ndash\":\"–\",\"nearhk\":\"⤤\",\"nearr\":\"↗\",\"neArr\":\"⇗\",\"nearrow\":\"↗\",\"ne\":\"≠\",\"nedot\":\"≐̸\",\"NegativeMediumSpace\":\"​\",\"NegativeThickSpace\":\"​\",\"NegativeThinSpace\":\"​\",\"NegativeVeryThinSpace\":\"​\",\"nequiv\":\"≢\",\"nesear\":\"⤨\",\"nesim\":\"≂̸\",\"NestedGreaterGreater\":\"≫\",\"NestedLessLess\":\"≪\",\"NewLine\":\"\\\\n\",\"nexist\":\"∄\",\"nexists\":\"∄\",\"Nfr\":\"𝔑\",\"nfr\":\"𝔫\",\"ngE\":\"≧̸\",\"nge\":\"≱\",\"ngeq\":\"≱\",\"ngeqq\":\"≧̸\",\"ngeqslant\":\"⩾̸\",\"nges\":\"⩾̸\",\"nGg\":\"⋙̸\",\"ngsim\":\"≵\",\"nGt\":\"≫⃒\",\"ngt\":\"≯\",\"ngtr\":\"≯\",\"nGtv\":\"≫̸\",\"nharr\":\"↮\",\"nhArr\":\"⇎\",\"nhpar\":\"⫲\",\"ni\":\"∋\",\"nis\":\"⋼\",\"nisd\":\"⋺\",\"niv\":\"∋\",\"NJcy\":\"Њ\",\"njcy\":\"њ\",\"nlarr\":\"↚\",\"nlArr\":\"⇍\",\"nldr\":\"‥\",\"nlE\":\"≦̸\",\"nle\":\"≰\",\"nleftarrow\":\"↚\",\"nLeftarrow\":\"⇍\",\"nleftrightarrow\":\"↮\",\"nLeftrightarrow\":\"⇎\",\"nleq\":\"≰\",\"nleqq\":\"≦̸\",\"nleqslant\":\"⩽̸\",\"nles\":\"⩽̸\",\"nless\":\"≮\",\"nLl\":\"⋘̸\",\"nlsim\":\"≴\",\"nLt\":\"≪⃒\",\"nlt\":\"≮\",\"nltri\":\"⋪\",\"nltrie\":\"⋬\",\"nLtv\":\"≪̸\",\"nmid\":\"∤\",\"NoBreak\":\"⁠\",\"NonBreakingSpace\":\" \",\"nopf\":\"𝕟\",\"Nopf\":\"ℕ\",\"Not\":\"⫬\",\"not\":\"¬\",\"NotCongruent\":\"≢\",\"NotCupCap\":\"≭\",\"NotDoubleVerticalBar\":\"∦\",\"NotElement\":\"∉\",\"NotEqual\":\"≠\",\"NotEqualTilde\":\"≂̸\",\"NotExists\":\"∄\",\"NotGreater\":\"≯\",\"NotGreaterEqual\":\"≱\",\"NotGreaterFullEqual\":\"≧̸\",\"NotGreaterGreater\":\"≫̸\",\"NotGreaterLess\":\"≹\",\"NotGreaterSlantEqual\":\"⩾̸\",\"NotGreaterTilde\":\"≵\",\"NotHumpDownHump\":\"≎̸\",\"NotHumpEqual\":\"≏̸\",\"notin\":\"∉\",\"notindot\":\"⋵̸\",\"notinE\":\"⋹̸\",\"notinva\":\"∉\",\"notinvb\":\"⋷\",\"notinvc\":\"⋶\",\"NotLeftTriangleBar\":\"⧏̸\",\"NotLeftTriangle\":\"⋪\",\"NotLeftTriangleEqual\":\"⋬\",\"NotLess\":\"≮\",\"NotLessEqual\":\"≰\",\"NotLessGreater\":\"≸\",\"NotLessLess\":\"≪̸\",\"NotLessSlantEqual\":\"⩽̸\",\"NotLessTilde\":\"≴\",\"NotNestedGreaterGreater\":\"⪢̸\",\"NotNestedLessLess\":\"⪡̸\",\"notni\":\"∌\",\"notniva\":\"∌\",\"notnivb\":\"⋾\",\"notnivc\":\"⋽\",\"NotPrecedes\":\"⊀\",\"NotPrecedesEqual\":\"⪯̸\",\"NotPrecedesSlantEqual\":\"⋠\",\"NotReverseElement\":\"∌\",\"NotRightTriangleBar\":\"⧐̸\",\"NotRightTriangle\":\"⋫\",\"NotRightTriangleEqual\":\"⋭\",\"NotSquareSubset\":\"⊏̸\",\"NotSquareSubsetEqual\":\"⋢\",\"NotSquareSuperset\":\"⊐̸\",\"NotSquareSupersetEqual\":\"⋣\",\"NotSubset\":\"⊂⃒\",\"NotSubsetEqual\":\"⊈\",\"NotSucceeds\":\"⊁\",\"NotSucceedsEqual\":\"⪰̸\",\"NotSucceedsSlantEqual\":\"⋡\",\"NotSucceedsTilde\":\"≿̸\",\"NotSuperset\":\"⊃⃒\",\"NotSupersetEqual\":\"⊉\",\"NotTilde\":\"≁\",\"NotTildeEqual\":\"≄\",\"NotTildeFullEqual\":\"≇\",\"NotTildeTilde\":\"≉\",\"NotVerticalBar\":\"∤\",\"nparallel\":\"∦\",\"npar\":\"∦\",\"nparsl\":\"⫽⃥\",\"npart\":\"∂̸\",\"npolint\":\"⨔\",\"npr\":\"⊀\",\"nprcue\":\"⋠\",\"nprec\":\"⊀\",\"npreceq\":\"⪯̸\",\"npre\":\"⪯̸\",\"nrarrc\":\"⤳̸\",\"nrarr\":\"↛\",\"nrArr\":\"⇏\",\"nrarrw\":\"↝̸\",\"nrightarrow\":\"↛\",\"nRightarrow\":\"⇏\",\"nrtri\":\"⋫\",\"nrtrie\":\"⋭\",\"nsc\":\"⊁\",\"nsccue\":\"⋡\",\"nsce\":\"⪰̸\",\"Nscr\":\"𝒩\",\"nscr\":\"𝓃\",\"nshortmid\":\"∤\",\"nshortparallel\":\"∦\",\"nsim\":\"≁\",\"nsime\":\"≄\",\"nsimeq\":\"≄\",\"nsmid\":\"∤\",\"nspar\":\"∦\",\"nsqsube\":\"⋢\",\"nsqsupe\":\"⋣\",\"nsub\":\"⊄\",\"nsubE\":\"⫅̸\",\"nsube\":\"⊈\",\"nsubset\":\"⊂⃒\",\"nsubseteq\":\"⊈\",\"nsubseteqq\":\"⫅̸\",\"nsucc\":\"⊁\",\"nsucceq\":\"⪰̸\",\"nsup\":\"⊅\",\"nsupE\":\"⫆̸\",\"nsupe\":\"⊉\",\"nsupset\":\"⊃⃒\",\"nsupseteq\":\"⊉\",\"nsupseteqq\":\"⫆̸\",\"ntgl\":\"≹\",\"Ntilde\":\"Ñ\",\"ntilde\":\"ñ\",\"ntlg\":\"≸\",\"ntriangleleft\":\"⋪\",\"ntrianglelefteq\":\"⋬\",\"ntriangleright\":\"⋫\",\"ntrianglerighteq\":\"⋭\",\"Nu\":\"Ν\",\"nu\":\"ν\",\"num\":\"#\",\"numero\":\"№\",\"numsp\":\" \",\"nvap\":\"≍⃒\",\"nvdash\":\"⊬\",\"nvDash\":\"⊭\",\"nVdash\":\"⊮\",\"nVDash\":\"⊯\",\"nvge\":\"≥⃒\",\"nvgt\":\">⃒\",\"nvHarr\":\"⤄\",\"nvinfin\":\"⧞\",\"nvlArr\":\"⤂\",\"nvle\":\"≤⃒\",\"nvlt\":\"<⃒\",\"nvltrie\":\"⊴⃒\",\"nvrArr\":\"⤃\",\"nvrtrie\":\"⊵⃒\",\"nvsim\":\"∼⃒\",\"nwarhk\":\"⤣\",\"nwarr\":\"↖\",\"nwArr\":\"⇖\",\"nwarrow\":\"↖\",\"nwnear\":\"⤧\",\"Oacute\":\"Ó\",\"oacute\":\"ó\",\"oast\":\"⊛\",\"Ocirc\":\"Ô\",\"ocirc\":\"ô\",\"ocir\":\"⊚\",\"Ocy\":\"О\",\"ocy\":\"о\",\"odash\":\"⊝\",\"Odblac\":\"Ő\",\"odblac\":\"ő\",\"odiv\":\"⨸\",\"odot\":\"⊙\",\"odsold\":\"⦼\",\"OElig\":\"Œ\",\"oelig\":\"œ\",\"ofcir\":\"⦿\",\"Ofr\":\"𝔒\",\"ofr\":\"𝔬\",\"ogon\":\"˛\",\"Ograve\":\"Ò\",\"ograve\":\"ò\",\"ogt\":\"⧁\",\"ohbar\":\"⦵\",\"ohm\":\"Ω\",\"oint\":\"∮\",\"olarr\":\"↺\",\"olcir\":\"⦾\",\"olcross\":\"⦻\",\"oline\":\"‾\",\"olt\":\"⧀\",\"Omacr\":\"Ō\",\"omacr\":\"ō\",\"Omega\":\"Ω\",\"omega\":\"ω\",\"Omicron\":\"Ο\",\"omicron\":\"ο\",\"omid\":\"⦶\",\"ominus\":\"⊖\",\"Oopf\":\"𝕆\",\"oopf\":\"𝕠\",\"opar\":\"⦷\",\"OpenCurlyDoubleQuote\":\"“\",\"OpenCurlyQuote\":\"‘\",\"operp\":\"⦹\",\"oplus\":\"⊕\",\"orarr\":\"↻\",\"Or\":\"⩔\",\"or\":\"∨\",\"ord\":\"⩝\",\"order\":\"ℴ\",\"orderof\":\"ℴ\",\"ordf\":\"ª\",\"ordm\":\"º\",\"origof\":\"⊶\",\"oror\":\"⩖\",\"orslope\":\"⩗\",\"orv\":\"⩛\",\"oS\":\"Ⓢ\",\"Oscr\":\"𝒪\",\"oscr\":\"ℴ\",\"Oslash\":\"Ø\",\"oslash\":\"ø\",\"osol\":\"⊘\",\"Otilde\":\"Õ\",\"otilde\":\"õ\",\"otimesas\":\"⨶\",\"Otimes\":\"⨷\",\"otimes\":\"⊗\",\"Ouml\":\"Ö\",\"ouml\":\"ö\",\"ovbar\":\"⌽\",\"OverBar\":\"‾\",\"OverBrace\":\"⏞\",\"OverBracket\":\"⎴\",\"OverParenthesis\":\"⏜\",\"para\":\"¶\",\"parallel\":\"∥\",\"par\":\"∥\",\"parsim\":\"⫳\",\"parsl\":\"⫽\",\"part\":\"∂\",\"PartialD\":\"∂\",\"Pcy\":\"П\",\"pcy\":\"п\",\"percnt\":\"%\",\"period\":\".\",\"permil\":\"‰\",\"perp\":\"⊥\",\"pertenk\":\"‱\",\"Pfr\":\"𝔓\",\"pfr\":\"𝔭\",\"Phi\":\"Φ\",\"phi\":\"φ\",\"phiv\":\"ϕ\",\"phmmat\":\"ℳ\",\"phone\":\"☎\",\"Pi\":\"Π\",\"pi\":\"π\",\"pitchfork\":\"⋔\",\"piv\":\"ϖ\",\"planck\":\"ℏ\",\"planckh\":\"ℎ\",\"plankv\":\"ℏ\",\"plusacir\":\"⨣\",\"plusb\":\"⊞\",\"pluscir\":\"⨢\",\"plus\":\"+\",\"plusdo\":\"∔\",\"plusdu\":\"⨥\",\"pluse\":\"⩲\",\"PlusMinus\":\"±\",\"plusmn\":\"±\",\"plussim\":\"⨦\",\"plustwo\":\"⨧\",\"pm\":\"±\",\"Poincareplane\":\"ℌ\",\"pointint\":\"⨕\",\"popf\":\"𝕡\",\"Popf\":\"ℙ\",\"pound\":\"£\",\"prap\":\"⪷\",\"Pr\":\"⪻\",\"pr\":\"≺\",\"prcue\":\"≼\",\"precapprox\":\"⪷\",\"prec\":\"≺\",\"preccurlyeq\":\"≼\",\"Precedes\":\"≺\",\"PrecedesEqual\":\"⪯\",\"PrecedesSlantEqual\":\"≼\",\"PrecedesTilde\":\"≾\",\"preceq\":\"⪯\",\"precnapprox\":\"⪹\",\"precneqq\":\"⪵\",\"precnsim\":\"⋨\",\"pre\":\"⪯\",\"prE\":\"⪳\",\"precsim\":\"≾\",\"prime\":\"′\",\"Prime\":\"″\",\"primes\":\"ℙ\",\"prnap\":\"⪹\",\"prnE\":\"⪵\",\"prnsim\":\"⋨\",\"prod\":\"∏\",\"Product\":\"∏\",\"profalar\":\"⌮\",\"profline\":\"⌒\",\"profsurf\":\"⌓\",\"prop\":\"∝\",\"Proportional\":\"∝\",\"Proportion\":\"∷\",\"propto\":\"∝\",\"prsim\":\"≾\",\"prurel\":\"⊰\",\"Pscr\":\"𝒫\",\"pscr\":\"𝓅\",\"Psi\":\"Ψ\",\"psi\":\"ψ\",\"puncsp\":\" \",\"Qfr\":\"𝔔\",\"qfr\":\"𝔮\",\"qint\":\"⨌\",\"qopf\":\"𝕢\",\"Qopf\":\"ℚ\",\"qprime\":\"⁗\",\"Qscr\":\"𝒬\",\"qscr\":\"𝓆\",\"quaternions\":\"ℍ\",\"quatint\":\"⨖\",\"quest\":\"?\",\"questeq\":\"≟\",\"quot\":\"\\\\\"\",\"QUOT\":\"\\\\\"\",\"rAarr\":\"⇛\",\"race\":\"∽̱\",\"Racute\":\"Ŕ\",\"racute\":\"ŕ\",\"radic\":\"√\",\"raemptyv\":\"⦳\",\"rang\":\"⟩\",\"Rang\":\"⟫\",\"rangd\":\"⦒\",\"range\":\"⦥\",\"rangle\":\"⟩\",\"raquo\":\"»\",\"rarrap\":\"⥵\",\"rarrb\":\"⇥\",\"rarrbfs\":\"⤠\",\"rarrc\":\"⤳\",\"rarr\":\"→\",\"Rarr\":\"↠\",\"rArr\":\"⇒\",\"rarrfs\":\"⤞\",\"rarrhk\":\"↪\",\"rarrlp\":\"↬\",\"rarrpl\":\"⥅\",\"rarrsim\":\"⥴\",\"Rarrtl\":\"⤖\",\"rarrtl\":\"↣\",\"rarrw\":\"↝\",\"ratail\":\"⤚\",\"rAtail\":\"⤜\",\"ratio\":\"∶\",\"rationals\":\"ℚ\",\"rbarr\":\"⤍\",\"rBarr\":\"⤏\",\"RBarr\":\"⤐\",\"rbbrk\":\"❳\",\"rbrace\":\"}\",\"rbrack\":\"]\",\"rbrke\":\"⦌\",\"rbrksld\":\"⦎\",\"rbrkslu\":\"⦐\",\"Rcaron\":\"Ř\",\"rcaron\":\"ř\",\"Rcedil\":\"Ŗ\",\"rcedil\":\"ŗ\",\"rceil\":\"⌉\",\"rcub\":\"}\",\"Rcy\":\"Р\",\"rcy\":\"р\",\"rdca\":\"⤷\",\"rdldhar\":\"⥩\",\"rdquo\":\"”\",\"rdquor\":\"”\",\"rdsh\":\"↳\",\"real\":\"ℜ\",\"realine\":\"ℛ\",\"realpart\":\"ℜ\",\"reals\":\"ℝ\",\"Re\":\"ℜ\",\"rect\":\"▭\",\"reg\":\"®\",\"REG\":\"®\",\"ReverseElement\":\"∋\",\"ReverseEquilibrium\":\"⇋\",\"ReverseUpEquilibrium\":\"⥯\",\"rfisht\":\"⥽\",\"rfloor\":\"⌋\",\"rfr\":\"𝔯\",\"Rfr\":\"ℜ\",\"rHar\":\"⥤\",\"rhard\":\"⇁\",\"rharu\":\"⇀\",\"rharul\":\"⥬\",\"Rho\":\"Ρ\",\"rho\":\"ρ\",\"rhov\":\"ϱ\",\"RightAngleBracket\":\"⟩\",\"RightArrowBar\":\"⇥\",\"rightarrow\":\"→\",\"RightArrow\":\"→\",\"Rightarrow\":\"⇒\",\"RightArrowLeftArrow\":\"⇄\",\"rightarrowtail\":\"↣\",\"RightCeiling\":\"⌉\",\"RightDoubleBracket\":\"⟧\",\"RightDownTeeVector\":\"⥝\",\"RightDownVectorBar\":\"⥕\",\"RightDownVector\":\"⇂\",\"RightFloor\":\"⌋\",\"rightharpoondown\":\"⇁\",\"rightharpoonup\":\"⇀\",\"rightleftarrows\":\"⇄\",\"rightleftharpoons\":\"⇌\",\"rightrightarrows\":\"⇉\",\"rightsquigarrow\":\"↝\",\"RightTeeArrow\":\"↦\",\"RightTee\":\"⊢\",\"RightTeeVector\":\"⥛\",\"rightthreetimes\":\"⋌\",\"RightTriangleBar\":\"⧐\",\"RightTriangle\":\"⊳\",\"RightTriangleEqual\":\"⊵\",\"RightUpDownVector\":\"⥏\",\"RightUpTeeVector\":\"⥜\",\"RightUpVectorBar\":\"⥔\",\"RightUpVector\":\"↾\",\"RightVectorBar\":\"⥓\",\"RightVector\":\"⇀\",\"ring\":\"˚\",\"risingdotseq\":\"≓\",\"rlarr\":\"⇄\",\"rlhar\":\"⇌\",\"rlm\":\"‏\",\"rmoustache\":\"⎱\",\"rmoust\":\"⎱\",\"rnmid\":\"⫮\",\"roang\":\"⟭\",\"roarr\":\"⇾\",\"robrk\":\"⟧\",\"ropar\":\"⦆\",\"ropf\":\"𝕣\",\"Ropf\":\"ℝ\",\"roplus\":\"⨮\",\"rotimes\":\"⨵\",\"RoundImplies\":\"⥰\",\"rpar\":\")\",\"rpargt\":\"⦔\",\"rppolint\":\"⨒\",\"rrarr\":\"⇉\",\"Rrightarrow\":\"⇛\",\"rsaquo\":\"›\",\"rscr\":\"𝓇\",\"Rscr\":\"ℛ\",\"rsh\":\"↱\",\"Rsh\":\"↱\",\"rsqb\":\"]\",\"rsquo\":\"’\",\"rsquor\":\"’\",\"rthree\":\"⋌\",\"rtimes\":\"⋊\",\"rtri\":\"▹\",\"rtrie\":\"⊵\",\"rtrif\":\"▸\",\"rtriltri\":\"⧎\",\"RuleDelayed\":\"⧴\",\"ruluhar\":\"⥨\",\"rx\":\"℞\",\"Sacute\":\"Ś\",\"sacute\":\"ś\",\"sbquo\":\"‚\",\"scap\":\"⪸\",\"Scaron\":\"Š\",\"scaron\":\"š\",\"Sc\":\"⪼\",\"sc\":\"≻\",\"sccue\":\"≽\",\"sce\":\"⪰\",\"scE\":\"⪴\",\"Scedil\":\"Ş\",\"scedil\":\"ş\",\"Scirc\":\"Ŝ\",\"scirc\":\"ŝ\",\"scnap\":\"⪺\",\"scnE\":\"⪶\",\"scnsim\":\"⋩\",\"scpolint\":\"⨓\",\"scsim\":\"≿\",\"Scy\":\"С\",\"scy\":\"с\",\"sdotb\":\"⊡\",\"sdot\":\"⋅\",\"sdote\":\"⩦\",\"searhk\":\"⤥\",\"searr\":\"↘\",\"seArr\":\"⇘\",\"searrow\":\"↘\",\"sect\":\"§\",\"semi\":\";\",\"seswar\":\"⤩\",\"setminus\":\"∖\",\"setmn\":\"∖\",\"sext\":\"✶\",\"Sfr\":\"𝔖\",\"sfr\":\"𝔰\",\"sfrown\":\"⌢\",\"sharp\":\"♯\",\"SHCHcy\":\"Щ\",\"shchcy\":\"щ\",\"SHcy\":\"Ш\",\"shcy\":\"ш\",\"ShortDownArrow\":\"↓\",\"ShortLeftArrow\":\"←\",\"shortmid\":\"∣\",\"shortparallel\":\"∥\",\"ShortRightArrow\":\"→\",\"ShortUpArrow\":\"↑\",\"shy\":\"­\",\"Sigma\":\"Σ\",\"sigma\":\"σ\",\"sigmaf\":\"ς\",\"sigmav\":\"ς\",\"sim\":\"∼\",\"simdot\":\"⩪\",\"sime\":\"≃\",\"simeq\":\"≃\",\"simg\":\"⪞\",\"simgE\":\"⪠\",\"siml\":\"⪝\",\"simlE\":\"⪟\",\"simne\":\"≆\",\"simplus\":\"⨤\",\"simrarr\":\"⥲\",\"slarr\":\"←\",\"SmallCircle\":\"∘\",\"smallsetminus\":\"∖\",\"smashp\":\"⨳\",\"smeparsl\":\"⧤\",\"smid\":\"∣\",\"smile\":\"⌣\",\"smt\":\"⪪\",\"smte\":\"⪬\",\"smtes\":\"⪬︀\",\"SOFTcy\":\"Ь\",\"softcy\":\"ь\",\"solbar\":\"⌿\",\"solb\":\"⧄\",\"sol\":\"/\",\"Sopf\":\"𝕊\",\"sopf\":\"𝕤\",\"spades\":\"♠\",\"spadesuit\":\"♠\",\"spar\":\"∥\",\"sqcap\":\"⊓\",\"sqcaps\":\"⊓︀\",\"sqcup\":\"⊔\",\"sqcups\":\"⊔︀\",\"Sqrt\":\"√\",\"sqsub\":\"⊏\",\"sqsube\":\"⊑\",\"sqsubset\":\"⊏\",\"sqsubseteq\":\"⊑\",\"sqsup\":\"⊐\",\"sqsupe\":\"⊒\",\"sqsupset\":\"⊐\",\"sqsupseteq\":\"⊒\",\"square\":\"□\",\"Square\":\"□\",\"SquareIntersection\":\"⊓\",\"SquareSubset\":\"⊏\",\"SquareSubsetEqual\":\"⊑\",\"SquareSuperset\":\"⊐\",\"SquareSupersetEqual\":\"⊒\",\"SquareUnion\":\"⊔\",\"squarf\":\"▪\",\"squ\":\"□\",\"squf\":\"▪\",\"srarr\":\"→\",\"Sscr\":\"𝒮\",\"sscr\":\"𝓈\",\"ssetmn\":\"∖\",\"ssmile\":\"⌣\",\"sstarf\":\"⋆\",\"Star\":\"⋆\",\"star\":\"☆\",\"starf\":\"★\",\"straightepsilon\":\"ϵ\",\"straightphi\":\"ϕ\",\"strns\":\"¯\",\"sub\":\"⊂\",\"Sub\":\"⋐\",\"subdot\":\"⪽\",\"subE\":\"⫅\",\"sube\":\"⊆\",\"subedot\":\"⫃\",\"submult\":\"⫁\",\"subnE\":\"⫋\",\"subne\":\"⊊\",\"subplus\":\"⪿\",\"subrarr\":\"⥹\",\"subset\":\"⊂\",\"Subset\":\"⋐\",\"subseteq\":\"⊆\",\"subseteqq\":\"⫅\",\"SubsetEqual\":\"⊆\",\"subsetneq\":\"⊊\",\"subsetneqq\":\"⫋\",\"subsim\":\"⫇\",\"subsub\":\"⫕\",\"subsup\":\"⫓\",\"succapprox\":\"⪸\",\"succ\":\"≻\",\"succcurlyeq\":\"≽\",\"Succeeds\":\"≻\",\"SucceedsEqual\":\"⪰\",\"SucceedsSlantEqual\":\"≽\",\"SucceedsTilde\":\"≿\",\"succeq\":\"⪰\",\"succnapprox\":\"⪺\",\"succneqq\":\"⪶\",\"succnsim\":\"⋩\",\"succsim\":\"≿\",\"SuchThat\":\"∋\",\"sum\":\"∑\",\"Sum\":\"∑\",\"sung\":\"♪\",\"sup1\":\"¹\",\"sup2\":\"²\",\"sup3\":\"³\",\"sup\":\"⊃\",\"Sup\":\"⋑\",\"supdot\":\"⪾\",\"supdsub\":\"⫘\",\"supE\":\"⫆\",\"supe\":\"⊇\",\"supedot\":\"⫄\",\"Superset\":\"⊃\",\"SupersetEqual\":\"⊇\",\"suphsol\":\"⟉\",\"suphsub\":\"⫗\",\"suplarr\":\"⥻\",\"supmult\":\"⫂\",\"supnE\":\"⫌\",\"supne\":\"⊋\",\"supplus\":\"⫀\",\"supset\":\"⊃\",\"Supset\":\"⋑\",\"supseteq\":\"⊇\",\"supseteqq\":\"⫆\",\"supsetneq\":\"⊋\",\"supsetneqq\":\"⫌\",\"supsim\":\"⫈\",\"supsub\":\"⫔\",\"supsup\":\"⫖\",\"swarhk\":\"⤦\",\"swarr\":\"↙\",\"swArr\":\"⇙\",\"swarrow\":\"↙\",\"swnwar\":\"⤪\",\"szlig\":\"ß\",\"Tab\":\"\\\\t\",\"target\":\"⌖\",\"Tau\":\"Τ\",\"tau\":\"τ\",\"tbrk\":\"⎴\",\"Tcaron\":\"Ť\",\"tcaron\":\"ť\",\"Tcedil\":\"Ţ\",\"tcedil\":\"ţ\",\"Tcy\":\"Т\",\"tcy\":\"т\",\"tdot\":\"⃛\",\"telrec\":\"⌕\",\"Tfr\":\"𝔗\",\"tfr\":\"𝔱\",\"there4\":\"∴\",\"therefore\":\"∴\",\"Therefore\":\"∴\",\"Theta\":\"Θ\",\"theta\":\"θ\",\"thetasym\":\"ϑ\",\"thetav\":\"ϑ\",\"thickapprox\":\"≈\",\"thicksim\":\"∼\",\"ThickSpace\":\"  \",\"ThinSpace\":\" \",\"thinsp\":\" \",\"thkap\":\"≈\",\"thksim\":\"∼\",\"THORN\":\"Þ\",\"thorn\":\"þ\",\"tilde\":\"˜\",\"Tilde\":\"∼\",\"TildeEqual\":\"≃\",\"TildeFullEqual\":\"≅\",\"TildeTilde\":\"≈\",\"timesbar\":\"⨱\",\"timesb\":\"⊠\",\"times\":\"×\",\"timesd\":\"⨰\",\"tint\":\"∭\",\"toea\":\"⤨\",\"topbot\":\"⌶\",\"topcir\":\"⫱\",\"top\":\"⊤\",\"Topf\":\"𝕋\",\"topf\":\"𝕥\",\"topfork\":\"⫚\",\"tosa\":\"⤩\",\"tprime\":\"‴\",\"trade\":\"™\",\"TRADE\":\"™\",\"triangle\":\"▵\",\"triangledown\":\"▿\",\"triangleleft\":\"◃\",\"trianglelefteq\":\"⊴\",\"triangleq\":\"≜\",\"triangleright\":\"▹\",\"trianglerighteq\":\"⊵\",\"tridot\":\"◬\",\"trie\":\"≜\",\"triminus\":\"⨺\",\"TripleDot\":\"⃛\",\"triplus\":\"⨹\",\"trisb\":\"⧍\",\"tritime\":\"⨻\",\"trpezium\":\"⏢\",\"Tscr\":\"𝒯\",\"tscr\":\"𝓉\",\"TScy\":\"Ц\",\"tscy\":\"ц\",\"TSHcy\":\"Ћ\",\"tshcy\":\"ћ\",\"Tstrok\":\"Ŧ\",\"tstrok\":\"ŧ\",\"twixt\":\"≬\",\"twoheadleftarrow\":\"↞\",\"twoheadrightarrow\":\"↠\",\"Uacute\":\"Ú\",\"uacute\":\"ú\",\"uarr\":\"↑\",\"Uarr\":\"↟\",\"uArr\":\"⇑\",\"Uarrocir\":\"⥉\",\"Ubrcy\":\"Ў\",\"ubrcy\":\"ў\",\"Ubreve\":\"Ŭ\",\"ubreve\":\"ŭ\",\"Ucirc\":\"Û\",\"ucirc\":\"û\",\"Ucy\":\"У\",\"ucy\":\"у\",\"udarr\":\"⇅\",\"Udblac\":\"Ű\",\"udblac\":\"ű\",\"udhar\":\"⥮\",\"ufisht\":\"⥾\",\"Ufr\":\"𝔘\",\"ufr\":\"𝔲\",\"Ugrave\":\"Ù\",\"ugrave\":\"ù\",\"uHar\":\"⥣\",\"uharl\":\"↿\",\"uharr\":\"↾\",\"uhblk\":\"▀\",\"ulcorn\":\"⌜\",\"ulcorner\":\"⌜\",\"ulcrop\":\"⌏\",\"ultri\":\"◸\",\"Umacr\":\"Ū\",\"umacr\":\"ū\",\"uml\":\"¨\",\"UnderBar\":\"_\",\"UnderBrace\":\"⏟\",\"UnderBracket\":\"⎵\",\"UnderParenthesis\":\"⏝\",\"Union\":\"⋃\",\"UnionPlus\":\"⊎\",\"Uogon\":\"Ų\",\"uogon\":\"ų\",\"Uopf\":\"𝕌\",\"uopf\":\"𝕦\",\"UpArrowBar\":\"⤒\",\"uparrow\":\"↑\",\"UpArrow\":\"↑\",\"Uparrow\":\"⇑\",\"UpArrowDownArrow\":\"⇅\",\"updownarrow\":\"↕\",\"UpDownArrow\":\"↕\",\"Updownarrow\":\"⇕\",\"UpEquilibrium\":\"⥮\",\"upharpoonleft\":\"↿\",\"upharpoonright\":\"↾\",\"uplus\":\"⊎\",\"UpperLeftArrow\":\"↖\",\"UpperRightArrow\":\"↗\",\"upsi\":\"υ\",\"Upsi\":\"ϒ\",\"upsih\":\"ϒ\",\"Upsilon\":\"Υ\",\"upsilon\":\"υ\",\"UpTeeArrow\":\"↥\",\"UpTee\":\"⊥\",\"upuparrows\":\"⇈\",\"urcorn\":\"⌝\",\"urcorner\":\"⌝\",\"urcrop\":\"⌎\",\"Uring\":\"Ů\",\"uring\":\"ů\",\"urtri\":\"◹\",\"Uscr\":\"𝒰\",\"uscr\":\"𝓊\",\"utdot\":\"⋰\",\"Utilde\":\"Ũ\",\"utilde\":\"ũ\",\"utri\":\"▵\",\"utrif\":\"▴\",\"uuarr\":\"⇈\",\"Uuml\":\"Ü\",\"uuml\":\"ü\",\"uwangle\":\"⦧\",\"vangrt\":\"⦜\",\"varepsilon\":\"ϵ\",\"varkappa\":\"ϰ\",\"varnothing\":\"∅\",\"varphi\":\"ϕ\",\"varpi\":\"ϖ\",\"varpropto\":\"∝\",\"varr\":\"↕\",\"vArr\":\"⇕\",\"varrho\":\"ϱ\",\"varsigma\":\"ς\",\"varsubsetneq\":\"⊊︀\",\"varsubsetneqq\":\"⫋︀\",\"varsupsetneq\":\"⊋︀\",\"varsupsetneqq\":\"⫌︀\",\"vartheta\":\"ϑ\",\"vartriangleleft\":\"⊲\",\"vartriangleright\":\"⊳\",\"vBar\":\"⫨\",\"Vbar\":\"⫫\",\"vBarv\":\"⫩\",\"Vcy\":\"В\",\"vcy\":\"в\",\"vdash\":\"⊢\",\"vDash\":\"⊨\",\"Vdash\":\"⊩\",\"VDash\":\"⊫\",\"Vdashl\":\"⫦\",\"veebar\":\"⊻\",\"vee\":\"∨\",\"Vee\":\"⋁\",\"veeeq\":\"≚\",\"vellip\":\"⋮\",\"verbar\":\"|\",\"Verbar\":\"‖\",\"vert\":\"|\",\"Vert\":\"‖\",\"VerticalBar\":\"∣\",\"VerticalLine\":\"|\",\"VerticalSeparator\":\"❘\",\"VerticalTilde\":\"≀\",\"VeryThinSpace\":\" \",\"Vfr\":\"𝔙\",\"vfr\":\"𝔳\",\"vltri\":\"⊲\",\"vnsub\":\"⊂⃒\",\"vnsup\":\"⊃⃒\",\"Vopf\":\"𝕍\",\"vopf\":\"𝕧\",\"vprop\":\"∝\",\"vrtri\":\"⊳\",\"Vscr\":\"𝒱\",\"vscr\":\"𝓋\",\"vsubnE\":\"⫋︀\",\"vsubne\":\"⊊︀\",\"vsupnE\":\"⫌︀\",\"vsupne\":\"⊋︀\",\"Vvdash\":\"⊪\",\"vzigzag\":\"⦚\",\"Wcirc\":\"Ŵ\",\"wcirc\":\"ŵ\",\"wedbar\":\"⩟\",\"wedge\":\"∧\",\"Wedge\":\"⋀\",\"wedgeq\":\"≙\",\"weierp\":\"℘\",\"Wfr\":\"𝔚\",\"wfr\":\"𝔴\",\"Wopf\":\"𝕎\",\"wopf\":\"𝕨\",\"wp\":\"℘\",\"wr\":\"≀\",\"wreath\":\"≀\",\"Wscr\":\"𝒲\",\"wscr\":\"𝓌\",\"xcap\":\"⋂\",\"xcirc\":\"◯\",\"xcup\":\"⋃\",\"xdtri\":\"▽\",\"Xfr\":\"𝔛\",\"xfr\":\"𝔵\",\"xharr\":\"⟷\",\"xhArr\":\"⟺\",\"Xi\":\"Ξ\",\"xi\":\"ξ\",\"xlarr\":\"⟵\",\"xlArr\":\"⟸\",\"xmap\":\"⟼\",\"xnis\":\"⋻\",\"xodot\":\"⨀\",\"Xopf\":\"𝕏\",\"xopf\":\"𝕩\",\"xoplus\":\"⨁\",\"xotime\":\"⨂\",\"xrarr\":\"⟶\",\"xrArr\":\"⟹\",\"Xscr\":\"𝒳\",\"xscr\":\"𝓍\",\"xsqcup\":\"⨆\",\"xuplus\":\"⨄\",\"xutri\":\"△\",\"xvee\":\"⋁\",\"xwedge\":\"⋀\",\"Yacute\":\"Ý\",\"yacute\":\"ý\",\"YAcy\":\"Я\",\"yacy\":\"я\",\"Ycirc\":\"Ŷ\",\"ycirc\":\"ŷ\",\"Ycy\":\"Ы\",\"ycy\":\"ы\",\"yen\":\"¥\",\"Yfr\":\"𝔜\",\"yfr\":\"𝔶\",\"YIcy\":\"Ї\",\"yicy\":\"ї\",\"Yopf\":\"𝕐\",\"yopf\":\"𝕪\",\"Yscr\":\"𝒴\",\"yscr\":\"𝓎\",\"YUcy\":\"Ю\",\"yucy\":\"ю\",\"yuml\":\"ÿ\",\"Yuml\":\"Ÿ\",\"Zacute\":\"Ź\",\"zacute\":\"ź\",\"Zcaron\":\"Ž\",\"zcaron\":\"ž\",\"Zcy\":\"З\",\"zcy\":\"з\",\"Zdot\":\"Ż\",\"zdot\":\"ż\",\"zeetrf\":\"ℨ\",\"ZeroWidthSpace\":\"​\",\"Zeta\":\"Ζ\",\"zeta\":\"ζ\",\"zfr\":\"𝔷\",\"Zfr\":\"ℨ\",\"ZHcy\":\"Ж\",\"zhcy\":\"ж\",\"zigrarr\":\"⇝\",\"zopf\":\"𝕫\",\"Zopf\":\"ℤ\",\"Zscr\":\"𝒵\",\"zscr\":\"𝓏\",\"zwj\":\"‍\",\"zwnj\":\"‌\"}');\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/entities/lib/maps/entities.json?");

/***/ }),

/***/ "./src/node_modules/entities/lib/maps/legacy.json":
/*!********************************************************!*\
  !*** ./src/node_modules/entities/lib/maps/legacy.json ***!
  \********************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"Aacute\":\"Á\",\"aacute\":\"á\",\"Acirc\":\"Â\",\"acirc\":\"â\",\"acute\":\"´\",\"AElig\":\"Æ\",\"aelig\":\"æ\",\"Agrave\":\"À\",\"agrave\":\"à\",\"amp\":\"&\",\"AMP\":\"&\",\"Aring\":\"Å\",\"aring\":\"å\",\"Atilde\":\"Ã\",\"atilde\":\"ã\",\"Auml\":\"Ä\",\"auml\":\"ä\",\"brvbar\":\"¦\",\"Ccedil\":\"Ç\",\"ccedil\":\"ç\",\"cedil\":\"¸\",\"cent\":\"¢\",\"copy\":\"©\",\"COPY\":\"©\",\"curren\":\"¤\",\"deg\":\"°\",\"divide\":\"÷\",\"Eacute\":\"É\",\"eacute\":\"é\",\"Ecirc\":\"Ê\",\"ecirc\":\"ê\",\"Egrave\":\"È\",\"egrave\":\"è\",\"ETH\":\"Ð\",\"eth\":\"ð\",\"Euml\":\"Ë\",\"euml\":\"ë\",\"frac12\":\"½\",\"frac14\":\"¼\",\"frac34\":\"¾\",\"gt\":\">\",\"GT\":\">\",\"Iacute\":\"Í\",\"iacute\":\"í\",\"Icirc\":\"Î\",\"icirc\":\"î\",\"iexcl\":\"¡\",\"Igrave\":\"Ì\",\"igrave\":\"ì\",\"iquest\":\"¿\",\"Iuml\":\"Ï\",\"iuml\":\"ï\",\"laquo\":\"«\",\"lt\":\"<\",\"LT\":\"<\",\"macr\":\"¯\",\"micro\":\"µ\",\"middot\":\"·\",\"nbsp\":\" \",\"not\":\"¬\",\"Ntilde\":\"Ñ\",\"ntilde\":\"ñ\",\"Oacute\":\"Ó\",\"oacute\":\"ó\",\"Ocirc\":\"Ô\",\"ocirc\":\"ô\",\"Ograve\":\"Ò\",\"ograve\":\"ò\",\"ordf\":\"ª\",\"ordm\":\"º\",\"Oslash\":\"Ø\",\"oslash\":\"ø\",\"Otilde\":\"Õ\",\"otilde\":\"õ\",\"Ouml\":\"Ö\",\"ouml\":\"ö\",\"para\":\"¶\",\"plusmn\":\"±\",\"pound\":\"£\",\"quot\":\"\\\\\"\",\"QUOT\":\"\\\\\"\",\"raquo\":\"»\",\"reg\":\"®\",\"REG\":\"®\",\"sect\":\"§\",\"shy\":\"­\",\"sup1\":\"¹\",\"sup2\":\"²\",\"sup3\":\"³\",\"szlig\":\"ß\",\"THORN\":\"Þ\",\"thorn\":\"þ\",\"times\":\"×\",\"Uacute\":\"Ú\",\"uacute\":\"ú\",\"Ucirc\":\"Û\",\"ucirc\":\"û\",\"Ugrave\":\"Ù\",\"ugrave\":\"ù\",\"uml\":\"¨\",\"Uuml\":\"Ü\",\"uuml\":\"ü\",\"Yacute\":\"Ý\",\"yacute\":\"ý\",\"yen\":\"¥\",\"yuml\":\"ÿ\"}');\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/entities/lib/maps/legacy.json?");

/***/ }),

/***/ "./src/node_modules/entities/lib/maps/xml.json":
/*!*****************************************************!*\
  !*** ./src/node_modules/entities/lib/maps/xml.json ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"amp\":\"&\",\"apos\":\"\\'\",\"gt\":\">\",\"lt\":\"<\",\"quot\":\"\\\\\"\"}');\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/entities/lib/maps/xml.json?");

/***/ }),

/***/ "./src/node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js":
/*!**************************************************************************!*\
  !*** ./src/node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar GetIntrinsic = __webpack_require__(/*! get-intrinsic */ \"get-intrinsic\");\n\nvar $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%');\nif ($gOPD) {\n\ttry {\n\t\t$gOPD([], 'length');\n\t} catch (e) {\n\t\t// IE 8 has a broken gOPD\n\t\t$gOPD = null;\n\t}\n}\n\nmodule.exports = $gOPD;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js?");

/***/ }),

/***/ "./src/node_modules/es-get-iterator/node.js":
/*!**************************************************!*\
  !*** ./src/node_modules/es-get-iterator/node.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n// this should only run in node >= 13.2, so it\n// does not need any of the intense fallbacks that old node/browsers do\n\nvar $iterator = Symbol.iterator;\nmodule.exports = function getIterator(iterable) {\n\t// alternatively, `iterable[$iterator]?.()`\n\tif (iterable != null && typeof iterable[$iterator] !== 'undefined') {\n\t\treturn iterable[$iterator]();\n\t}\n};\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/es-get-iterator/node.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/auth/action-code-settings-builder.js":
/*!**********************************************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/auth/action-code-settings-builder.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\n/*!\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar validator = __webpack_require__(/*! ../utils/validator */ \"./src/node_modules/firebase-admin/lib/utils/validator.js\");\nvar error_1 = __webpack_require__(/*! ../utils/error */ \"./src/node_modules/firebase-admin/lib/utils/error.js\");\n/**\n * Defines the ActionCodeSettings builder class used to convert the\n * ActionCodeSettings object to its corresponding server request.\n */\nvar ActionCodeSettingsBuilder = /** @class */ (function () {\n    /**\n     * ActionCodeSettingsBuilder constructor.\n     *\n     * @param {ActionCodeSettings} actionCodeSettings The ActionCodeSettings\n     *     object used to initiliaze this server request builder.\n     * @constructor\n     */\n    function ActionCodeSettingsBuilder(actionCodeSettings) {\n        if (!validator.isNonNullObject(actionCodeSettings)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"ActionCodeSettings\" must be a non-null object.');\n        }\n        if (typeof actionCodeSettings.url === 'undefined') {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISSING_CONTINUE_URI);\n        }\n        else if (!validator.isURL(actionCodeSettings.url)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONTINUE_URI);\n        }\n        this.continueUrl = actionCodeSettings.url;\n        if (typeof actionCodeSettings.handleCodeInApp !== 'undefined' &&\n            !validator.isBoolean(actionCodeSettings.handleCodeInApp)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"ActionCodeSettings.handleCodeInApp\" must be a boolean.');\n        }\n        this.canHandleCodeInApp = actionCodeSettings.handleCodeInApp || false;\n        if (typeof actionCodeSettings.dynamicLinkDomain !== 'undefined' &&\n            !validator.isNonEmptyString(actionCodeSettings.dynamicLinkDomain)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DYNAMIC_LINK_DOMAIN);\n        }\n        this.dynamicLinkDomain = actionCodeSettings.dynamicLinkDomain;\n        if (typeof actionCodeSettings.iOS !== 'undefined') {\n            if (!validator.isNonNullObject(actionCodeSettings.iOS)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"ActionCodeSettings.iOS\" must be a valid non-null object.');\n            }\n            else if (typeof actionCodeSettings.iOS.bundleId === 'undefined') {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISSING_IOS_BUNDLE_ID);\n            }\n            else if (!validator.isNonEmptyString(actionCodeSettings.iOS.bundleId)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"ActionCodeSettings.iOS.bundleId\" must be a valid non-empty string.');\n            }\n            this.ibi = actionCodeSettings.iOS.bundleId;\n        }\n        if (typeof actionCodeSettings.android !== 'undefined') {\n            if (!validator.isNonNullObject(actionCodeSettings.android)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"ActionCodeSettings.android\" must be a valid non-null object.');\n            }\n            else if (typeof actionCodeSettings.android.packageName === 'undefined') {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISSING_ANDROID_PACKAGE_NAME);\n            }\n            else if (!validator.isNonEmptyString(actionCodeSettings.android.packageName)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"ActionCodeSettings.android.packageName\" must be a valid non-empty string.');\n            }\n            else if (typeof actionCodeSettings.android.minimumVersion !== 'undefined' &&\n                !validator.isNonEmptyString(actionCodeSettings.android.minimumVersion)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"ActionCodeSettings.android.minimumVersion\" must be a valid non-empty string.');\n            }\n            else if (typeof actionCodeSettings.android.installApp !== 'undefined' &&\n                !validator.isBoolean(actionCodeSettings.android.installApp)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"ActionCodeSettings.android.installApp\" must be a valid boolean.');\n            }\n            this.apn = actionCodeSettings.android.packageName;\n            this.amv = actionCodeSettings.android.minimumVersion;\n            this.installApp = actionCodeSettings.android.installApp || false;\n        }\n    }\n    /**\n     * Returns the corresponding constructed server request corresponding to the\n     * current ActionCodeSettings.\n     *\n     * @return {EmailActionCodeRequest} The constructed EmailActionCodeRequest request.\n     */\n    ActionCodeSettingsBuilder.prototype.buildRequest = function () {\n        var request = {\n            continueUrl: this.continueUrl,\n            canHandleCodeInApp: this.canHandleCodeInApp,\n            dynamicLinkDomain: this.dynamicLinkDomain,\n            androidPackageName: this.apn,\n            androidMinimumVersion: this.amv,\n            androidInstallApp: this.installApp,\n            iOSBundleId: this.ibi,\n        };\n        // Remove all null and undefined fields from request.\n        for (var key in request) {\n            if (Object.prototype.hasOwnProperty.call(request, key)) {\n                if (typeof request[key] === 'undefined' || request[key] === null) {\n                    delete request[key];\n                }\n            }\n        }\n        return request;\n    };\n    return ActionCodeSettingsBuilder;\n}());\nexports.ActionCodeSettingsBuilder = ActionCodeSettingsBuilder;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/auth/action-code-settings-builder.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/auth/auth-api-request.js":
/*!**********************************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/auth/auth-api-request.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\n/*!\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar validator = __webpack_require__(/*! ../utils/validator */ \"./src/node_modules/firebase-admin/lib/utils/validator.js\");\nvar deep_copy_1 = __webpack_require__(/*! ../utils/deep-copy */ \"./src/node_modules/firebase-admin/lib/utils/deep-copy.js\");\nvar identifier_1 = __webpack_require__(/*! ./identifier */ \"./src/node_modules/firebase-admin/lib/auth/identifier.js\");\nvar error_1 = __webpack_require__(/*! ../utils/error */ \"./src/node_modules/firebase-admin/lib/utils/error.js\");\nvar api_request_1 = __webpack_require__(/*! ../utils/api-request */ \"./src/node_modules/firebase-admin/lib/utils/api-request.js\");\nvar user_import_builder_1 = __webpack_require__(/*! ./user-import-builder */ \"./src/node_modules/firebase-admin/lib/auth/user-import-builder.js\");\nvar utils = __webpack_require__(/*! ../utils/index */ \"./src/node_modules/firebase-admin/lib/utils/index.js\");\nvar action_code_settings_builder_1 = __webpack_require__(/*! ./action-code-settings-builder */ \"./src/node_modules/firebase-admin/lib/auth/action-code-settings-builder.js\");\nvar auth_config_1 = __webpack_require__(/*! ./auth-config */ \"./src/node_modules/firebase-admin/lib/auth/auth-config.js\");\nvar tenant_1 = __webpack_require__(/*! ./tenant */ \"./src/node_modules/firebase-admin/lib/auth/tenant.js\");\n/** Firebase Auth request header. */\nvar FIREBASE_AUTH_HEADER = {\n    'X-Client-Version': 'Node/Admin/8.13.0',\n};\n/** Firebase Auth request timeout duration in milliseconds. */\nvar FIREBASE_AUTH_TIMEOUT = 25000;\n/** List of reserved claims which cannot be provided when creating a custom token. */\nexports.RESERVED_CLAIMS = [\n    'acr', 'amr', 'at_hash', 'aud', 'auth_time', 'azp', 'cnf', 'c_hash', 'exp', 'iat',\n    'iss', 'jti', 'nbf', 'nonce', 'sub', 'firebase',\n];\n/** List of supported email action request types. */\nexports.EMAIL_ACTION_REQUEST_TYPES = [\n    'PASSWORD_RESET', 'VERIFY_EMAIL', 'EMAIL_SIGNIN',\n];\n/** Maximum allowed number of characters in the custom claims payload. */\nvar MAX_CLAIMS_PAYLOAD_SIZE = 1000;\n/** Maximum allowed number of users to batch download at one time. */\nvar MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE = 1000;\n/** Maximum allowed number of users to batch upload at one time. */\nvar MAX_UPLOAD_ACCOUNT_BATCH_SIZE = 1000;\n/** Maximum allowed number of users to batch get at one time. */\nvar MAX_GET_ACCOUNTS_BATCH_SIZE = 100;\n/** Maximum allowed number of users to batch delete at one time. */\nvar MAX_DELETE_ACCOUNTS_BATCH_SIZE = 1000;\n/** Minimum allowed session cookie duration in seconds (5 minutes). */\nvar MIN_SESSION_COOKIE_DURATION_SECS = 5 * 60;\n/** Maximum allowed session cookie duration in seconds (2 weeks). */\nvar MAX_SESSION_COOKIE_DURATION_SECS = 14 * 24 * 60 * 60;\n/** Maximum allowed number of provider configurations to batch download at one time. */\nvar MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE = 100;\n/** The Firebase Auth backend base URL format. */\nvar FIREBASE_AUTH_BASE_URL_FORMAT = 'https://identitytoolkit.googleapis.com/{version}/projects/{projectId}{api}';\n/** The Firebase Auth backend multi-tenancy base URL format. */\nvar FIREBASE_AUTH_TENANT_URL_FORMAT = FIREBASE_AUTH_BASE_URL_FORMAT.replace('projects/{projectId}', 'projects/{projectId}/tenants/{tenantId}');\n/** Maximum allowed number of tenants to download at one time. */\nvar MAX_LIST_TENANT_PAGE_SIZE = 1000;\n/**\n * Enum for the user write operation type.\n */\nvar WriteOperationType;\n(function (WriteOperationType) {\n    WriteOperationType[\"Create\"] = \"create\";\n    WriteOperationType[\"Update\"] = \"update\";\n    WriteOperationType[\"Upload\"] = \"upload\";\n})(WriteOperationType || (WriteOperationType = {}));\n/** Defines a base utility to help with resource URL construction. */\nvar AuthResourceUrlBuilder = /** @class */ (function () {\n    /**\n     * The resource URL builder constructor.\n     *\n     * @param {string} projectId The resource project ID.\n     * @param {string} version The endpoint API version.\n     * @constructor\n     */\n    function AuthResourceUrlBuilder(app, version) {\n        if (version === void 0) { version = 'v1'; }\n        this.app = app;\n        this.version = version;\n        this.urlFormat = FIREBASE_AUTH_BASE_URL_FORMAT;\n    }\n    /**\n     * Returns the resource URL corresponding to the provided parameters.\n     *\n     * @param {string=} api The backend API name.\n     * @param {object=} params The optional additional parameters to substitute in the\n     *     URL path.\n     * @return {Promise<string>} The corresponding resource URL.\n     */\n    AuthResourceUrlBuilder.prototype.getUrl = function (api, params) {\n        var _this = this;\n        return this.getProjectId()\n            .then(function (projectId) {\n            var baseParams = {\n                version: _this.version,\n                projectId: projectId,\n                api: api || '',\n            };\n            var baseUrl = utils.formatString(_this.urlFormat, baseParams);\n            // Substitute additional api related parameters.\n            return utils.formatString(baseUrl, params || {});\n        });\n    };\n    AuthResourceUrlBuilder.prototype.getProjectId = function () {\n        var _this = this;\n        if (this.projectId) {\n            return Promise.resolve(this.projectId);\n        }\n        return utils.findProjectId(this.app)\n            .then(function (projectId) {\n            if (!validator.isNonEmptyString(projectId)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CREDENTIAL, 'Failed to determine project ID for Auth. Initialize the '\n                    + 'SDK with service account credentials or set project ID as an app option. '\n                    + 'Alternatively set the GOOGLE_CLOUD_PROJECT environment variable.');\n            }\n            _this.projectId = projectId;\n            return projectId;\n        });\n    };\n    return AuthResourceUrlBuilder;\n}());\n/** Tenant aware resource builder utility. */\nvar TenantAwareAuthResourceUrlBuilder = /** @class */ (function (_super) {\n    __extends(TenantAwareAuthResourceUrlBuilder, _super);\n    /**\n     * The tenant aware resource URL builder constructor.\n     *\n     * @param {string} projectId The resource project ID.\n     * @param {string} version The endpoint API version.\n     * @param {string} tenantId The tenant ID.\n     * @constructor\n     */\n    function TenantAwareAuthResourceUrlBuilder(app, version, tenantId) {\n        var _this = _super.call(this, app, version) || this;\n        _this.app = app;\n        _this.version = version;\n        _this.tenantId = tenantId;\n        _this.urlFormat = FIREBASE_AUTH_TENANT_URL_FORMAT;\n        return _this;\n    }\n    /**\n     * Returns the resource URL corresponding to the provided parameters.\n     *\n     * @param {string=} api The backend API name.\n     * @param {object=} params The optional additional parameters to substitute in the\n     *     URL path.\n     * @return {Promise<string>} The corresponding resource URL.\n     */\n    TenantAwareAuthResourceUrlBuilder.prototype.getUrl = function (api, params) {\n        var _this = this;\n        return _super.prototype.getUrl.call(this, api, params)\n            .then(function (url) {\n            return utils.formatString(url, { tenantId: _this.tenantId });\n        });\n    };\n    return TenantAwareAuthResourceUrlBuilder;\n}(AuthResourceUrlBuilder));\n/**\n * Validates an AuthFactorInfo object. All unsupported parameters\n * are removed from the original request. If an invalid field is passed\n * an error is thrown.\n *\n * @param request The AuthFactorInfo request object.\n * @param writeOperationType The write operation type.\n */\nfunction validateAuthFactorInfo(request, writeOperationType) {\n    var validKeys = {\n        mfaEnrollmentId: true,\n        displayName: true,\n        phoneInfo: true,\n        enrolledAt: true,\n    };\n    // Remove unsupported keys from the original request.\n    for (var key in request) {\n        if (!(key in validKeys)) {\n            delete request[key];\n        }\n    }\n    // No enrollment ID is available for signupNewUser. Use another identifier.\n    var authFactorInfoIdentifier = request.mfaEnrollmentId || request.phoneInfo || JSON.stringify(request);\n    var uidRequired = writeOperationType !== WriteOperationType.Create;\n    if ((typeof request.mfaEnrollmentId !== 'undefined' || uidRequired) &&\n        !validator.isNonEmptyString(request.mfaEnrollmentId)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID, \"The second factor \\\"uid\\\" must be a valid non-empty string.\");\n    }\n    if (typeof request.displayName !== 'undefined' &&\n        !validator.isString(request.displayName)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISPLAY_NAME, \"The second factor \\\"displayName\\\" for \\\"\" + authFactorInfoIdentifier + \"\\\" must be a valid string.\");\n    }\n    // enrolledAt must be a valid UTC date string.\n    if (typeof request.enrolledAt !== 'undefined' &&\n        !validator.isISODateString(request.enrolledAt)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ENROLLMENT_TIME, \"The second factor \\\"enrollmentTime\\\" for \\\"\" + authFactorInfoIdentifier + \"\\\" must be a valid \" +\n            \"UTC date string.\");\n    }\n    // Validate required fields depending on second factor type.\n    if (typeof request.phoneInfo !== 'undefined') {\n        // phoneNumber should be a string and a valid phone number.\n        if (!validator.isPhoneNumber(request.phoneInfo)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHONE_NUMBER, \"The second factor \\\"phoneNumber\\\" for \\\"\" + authFactorInfoIdentifier + \"\\\" must be a non-empty \" +\n                \"E.164 standard compliant identifier string.\");\n        }\n    }\n    else {\n        // Invalid second factor. For example, a phone second factor may have been provided without\n        // a phone number. A TOTP based second factor may require a secret key, etc.\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ENROLLED_FACTORS, \"MFAInfo object provided is invalid.\");\n    }\n}\n/**\n * Validates a providerUserInfo object. All unsupported parameters\n * are removed from the original request. If an invalid field is passed\n * an error is thrown.\n *\n * @param {any} request The providerUserInfo request object.\n */\nfunction validateProviderUserInfo(request) {\n    var validKeys = {\n        rawId: true,\n        providerId: true,\n        email: true,\n        displayName: true,\n        photoUrl: true,\n    };\n    // Remove invalid keys from original request.\n    for (var key in request) {\n        if (!(key in validKeys)) {\n            delete request[key];\n        }\n    }\n    if (!validator.isNonEmptyString(request.providerId)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID);\n    }\n    if (typeof request.displayName !== 'undefined' &&\n        typeof request.displayName !== 'string') {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISPLAY_NAME, \"The provider \\\"displayName\\\" for \\\"\" + request.providerId + \"\\\" must be a valid string.\");\n    }\n    if (!validator.isNonEmptyString(request.rawId)) {\n        // This is called localId on the backend but the developer specifies this as\n        // uid externally. So the error message should use the client facing name.\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID, \"The provider \\\"uid\\\" for \\\"\" + request.providerId + \"\\\" must be a valid non-empty string.\");\n    }\n    // email should be a string and a valid email.\n    if (typeof request.email !== 'undefined' && !validator.isEmail(request.email)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL, \"The provider \\\"email\\\" for \\\"\" + request.providerId + \"\\\" must be a valid email string.\");\n    }\n    // photoUrl should be a URL.\n    if (typeof request.photoUrl !== 'undefined' &&\n        !validator.isURL(request.photoUrl)) {\n        // This is called photoUrl on the backend but the developer specifies this as\n        // photoURL externally. So the error message should use the client facing name.\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHOTO_URL, \"The provider \\\"photoURL\\\" for \\\"\" + request.providerId + \"\\\" must be a valid URL string.\");\n    }\n}\n/**\n * Validates a create/edit request object. All unsupported parameters\n * are removed from the original request. If an invalid field is passed\n * an error is thrown.\n *\n * @param request The create/edit request object.\n * @param writeOperationType The write operation type.\n */\nfunction validateCreateEditRequest(request, writeOperationType) {\n    var uploadAccountRequest = writeOperationType === WriteOperationType.Upload;\n    // Hash set of whitelisted parameters.\n    var validKeys = {\n        displayName: true,\n        localId: true,\n        email: true,\n        password: true,\n        rawPassword: true,\n        emailVerified: true,\n        photoUrl: true,\n        disabled: true,\n        disableUser: true,\n        deleteAttribute: true,\n        deleteProvider: true,\n        sanityCheck: true,\n        phoneNumber: true,\n        customAttributes: true,\n        validSince: true,\n        // Pass tenantId only for uploadAccount requests.\n        tenantId: uploadAccountRequest,\n        passwordHash: uploadAccountRequest,\n        salt: uploadAccountRequest,\n        createdAt: uploadAccountRequest,\n        lastLoginAt: uploadAccountRequest,\n        providerUserInfo: uploadAccountRequest,\n        mfaInfo: uploadAccountRequest,\n        // Only for non-uploadAccount requests.\n        mfa: !uploadAccountRequest,\n    };\n    // Remove invalid keys from original request.\n    for (var key in request) {\n        if (!(key in validKeys)) {\n            delete request[key];\n        }\n    }\n    if (typeof request.tenantId !== 'undefined' &&\n        !validator.isNonEmptyString(request.tenantId)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID);\n    }\n    // For any invalid parameter, use the external key name in the error description.\n    // displayName should be a string.\n    if (typeof request.displayName !== 'undefined' &&\n        !validator.isString(request.displayName)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISPLAY_NAME);\n    }\n    if ((typeof request.localId !== 'undefined' || uploadAccountRequest) &&\n        !validator.isUid(request.localId)) {\n        // This is called localId on the backend but the developer specifies this as\n        // uid externally. So the error message should use the client facing name.\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID);\n    }\n    // email should be a string and a valid email.\n    if (typeof request.email !== 'undefined' && !validator.isEmail(request.email)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL);\n    }\n    // phoneNumber should be a string and a valid phone number.\n    if (typeof request.phoneNumber !== 'undefined' &&\n        !validator.isPhoneNumber(request.phoneNumber)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHONE_NUMBER);\n    }\n    // password should be a string and a minimum of 6 chars.\n    if (typeof request.password !== 'undefined' &&\n        !validator.isPassword(request.password)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD);\n    }\n    // rawPassword should be a string and a minimum of 6 chars.\n    if (typeof request.rawPassword !== 'undefined' &&\n        !validator.isPassword(request.rawPassword)) {\n        // This is called rawPassword on the backend but the developer specifies this as\n        // password externally. So the error message should use the client facing name.\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD);\n    }\n    // emailVerified should be a boolean.\n    if (typeof request.emailVerified !== 'undefined' &&\n        typeof request.emailVerified !== 'boolean') {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL_VERIFIED);\n    }\n    // photoUrl should be a URL.\n    if (typeof request.photoUrl !== 'undefined' &&\n        !validator.isURL(request.photoUrl)) {\n        // This is called photoUrl on the backend but the developer specifies this as\n        // photoURL externally. So the error message should use the client facing name.\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHOTO_URL);\n    }\n    // disabled should be a boolean.\n    if (typeof request.disabled !== 'undefined' &&\n        typeof request.disabled !== 'boolean') {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISABLED_FIELD);\n    }\n    // validSince should be a number.\n    if (typeof request.validSince !== 'undefined' &&\n        !validator.isNumber(request.validSince)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TOKENS_VALID_AFTER_TIME);\n    }\n    // createdAt should be a number.\n    if (typeof request.createdAt !== 'undefined' &&\n        !validator.isNumber(request.createdAt)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CREATION_TIME);\n    }\n    // lastSignInAt should be a number.\n    if (typeof request.lastLoginAt !== 'undefined' &&\n        !validator.isNumber(request.lastLoginAt)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_LAST_SIGN_IN_TIME);\n    }\n    // disableUser should be a boolean.\n    if (typeof request.disableUser !== 'undefined' &&\n        typeof request.disableUser !== 'boolean') {\n        // This is called disableUser on the backend but the developer specifies this as\n        // disabled externally. So the error message should use the client facing name.\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISABLED_FIELD);\n    }\n    // customAttributes should be stringified JSON with no blacklisted claims.\n    // The payload should not exceed 1KB.\n    if (typeof request.customAttributes !== 'undefined') {\n        var developerClaims_1;\n        try {\n            developerClaims_1 = JSON.parse(request.customAttributes);\n        }\n        catch (error) {\n            // JSON parsing error. This should never happen as we stringify the claims internally.\n            // However, we still need to check since setAccountInfo via edit requests could pass\n            // this field.\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CLAIMS, error.message);\n        }\n        var invalidClaims_1 = [];\n        // Check for any invalid claims.\n        exports.RESERVED_CLAIMS.forEach(function (blacklistedClaim) {\n            if (Object.prototype.hasOwnProperty.call(developerClaims_1, blacklistedClaim)) {\n                invalidClaims_1.push(blacklistedClaim);\n            }\n        });\n        // Throw an error if an invalid claim is detected.\n        if (invalidClaims_1.length > 0) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.FORBIDDEN_CLAIM, invalidClaims_1.length > 1 ?\n                \"Developer claims \\\"\" + invalidClaims_1.join('\", \"') + \"\\\" are reserved and cannot be specified.\" :\n                \"Developer claim \\\"\" + invalidClaims_1[0] + \"\\\" is reserved and cannot be specified.\");\n        }\n        // Check claims payload does not exceed maxmimum size.\n        if (request.customAttributes.length > MAX_CLAIMS_PAYLOAD_SIZE) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.CLAIMS_TOO_LARGE, \"Developer claims payload should not exceed \" + MAX_CLAIMS_PAYLOAD_SIZE + \" characters.\");\n        }\n    }\n    // passwordHash has to be a base64 encoded string.\n    if (typeof request.passwordHash !== 'undefined' &&\n        !validator.isString(request.passwordHash)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_HASH);\n    }\n    // salt has to be a base64 encoded string.\n    if (typeof request.salt !== 'undefined' &&\n        !validator.isString(request.salt)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_SALT);\n    }\n    // providerUserInfo has to be an array of valid UserInfo requests.\n    if (typeof request.providerUserInfo !== 'undefined' &&\n        !validator.isArray(request.providerUserInfo)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_DATA);\n    }\n    else if (validator.isArray(request.providerUserInfo)) {\n        request.providerUserInfo.forEach(function (providerUserInfoEntry) {\n            validateProviderUserInfo(providerUserInfoEntry);\n        });\n    }\n    // mfaInfo is used for importUsers.\n    // mfa.enrollments is used for setAccountInfo.\n    // enrollments has to be an array of valid AuthFactorInfo requests.\n    var enrollments = null;\n    if (request.mfaInfo) {\n        enrollments = request.mfaInfo;\n    }\n    else if (request.mfa && request.mfa.enrollments) {\n        enrollments = request.mfa.enrollments;\n    }\n    if (enrollments) {\n        if (!validator.isArray(enrollments)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ENROLLED_FACTORS);\n        }\n        enrollments.forEach(function (authFactorInfoEntry) {\n            validateAuthFactorInfo(authFactorInfoEntry, writeOperationType);\n        });\n    }\n}\n/** Instantiates the createSessionCookie endpoint settings. */\nexports.FIREBASE_AUTH_CREATE_SESSION_COOKIE = new api_request_1.ApiSettings(':createSessionCookie', 'POST')\n    // Set request validator.\n    .setRequestValidator(function (request) {\n    // Validate the ID token is a non-empty string.\n    if (!validator.isNonEmptyString(request.idToken)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ID_TOKEN);\n    }\n    // Validate the custom session cookie duration.\n    if (!validator.isNumber(request.validDuration) ||\n        request.validDuration < MIN_SESSION_COOKIE_DURATION_SECS ||\n        request.validDuration > MAX_SESSION_COOKIE_DURATION_SECS) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION);\n    }\n})\n    // Set response validator.\n    .setResponseValidator(function (response) {\n    // Response should always contain the session cookie.\n    if (!validator.isNonEmptyString(response.sessionCookie)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR);\n    }\n});\n/** Instantiates the uploadAccount endpoint settings. */\nexports.FIREBASE_AUTH_UPLOAD_ACCOUNT = new api_request_1.ApiSettings('/accounts:batchCreate', 'POST');\n/** Instantiates the downloadAccount endpoint settings. */\nexports.FIREBASE_AUTH_DOWNLOAD_ACCOUNT = new api_request_1.ApiSettings('/accounts:batchGet', 'GET')\n    // Set request validator.\n    .setRequestValidator(function (request) {\n    // Validate next page token.\n    if (typeof request.nextPageToken !== 'undefined' &&\n        !validator.isNonEmptyString(request.nextPageToken)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PAGE_TOKEN);\n    }\n    // Validate max results.\n    if (!validator.isNumber(request.maxResults) ||\n        request.maxResults <= 0 ||\n        request.maxResults > MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"Required \\\"maxResults\\\" must be a positive integer that does not exceed \" +\n            (MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE + \".\"));\n    }\n});\n/** Instantiates the getAccountInfo endpoint settings. */\nexports.FIREBASE_AUTH_GET_ACCOUNT_INFO = new api_request_1.ApiSettings('/accounts:lookup', 'POST')\n    // Set request validator.\n    .setRequestValidator(function (request) {\n    if (!request.localId && !request.email && !request.phoneNumber && !request.federatedUserId) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing user identifier');\n    }\n})\n    // Set response validator.\n    .setResponseValidator(function (response) {\n    if (!response.users) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.USER_NOT_FOUND);\n    }\n});\n/**\n * Instantiates the getAccountInfo endpoint settings for use when fetching info\n * for multiple accounts.\n */\nexports.FIREBASE_AUTH_GET_ACCOUNTS_INFO = new api_request_1.ApiSettings('/accounts:lookup', 'POST')\n    // Set request validator.\n    .setRequestValidator(function (request) {\n    if (!request.localId && !request.email && !request.phoneNumber && !request.federatedUserId) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing user identifier');\n    }\n});\n/** Instantiates the deleteAccount endpoint settings. */\nexports.FIREBASE_AUTH_DELETE_ACCOUNT = new api_request_1.ApiSettings('/accounts:delete', 'POST')\n    // Set request validator.\n    .setRequestValidator(function (request) {\n    if (!request.localId) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing user identifier');\n    }\n});\nexports.FIREBASE_AUTH_BATCH_DELETE_ACCOUNTS = new api_request_1.ApiSettings('/accounts:batchDelete', 'POST')\n    .setRequestValidator(function (request) {\n    if (!request.localIds) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing user identifiers');\n    }\n    if (typeof request.force === 'undefined' || request.force !== true) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing force=true field');\n    }\n})\n    .setResponseValidator(function (response) {\n    var errors = response.errors || [];\n    errors.forEach(function (batchDeleteErrorInfo) {\n        if (typeof batchDeleteErrorInfo.index === 'undefined') {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server BatchDeleteAccountResponse is missing an errors.index field');\n        }\n        if (!batchDeleteErrorInfo.localId) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server BatchDeleteAccountResponse is missing an errors.localId field');\n        }\n        // Allow the (error) message to be missing/undef.\n    });\n});\n/** Instantiates the setAccountInfo endpoint settings for updating existing accounts. */\nexports.FIREBASE_AUTH_SET_ACCOUNT_INFO = new api_request_1.ApiSettings('/accounts:update', 'POST')\n    // Set request validator.\n    .setRequestValidator(function (request) {\n    // localId is a required parameter.\n    if (typeof request.localId === 'undefined') {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing user identifier');\n    }\n    // Throw error when tenantId is passed in POST body.\n    if (typeof request.tenantId !== 'undefined') {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"tenantId\" is an invalid \"UpdateRequest\" property.');\n    }\n    validateCreateEditRequest(request, WriteOperationType.Update);\n})\n    // Set response validator.\n    .setResponseValidator(function (response) {\n    // If the localId is not returned, then the request failed.\n    if (!response.localId) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.USER_NOT_FOUND);\n    }\n});\n/**\n * Instantiates the signupNewUser endpoint settings for creating a new user with or without\n * uid being specified. The backend will create a new one if not provided and return it.\n */\nexports.FIREBASE_AUTH_SIGN_UP_NEW_USER = new api_request_1.ApiSettings('/accounts', 'POST')\n    // Set request validator.\n    .setRequestValidator(function (request) {\n    // signupNewUser does not support customAttributes.\n    if (typeof request.customAttributes !== 'undefined') {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"\\\"customAttributes\\\" cannot be set when creating a new user.\");\n    }\n    // signupNewUser does not support validSince.\n    if (typeof request.validSince !== 'undefined') {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"\\\"validSince\\\" cannot be set when creating a new user.\");\n    }\n    // Throw error when tenantId is passed in POST body.\n    if (typeof request.tenantId !== 'undefined') {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"tenantId\" is an invalid \"CreateRequest\" property.');\n    }\n    validateCreateEditRequest(request, WriteOperationType.Create);\n})\n    // Set response validator.\n    .setResponseValidator(function (response) {\n    // If the localId is not returned, then the request failed.\n    if (!response.localId) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new user');\n    }\n});\nvar FIREBASE_AUTH_GET_OOB_CODE = new api_request_1.ApiSettings('/accounts:sendOobCode', 'POST')\n    // Set request validator.\n    .setRequestValidator(function (request) {\n    if (!validator.isEmail(request.email)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL);\n    }\n    if (exports.EMAIL_ACTION_REQUEST_TYPES.indexOf(request.requestType) === -1) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"\\\"\" + request.requestType + \"\\\" is not a supported email action request type.\");\n    }\n})\n    // Set response validator.\n    .setResponseValidator(function (response) {\n    // If the oobLink is not returned, then the request failed.\n    if (!response.oobLink) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create the email action link');\n    }\n});\n/** Instantiates the retrieve OIDC configuration endpoint settings. */\nvar GET_OAUTH_IDP_CONFIG = new api_request_1.ApiSettings('/oauthIdpConfigs/{providerId}', 'GET')\n    // Set response validator.\n    .setResponseValidator(function (response) {\n    // Response should always contain the OIDC provider resource name.\n    if (!validator.isNonEmptyString(response.name)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to get OIDC configuration');\n    }\n});\n/** Instantiates the delete OIDC configuration endpoint settings. */\nvar DELETE_OAUTH_IDP_CONFIG = new api_request_1.ApiSettings('/oauthIdpConfigs/{providerId}', 'DELETE');\n/** Instantiates the create OIDC configuration endpoint settings. */\nvar CREATE_OAUTH_IDP_CONFIG = new api_request_1.ApiSettings('/oauthIdpConfigs?oauthIdpConfigId={providerId}', 'POST')\n    // Set response validator.\n    .setResponseValidator(function (response) {\n    // Response should always contain the OIDC provider resource name.\n    if (!validator.isNonEmptyString(response.name)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new OIDC configuration');\n    }\n});\n/** Instantiates the update OIDC configuration endpoint settings. */\nvar UPDATE_OAUTH_IDP_CONFIG = new api_request_1.ApiSettings('/oauthIdpConfigs/{providerId}?updateMask={updateMask}', 'PATCH')\n    // Set response validator.\n    .setResponseValidator(function (response) {\n    // Response should always contain the configuration resource name.\n    if (!validator.isNonEmptyString(response.name)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update OIDC configuration');\n    }\n});\n/** Instantiates the list OIDC configuration endpoint settings. */\nvar LIST_OAUTH_IDP_CONFIGS = new api_request_1.ApiSettings('/oauthIdpConfigs', 'GET')\n    // Set request validator.\n    .setRequestValidator(function (request) {\n    // Validate next page token.\n    if (typeof request.pageToken !== 'undefined' &&\n        !validator.isNonEmptyString(request.pageToken)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PAGE_TOKEN);\n    }\n    // Validate max results.\n    if (!validator.isNumber(request.pageSize) ||\n        request.pageSize <= 0 ||\n        request.pageSize > MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"Required \\\"maxResults\\\" must be a positive integer that does not exceed \" +\n            (MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE + \".\"));\n    }\n});\n/** Instantiates the retrieve SAML configuration endpoint settings. */\nvar GET_INBOUND_SAML_CONFIG = new api_request_1.ApiSettings('/inboundSamlConfigs/{providerId}', 'GET')\n    // Set response validator.\n    .setResponseValidator(function (response) {\n    // Response should always contain the SAML provider resource name.\n    if (!validator.isNonEmptyString(response.name)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to get SAML configuration');\n    }\n});\n/** Instantiates the delete SAML configuration endpoint settings. */\nvar DELETE_INBOUND_SAML_CONFIG = new api_request_1.ApiSettings('/inboundSamlConfigs/{providerId}', 'DELETE');\n/** Instantiates the create SAML configuration endpoint settings. */\nvar CREATE_INBOUND_SAML_CONFIG = new api_request_1.ApiSettings('/inboundSamlConfigs?inboundSamlConfigId={providerId}', 'POST')\n    // Set response validator.\n    .setResponseValidator(function (response) {\n    // Response should always contain the SAML provider resource name.\n    if (!validator.isNonEmptyString(response.name)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new SAML configuration');\n    }\n});\n/** Instantiates the update SAML configuration endpoint settings. */\nvar UPDATE_INBOUND_SAML_CONFIG = new api_request_1.ApiSettings('/inboundSamlConfigs/{providerId}?updateMask={updateMask}', 'PATCH')\n    // Set response validator.\n    .setResponseValidator(function (response) {\n    // Response should always contain the configuration resource name.\n    if (!validator.isNonEmptyString(response.name)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update SAML configuration');\n    }\n});\n/** Instantiates the list SAML configuration endpoint settings. */\nvar LIST_INBOUND_SAML_CONFIGS = new api_request_1.ApiSettings('/inboundSamlConfigs', 'GET')\n    // Set request validator.\n    .setRequestValidator(function (request) {\n    // Validate next page token.\n    if (typeof request.pageToken !== 'undefined' &&\n        !validator.isNonEmptyString(request.pageToken)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PAGE_TOKEN);\n    }\n    // Validate max results.\n    if (!validator.isNumber(request.pageSize) ||\n        request.pageSize <= 0 ||\n        request.pageSize > MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"Required \\\"maxResults\\\" must be a positive integer that does not exceed \" +\n            (MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE + \".\"));\n    }\n});\n/**\n * Class that provides the mechanism to send requests to the Firebase Auth backend endpoints.\n */\nvar AbstractAuthRequestHandler = /** @class */ (function () {\n    /**\n     * @param {FirebaseApp} app The app used to fetch access tokens to sign API requests.\n     * @constructor\n     */\n    function AbstractAuthRequestHandler(app) {\n        this.app = app;\n        if (typeof app !== 'object' || app === null || !('options' in app)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'First argument passed to admin.auth() must be a valid Firebase app instance.');\n        }\n        this.httpClient = new api_request_1.AuthorizedHttpClient(app);\n    }\n    /**\n     * @param {any} response The response to check for errors.\n     * @return {string|null} The error code if present; null otherwise.\n     */\n    AbstractAuthRequestHandler.getErrorCode = function (response) {\n        return (validator.isNonNullObject(response) && response.error && response.error.message) || null;\n    };\n    AbstractAuthRequestHandler.addUidToRequest = function (id, request) {\n        if (!validator.isUid(id.uid)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID);\n        }\n        request.localId ? request.localId.push(id.uid) : request.localId = [id.uid];\n        return request;\n    };\n    AbstractAuthRequestHandler.addEmailToRequest = function (id, request) {\n        if (!validator.isEmail(id.email)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL);\n        }\n        request.email ? request.email.push(id.email) : request.email = [id.email];\n        return request;\n    };\n    AbstractAuthRequestHandler.addPhoneToRequest = function (id, request) {\n        if (!validator.isPhoneNumber(id.phoneNumber)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHONE_NUMBER);\n        }\n        request.phoneNumber ? request.phoneNumber.push(id.phoneNumber) : request.phoneNumber = [id.phoneNumber];\n        return request;\n    };\n    AbstractAuthRequestHandler.addProviderToRequest = function (id, request) {\n        if (!validator.isNonEmptyString(id.providerId)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID);\n        }\n        if (!validator.isNonEmptyString(id.providerUid)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_UID);\n        }\n        var federatedUserId = {\n            providerId: id.providerId,\n            rawId: id.providerUid,\n        };\n        request.federatedUserId\n            ? request.federatedUserId.push(federatedUserId)\n            : request.federatedUserId = [federatedUserId];\n        return request;\n    };\n    /**\n     * Creates a new Firebase session cookie with the specified duration that can be used for\n     * session management (set as a server side session cookie with custom cookie policy).\n     * The session cookie JWT will have the same payload claims as the provided ID token.\n     *\n     * @param {string} idToken The Firebase ID token to exchange for a session cookie.\n     * @param {number} expiresIn The session cookie duration in milliseconds.\n     *\n     * @return {Promise<string>} A promise that resolves on success with the created session cookie.\n     */\n    AbstractAuthRequestHandler.prototype.createSessionCookie = function (idToken, expiresIn) {\n        var request = {\n            idToken: idToken,\n            // Convert to seconds.\n            validDuration: expiresIn / 1000,\n        };\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_CREATE_SESSION_COOKIE, request)\n            .then(function (response) { return response.sessionCookie; });\n    };\n    /**\n     * Looks up a user by uid.\n     *\n     * @param {string} uid The uid of the user to lookup.\n     * @return {Promise<object>} A promise that resolves with the user information.\n     */\n    AbstractAuthRequestHandler.prototype.getAccountInfoByUid = function (uid) {\n        if (!validator.isUid(uid)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));\n        }\n        var request = {\n            localId: [uid],\n        };\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNT_INFO, request);\n    };\n    /**\n     * Looks up a user by email.\n     *\n     * @param {string} email The email of the user to lookup.\n     * @return {Promise<object>} A promise that resolves with the user information.\n     */\n    AbstractAuthRequestHandler.prototype.getAccountInfoByEmail = function (email) {\n        if (!validator.isEmail(email)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL));\n        }\n        var request = {\n            email: [email],\n        };\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNT_INFO, request);\n    };\n    /**\n     * Looks up a user by phone number.\n     *\n     * @param {string} phoneNumber The phone number of the user to lookup.\n     * @return {Promise<object>} A promise that resolves with the user information.\n     */\n    AbstractAuthRequestHandler.prototype.getAccountInfoByPhoneNumber = function (phoneNumber) {\n        if (!validator.isPhoneNumber(phoneNumber)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHONE_NUMBER));\n        }\n        var request = {\n            phoneNumber: [phoneNumber],\n        };\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNT_INFO, request);\n    };\n    /**\n     * Looks up multiple users by their identifiers (uid, email, etc).\n     *\n     * @param {UserIdentifier[]} identifiers The identifiers indicating the users\n     *     to be looked up. Must have <= 100 entries.\n     * @param {Promise<object>} A promise that resolves with the set of successfully\n     *     looked up users. Possibly empty if no users were looked up.\n     */\n    AbstractAuthRequestHandler.prototype.getAccountInfoByIdentifiers = function (identifiers) {\n        if (identifiers.length === 0) {\n            return Promise.resolve({ users: [] });\n        }\n        else if (identifiers.length > MAX_GET_ACCOUNTS_BATCH_SIZE) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MAXIMUM_USER_COUNT_EXCEEDED, '`identifiers` parameter must have <= ' + MAX_GET_ACCOUNTS_BATCH_SIZE + ' entries.');\n        }\n        var request = {};\n        for (var _i = 0, identifiers_1 = identifiers; _i < identifiers_1.length; _i++) {\n            var id = identifiers_1[_i];\n            if (identifier_1.isUidIdentifier(id)) {\n                request = AbstractAuthRequestHandler.addUidToRequest(id, request);\n            }\n            else if (identifier_1.isEmailIdentifier(id)) {\n                request = AbstractAuthRequestHandler.addEmailToRequest(id, request);\n            }\n            else if (identifier_1.isPhoneIdentifier(id)) {\n                request = AbstractAuthRequestHandler.addPhoneToRequest(id, request);\n            }\n            else if (identifier_1.isProviderIdentifier(id)) {\n                request = AbstractAuthRequestHandler.addProviderToRequest(id, request);\n            }\n            else {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Unrecognized identifier: ' + id);\n            }\n        }\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNTS_INFO, request);\n    };\n    /**\n     * Exports the users (single batch only) with a size of maxResults and starting from\n     * the offset as specified by pageToken.\n     *\n     * @param {number=} maxResults The page size, 1000 if undefined. This is also the maximum\n     *     allowed limit.\n     * @param {string=} pageToken The next page token. If not specified, returns users starting\n     *     without any offset. Users are returned in the order they were created from oldest to\n     *     newest, relative to the page token offset.\n     * @return {Promise<object>} A promise that resolves with the current batch of downloaded\n     *     users and the next page token if available. For the last page, an empty list of users\n     *     and no page token are returned.\n     */\n    AbstractAuthRequestHandler.prototype.downloadAccount = function (maxResults, pageToken) {\n        if (maxResults === void 0) { maxResults = MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE; }\n        // Construct request.\n        var request = {\n            maxResults: maxResults,\n            nextPageToken: pageToken,\n        };\n        // Remove next page token if not provided.\n        if (typeof request.nextPageToken === 'undefined') {\n            delete request.nextPageToken;\n        }\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_DOWNLOAD_ACCOUNT, request)\n            .then(function (response) {\n            // No more users available.\n            if (!response.users) {\n                response.users = [];\n            }\n            return response;\n        });\n    };\n    /**\n     * Imports the list of users provided to Firebase Auth. This is useful when\n     * migrating from an external authentication system without having to use the Firebase CLI SDK.\n     * At most, 1000 users are allowed to be imported one at a time.\n     * When importing a list of password users, UserImportOptions are required to be specified.\n     *\n     * @param {UserImportRecord[]} users The list of user records to import to Firebase Auth.\n     * @param {UserImportOptions=} options The user import options, required when the users provided\n     *     include password credentials.\n     * @return {Promise<UserImportResult>} A promise that resolves when the operation completes\n     *     with the result of the import. This includes the number of successful imports, the number\n     *     of failed uploads and their corresponding errors.\n     */\n    AbstractAuthRequestHandler.prototype.uploadAccount = function (users, options) {\n        // This will throw if any error is detected in the hash options.\n        // For errors in the list of users, this will not throw and will report the errors and the\n        // corresponding user index in the user import generated response below.\n        // No need to validate raw request or raw response as this is done in UserImportBuilder.\n        var userImportBuilder = new user_import_builder_1.UserImportBuilder(users, options, function (userRequest) {\n            // Pass true to validate the uploadAccount specific fields.\n            validateCreateEditRequest(userRequest, WriteOperationType.Upload);\n        });\n        var request = userImportBuilder.buildRequest();\n        // Fail quickly if more users than allowed are to be imported.\n        if (validator.isArray(users) && users.length > MAX_UPLOAD_ACCOUNT_BATCH_SIZE) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MAXIMUM_USER_COUNT_EXCEEDED, \"A maximum of \" + MAX_UPLOAD_ACCOUNT_BATCH_SIZE + \" users can be imported at once.\");\n        }\n        // If no remaining user in request after client side processing, there is no need\n        // to send the request to the server.\n        if (!request.users || request.users.length === 0) {\n            return Promise.resolve(userImportBuilder.buildResponse([]));\n        }\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_UPLOAD_ACCOUNT, request)\n            .then(function (response) {\n            // No error object is returned if no error encountered.\n            var failedUploads = (response.error || []);\n            // Rewrite response as UserImportResult and re-insert client previously detected errors.\n            return userImportBuilder.buildResponse(failedUploads);\n        });\n    };\n    /**\n     * Deletes an account identified by a uid.\n     *\n     * @param {string} uid The uid of the user to delete.\n     * @return {Promise<object>} A promise that resolves when the user is deleted.\n     */\n    AbstractAuthRequestHandler.prototype.deleteAccount = function (uid) {\n        if (!validator.isUid(uid)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));\n        }\n        var request = {\n            localId: uid,\n        };\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_DELETE_ACCOUNT, request);\n    };\n    AbstractAuthRequestHandler.prototype.deleteAccounts = function (uids, force) {\n        if (uids.length === 0) {\n            return Promise.resolve({});\n        }\n        else if (uids.length > MAX_DELETE_ACCOUNTS_BATCH_SIZE) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MAXIMUM_USER_COUNT_EXCEEDED, '`uids` parameter must have <= ' + MAX_DELETE_ACCOUNTS_BATCH_SIZE + ' entries.');\n        }\n        var request = {\n            localIds: [],\n            force: force,\n        };\n        uids.forEach(function (uid) {\n            if (!validator.isUid(uid)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID);\n            }\n            request.localIds.push(uid);\n        });\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_BATCH_DELETE_ACCOUNTS, request);\n    };\n    /**\n     * Sets additional developer claims on an existing user identified by provided UID.\n     *\n     * @param {string} uid The user to edit.\n     * @param {object} customUserClaims The developer claims to set.\n     * @return {Promise<string>} A promise that resolves when the operation completes\n     *     with the user id that was edited.\n     */\n    AbstractAuthRequestHandler.prototype.setCustomUserClaims = function (uid, customUserClaims) {\n        // Validate user UID.\n        if (!validator.isUid(uid)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));\n        }\n        else if (!validator.isObject(customUserClaims)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'CustomUserClaims argument must be an object or null.'));\n        }\n        // Delete operation. Replace null with an empty object.\n        if (customUserClaims === null) {\n            customUserClaims = {};\n        }\n        // Construct custom user attribute editting request.\n        var request = {\n            localId: uid,\n            customAttributes: JSON.stringify(customUserClaims),\n        };\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_SET_ACCOUNT_INFO, request)\n            .then(function (response) {\n            return response.localId;\n        });\n    };\n    /**\n     * Edits an existing user.\n     *\n     * @param {string} uid The user to edit.\n     * @param {object} properties The properties to set on the user.\n     * @return {Promise<string>} A promise that resolves when the operation completes\n     *     with the user id that was edited.\n     */\n    AbstractAuthRequestHandler.prototype.updateExistingAccount = function (uid, properties) {\n        if (!validator.isUid(uid)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));\n        }\n        else if (!validator.isNonNullObject(properties)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Properties argument must be a non-null object.'));\n        }\n        // Build the setAccountInfo request.\n        var request = deep_copy_1.deepCopy(properties);\n        request.localId = uid;\n        // For deleting displayName or photoURL, these values must be passed as null.\n        // They will be removed from the backend request and an additional parameter\n        // deleteAttribute: ['PHOTO_URL', 'DISPLAY_NAME']\n        // with an array of the parameter names to delete will be passed.\n        // Parameters that are deletable and their deleteAttribute names.\n        // Use client facing names, photoURL instead of photoUrl.\n        var deletableParams = {\n            displayName: 'DISPLAY_NAME',\n            photoURL: 'PHOTO_URL',\n        };\n        // Properties to delete if available.\n        request.deleteAttribute = [];\n        for (var key in deletableParams) {\n            if (request[key] === null) {\n                // Add property identifier to list of attributes to delete.\n                request.deleteAttribute.push(deletableParams[key]);\n                // Remove property from request.\n                delete request[key];\n            }\n        }\n        if (request.deleteAttribute.length === 0) {\n            delete request.deleteAttribute;\n        }\n        // For deleting phoneNumber, this value must be passed as null.\n        // It will be removed from the backend request and an additional parameter\n        // deleteProvider: ['phone'] with an array of providerIds (phone in this case),\n        // will be passed.\n        // Currently this applies to phone provider only.\n        if (request.phoneNumber === null) {\n            request.deleteProvider = ['phone'];\n            delete request.phoneNumber;\n        }\n        else {\n            // Doesn't apply to other providers in admin SDK.\n            delete request.deleteProvider;\n        }\n        // Rewrite photoURL to photoUrl.\n        if (typeof request.photoURL !== 'undefined') {\n            request.photoUrl = request.photoURL;\n            delete request.photoURL;\n        }\n        // Rewrite disabled to disableUser.\n        if (typeof request.disabled !== 'undefined') {\n            request.disableUser = request.disabled;\n            delete request.disabled;\n        }\n        // Construct mfa related user data.\n        if (validator.isNonNullObject(request.multiFactor)) {\n            if (request.multiFactor.enrolledFactors === null) {\n                // Remove all second factors.\n                request.mfa = {};\n            }\n            else if (validator.isArray(request.multiFactor.enrolledFactors)) {\n                request.mfa = {\n                    enrollments: [],\n                };\n                try {\n                    request.multiFactor.enrolledFactors.forEach(function (multiFactorInfo) {\n                        request.mfa.enrollments.push(user_import_builder_1.convertMultiFactorInfoToServerFormat(multiFactorInfo));\n                    });\n                }\n                catch (e) {\n                    return Promise.reject(e);\n                }\n                if (request.mfa.enrollments.length === 0) {\n                    delete request.mfa.enrollments;\n                }\n            }\n            delete request.multiFactor;\n        }\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_SET_ACCOUNT_INFO, request)\n            .then(function (response) {\n            return response.localId;\n        });\n    };\n    /**\n     * Revokes all refresh tokens for the specified user identified by the uid provided.\n     * In addition to revoking all refresh tokens for a user, all ID tokens issued\n     * before revocation will also be revoked on the Auth backend. Any request with an\n     * ID token generated before revocation will be rejected with a token expired error.\n     * Note that due to the fact that the timestamp is stored in seconds, any tokens minted in\n     * the same second as the revocation will still be valid. If there is a chance that a token\n     * was minted in the last second, delay for 1 second before revoking.\n     *\n     * @param {string} uid The user whose tokens are to be revoked.\n     * @return {Promise<string>} A promise that resolves when the operation completes\n     *     successfully with the user id of the corresponding user.\n     */\n    AbstractAuthRequestHandler.prototype.revokeRefreshTokens = function (uid) {\n        // Validate user UID.\n        if (!validator.isUid(uid)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));\n        }\n        var request = {\n            localId: uid,\n            // validSince is in UTC seconds.\n            validSince: Math.floor(new Date().getTime() / 1000),\n        };\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_SET_ACCOUNT_INFO, request)\n            .then(function (response) {\n            return response.localId;\n        });\n    };\n    /**\n     * Create a new user with the properties supplied.\n     *\n     * @param {object} properties The properties to set on the user.\n     * @return {Promise<string>} A promise that resolves when the operation completes\n     *     with the user id that was created.\n     */\n    AbstractAuthRequestHandler.prototype.createNewAccount = function (properties) {\n        if (!validator.isNonNullObject(properties)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Properties argument must be a non-null object.'));\n        }\n        // Build the signupNewUser request.\n        var request = deep_copy_1.deepCopy(properties);\n        // Rewrite photoURL to photoUrl.\n        if (typeof request.photoURL !== 'undefined') {\n            request.photoUrl = request.photoURL;\n            delete request.photoURL;\n        }\n        // Rewrite uid to localId if it exists.\n        if (typeof request.uid !== 'undefined') {\n            request.localId = request.uid;\n            delete request.uid;\n        }\n        // Construct mfa related user data.\n        if (validator.isNonNullObject(request.multiFactor)) {\n            if (validator.isNonEmptyArray(request.multiFactor.enrolledFactors)) {\n                var mfaInfo_1 = [];\n                try {\n                    request.multiFactor.enrolledFactors.forEach(function (multiFactorInfo) {\n                        // Enrollment time and uid are not allowed for signupNewUser endpoint.\n                        // They will automatically be provisioned server side.\n                        if (multiFactorInfo.enrollmentTime) {\n                            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"enrollmentTime\" is not supported when adding second factors via \"createUser()\"');\n                        }\n                        else if (multiFactorInfo.uid) {\n                            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"uid\" is not supported when adding second factors via \"createUser()\"');\n                        }\n                        mfaInfo_1.push(user_import_builder_1.convertMultiFactorInfoToServerFormat(multiFactorInfo));\n                    });\n                }\n                catch (e) {\n                    return Promise.reject(e);\n                }\n                request.mfaInfo = mfaInfo_1;\n            }\n            delete request.multiFactor;\n        }\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_SIGN_UP_NEW_USER, request)\n            .then(function (response) {\n            // Return the user id.\n            return response.localId;\n        });\n    };\n    /**\n     * Generates the out of band email action link for the email specified using the action code settings provided.\n     * Returns a promise that resolves with the generated link.\n     *\n     * @param {string} requestType The request type. This could be either used for password reset,\n     *     email verification, email link sign-in.\n     * @param {string} email The email of the user the link is being sent to.\n     * @param {ActionCodeSettings=} actionCodeSettings The optional action code setings which defines whether\n     *     the link is to be handled by a mobile app and the additional state information to be passed in the\n     *     deep link, etc. Required when requestType == 'EMAIL_SIGNIN'\n     * @return {Promise<string>} A promise that resolves with the email action link.\n     */\n    AbstractAuthRequestHandler.prototype.getEmailActionLink = function (requestType, email, actionCodeSettings) {\n        var request = { requestType: requestType, email: email, returnOobLink: true };\n        // ActionCodeSettings required for email link sign-in to determine the url where the sign-in will\n        // be completed.\n        if (typeof actionCodeSettings === 'undefined' && requestType === 'EMAIL_SIGNIN') {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"`actionCodeSettings` is required when `requestType` === 'EMAIL_SIGNIN'\"));\n        }\n        if (typeof actionCodeSettings !== 'undefined' || requestType === 'EMAIL_SIGNIN') {\n            try {\n                var builder = new action_code_settings_builder_1.ActionCodeSettingsBuilder(actionCodeSettings);\n                request = deep_copy_1.deepExtend(request, builder.buildRequest());\n            }\n            catch (e) {\n                return Promise.reject(e);\n            }\n        }\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), FIREBASE_AUTH_GET_OOB_CODE, request)\n            .then(function (response) {\n            // Return the link.\n            return response.oobLink;\n        });\n    };\n    /**\n     * Looks up an OIDC provider configuration by provider ID.\n     *\n     * @param {string} providerId The provider identifier of the configuration to lookup.\n     * @return {Promise<OIDCConfigServerResponse>} A promise that resolves with the provider configuration information.\n     */\n    AbstractAuthRequestHandler.prototype.getOAuthIdpConfig = function (providerId) {\n        if (!auth_config_1.OIDCConfig.isProviderId(providerId)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n        }\n        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), GET_OAUTH_IDP_CONFIG, {}, { providerId: providerId });\n    };\n    /**\n     * Lists the OIDC configurations (single batch only) with a size of maxResults and starting from\n     * the offset as specified by pageToken.\n     *\n     * @param {number=} maxResults The page size, 100 if undefined. This is also the maximum\n     *     allowed limit.\n     * @param {string=} pageToken The next page token. If not specified, returns OIDC configurations\n     *     without any offset. Configurations are returned in the order they were created from oldest to\n     *     newest, relative to the page token offset.\n     * @return {Promise<object>} A promise that resolves with the current batch of downloaded\n     *     OIDC configurations and the next page token if available. For the last page, an empty list of provider\n     *     configuration and no page token are returned.\n     */\n    AbstractAuthRequestHandler.prototype.listOAuthIdpConfigs = function (maxResults, pageToken) {\n        if (maxResults === void 0) { maxResults = MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE; }\n        var request = {\n            pageSize: maxResults,\n        };\n        // Add next page token if provided.\n        if (typeof pageToken !== 'undefined') {\n            request.pageToken = pageToken;\n        }\n        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), LIST_OAUTH_IDP_CONFIGS, request)\n            .then(function (response) {\n            if (!response.oauthIdpConfigs) {\n                response.oauthIdpConfigs = [];\n                delete response.nextPageToken;\n            }\n            return response;\n        });\n    };\n    /**\n     * Deletes an OIDC configuration identified by a providerId.\n     *\n     * @param {string} providerId The identifier of the OIDC configuration to delete.\n     * @return {Promise<void>} A promise that resolves when the OIDC provider is deleted.\n     */\n    AbstractAuthRequestHandler.prototype.deleteOAuthIdpConfig = function (providerId) {\n        if (!auth_config_1.OIDCConfig.isProviderId(providerId)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n        }\n        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), DELETE_OAUTH_IDP_CONFIG, {}, { providerId: providerId })\n            .then(function () {\n            // Return nothing.\n        });\n    };\n    /**\n     * Creates a new OIDC provider configuration with the properties provided.\n     *\n     * @param {AuthProviderConfig} options The properties to set on the new OIDC provider configuration to be created.\n     * @return {Promise<OIDCConfigServerResponse>} A promise that resolves with the newly created OIDC\n     *     configuration.\n     */\n    AbstractAuthRequestHandler.prototype.createOAuthIdpConfig = function (options) {\n        // Construct backend request.\n        var request;\n        try {\n            request = auth_config_1.OIDCConfig.buildServerRequest(options) || {};\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n        var providerId = options.providerId;\n        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), CREATE_OAUTH_IDP_CONFIG, request, { providerId: providerId })\n            .then(function (response) {\n            if (!auth_config_1.OIDCConfig.getProviderIdFromResourceName(response.name)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new OIDC provider configuration');\n            }\n            return response;\n        });\n    };\n    /**\n     * Updates an existing OIDC provider configuration with the properties provided.\n     *\n     * @param {string} providerId The provider identifier of the OIDC configuration to update.\n     * @param {OIDCUpdateAuthProviderRequest} options The properties to update on the existing configuration.\n     * @return {Promise<OIDCConfigServerResponse>} A promise that resolves with the modified provider\n     *     configuration.\n     */\n    AbstractAuthRequestHandler.prototype.updateOAuthIdpConfig = function (providerId, options) {\n        if (!auth_config_1.OIDCConfig.isProviderId(providerId)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n        }\n        // Construct backend request.\n        var request;\n        try {\n            request = auth_config_1.OIDCConfig.buildServerRequest(options, true) || {};\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n        var updateMask = utils.generateUpdateMask(request);\n        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), UPDATE_OAUTH_IDP_CONFIG, request, { providerId: providerId, updateMask: updateMask.join(',') })\n            .then(function (response) {\n            if (!auth_config_1.OIDCConfig.getProviderIdFromResourceName(response.name)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update OIDC provider configuration');\n            }\n            return response;\n        });\n    };\n    /**\n     * Looks up an SAML provider configuration by provider ID.\n     *\n     * @param {string} providerId The provider identifier of the configuration to lookup.\n     * @return {Promise<SAMLConfigServerResponse>} A promise that resolves with the provider configuration information.\n     */\n    AbstractAuthRequestHandler.prototype.getInboundSamlConfig = function (providerId) {\n        if (!auth_config_1.SAMLConfig.isProviderId(providerId)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n        }\n        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), GET_INBOUND_SAML_CONFIG, {}, { providerId: providerId });\n    };\n    /**\n     * Lists the SAML configurations (single batch only) with a size of maxResults and starting from\n     * the offset as specified by pageToken.\n     *\n     * @param {number=} maxResults The page size, 100 if undefined. This is also the maximum\n     *     allowed limit.\n     * @param {string=} pageToken The next page token. If not specified, returns SAML configurations starting\n     *     without any offset. Configurations are returned in the order they were created from oldest to\n     *     newest, relative to the page token offset.\n     * @return {Promise<object>} A promise that resolves with the current batch of downloaded\n     *     SAML configurations and the next page token if available. For the last page, an empty list of provider\n     *     configuration and no page token are returned.\n     */\n    AbstractAuthRequestHandler.prototype.listInboundSamlConfigs = function (maxResults, pageToken) {\n        if (maxResults === void 0) { maxResults = MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE; }\n        var request = {\n            pageSize: maxResults,\n        };\n        // Add next page token if provided.\n        if (typeof pageToken !== 'undefined') {\n            request.pageToken = pageToken;\n        }\n        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), LIST_INBOUND_SAML_CONFIGS, request)\n            .then(function (response) {\n            if (!response.inboundSamlConfigs) {\n                response.inboundSamlConfigs = [];\n                delete response.nextPageToken;\n            }\n            return response;\n        });\n    };\n    /**\n     * Deletes a SAML configuration identified by a providerId.\n     *\n     * @param {string} providerId The identifier of the SAML configuration to delete.\n     * @return {Promise<void>} A promise that resolves when the SAML provider is deleted.\n     */\n    AbstractAuthRequestHandler.prototype.deleteInboundSamlConfig = function (providerId) {\n        if (!auth_config_1.SAMLConfig.isProviderId(providerId)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n        }\n        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), DELETE_INBOUND_SAML_CONFIG, {}, { providerId: providerId })\n            .then(function () {\n            // Return nothing.\n        });\n    };\n    /**\n     * Creates a new SAML provider configuration with the properties provided.\n     *\n     * @param {AuthProviderConfig} options The properties to set on the new SAML provider configuration to be created.\n     * @return {Promise<SAMLConfigServerResponse>} A promise that resolves with the newly created SAML\n     *     configuration.\n     */\n    AbstractAuthRequestHandler.prototype.createInboundSamlConfig = function (options) {\n        // Construct backend request.\n        var request;\n        try {\n            request = auth_config_1.SAMLConfig.buildServerRequest(options) || {};\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n        var providerId = options.providerId;\n        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), CREATE_INBOUND_SAML_CONFIG, request, { providerId: providerId })\n            .then(function (response) {\n            if (!auth_config_1.SAMLConfig.getProviderIdFromResourceName(response.name)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new SAML provider configuration');\n            }\n            return response;\n        });\n    };\n    /**\n     * Updates an existing SAML provider configuration with the properties provided.\n     *\n     * @param {string} providerId The provider identifier of the SAML configuration to update.\n     * @param {SAMLUpdateAuthProviderRequest} options The properties to update on the existing configuration.\n     * @return {Promise<SAMLConfigServerResponse>} A promise that resolves with the modified provider\n     *     configuration.\n     */\n    AbstractAuthRequestHandler.prototype.updateInboundSamlConfig = function (providerId, options) {\n        if (!auth_config_1.SAMLConfig.isProviderId(providerId)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n        }\n        // Construct backend request.\n        var request;\n        try {\n            request = auth_config_1.SAMLConfig.buildServerRequest(options, true) || {};\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n        var updateMask = utils.generateUpdateMask(request);\n        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), UPDATE_INBOUND_SAML_CONFIG, request, { providerId: providerId, updateMask: updateMask.join(',') })\n            .then(function (response) {\n            if (!auth_config_1.SAMLConfig.getProviderIdFromResourceName(response.name)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update SAML provider configuration');\n            }\n            return response;\n        });\n    };\n    /**\n     * Invokes the request handler based on the API settings object passed.\n     *\n     * @param {AuthResourceUrlBuilder} urlBuilder The URL builder for Auth endpoints.\n     * @param {ApiSettings} apiSettings The API endpoint settings to apply to request and response.\n     * @param {object} requestData The request data.\n     * @param {object=} additionalResourceParams Additional resource related params if needed.\n     * @return {Promise<object>} A promise that resolves with the response.\n     */\n    AbstractAuthRequestHandler.prototype.invokeRequestHandler = function (urlBuilder, apiSettings, requestData, additionalResourceParams) {\n        var _this = this;\n        return urlBuilder.getUrl(apiSettings.getEndpoint(), additionalResourceParams)\n            .then(function (url) {\n            // Validate request.\n            var requestValidator = apiSettings.getRequestValidator();\n            requestValidator(requestData);\n            // Process request.\n            var req = {\n                method: apiSettings.getHttpMethod(),\n                url: url,\n                headers: FIREBASE_AUTH_HEADER,\n                data: requestData,\n                timeout: FIREBASE_AUTH_TIMEOUT,\n            };\n            return _this.httpClient.send(req);\n        })\n            .then(function (response) {\n            // Validate response.\n            var responseValidator = apiSettings.getResponseValidator();\n            responseValidator(response.data);\n            // Return entire response.\n            return response.data;\n        })\n            .catch(function (err) {\n            if (err instanceof api_request_1.HttpError) {\n                var error = err.response.data;\n                var errorCode = AbstractAuthRequestHandler.getErrorCode(error);\n                if (!errorCode) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Error returned from server: ' + error + '. Additionally, an ' +\n                        'internal error occurred while attempting to extract the ' +\n                        'errorcode from the error.');\n                }\n                throw error_1.FirebaseAuthError.fromServerError(errorCode, /* message */ undefined, error);\n            }\n            throw err;\n        });\n    };\n    /**\n     * @return {AuthResourceUrlBuilder} The current Auth user management resource URL builder.\n     */\n    AbstractAuthRequestHandler.prototype.getAuthUrlBuilder = function () {\n        if (!this.authUrlBuilder) {\n            this.authUrlBuilder = this.newAuthUrlBuilder();\n        }\n        return this.authUrlBuilder;\n    };\n    /**\n     * @return {AuthResourceUrlBuilder} The current project config resource URL builder.\n     */\n    AbstractAuthRequestHandler.prototype.getProjectConfigUrlBuilder = function () {\n        if (!this.projectConfigUrlBuilder) {\n            this.projectConfigUrlBuilder = this.newProjectConfigUrlBuilder();\n        }\n        return this.projectConfigUrlBuilder;\n    };\n    return AbstractAuthRequestHandler;\n}());\nexports.AbstractAuthRequestHandler = AbstractAuthRequestHandler;\n/** Instantiates the getTenant endpoint settings. */\nvar GET_TENANT = new api_request_1.ApiSettings('/tenants/{tenantId}', 'GET')\n    // Set response validator.\n    .setResponseValidator(function (response) {\n    // Response should always contain at least the tenant name.\n    if (!validator.isNonEmptyString(response.name)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to get tenant');\n    }\n});\n/** Instantiates the deleteTenant endpoint settings. */\nvar DELETE_TENANT = new api_request_1.ApiSettings('/tenants/{tenantId}', 'DELETE');\n/** Instantiates the updateTenant endpoint settings. */\nvar UPDATE_TENANT = new api_request_1.ApiSettings('/tenants/{tenantId}?updateMask={updateMask}', 'PATCH')\n    // Set response validator.\n    .setResponseValidator(function (response) {\n    // Response should always contain at least the tenant name.\n    if (!validator.isNonEmptyString(response.name) ||\n        !tenant_1.Tenant.getTenantIdFromResourceName(response.name)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update tenant');\n    }\n});\n/** Instantiates the listTenants endpoint settings. */\nvar LIST_TENANTS = new api_request_1.ApiSettings('/tenants', 'GET')\n    // Set request validator.\n    .setRequestValidator(function (request) {\n    // Validate next page token.\n    if (typeof request.pageToken !== 'undefined' &&\n        !validator.isNonEmptyString(request.pageToken)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PAGE_TOKEN);\n    }\n    // Validate max results.\n    if (!validator.isNumber(request.pageSize) ||\n        request.pageSize <= 0 ||\n        request.pageSize > MAX_LIST_TENANT_PAGE_SIZE) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"Required \\\"maxResults\\\" must be a positive non-zero number that does not exceed \" +\n            (\"the allowed \" + MAX_LIST_TENANT_PAGE_SIZE + \".\"));\n    }\n});\n/** Instantiates the createTenant endpoint settings. */\nvar CREATE_TENANT = new api_request_1.ApiSettings('/tenants', 'POST')\n    // Set response validator.\n    .setResponseValidator(function (response) {\n    // Response should always contain at least the tenant name.\n    if (!validator.isNonEmptyString(response.name) ||\n        !tenant_1.Tenant.getTenantIdFromResourceName(response.name)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new tenant');\n    }\n});\n/**\n * Utility for sending requests to Auth server that are Auth instance related. This includes user and\n * tenant management related APIs. This extends the BaseFirebaseAuthRequestHandler class and defines\n * additional tenant management related APIs.\n */\nvar AuthRequestHandler = /** @class */ (function (_super) {\n    __extends(AuthRequestHandler, _super);\n    /**\n     * The FirebaseAuthRequestHandler constructor used to initialize an instance using a FirebaseApp.\n     *\n     * @param {FirebaseApp} app The app used to fetch access tokens to sign API requests.\n     * @constructor.\n     */\n    function AuthRequestHandler(app) {\n        var _this = _super.call(this, app) || this;\n        _this.tenantMgmtResourceBuilder = new AuthResourceUrlBuilder(app, 'v2');\n        return _this;\n    }\n    /**\n     * @return {AuthResourceUrlBuilder} A new Auth user management resource URL builder instance.\n     */\n    AuthRequestHandler.prototype.newAuthUrlBuilder = function () {\n        return new AuthResourceUrlBuilder(this.app, 'v1');\n    };\n    /**\n     * @return {AuthResourceUrlBuilder} A new project config resource URL builder instance.\n     */\n    AuthRequestHandler.prototype.newProjectConfigUrlBuilder = function () {\n        return new AuthResourceUrlBuilder(this.app, 'v2');\n    };\n    /**\n     * Looks up a tenant by tenant ID.\n     *\n     * @param {string} tenantId The tenant identifier of the tenant to lookup.\n     * @return {Promise<TenantServerResponse>} A promise that resolves with the tenant information.\n     */\n    AuthRequestHandler.prototype.getTenant = function (tenantId) {\n        if (!validator.isNonEmptyString(tenantId)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID));\n        }\n        return this.invokeRequestHandler(this.tenantMgmtResourceBuilder, GET_TENANT, {}, { tenantId: tenantId })\n            .then(function (response) {\n            return response;\n        });\n    };\n    /**\n     * Exports the tenants (single batch only) with a size of maxResults and starting from\n     * the offset as specified by pageToken.\n     *\n     * @param {number=} maxResults The page size, 1000 if undefined. This is also the maximum\n     *     allowed limit.\n     * @param {string=} pageToken The next page token. If not specified, returns tenants starting\n     *     without any offset. Tenants are returned in the order they were created from oldest to\n     *     newest, relative to the page token offset.\n     * @return {Promise<object>} A promise that resolves with the current batch of downloaded\n     *     tenants and the next page token if available. For the last page, an empty list of tenants\n     *     and no page token are returned.\n     */\n    AuthRequestHandler.prototype.listTenants = function (maxResults, pageToken) {\n        if (maxResults === void 0) { maxResults = MAX_LIST_TENANT_PAGE_SIZE; }\n        var request = {\n            pageSize: maxResults,\n            pageToken: pageToken,\n        };\n        // Remove next page token if not provided.\n        if (typeof request.pageToken === 'undefined') {\n            delete request.pageToken;\n        }\n        return this.invokeRequestHandler(this.tenantMgmtResourceBuilder, LIST_TENANTS, request)\n            .then(function (response) {\n            if (!response.tenants) {\n                response.tenants = [];\n                delete response.nextPageToken;\n            }\n            return response;\n        });\n    };\n    /**\n     * Deletes a tenant identified by a tenantId.\n     *\n     * @param {string} tenantId The identifier of the tenant to delete.\n     * @return {Promise<void>} A promise that resolves when the tenant is deleted.\n     */\n    AuthRequestHandler.prototype.deleteTenant = function (tenantId) {\n        if (!validator.isNonEmptyString(tenantId)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID));\n        }\n        return this.invokeRequestHandler(this.tenantMgmtResourceBuilder, DELETE_TENANT, {}, { tenantId: tenantId })\n            .then(function () {\n            // Return nothing.\n        });\n    };\n    /**\n     * Creates a new tenant with the properties provided.\n     *\n     * @param {TenantOptions} tenantOptions The properties to set on the new tenant to be created.\n     * @return {Promise<TenantServerResponse>} A promise that resolves with the newly created tenant object.\n     */\n    AuthRequestHandler.prototype.createTenant = function (tenantOptions) {\n        try {\n            // Construct backend request.\n            var request = tenant_1.Tenant.buildServerRequest(tenantOptions, true);\n            return this.invokeRequestHandler(this.tenantMgmtResourceBuilder, CREATE_TENANT, request)\n                .then(function (response) {\n                return response;\n            });\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n    };\n    /**\n     * Updates an existing tenant with the properties provided.\n     *\n     * @param {string} tenantId The tenant identifier of the tenant to update.\n     * @param {TenantOptions} tenantOptions The properties to update on the existing tenant.\n     * @return {Promise<TenantServerResponse>} A promise that resolves with the modified tenant object.\n     */\n    AuthRequestHandler.prototype.updateTenant = function (tenantId, tenantOptions) {\n        if (!validator.isNonEmptyString(tenantId)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID));\n        }\n        try {\n            // Construct backend request.\n            var request = tenant_1.Tenant.buildServerRequest(tenantOptions, false);\n            var updateMask = utils.generateUpdateMask(request);\n            return this.invokeRequestHandler(this.tenantMgmtResourceBuilder, UPDATE_TENANT, request, { tenantId: tenantId, updateMask: updateMask.join(',') })\n                .then(function (response) {\n                return response;\n            });\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n    };\n    return AuthRequestHandler;\n}(AbstractAuthRequestHandler));\nexports.AuthRequestHandler = AuthRequestHandler;\n/**\n * Utility for sending requests to Auth server that are tenant Auth instance related. This includes user\n * management related APIs for specified tenants.\n * This extends the BaseFirebaseAuthRequestHandler class.\n */\nvar TenantAwareAuthRequestHandler = /** @class */ (function (_super) {\n    __extends(TenantAwareAuthRequestHandler, _super);\n    /**\n     * The FirebaseTenantRequestHandler constructor used to initialize an instance using a\n     * FirebaseApp and a tenant ID.\n     *\n     * @param {FirebaseApp} app The app used to fetch access tokens to sign API requests.\n     * @param {string} tenantId The request handler's tenant ID.\n     * @constructor\n     */\n    function TenantAwareAuthRequestHandler(app, tenantId) {\n        var _this = _super.call(this, app) || this;\n        _this.tenantId = tenantId;\n        return _this;\n    }\n    /**\n     * @return {AuthResourceUrlBuilder} A new Auth user management resource URL builder instance.\n     */\n    TenantAwareAuthRequestHandler.prototype.newAuthUrlBuilder = function () {\n        return new TenantAwareAuthResourceUrlBuilder(this.app, 'v1', this.tenantId);\n    };\n    /**\n     * @return {AuthResourceUrlBuilder} A new project config resource URL builder instance.\n     */\n    TenantAwareAuthRequestHandler.prototype.newProjectConfigUrlBuilder = function () {\n        return new TenantAwareAuthResourceUrlBuilder(this.app, 'v2', this.tenantId);\n    };\n    /**\n     * Imports the list of users provided to Firebase Auth. This is useful when\n     * migrating from an external authentication system without having to use the Firebase CLI SDK.\n     * At most, 1000 users are allowed to be imported one at a time.\n     * When importing a list of password users, UserImportOptions are required to be specified.\n     *\n     * Overrides the superclass methods by adding an additional check to match tenant IDs of\n     * imported user records if present.\n     *\n     * @param {UserImportRecord[]} users The list of user records to import to Firebase Auth.\n     * @param {UserImportOptions=} options The user import options, required when the users provided\n     *     include password credentials.\n     * @return {Promise<UserImportResult>} A promise that resolves when the operation completes\n     *     with the result of the import. This includes the number of successful imports, the number\n     *     of failed uploads and their corresponding errors.\n     */\n    TenantAwareAuthRequestHandler.prototype.uploadAccount = function (users, options) {\n        var _this = this;\n        // Add additional check to match tenant ID of imported user records.\n        users.forEach(function (user, index) {\n            if (validator.isNonEmptyString(user.tenantId) &&\n                user.tenantId !== _this.tenantId) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISMATCHING_TENANT_ID, \"UserRecord of index \\\"\" + index + \"\\\" has mismatching tenant ID \\\"\" + user.tenantId + \"\\\"\");\n            }\n        });\n        return _super.prototype.uploadAccount.call(this, users, options);\n    };\n    return TenantAwareAuthRequestHandler;\n}(AbstractAuthRequestHandler));\nexports.TenantAwareAuthRequestHandler = TenantAwareAuthRequestHandler;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/auth/auth-api-request.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/auth/auth-config.js":
/*!*****************************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/auth/auth-config.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\n/*!\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar validator = __webpack_require__(/*! ../utils/validator */ \"./src/node_modules/firebase-admin/lib/utils/validator.js\");\nvar deep_copy_1 = __webpack_require__(/*! ../utils/deep-copy */ \"./src/node_modules/firebase-admin/lib/utils/deep-copy.js\");\nvar error_1 = __webpack_require__(/*! ../utils/error */ \"./src/node_modules/firebase-admin/lib/utils/error.js\");\n/**\n * Defines the email sign-in config class used to convert client side EmailSignInConfig\n * to a format that is understood by the Auth server.\n */\nvar EmailSignInConfig = /** @class */ (function () {\n    /**\n     * The EmailSignInConfig constructor.\n     *\n     * @param {any} response The server side response used to initialize the\n     *     EmailSignInConfig object.\n     * @constructor\n     */\n    function EmailSignInConfig(response) {\n        if (typeof response.allowPasswordSignup === 'undefined') {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid email sign-in configuration response');\n        }\n        this.enabled = response.allowPasswordSignup;\n        this.passwordRequired = !response.enableEmailLinkSignin;\n    }\n    /**\n     * Static method to convert a client side request to a EmailSignInConfigServerRequest.\n     * Throws an error if validation fails.\n     *\n     * @param {any} options The options object to convert to a server request.\n     * @return {EmailSignInConfigServerRequest} The resulting server request.\n     */\n    EmailSignInConfig.buildServerRequest = function (options) {\n        var request = {};\n        EmailSignInConfig.validate(options);\n        if (Object.prototype.hasOwnProperty.call(options, 'enabled')) {\n            request.allowPasswordSignup = options.enabled;\n        }\n        if (Object.prototype.hasOwnProperty.call(options, 'passwordRequired')) {\n            request.enableEmailLinkSignin = !options.passwordRequired;\n        }\n        return request;\n    };\n    /**\n     * Validates the EmailSignInConfig options object. Throws an error on failure.\n     *\n     * @param {any} options The options object to validate.\n     */\n    EmailSignInConfig.validate = function (options) {\n        // TODO: Validate the request.\n        var validKeys = {\n            enabled: true,\n            passwordRequired: true,\n        };\n        if (!validator.isNonNullObject(options)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"EmailSignInConfig\" must be a non-null object.');\n        }\n        // Check for unsupported top level attributes.\n        for (var key in options) {\n            if (!(key in validKeys)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"\\\"\" + key + \"\\\" is not a valid EmailSignInConfig parameter.\");\n            }\n        }\n        // Validate content.\n        if (typeof options.enabled !== 'undefined' &&\n            !validator.isBoolean(options.enabled)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"EmailSignInConfig.enabled\" must be a boolean.');\n        }\n        if (typeof options.passwordRequired !== 'undefined' &&\n            !validator.isBoolean(options.passwordRequired)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"EmailSignInConfig.passwordRequired\" must be a boolean.');\n        }\n    };\n    /** @return {object} The plain object representation of the email sign-in config. */\n    EmailSignInConfig.prototype.toJSON = function () {\n        return {\n            enabled: this.enabled,\n            passwordRequired: this.passwordRequired,\n        };\n    };\n    return EmailSignInConfig;\n}());\nexports.EmailSignInConfig = EmailSignInConfig;\n/**\n * Defines the SAMLConfig class used to convert a client side configuration to its\n * server side representation.\n */\nvar SAMLConfig = /** @class */ (function () {\n    /**\n     * The SAMLConfig constructor.\n     *\n     * @param {any} response The server side response used to initialize the SAMLConfig object.\n     * @constructor\n     */\n    function SAMLConfig(response) {\n        if (!response ||\n            !response.idpConfig ||\n            !response.idpConfig.idpEntityId ||\n            !response.idpConfig.ssoUrl ||\n            !response.spConfig ||\n            !response.spConfig.spEntityId ||\n            !response.name ||\n            !(validator.isString(response.name) &&\n                SAMLConfig.getProviderIdFromResourceName(response.name))) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid SAML configuration response');\n        }\n        var providerId = SAMLConfig.getProviderIdFromResourceName(response.name);\n        if (!providerId) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid SAML configuration response');\n        }\n        this.providerId = providerId;\n        // RP config.\n        this.rpEntityId = response.spConfig.spEntityId;\n        this.callbackURL = response.spConfig.callbackUri;\n        // IdP config.\n        this.idpEntityId = response.idpConfig.idpEntityId;\n        this.ssoURL = response.idpConfig.ssoUrl;\n        this.enableRequestSigning = !!response.idpConfig.signRequest;\n        var x509Certificates = [];\n        for (var _i = 0, _a = (response.idpConfig.idpCertificates || []); _i < _a.length; _i++) {\n            var cert = _a[_i];\n            if (cert.x509Certificate) {\n                x509Certificates.push(cert.x509Certificate);\n            }\n        }\n        this.x509Certificates = x509Certificates;\n        // When enabled is undefined, it takes its default value of false.\n        this.enabled = !!response.enabled;\n        this.displayName = response.displayName;\n    }\n    /**\n     * Converts a client side request to a SAMLConfigServerRequest which is the format\n     * accepted by the backend server.\n     * Throws an error if validation fails. If the request is not a SAMLConfig request,\n     * returns null.\n     *\n     * @param {SAMLAuthProviderRequest} options The options object to convert to a server request.\n     * @param {boolean=} ignoreMissingFields Whether to ignore missing fields.\n     * @return {?SAMLConfigServerRequest} The resulting server request or null if not valid.\n     */\n    SAMLConfig.buildServerRequest = function (options, ignoreMissingFields) {\n        if (ignoreMissingFields === void 0) { ignoreMissingFields = false; }\n        var makeRequest = validator.isNonNullObject(options) &&\n            (options.providerId || ignoreMissingFields);\n        if (!makeRequest) {\n            return null;\n        }\n        var request = {};\n        // Validate options.\n        SAMLConfig.validate(options, ignoreMissingFields);\n        request.enabled = options.enabled;\n        request.displayName = options.displayName;\n        // IdP config.\n        if (options.idpEntityId || options.ssoURL || options.x509Certificates) {\n            request.idpConfig = {\n                idpEntityId: options.idpEntityId,\n                ssoUrl: options.ssoURL,\n                signRequest: options.enableRequestSigning,\n                idpCertificates: typeof options.x509Certificates === 'undefined' ? undefined : [],\n            };\n            if (options.x509Certificates) {\n                for (var _i = 0, _a = (options.x509Certificates || []); _i < _a.length; _i++) {\n                    var cert = _a[_i];\n                    request.idpConfig.idpCertificates.push({ x509Certificate: cert });\n                }\n            }\n        }\n        // RP config.\n        if (options.callbackURL || options.rpEntityId) {\n            request.spConfig = {\n                spEntityId: options.rpEntityId,\n                callbackUri: options.callbackURL,\n            };\n        }\n        return request;\n    };\n    /**\n     * Returns the provider ID corresponding to the resource name if available.\n     *\n     * @param {string} resourceName The server side resource name.\n     * @return {?string} The provider ID corresponding to the resource, null otherwise.\n     */\n    SAMLConfig.getProviderIdFromResourceName = function (resourceName) {\n        // name is of form projects/project1/inboundSamlConfigs/providerId1\n        var matchProviderRes = resourceName.match(/\\/inboundSamlConfigs\\/(saml\\..*)$/);\n        if (!matchProviderRes || matchProviderRes.length < 2) {\n            return null;\n        }\n        return matchProviderRes[1];\n    };\n    /**\n     * @param {any} providerId The provider ID to check.\n     * @return {boolean} Whether the provider ID corresponds to a SAML provider.\n     */\n    SAMLConfig.isProviderId = function (providerId) {\n        return validator.isNonEmptyString(providerId) && providerId.indexOf('saml.') === 0;\n    };\n    /**\n     * Validates the SAMLConfig options object. Throws an error on failure.\n     *\n     * @param {SAMLAuthProviderRequest} options The options object to validate.\n     * @param {boolean=} ignoreMissingFields Whether to ignore missing fields.\n     */\n    SAMLConfig.validate = function (options, ignoreMissingFields) {\n        if (ignoreMissingFields === void 0) { ignoreMissingFields = false; }\n        var validKeys = {\n            enabled: true,\n            displayName: true,\n            providerId: true,\n            idpEntityId: true,\n            ssoURL: true,\n            x509Certificates: true,\n            rpEntityId: true,\n            callbackURL: true,\n            enableRequestSigning: true,\n        };\n        if (!validator.isNonNullObject(options)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig\" must be a valid non-null object.');\n        }\n        // Check for unsupported top level attributes.\n        for (var key in options) {\n            if (!(key in validKeys)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, \"\\\"\" + key + \"\\\" is not a valid SAML config parameter.\");\n            }\n        }\n        // Required fields.\n        if (validator.isNonEmptyString(options.providerId)) {\n            if (options.providerId.indexOf('saml.') !== 0) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '\"SAMLAuthProviderConfig.providerId\" must be a valid non-empty string prefixed with \"saml.\".');\n            }\n        }\n        else if (!ignoreMissingFields) {\n            // providerId is required and not provided correctly.\n            throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '\"SAMLAuthProviderConfig.providerId\" must be a valid non-empty string prefixed with \"saml.\".');\n        }\n        if (!(ignoreMissingFields && typeof options.idpEntityId === 'undefined') &&\n            !validator.isNonEmptyString(options.idpEntityId)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.idpEntityId\" must be a valid non-empty string.');\n        }\n        if (!(ignoreMissingFields && typeof options.ssoURL === 'undefined') &&\n            !validator.isURL(options.ssoURL)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.ssoURL\" must be a valid URL string.');\n        }\n        if (!(ignoreMissingFields && typeof options.rpEntityId === 'undefined') &&\n            !validator.isNonEmptyString(options.rpEntityId)) {\n            throw new error_1.FirebaseAuthError(!options.rpEntityId ? error_1.AuthClientErrorCode.MISSING_SAML_RELYING_PARTY_CONFIG :\n                error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.rpEntityId\" must be a valid non-empty string.');\n        }\n        if (!(ignoreMissingFields && typeof options.callbackURL === 'undefined') &&\n            !validator.isURL(options.callbackURL)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.callbackURL\" must be a valid URL string.');\n        }\n        if (!(ignoreMissingFields && typeof options.x509Certificates === 'undefined') &&\n            !validator.isArray(options.x509Certificates)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.x509Certificates\" must be a valid array of X509 certificate strings.');\n        }\n        (options.x509Certificates || []).forEach(function (cert) {\n            if (!validator.isNonEmptyString(cert)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.x509Certificates\" must be a valid array of X509 certificate strings.');\n            }\n        });\n        if (typeof options.enableRequestSigning !== 'undefined' &&\n            !validator.isBoolean(options.enableRequestSigning)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.enableRequestSigning\" must be a boolean.');\n        }\n        if (typeof options.enabled !== 'undefined' &&\n            !validator.isBoolean(options.enabled)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.enabled\" must be a boolean.');\n        }\n        if (typeof options.displayName !== 'undefined' &&\n            !validator.isString(options.displayName)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.displayName\" must be a valid string.');\n        }\n    };\n    /** @return {SAMLAuthProviderConfig} The plain object representation of the SAMLConfig. */\n    SAMLConfig.prototype.toJSON = function () {\n        return {\n            enabled: this.enabled,\n            displayName: this.displayName,\n            providerId: this.providerId,\n            idpEntityId: this.idpEntityId,\n            ssoURL: this.ssoURL,\n            x509Certificates: deep_copy_1.deepCopy(this.x509Certificates),\n            rpEntityId: this.rpEntityId,\n            callbackURL: this.callbackURL,\n            enableRequestSigning: this.enableRequestSigning,\n        };\n    };\n    return SAMLConfig;\n}());\nexports.SAMLConfig = SAMLConfig;\n/**\n * Defines the OIDCConfig class used to convert a client side configuration to its\n * server side representation.\n */\nvar OIDCConfig = /** @class */ (function () {\n    /**\n     * The OIDCConfig constructor.\n     *\n     * @param {any} response The server side response used to initialize the OIDCConfig object.\n     * @constructor\n     */\n    function OIDCConfig(response) {\n        if (!response ||\n            !response.issuer ||\n            !response.clientId ||\n            !response.name ||\n            !(validator.isString(response.name) &&\n                OIDCConfig.getProviderIdFromResourceName(response.name))) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid OIDC configuration response');\n        }\n        var providerId = OIDCConfig.getProviderIdFromResourceName(response.name);\n        if (!providerId) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid SAML configuration response');\n        }\n        this.providerId = providerId;\n        this.clientId = response.clientId;\n        this.issuer = response.issuer;\n        // When enabled is undefined, it takes its default value of false.\n        this.enabled = !!response.enabled;\n        this.displayName = response.displayName;\n    }\n    /**\n     * Converts a client side request to a OIDCConfigServerRequest which is the format\n     * accepted by the backend server.\n     * Throws an error if validation fails. If the request is not a OIDCConfig request,\n     * returns null.\n     *\n     * @param {OIDCAuthProviderRequest} options The options object to convert to a server request.\n     * @param {boolean=} ignoreMissingFields Whether to ignore missing fields.\n     * @return {?OIDCConfigServerRequest} The resulting server request or null if not valid.\n     */\n    OIDCConfig.buildServerRequest = function (options, ignoreMissingFields) {\n        if (ignoreMissingFields === void 0) { ignoreMissingFields = false; }\n        var makeRequest = validator.isNonNullObject(options) &&\n            (options.providerId || ignoreMissingFields);\n        if (!makeRequest) {\n            return null;\n        }\n        var request = {};\n        // Validate options.\n        OIDCConfig.validate(options, ignoreMissingFields);\n        request.enabled = options.enabled;\n        request.displayName = options.displayName;\n        request.issuer = options.issuer;\n        request.clientId = options.clientId;\n        return request;\n    };\n    /**\n     * Returns the provider ID corresponding to the resource name if available.\n     *\n     * @param {string} resourceName The server side resource name\n     * @return {?string} The provider ID corresponding to the resource, null otherwise.\n     */\n    OIDCConfig.getProviderIdFromResourceName = function (resourceName) {\n        // name is of form projects/project1/oauthIdpConfigs/providerId1\n        var matchProviderRes = resourceName.match(/\\/oauthIdpConfigs\\/(oidc\\..*)$/);\n        if (!matchProviderRes || matchProviderRes.length < 2) {\n            return null;\n        }\n        return matchProviderRes[1];\n    };\n    /**\n     * @param {any} providerId The provider ID to check.\n     * @return {boolean} Whether the provider ID corresponds to an OIDC provider.\n     */\n    OIDCConfig.isProviderId = function (providerId) {\n        return validator.isNonEmptyString(providerId) && providerId.indexOf('oidc.') === 0;\n    };\n    /**\n     * Validates the OIDCConfig options object. Throws an error on failure.\n     *\n     * @param {OIDCAuthProviderRequest} options The options object to validate.\n     * @param {boolean=} ignoreMissingFields Whether to ignore missing fields.\n     */\n    OIDCConfig.validate = function (options, ignoreMissingFields) {\n        if (ignoreMissingFields === void 0) { ignoreMissingFields = false; }\n        var validKeys = {\n            enabled: true,\n            displayName: true,\n            providerId: true,\n            clientId: true,\n            issuer: true,\n        };\n        if (!validator.isNonNullObject(options)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig\" must be a valid non-null object.');\n        }\n        // Check for unsupported top level attributes.\n        for (var key in options) {\n            if (!(key in validKeys)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, \"\\\"\" + key + \"\\\" is not a valid OIDC config parameter.\");\n            }\n        }\n        // Required fields.\n        if (validator.isNonEmptyString(options.providerId)) {\n            if (options.providerId.indexOf('oidc.') !== 0) {\n                throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '\"OIDCAuthProviderConfig.providerId\" must be a valid non-empty string prefixed with \"oidc.\".');\n            }\n        }\n        else if (!ignoreMissingFields) {\n            throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '\"OIDCAuthProviderConfig.providerId\" must be a valid non-empty string prefixed with \"oidc.\".');\n        }\n        if (!(ignoreMissingFields && typeof options.clientId === 'undefined') &&\n            !validator.isNonEmptyString(options.clientId)) {\n            throw new error_1.FirebaseAuthError(!options.clientId ? error_1.AuthClientErrorCode.MISSING_OAUTH_CLIENT_ID : error_1.AuthClientErrorCode.INVALID_OAUTH_CLIENT_ID, '\"OIDCAuthProviderConfig.clientId\" must be a valid non-empty string.');\n        }\n        if (!(ignoreMissingFields && typeof options.issuer === 'undefined') &&\n            !validator.isURL(options.issuer)) {\n            throw new error_1.FirebaseAuthError(!options.issuer ? error_1.AuthClientErrorCode.MISSING_ISSUER : error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig.issuer\" must be a valid URL string.');\n        }\n        if (typeof options.enabled !== 'undefined' &&\n            !validator.isBoolean(options.enabled)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig.enabled\" must be a boolean.');\n        }\n        if (typeof options.displayName !== 'undefined' &&\n            !validator.isString(options.displayName)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig.displayName\" must be a valid string.');\n        }\n    };\n    /** @return {OIDCAuthProviderConfig} The plain object representation of the OIDCConfig. */\n    OIDCConfig.prototype.toJSON = function () {\n        return {\n            enabled: this.enabled,\n            displayName: this.displayName,\n            providerId: this.providerId,\n            issuer: this.issuer,\n            clientId: this.clientId,\n        };\n    };\n    return OIDCConfig;\n}());\nexports.OIDCConfig = OIDCConfig;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/auth/auth-config.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/auth/auth.js":
/*!**********************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/auth/auth.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\n/*!\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar user_record_1 = __webpack_require__(/*! ./user-record */ \"./src/node_modules/firebase-admin/lib/auth/user-record.js\");\nvar identifier_1 = __webpack_require__(/*! ./identifier */ \"./src/node_modules/firebase-admin/lib/auth/identifier.js\");\nvar token_generator_1 = __webpack_require__(/*! ./token-generator */ \"./src/node_modules/firebase-admin/lib/auth/token-generator.js\");\nvar auth_api_request_1 = __webpack_require__(/*! ./auth-api-request */ \"./src/node_modules/firebase-admin/lib/auth/auth-api-request.js\");\nvar error_1 = __webpack_require__(/*! ../utils/error */ \"./src/node_modules/firebase-admin/lib/utils/error.js\");\nvar utils = __webpack_require__(/*! ../utils/index */ \"./src/node_modules/firebase-admin/lib/utils/index.js\");\nvar validator = __webpack_require__(/*! ../utils/validator */ \"./src/node_modules/firebase-admin/lib/utils/validator.js\");\nvar token_verifier_1 = __webpack_require__(/*! ./token-verifier */ \"./src/node_modules/firebase-admin/lib/auth/token-verifier.js\");\nvar auth_config_1 = __webpack_require__(/*! ./auth-config */ \"./src/node_modules/firebase-admin/lib/auth/auth-config.js\");\nvar tenant_manager_1 = __webpack_require__(/*! ./tenant-manager */ \"./src/node_modules/firebase-admin/lib/auth/tenant-manager.js\");\n/**\n * Internals of an Auth instance.\n */\nvar AuthInternals = /** @class */ (function () {\n    function AuthInternals() {\n    }\n    /**\n     * Deletes the service and its associated resources.\n     *\n     * @return {Promise<()>} An empty Promise that will be fulfilled when the service is deleted.\n     */\n    AuthInternals.prototype.delete = function () {\n        // There are no resources to clean up\n        return Promise.resolve(undefined);\n    };\n    return AuthInternals;\n}());\n/**\n * Base Auth class. Mainly used for user management APIs.\n */\nvar BaseAuth = /** @class */ (function () {\n    /**\n     * The BaseAuth class constructor.\n     *\n     * @param app The FirebaseApp to associate with this Auth instance.\n     * @param authRequestHandler The RPC request handler for this instance.\n     * @param tokenGenerator Optional token generator. If not specified, a\n     *     (non-tenant-aware) instance will be created. Use this paramter to\n     *     specify a tenant-aware tokenGenerator.\n     * @constructor\n     */\n    function BaseAuth(app, authRequestHandler, tokenGenerator) {\n        this.authRequestHandler = authRequestHandler;\n        if (tokenGenerator) {\n            this.tokenGenerator = tokenGenerator;\n        }\n        else {\n            var cryptoSigner = token_generator_1.cryptoSignerFromApp(app);\n            this.tokenGenerator = new token_generator_1.FirebaseTokenGenerator(cryptoSigner);\n        }\n        this.sessionCookieVerifier = token_verifier_1.createSessionCookieVerifier(app);\n        this.idTokenVerifier = token_verifier_1.createIdTokenVerifier(app);\n    }\n    /**\n     * Creates a new custom token that can be sent back to a client to use with\n     * signInWithCustomToken().\n     *\n     * @param {string} uid The uid to use as the JWT subject.\n     * @param {object=} developerClaims Optional additional claims to include in the JWT payload.\n     *\n     * @return {Promise<string>} A JWT for the provided payload.\n     */\n    BaseAuth.prototype.createCustomToken = function (uid, developerClaims) {\n        return this.tokenGenerator.createCustomToken(uid, developerClaims);\n    };\n    /**\n     * Verifies a JWT auth token. Returns a Promise with the tokens claims. Rejects\n     * the promise if the token could not be verified. If checkRevoked is set to true,\n     * verifies if the session corresponding to the ID token was revoked. If the corresponding\n     * user's session was invalidated, an auth/id-token-revoked error is thrown. If not specified\n     * the check is not applied.\n     *\n     * @param {string} idToken The JWT to verify.\n     * @param {boolean=} checkRevoked Whether to check if the ID token is revoked.\n     * @return {Promise<DecodedIdToken>} A Promise that will be fulfilled after a successful\n     *     verification.\n     */\n    BaseAuth.prototype.verifyIdToken = function (idToken, checkRevoked) {\n        var _this = this;\n        if (checkRevoked === void 0) { checkRevoked = false; }\n        return this.idTokenVerifier.verifyJWT(idToken)\n            .then(function (decodedIdToken) {\n            // Whether to check if the token was revoked.\n            if (!checkRevoked) {\n                return decodedIdToken;\n            }\n            return _this.verifyDecodedJWTNotRevoked(decodedIdToken, error_1.AuthClientErrorCode.ID_TOKEN_REVOKED);\n        });\n    };\n    /**\n     * Looks up the user identified by the provided user id and returns a promise that is\n     * fulfilled with a user record for the given user if that user is found.\n     *\n     * @param {string} uid The uid of the user to look up.\n     * @return {Promise<UserRecord>} A promise that resolves with the corresponding user record.\n     */\n    BaseAuth.prototype.getUser = function (uid) {\n        return this.authRequestHandler.getAccountInfoByUid(uid)\n            .then(function (response) {\n            // Returns the user record populated with server response.\n            return new user_record_1.UserRecord(response.users[0]);\n        });\n    };\n    /**\n     * Looks up the user identified by the provided email and returns a promise that is\n     * fulfilled with a user record for the given user if that user is found.\n     *\n     * @param {string} email The email of the user to look up.\n     * @return {Promise<UserRecord>} A promise that resolves with the corresponding user record.\n     */\n    BaseAuth.prototype.getUserByEmail = function (email) {\n        return this.authRequestHandler.getAccountInfoByEmail(email)\n            .then(function (response) {\n            // Returns the user record populated with server response.\n            return new user_record_1.UserRecord(response.users[0]);\n        });\n    };\n    /**\n     * Looks up the user identified by the provided phone number and returns a promise that is\n     * fulfilled with a user record for the given user if that user is found.\n     *\n     * @param {string} phoneNumber The phone number of the user to look up.\n     * @return {Promise<UserRecord>} A promise that resolves with the corresponding user record.\n     */\n    BaseAuth.prototype.getUserByPhoneNumber = function (phoneNumber) {\n        return this.authRequestHandler.getAccountInfoByPhoneNumber(phoneNumber)\n            .then(function (response) {\n            // Returns the user record populated with server response.\n            return new user_record_1.UserRecord(response.users[0]);\n        });\n    };\n    /**\n     * Gets the user data corresponding to the specified identifiers.\n     *\n     * There are no ordering guarantees; in particular, the nth entry in the result list is not\n     * guaranteed to correspond to the nth entry in the input parameters list.\n     *\n     * Only a maximum of 100 identifiers may be supplied. If more than 100 identifiers are supplied,\n     * this method will immediately throw a FirebaseAuthError.\n     *\n     * @param identifiers The identifiers used to indicate which user records should be returned. Must\n     *     have <= 100 entries.\n     * @return {Promise<GetUsersResult>} A promise that resolves to the corresponding user records.\n     * @throws FirebaseAuthError If any of the identifiers are invalid or if more than 100\n     *     identifiers are specified.\n     */\n    BaseAuth.prototype.getUsers = function (identifiers) {\n        if (!validator.isArray(identifiers)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '`identifiers` parameter must be an array');\n        }\n        return this.authRequestHandler\n            .getAccountInfoByIdentifiers(identifiers)\n            .then(function (response) {\n            /**\n             * Checks if the specified identifier is within the list of\n             * UserRecords.\n             */\n            var isUserFound = (function (id, userRecords) {\n                return !!userRecords.find(function (userRecord) {\n                    if (identifier_1.isUidIdentifier(id)) {\n                        return id.uid === userRecord.uid;\n                    }\n                    else if (identifier_1.isEmailIdentifier(id)) {\n                        return id.email === userRecord.email;\n                    }\n                    else if (identifier_1.isPhoneIdentifier(id)) {\n                        return id.phoneNumber === userRecord.phoneNumber;\n                    }\n                    else if (identifier_1.isProviderIdentifier(id)) {\n                        var matchingUserInfo = userRecord.providerData.find(function (userInfo) {\n                            return id.providerId === userInfo.providerId;\n                        });\n                        return !!matchingUserInfo && id.providerUid === matchingUserInfo.uid;\n                    }\n                    else {\n                        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Unhandled identifier type');\n                    }\n                });\n            });\n            var users = response.users ? response.users.map(function (user) { return new user_record_1.UserRecord(user); }) : [];\n            var notFound = identifiers.filter(function (id) { return !isUserFound(id, users); });\n            return { users: users, notFound: notFound };\n        });\n    };\n    /**\n     * Exports a batch of user accounts. Batch size is determined by the maxResults argument.\n     * Starting point of the batch is determined by the pageToken argument.\n     *\n     * @param {number=} maxResults The page size, 1000 if undefined. This is also the maximum\n     *     allowed limit.\n     * @param {string=} pageToken The next page token. If not specified, returns users starting\n     *     without any offset.\n     * @return {Promise<{users: UserRecord[], pageToken?: string}>} A promise that resolves with\n     *     the current batch of downloaded users and the next page token. For the last page, an\n     *     empty list of users and no page token are returned.\n     */\n    BaseAuth.prototype.listUsers = function (maxResults, pageToken) {\n        return this.authRequestHandler.downloadAccount(maxResults, pageToken)\n            .then(function (response) {\n            // List of users to return.\n            var users = [];\n            // Convert each user response to a UserRecord.\n            response.users.forEach(function (userResponse) {\n                users.push(new user_record_1.UserRecord(userResponse));\n            });\n            // Return list of user records and the next page token if available.\n            var result = {\n                users: users,\n                pageToken: response.nextPageToken,\n            };\n            // Delete result.pageToken if undefined.\n            if (typeof result.pageToken === 'undefined') {\n                delete result.pageToken;\n            }\n            return result;\n        });\n    };\n    /**\n     * Creates a new user with the properties provided.\n     *\n     * @param {CreateRequest} properties The properties to set on the new user record to be created.\n     * @return {Promise<UserRecord>} A promise that resolves with the newly created user record.\n     */\n    BaseAuth.prototype.createUser = function (properties) {\n        var _this = this;\n        return this.authRequestHandler.createNewAccount(properties)\n            .then(function (uid) {\n            // Return the corresponding user record.\n            return _this.getUser(uid);\n        })\n            .catch(function (error) {\n            if (error.code === 'auth/user-not-found') {\n                // Something must have happened after creating the user and then retrieving it.\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Unable to create the user record provided.');\n            }\n            throw error;\n        });\n    };\n    /**\n     * Deletes the user identified by the provided user id and returns a promise that is\n     * fulfilled when the user is found and successfully deleted.\n     *\n     * @param {string} uid The uid of the user to delete.\n     * @return {Promise<void>} A promise that resolves when the user is successfully deleted.\n     */\n    BaseAuth.prototype.deleteUser = function (uid) {\n        return this.authRequestHandler.deleteAccount(uid)\n            .then(function () {\n            // Return nothing on success.\n        });\n    };\n    BaseAuth.prototype.deleteUsers = function (uids) {\n        if (!validator.isArray(uids)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '`uids` parameter must be an array');\n        }\n        return this.authRequestHandler.deleteAccounts(uids, /*force=*/ true)\n            .then(function (batchDeleteAccountsResponse) {\n            var result = {\n                failureCount: 0,\n                successCount: uids.length,\n                errors: [],\n            };\n            if (!validator.isNonEmptyArray(batchDeleteAccountsResponse.errors)) {\n                return result;\n            }\n            result.failureCount = batchDeleteAccountsResponse.errors.length;\n            result.successCount = uids.length - batchDeleteAccountsResponse.errors.length;\n            result.errors = batchDeleteAccountsResponse.errors.map(function (batchDeleteErrorInfo) {\n                if (batchDeleteErrorInfo.index === undefined) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Corrupt BatchDeleteAccountsResponse detected');\n                }\n                var errMsgToError = function (msg) {\n                    // We unconditionally set force=true, so the 'NOT_DISABLED' error\n                    // should not be possible.\n                    var code = msg && msg.startsWith('NOT_DISABLED') ?\n                        error_1.AuthClientErrorCode.USER_NOT_DISABLED : error_1.AuthClientErrorCode.INTERNAL_ERROR;\n                    return new error_1.FirebaseAuthError(code, batchDeleteErrorInfo.message);\n                };\n                return {\n                    index: batchDeleteErrorInfo.index,\n                    error: errMsgToError(batchDeleteErrorInfo.message),\n                };\n            });\n            return result;\n        });\n    };\n    /**\n     * Updates an existing user with the properties provided.\n     *\n     * @param {string} uid The uid identifier of the user to update.\n     * @param {UpdateRequest} properties The properties to update on the existing user.\n     * @return {Promise<UserRecord>} A promise that resolves with the modified user record.\n     */\n    BaseAuth.prototype.updateUser = function (uid, properties) {\n        var _this = this;\n        return this.authRequestHandler.updateExistingAccount(uid, properties)\n            .then(function (existingUid) {\n            // Return the corresponding user record.\n            return _this.getUser(existingUid);\n        });\n    };\n    /**\n     * Sets additional developer claims on an existing user identified by the provided UID.\n     *\n     * @param {string} uid The user to edit.\n     * @param {object} customUserClaims The developer claims to set.\n     * @return {Promise<void>} A promise that resolves when the operation completes\n     *     successfully.\n     */\n    BaseAuth.prototype.setCustomUserClaims = function (uid, customUserClaims) {\n        return this.authRequestHandler.setCustomUserClaims(uid, customUserClaims)\n            .then(function () {\n            // Return nothing on success.\n        });\n    };\n    /**\n     * Revokes all refresh tokens for the specified user identified by the provided UID.\n     * In addition to revoking all refresh tokens for a user, all ID tokens issued before\n     * revocation will also be revoked on the Auth backend. Any request with an ID token\n     * generated before revocation will be rejected with a token expired error.\n     *\n     * @param {string} uid The user whose tokens are to be revoked.\n     * @return {Promise<void>} A promise that resolves when the operation completes\n     *     successfully.\n     */\n    BaseAuth.prototype.revokeRefreshTokens = function (uid) {\n        return this.authRequestHandler.revokeRefreshTokens(uid)\n            .then(function () {\n            // Return nothing on success.\n        });\n    };\n    /**\n     * Imports the list of users provided to Firebase Auth. This is useful when\n     * migrating from an external authentication system without having to use the Firebase CLI SDK.\n     * At most, 1000 users are allowed to be imported one at a time.\n     * When importing a list of password users, UserImportOptions are required to be specified.\n     *\n     * @param {UserImportRecord[]} users The list of user records to import to Firebase Auth.\n     * @param {UserImportOptions=} options The user import options, required when the users provided\n     *     include password credentials.\n     * @return {Promise<UserImportResult>} A promise that resolves when the operation completes\n     *     with the result of the import. This includes the number of successful imports, the number\n     *     of failed uploads and their corresponding errors.\n     */\n    BaseAuth.prototype.importUsers = function (users, options) {\n        return this.authRequestHandler.uploadAccount(users, options);\n    };\n    /**\n     * Creates a new Firebase session cookie with the specified options that can be used for\n     * session management (set as a server side session cookie with custom cookie policy).\n     * The session cookie JWT will have the same payload claims as the provided ID token.\n     *\n     * @param {string} idToken The Firebase ID token to exchange for a session cookie.\n     * @param {SessionCookieOptions} sessionCookieOptions The session cookie options which includes\n     *     custom session duration.\n     *\n     * @return {Promise<string>} A promise that resolves on success with the created session cookie.\n     */\n    BaseAuth.prototype.createSessionCookie = function (idToken, sessionCookieOptions) {\n        // Return rejected promise if expiresIn is not available.\n        if (!validator.isNonNullObject(sessionCookieOptions) ||\n            !validator.isNumber(sessionCookieOptions.expiresIn)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION));\n        }\n        return this.authRequestHandler.createSessionCookie(idToken, sessionCookieOptions.expiresIn);\n    };\n    /**\n     * Verifies a Firebase session cookie. Returns a Promise with the tokens claims. Rejects\n     * the promise if the token could not be verified. If checkRevoked is set to true,\n     * verifies if the session corresponding to the session cookie was revoked. If the corresponding\n     * user's session was invalidated, an auth/session-cookie-revoked error is thrown. If not\n     * specified the check is not performed.\n     *\n     * @param {string} sessionCookie The session cookie to verify.\n     * @param {boolean=} checkRevoked Whether to check if the session cookie is revoked.\n     * @return {Promise<DecodedIdToken>} A Promise that will be fulfilled after a successful\n     *     verification.\n     */\n    BaseAuth.prototype.verifySessionCookie = function (sessionCookie, checkRevoked) {\n        var _this = this;\n        if (checkRevoked === void 0) { checkRevoked = false; }\n        return this.sessionCookieVerifier.verifyJWT(sessionCookie)\n            .then(function (decodedIdToken) {\n            // Whether to check if the token was revoked.\n            if (!checkRevoked) {\n                return decodedIdToken;\n            }\n            return _this.verifyDecodedJWTNotRevoked(decodedIdToken, error_1.AuthClientErrorCode.SESSION_COOKIE_REVOKED);\n        });\n    };\n    /**\n     * Generates the out of band email action link for password reset flows for the\n     * email specified using the action code settings provided.\n     * Returns a promise that resolves with the generated link.\n     *\n     * @param {string} email The email of the user whose password is to be reset.\n     * @param {ActionCodeSettings=} actionCodeSettings The optional action code setings which defines whether\n     *     the link is to be handled by a mobile app and the additional state information to be passed in the\n     *     deep link, etc.\n     * @return {Promise<string>} A promise that resolves with the password reset link.\n     */\n    BaseAuth.prototype.generatePasswordResetLink = function (email, actionCodeSettings) {\n        return this.authRequestHandler.getEmailActionLink('PASSWORD_RESET', email, actionCodeSettings);\n    };\n    /**\n     * Generates the out of band email action link for email verification flows for the\n     * email specified using the action code settings provided.\n     * Returns a promise that resolves with the generated link.\n     *\n     * @param {string} email The email of the user to be verified.\n     * @param {ActionCodeSettings=} actionCodeSettings The optional action code setings which defines whether\n     *     the link is to be handled by a mobile app and the additional state information to be passed in the\n     *     deep link, etc.\n     * @return {Promise<string>} A promise that resolves with the email verification link.\n     */\n    BaseAuth.prototype.generateEmailVerificationLink = function (email, actionCodeSettings) {\n        return this.authRequestHandler.getEmailActionLink('VERIFY_EMAIL', email, actionCodeSettings);\n    };\n    /**\n     * Generates the out of band email action link for email link sign-in flows for the\n     * email specified using the action code settings provided.\n     * Returns a promise that resolves with the generated link.\n     *\n     * @param {string} email The email of the user signing in.\n     * @param {ActionCodeSettings} actionCodeSettings The required action code setings which defines whether\n     *     the link is to be handled by a mobile app and the additional state information to be passed in the\n     *     deep link, etc.\n     * @return {Promise<string>} A promise that resolves with the email sign-in link.\n     */\n    BaseAuth.prototype.generateSignInWithEmailLink = function (email, actionCodeSettings) {\n        return this.authRequestHandler.getEmailActionLink('EMAIL_SIGNIN', email, actionCodeSettings);\n    };\n    /**\n     * Returns the list of existing provider configuation matching the filter provided.\n     * At most, 100 provider configs are allowed to be imported at a time.\n     *\n     * @param {AuthProviderConfigFilter} options The provider config filter to apply.\n     * @return {Promise<ListProviderConfigResults>} A promise that resolves with the list of provider configs\n     *     meeting the filter requirements.\n     */\n    BaseAuth.prototype.listProviderConfigs = function (options) {\n        var processResponse = function (response, providerConfigs) {\n            // Return list of provider configuration and the next page token if available.\n            var result = {\n                providerConfigs: providerConfigs,\n            };\n            // Delete result.pageToken if undefined.\n            if (Object.prototype.hasOwnProperty.call(response, 'nextPageToken')) {\n                result.pageToken = response.nextPageToken;\n            }\n            return result;\n        };\n        if (options && options.type === 'oidc') {\n            return this.authRequestHandler.listOAuthIdpConfigs(options.maxResults, options.pageToken)\n                .then(function (response) {\n                // List of provider configurations to return.\n                var providerConfigs = [];\n                // Convert each provider config response to a OIDCConfig.\n                response.oauthIdpConfigs.forEach(function (configResponse) {\n                    providerConfigs.push(new auth_config_1.OIDCConfig(configResponse));\n                });\n                // Return list of provider configuration and the next page token if available.\n                return processResponse(response, providerConfigs);\n            });\n        }\n        else if (options && options.type === 'saml') {\n            return this.authRequestHandler.listInboundSamlConfigs(options.maxResults, options.pageToken)\n                .then(function (response) {\n                // List of provider configurations to return.\n                var providerConfigs = [];\n                // Convert each provider config response to a SAMLConfig.\n                response.inboundSamlConfigs.forEach(function (configResponse) {\n                    providerConfigs.push(new auth_config_1.SAMLConfig(configResponse));\n                });\n                // Return list of provider configuration and the next page token if available.\n                return processResponse(response, providerConfigs);\n            });\n        }\n        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"\\\"AuthProviderConfigFilter.type\\\" must be either \\\"saml' or \\\"oidc\\\"\"));\n    };\n    /**\n     * Looks up an Auth provider configuration by ID.\n     * Returns a promise that resolves with the provider configuration corresponding to the provider ID specified.\n     *\n     * @param {string} providerId  The provider ID corresponding to the provider config to return.\n     * @return {Promise<AuthProviderConfig>}\n     */\n    BaseAuth.prototype.getProviderConfig = function (providerId) {\n        if (auth_config_1.OIDCConfig.isProviderId(providerId)) {\n            return this.authRequestHandler.getOAuthIdpConfig(providerId)\n                .then(function (response) {\n                return new auth_config_1.OIDCConfig(response);\n            });\n        }\n        else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {\n            return this.authRequestHandler.getInboundSamlConfig(providerId)\n                .then(function (response) {\n                return new auth_config_1.SAMLConfig(response);\n            });\n        }\n        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n    };\n    /**\n     * Deletes the provider configuration corresponding to the provider ID passed.\n     *\n     * @param {string} providerId The provider ID corresponding to the provider config to delete.\n     * @return {Promise<void>} A promise that resolves on completion.\n     */\n    BaseAuth.prototype.deleteProviderConfig = function (providerId) {\n        if (auth_config_1.OIDCConfig.isProviderId(providerId)) {\n            return this.authRequestHandler.deleteOAuthIdpConfig(providerId);\n        }\n        else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {\n            return this.authRequestHandler.deleteInboundSamlConfig(providerId);\n        }\n        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n    };\n    /**\n     * Returns a promise that resolves with the updated AuthProviderConfig when the provider configuration corresponding\n     * to the provider ID specified is updated with the specified configuration.\n     *\n     * @param {string} providerId The provider ID corresponding to the provider config to update.\n     * @param {UpdateAuthProviderRequest} updatedConfig The updated configuration.\n     * @return {Promise<AuthProviderConfig>} A promise that resolves with the updated provider configuration.\n     */\n    BaseAuth.prototype.updateProviderConfig = function (providerId, updatedConfig) {\n        if (!validator.isNonNullObject(updatedConfig)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, 'Request is missing \"UpdateAuthProviderRequest\" configuration.'));\n        }\n        if (auth_config_1.OIDCConfig.isProviderId(providerId)) {\n            return this.authRequestHandler.updateOAuthIdpConfig(providerId, updatedConfig)\n                .then(function (response) {\n                return new auth_config_1.OIDCConfig(response);\n            });\n        }\n        else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {\n            return this.authRequestHandler.updateInboundSamlConfig(providerId, updatedConfig)\n                .then(function (response) {\n                return new auth_config_1.SAMLConfig(response);\n            });\n        }\n        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n    };\n    /**\n     * Returns a promise that resolves with the newly created AuthProviderConfig when the new provider configuration is\n     * created.\n     * @param {AuthProviderConfig} config The provider configuration to create.\n     * @return {Promise<AuthProviderConfig>} A promise that resolves with the created provider configuration.\n     */\n    BaseAuth.prototype.createProviderConfig = function (config) {\n        if (!validator.isNonNullObject(config)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, 'Request is missing \"AuthProviderConfig\" configuration.'));\n        }\n        if (auth_config_1.OIDCConfig.isProviderId(config.providerId)) {\n            return this.authRequestHandler.createOAuthIdpConfig(config)\n                .then(function (response) {\n                return new auth_config_1.OIDCConfig(response);\n            });\n        }\n        else if (auth_config_1.SAMLConfig.isProviderId(config.providerId)) {\n            return this.authRequestHandler.createInboundSamlConfig(config)\n                .then(function (response) {\n                return new auth_config_1.SAMLConfig(response);\n            });\n        }\n        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n    };\n    /**\n     * Verifies the decoded Firebase issued JWT is not revoked. Returns a promise that resolves\n     * with the decoded claims on success. Rejects the promise with revocation error if revoked.\n     *\n     * @param {DecodedIdToken} decodedIdToken The JWT's decoded claims.\n     * @param {ErrorInfo} revocationErrorInfo The revocation error info to throw on revocation\n     *     detection.\n     * @return {Promise<DecodedIdToken>} A Promise that will be fulfilled after a successful\n     *     verification.\n     */\n    BaseAuth.prototype.verifyDecodedJWTNotRevoked = function (decodedIdToken, revocationErrorInfo) {\n        // Get tokens valid after time for the corresponding user.\n        return this.getUser(decodedIdToken.sub)\n            .then(function (user) {\n            // If no tokens valid after time available, token is not revoked.\n            if (user.tokensValidAfterTime) {\n                // Get the ID token authentication time and convert to milliseconds UTC.\n                var authTimeUtc = decodedIdToken.auth_time * 1000;\n                // Get user tokens valid after time in milliseconds UTC.\n                var validSinceUtc = new Date(user.tokensValidAfterTime).getTime();\n                // Check if authentication time is older than valid since time.\n                if (authTimeUtc < validSinceUtc) {\n                    throw new error_1.FirebaseAuthError(revocationErrorInfo);\n                }\n            }\n            // All checks above passed. Return the decoded token.\n            return decodedIdToken;\n        });\n    };\n    return BaseAuth;\n}());\nexports.BaseAuth = BaseAuth;\n/**\n * The tenant aware Auth class.\n */\nvar TenantAwareAuth = /** @class */ (function (_super) {\n    __extends(TenantAwareAuth, _super);\n    /**\n     * The TenantAwareAuth class constructor.\n     *\n     * @param {object} app The app that created this tenant.\n     * @param tenantId The corresponding tenant ID.\n     * @constructor\n     */\n    function TenantAwareAuth(app, tenantId) {\n        var _this = this;\n        var cryptoSigner = token_generator_1.cryptoSignerFromApp(app);\n        var tokenGenerator = new token_generator_1.FirebaseTokenGenerator(cryptoSigner, tenantId);\n        _this = _super.call(this, app, new auth_api_request_1.TenantAwareAuthRequestHandler(app, tenantId), tokenGenerator) || this;\n        utils.addReadonlyGetter(_this, 'tenantId', tenantId);\n        return _this;\n    }\n    /**\n     * Verifies a JWT auth token. Returns a Promise with the tokens claims. Rejects\n     * the promise if the token could not be verified. If checkRevoked is set to true,\n     * verifies if the session corresponding to the ID token was revoked. If the corresponding\n     * user's session was invalidated, an auth/id-token-revoked error is thrown. If not specified\n     * the check is not applied.\n     *\n     * @param {string} idToken The JWT to verify.\n     * @param {boolean=} checkRevoked Whether to check if the ID token is revoked.\n     * @return {Promise<DecodedIdToken>} A Promise that will be fulfilled after a successful\n     *     verification.\n     */\n    TenantAwareAuth.prototype.verifyIdToken = function (idToken, checkRevoked) {\n        var _this = this;\n        if (checkRevoked === void 0) { checkRevoked = false; }\n        return _super.prototype.verifyIdToken.call(this, idToken, checkRevoked)\n            .then(function (decodedClaims) {\n            // Validate tenant ID.\n            if (decodedClaims.firebase.tenant !== _this.tenantId) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISMATCHING_TENANT_ID);\n            }\n            return decodedClaims;\n        });\n    };\n    /**\n     * Creates a new Firebase session cookie with the specified options that can be used for\n     * session management (set as a server side session cookie with custom cookie policy).\n     * The session cookie JWT will have the same payload claims as the provided ID token.\n     *\n     * @param {string} idToken The Firebase ID token to exchange for a session cookie.\n     * @param {SessionCookieOptions} sessionCookieOptions The session cookie options which includes\n     *     custom session duration.\n     *\n     * @return {Promise<string>} A promise that resolves on success with the created session cookie.\n     */\n    TenantAwareAuth.prototype.createSessionCookie = function (idToken, sessionCookieOptions) {\n        var _this = this;\n        // Validate arguments before processing.\n        if (!validator.isNonEmptyString(idToken)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ID_TOKEN));\n        }\n        if (!validator.isNonNullObject(sessionCookieOptions) ||\n            !validator.isNumber(sessionCookieOptions.expiresIn)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION));\n        }\n        // This will verify the ID token and then match the tenant ID before creating the session cookie.\n        return this.verifyIdToken(idToken)\n            .then(function () {\n            return _super.prototype.createSessionCookie.call(_this, idToken, sessionCookieOptions);\n        });\n    };\n    /**\n     * Verifies a Firebase session cookie. Returns a Promise with the tokens claims. Rejects\n     * the promise if the token could not be verified. If checkRevoked is set to true,\n     * verifies if the session corresponding to the session cookie was revoked. If the corresponding\n     * user's session was invalidated, an auth/session-cookie-revoked error is thrown. If not\n     * specified the check is not performed.\n     *\n     * @param {string} sessionCookie The session cookie to verify.\n     * @param {boolean=} checkRevoked Whether to check if the session cookie is revoked.\n     * @return {Promise<DecodedIdToken>} A Promise that will be fulfilled after a successful\n     *     verification.\n     */\n    TenantAwareAuth.prototype.verifySessionCookie = function (sessionCookie, checkRevoked) {\n        var _this = this;\n        if (checkRevoked === void 0) { checkRevoked = false; }\n        return _super.prototype.verifySessionCookie.call(this, sessionCookie, checkRevoked)\n            .then(function (decodedClaims) {\n            if (decodedClaims.firebase.tenant !== _this.tenantId) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISMATCHING_TENANT_ID);\n            }\n            return decodedClaims;\n        });\n    };\n    return TenantAwareAuth;\n}(BaseAuth));\nexports.TenantAwareAuth = TenantAwareAuth;\n/**\n * Auth service bound to the provided app.\n * An Auth instance can have multiple tenants.\n */\nvar Auth = /** @class */ (function (_super) {\n    __extends(Auth, _super);\n    /**\n     * @param {object} app The app for this Auth service.\n     * @constructor\n     */\n    function Auth(app) {\n        var _this = _super.call(this, app, new auth_api_request_1.AuthRequestHandler(app)) || this;\n        _this.INTERNAL = new AuthInternals();\n        _this.app_ = app;\n        _this.tenantManager_ = new tenant_manager_1.TenantManager(app);\n        return _this;\n    }\n    Object.defineProperty(Auth.prototype, \"app\", {\n        /**\n         * Returns the app associated with this Auth instance.\n         *\n         * @return {FirebaseApp} The app associated with this Auth instance.\n         */\n        get: function () {\n            return this.app_;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** @return The current Auth instance's tenant manager. */\n    Auth.prototype.tenantManager = function () {\n        return this.tenantManager_;\n    };\n    return Auth;\n}(BaseAuth));\nexports.Auth = Auth;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/auth/auth.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/auth/credential.js":
/*!****************************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/auth/credential.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\n/*!\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// Use untyped import syntax for Node built-ins\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar os = __webpack_require__(/*! os */ \"os\");\nvar path = __webpack_require__(/*! path */ \"path\");\nvar error_1 = __webpack_require__(/*! ../utils/error */ \"./src/node_modules/firebase-admin/lib/utils/error.js\");\nvar api_request_1 = __webpack_require__(/*! ../utils/api-request */ \"./src/node_modules/firebase-admin/lib/utils/api-request.js\");\nvar util = __webpack_require__(/*! ../utils/validator */ \"./src/node_modules/firebase-admin/lib/utils/validator.js\");\nvar GOOGLE_TOKEN_AUDIENCE = 'https://accounts.google.com/o/oauth2/token';\nvar GOOGLE_AUTH_TOKEN_HOST = 'accounts.google.com';\nvar GOOGLE_AUTH_TOKEN_PATH = '/o/oauth2/token';\n// NOTE: the Google Metadata Service uses HTTP over a vlan\nvar GOOGLE_METADATA_SERVICE_HOST = 'metadata.google.internal';\nvar GOOGLE_METADATA_SERVICE_TOKEN_PATH = '/computeMetadata/v1/instance/service-accounts/default/token';\nvar GOOGLE_METADATA_SERVICE_PROJECT_ID_PATH = '/computeMetadata/v1/project/project-id';\nvar configDir = (function () {\n    // Windows has a dedicated low-rights location for apps at ~/Application Data\n    var sys = os.platform();\n    if (sys && sys.length >= 3 && sys.substring(0, 3).toLowerCase() === 'win') {\n        return process.env.APPDATA;\n    }\n    // On *nix the gcloud cli creates a . dir.\n    return process.env.HOME && path.resolve(process.env.HOME, '.config');\n})();\nvar GCLOUD_CREDENTIAL_SUFFIX = 'gcloud/application_default_credentials.json';\nvar GCLOUD_CREDENTIAL_PATH = configDir && path.resolve(configDir, GCLOUD_CREDENTIAL_SUFFIX);\nvar REFRESH_TOKEN_HOST = 'www.googleapis.com';\nvar REFRESH_TOKEN_PATH = '/oauth2/v4/token';\nvar ONE_HOUR_IN_SECONDS = 60 * 60;\nvar JWT_ALGORITHM = 'RS256';\n/**\n * Implementation of Credential that uses a service account.\n */\nvar ServiceAccountCredential = /** @class */ (function () {\n    /**\n     * Creates a new ServiceAccountCredential from the given parameters.\n     *\n     * @param serviceAccountPathOrObject Service account json object or path to a service account json file.\n     * @param httpAgent Optional http.Agent to use when calling the remote token server.\n     * @param implicit An optinal boolean indicating whether this credential was implicitly discovered from the\n     *   environment, as opposed to being explicitly specified by the developer.\n     *\n     * @constructor\n     */\n    function ServiceAccountCredential(serviceAccountPathOrObject, httpAgent, implicit) {\n        if (implicit === void 0) { implicit = false; }\n        this.httpAgent = httpAgent;\n        this.implicit = implicit;\n        var serviceAccount = (typeof serviceAccountPathOrObject === 'string') ?\n            ServiceAccount.fromPath(serviceAccountPathOrObject)\n            : new ServiceAccount(serviceAccountPathOrObject);\n        this.projectId = serviceAccount.projectId;\n        this.privateKey = serviceAccount.privateKey;\n        this.clientEmail = serviceAccount.clientEmail;\n        this.httpClient = new api_request_1.HttpClient();\n    }\n    ServiceAccountCredential.prototype.getAccessToken = function () {\n        var token = this.createAuthJwt_();\n        var postData = 'grant_type=urn%3Aietf%3Aparams%3Aoauth%3A' +\n            'grant-type%3Ajwt-bearer&assertion=' + token;\n        var request = {\n            method: 'POST',\n            url: \"https://\" + GOOGLE_AUTH_TOKEN_HOST + GOOGLE_AUTH_TOKEN_PATH,\n            headers: {\n                'Content-Type': 'application/x-www-form-urlencoded',\n            },\n            data: postData,\n            httpAgent: this.httpAgent,\n        };\n        return requestAccessToken(this.httpClient, request);\n    };\n    ServiceAccountCredential.prototype.createAuthJwt_ = function () {\n        var claims = {\n            scope: [\n                'https://www.googleapis.com/auth/cloud-platform',\n                'https://www.googleapis.com/auth/firebase.database',\n                'https://www.googleapis.com/auth/firebase.messaging',\n                'https://www.googleapis.com/auth/identitytoolkit',\n                'https://www.googleapis.com/auth/userinfo.email',\n            ].join(' '),\n        };\n        // eslint-disable-next-line @typescript-eslint/no-var-requires\n        var jwt = __webpack_require__(/*! jsonwebtoken */ \"jsonwebtoken\");\n        // This method is actually synchronous so we can capture and return the buffer.\n        return jwt.sign(claims, this.privateKey, {\n            audience: GOOGLE_TOKEN_AUDIENCE,\n            expiresIn: ONE_HOUR_IN_SECONDS,\n            issuer: this.clientEmail,\n            algorithm: JWT_ALGORITHM,\n        });\n    };\n    return ServiceAccountCredential;\n}());\nexports.ServiceAccountCredential = ServiceAccountCredential;\n/**\n * A struct containing the properties necessary to use service account JSON credentials.\n */\nvar ServiceAccount = /** @class */ (function () {\n    function ServiceAccount(json) {\n        if (!util.isNonNullObject(json)) {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Service account must be an object.');\n        }\n        copyAttr(this, json, 'projectId', 'project_id');\n        copyAttr(this, json, 'privateKey', 'private_key');\n        copyAttr(this, json, 'clientEmail', 'client_email');\n        var errorMessage;\n        if (!util.isNonEmptyString(this.projectId)) {\n            errorMessage = 'Service account object must contain a string \"project_id\" property.';\n        }\n        else if (!util.isNonEmptyString(this.privateKey)) {\n            errorMessage = 'Service account object must contain a string \"private_key\" property.';\n        }\n        else if (!util.isNonEmptyString(this.clientEmail)) {\n            errorMessage = 'Service account object must contain a string \"client_email\" property.';\n        }\n        if (typeof errorMessage !== 'undefined') {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-var-requires\n        var forge = __webpack_require__(/*! node-forge */ \"node-forge\");\n        try {\n            forge.pki.privateKeyFromPem(this.privateKey);\n        }\n        catch (error) {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse private key: ' + error);\n        }\n    }\n    ServiceAccount.fromPath = function (filePath) {\n        try {\n            return new ServiceAccount(JSON.parse(fs.readFileSync(filePath, 'utf8')));\n        }\n        catch (error) {\n            // Throw a nicely formed error message if the file contents cannot be parsed\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse service account json file: ' + error);\n        }\n    };\n    return ServiceAccount;\n}());\n/**\n * Implementation of Credential that gets access tokens from the metadata service available\n * in the Google Cloud Platform. This authenticates the process as the default service account\n * of an App Engine instance or Google Compute Engine machine.\n */\nvar ComputeEngineCredential = /** @class */ (function () {\n    function ComputeEngineCredential(httpAgent) {\n        this.httpClient = new api_request_1.HttpClient();\n        this.httpAgent = httpAgent;\n    }\n    ComputeEngineCredential.prototype.getAccessToken = function () {\n        var request = this.buildRequest(GOOGLE_METADATA_SERVICE_TOKEN_PATH);\n        return requestAccessToken(this.httpClient, request);\n    };\n    ComputeEngineCredential.prototype.getProjectId = function () {\n        var _this = this;\n        if (this.projectId) {\n            return Promise.resolve(this.projectId);\n        }\n        var request = this.buildRequest(GOOGLE_METADATA_SERVICE_PROJECT_ID_PATH);\n        return this.httpClient.send(request)\n            .then(function (resp) {\n            _this.projectId = resp.text;\n            return _this.projectId;\n        })\n            .catch(function (err) {\n            var detail = (err instanceof api_request_1.HttpError) ? getDetailFromResponse(err.response) : err.message;\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, \"Failed to determine project ID: \" + detail);\n        });\n    };\n    ComputeEngineCredential.prototype.buildRequest = function (urlPath) {\n        return {\n            method: 'GET',\n            url: \"http://\" + GOOGLE_METADATA_SERVICE_HOST + urlPath,\n            headers: {\n                'Metadata-Flavor': 'Google',\n            },\n            httpAgent: this.httpAgent,\n        };\n    };\n    return ComputeEngineCredential;\n}());\nexports.ComputeEngineCredential = ComputeEngineCredential;\n/**\n * Implementation of Credential that gets access tokens from refresh tokens.\n */\nvar RefreshTokenCredential = /** @class */ (function () {\n    /**\n     * Creates a new RefreshTokenCredential from the given parameters.\n     *\n     * @param refreshTokenPathOrObject Refresh token json object or path to a refresh token (user credentials) json file.\n     * @param httpAgent Optional http.Agent to use when calling the remote token server.\n     * @param implicit An optinal boolean indicating whether this credential was implicitly discovered from the\n     *   environment, as opposed to being explicitly specified by the developer.\n     *\n     * @constructor\n     */\n    function RefreshTokenCredential(refreshTokenPathOrObject, httpAgent, implicit) {\n        if (implicit === void 0) { implicit = false; }\n        this.httpAgent = httpAgent;\n        this.implicit = implicit;\n        this.refreshToken = (typeof refreshTokenPathOrObject === 'string') ?\n            RefreshToken.fromPath(refreshTokenPathOrObject)\n            : new RefreshToken(refreshTokenPathOrObject);\n        this.httpClient = new api_request_1.HttpClient();\n    }\n    RefreshTokenCredential.prototype.getAccessToken = function () {\n        var postData = 'client_id=' + this.refreshToken.clientId + '&' +\n            'client_secret=' + this.refreshToken.clientSecret + '&' +\n            'refresh_token=' + this.refreshToken.refreshToken + '&' +\n            'grant_type=refresh_token';\n        var request = {\n            method: 'POST',\n            url: \"https://\" + REFRESH_TOKEN_HOST + REFRESH_TOKEN_PATH,\n            headers: {\n                'Content-Type': 'application/x-www-form-urlencoded',\n            },\n            data: postData,\n            httpAgent: this.httpAgent,\n        };\n        return requestAccessToken(this.httpClient, request);\n    };\n    return RefreshTokenCredential;\n}());\nexports.RefreshTokenCredential = RefreshTokenCredential;\nvar RefreshToken = /** @class */ (function () {\n    function RefreshToken(json) {\n        copyAttr(this, json, 'clientId', 'client_id');\n        copyAttr(this, json, 'clientSecret', 'client_secret');\n        copyAttr(this, json, 'refreshToken', 'refresh_token');\n        copyAttr(this, json, 'type', 'type');\n        var errorMessage;\n        if (!util.isNonEmptyString(this.clientId)) {\n            errorMessage = 'Refresh token must contain a \"client_id\" property.';\n        }\n        else if (!util.isNonEmptyString(this.clientSecret)) {\n            errorMessage = 'Refresh token must contain a \"client_secret\" property.';\n        }\n        else if (!util.isNonEmptyString(this.refreshToken)) {\n            errorMessage = 'Refresh token must contain a \"refresh_token\" property.';\n        }\n        else if (!util.isNonEmptyString(this.type)) {\n            errorMessage = 'Refresh token must contain a \"type\" property.';\n        }\n        if (typeof errorMessage !== 'undefined') {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);\n        }\n    }\n    /*\n     * Tries to load a RefreshToken from a path. Throws if the path doesn't exist or the\n     * data at the path is invalid.\n     */\n    RefreshToken.fromPath = function (filePath) {\n        try {\n            return new RefreshToken(JSON.parse(fs.readFileSync(filePath, 'utf8')));\n        }\n        catch (error) {\n            // Throw a nicely formed error message if the file contents cannot be parsed\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse refresh token file: ' + error);\n        }\n    };\n    return RefreshToken;\n}());\nfunction getApplicationDefault(httpAgent) {\n    if (process.env.GOOGLE_APPLICATION_CREDENTIALS) {\n        return credentialFromFile(process.env.GOOGLE_APPLICATION_CREDENTIALS, httpAgent);\n    }\n    // It is OK to not have this file. If it is present, it must be valid.\n    if (GCLOUD_CREDENTIAL_PATH) {\n        var refreshToken = readCredentialFile(GCLOUD_CREDENTIAL_PATH, true);\n        if (refreshToken) {\n            return new RefreshTokenCredential(refreshToken, httpAgent, true);\n        }\n    }\n    return new ComputeEngineCredential(httpAgent);\n}\nexports.getApplicationDefault = getApplicationDefault;\n/**\n * Checks if the given credential was loaded via the application default credentials mechanism. This\n * includes all ComputeEngineCredential instances, and the ServiceAccountCredential and RefreshTokenCredential\n * instances that were loaded from well-known files or environment variables, rather than being explicitly\n * instantiated.\n *\n * @param credential The credential instance to check.\n */\nfunction isApplicationDefault(credential) {\n    return credential instanceof ComputeEngineCredential ||\n        (credential instanceof ServiceAccountCredential && credential.implicit) ||\n        (credential instanceof RefreshTokenCredential && credential.implicit);\n}\nexports.isApplicationDefault = isApplicationDefault;\n/**\n * Copies the specified property from one object to another.\n *\n * If no property exists by the given \"key\", looks for a property identified by \"alt\", and copies it instead.\n * This can be used to implement behaviors such as \"copy property myKey or my_key\".\n *\n * @param to Target object to copy the property into.\n * @param from Source object to copy the property from.\n * @param key Name of the property to copy.\n * @param alt Alternative name of the property to copy.\n */\nfunction copyAttr(to, from, key, alt) {\n    var tmp = from[key] || from[alt];\n    if (typeof tmp !== 'undefined') {\n        to[key] = tmp;\n    }\n}\n/**\n * Obtain a new OAuth2 token by making a remote service call.\n */\nfunction requestAccessToken(client, request) {\n    return client.send(request).then(function (resp) {\n        var json = resp.data;\n        if (!json.access_token || !json.expires_in) {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, \"Unexpected response while fetching access token: \" + JSON.stringify(json));\n        }\n        return json;\n    }).catch(function (err) {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, getErrorMessage(err));\n    });\n}\n/**\n * Constructs a human-readable error message from the given Error.\n */\nfunction getErrorMessage(err) {\n    var detail = (err instanceof api_request_1.HttpError) ? getDetailFromResponse(err.response) : err.message;\n    return \"Error fetching access token: \" + detail;\n}\n/**\n * Extracts details from the given HTTP error response, and returns a human-readable description. If\n * the response is JSON-formatted, looks up the error and error_description fields sent by the\n * Google Auth servers. Otherwise returns the entire response payload as the error detail.\n */\nfunction getDetailFromResponse(response) {\n    if (response.isJson() && response.data.error) {\n        var json = response.data;\n        var detail = json.error;\n        if (json.error_description) {\n            detail += ' (' + json.error_description + ')';\n        }\n        return detail;\n    }\n    return response.text || 'Missing error payload';\n}\nfunction credentialFromFile(filePath, httpAgent) {\n    var credentialsFile = readCredentialFile(filePath);\n    if (typeof credentialsFile !== 'object' || credentialsFile === null) {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse contents of the credentials file as an object');\n    }\n    if (credentialsFile.type === 'service_account') {\n        return new ServiceAccountCredential(credentialsFile, httpAgent, true);\n    }\n    if (credentialsFile.type === 'authorized_user') {\n        return new RefreshTokenCredential(credentialsFile, httpAgent, true);\n    }\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Invalid contents in the credentials file');\n}\nfunction readCredentialFile(filePath, ignoreMissing) {\n    var fileText;\n    try {\n        fileText = fs.readFileSync(filePath, 'utf8');\n    }\n    catch (error) {\n        if (ignoreMissing) {\n            return null;\n        }\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, \"Failed to read credentials from file \" + filePath + \": \" + error);\n    }\n    try {\n        return JSON.parse(fileText);\n    }\n    catch (error) {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse contents of the credentials file as an object: ' + error);\n    }\n}\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/auth/credential.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/auth/identifier.js":
/*!****************************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/auth/identifier.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\n/*!\n * Copyright 2020 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/* User defined type guards. See\n * https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards\n */\nfunction isUidIdentifier(id) {\n    return id.uid !== undefined;\n}\nexports.isUidIdentifier = isUidIdentifier;\nfunction isEmailIdentifier(id) {\n    return id.email !== undefined;\n}\nexports.isEmailIdentifier = isEmailIdentifier;\nfunction isPhoneIdentifier(id) {\n    return id.phoneNumber !== undefined;\n}\nexports.isPhoneIdentifier = isPhoneIdentifier;\nfunction isProviderIdentifier(id) {\n    var pid = id;\n    return pid.providerId !== undefined && pid.providerUid !== undefined;\n}\nexports.isProviderIdentifier = isProviderIdentifier;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/auth/identifier.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/auth/tenant-manager.js":
/*!********************************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/auth/tenant-manager.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\n/*!\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar auth_api_request_1 = __webpack_require__(/*! ./auth-api-request */ \"./src/node_modules/firebase-admin/lib/auth/auth-api-request.js\");\nvar auth_1 = __webpack_require__(/*! ./auth */ \"./src/node_modules/firebase-admin/lib/auth/auth.js\");\nvar tenant_1 = __webpack_require__(/*! ./tenant */ \"./src/node_modules/firebase-admin/lib/auth/tenant.js\");\nvar error_1 = __webpack_require__(/*! ../utils/error */ \"./src/node_modules/firebase-admin/lib/utils/error.js\");\nvar validator = __webpack_require__(/*! ../utils/validator */ \"./src/node_modules/firebase-admin/lib/utils/validator.js\");\n/**\n * Data structure used to help manage tenant related operations.\n * This includes:\n * - The ability to create, update, list, get and delete tenants for the underlying project.\n * - Getting a TenantAwareAuth instance for running Auth related operations (user mgmt, provider config mgmt, etc)\n *   in the context of a specified tenant.\n */\nvar TenantManager = /** @class */ (function () {\n    /**\n     * Initializes a TenantManager instance for a specified FirebaseApp.\n     * @param app The app for this TenantManager instance.\n     */\n    function TenantManager(app) {\n        this.app = app;\n        this.authRequestHandler = new auth_api_request_1.AuthRequestHandler(app);\n        this.tenantsMap = {};\n    }\n    /**\n     * Returns a TenantAwareAuth instance for the corresponding tenant ID.\n     *\n     * @param tenantId The tenant ID whose TenantAwareAuth is to be returned.\n     * @return The corresponding TenantAwareAuth instance.\n     */\n    TenantManager.prototype.authForTenant = function (tenantId) {\n        if (!validator.isNonEmptyString(tenantId)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID);\n        }\n        if (typeof this.tenantsMap[tenantId] === 'undefined') {\n            this.tenantsMap[tenantId] = new auth_1.TenantAwareAuth(this.app, tenantId);\n        }\n        return this.tenantsMap[tenantId];\n    };\n    /**\n     * Looks up the tenant identified by the provided tenant ID and returns a promise that is\n     * fulfilled with the corresponding tenant if it is found.\n     *\n     * @param tenantId The tenant ID of the tenant to look up.\n     * @return A promise that resolves with the corresponding tenant.\n     */\n    TenantManager.prototype.getTenant = function (tenantId) {\n        return this.authRequestHandler.getTenant(tenantId)\n            .then(function (response) {\n            return new tenant_1.Tenant(response);\n        });\n    };\n    /**\n     * Exports a batch of tenant accounts. Batch size is determined by the maxResults argument.\n     * Starting point of the batch is determined by the pageToken argument.\n     *\n     * @param maxResults The page size, 1000 if undefined. This is also the maximum\n     *     allowed limit.\n     * @param pageToken The next page token. If not specified, returns users starting\n     *     without any offset.\n     * @return A promise that resolves with\n     *     the current batch of downloaded tenants and the next page token. For the last page, an\n     *     empty list of tenants and no page token are returned.\n     */\n    TenantManager.prototype.listTenants = function (maxResults, pageToken) {\n        return this.authRequestHandler.listTenants(maxResults, pageToken)\n            .then(function (response) {\n            // List of tenants to return.\n            var tenants = [];\n            // Convert each user response to a Tenant.\n            response.tenants.forEach(function (tenantResponse) {\n                tenants.push(new tenant_1.Tenant(tenantResponse));\n            });\n            // Return list of tenants and the next page token if available.\n            var result = {\n                tenants: tenants,\n                pageToken: response.nextPageToken,\n            };\n            // Delete result.pageToken if undefined.\n            if (typeof result.pageToken === 'undefined') {\n                delete result.pageToken;\n            }\n            return result;\n        });\n    };\n    /**\n     * Deletes the tenant identified by the provided tenant ID and returns a promise that is\n     * fulfilled when the tenant is found and successfully deleted.\n     *\n     * @param tenantId The tenant ID of the tenant to delete.\n     * @return A promise that resolves when the tenant is successfully deleted.\n     */\n    TenantManager.prototype.deleteTenant = function (tenantId) {\n        return this.authRequestHandler.deleteTenant(tenantId);\n    };\n    /**\n     * Creates a new tenant with the properties provided.\n     *\n     * @param tenantOptions The properties to set on the new tenant to be created.\n     * @return A promise that resolves with the newly created tenant.\n     */\n    TenantManager.prototype.createTenant = function (tenantOptions) {\n        return this.authRequestHandler.createTenant(tenantOptions)\n            .then(function (response) {\n            return new tenant_1.Tenant(response);\n        });\n    };\n    /**\n     * Updates an existing tenant identified by the tenant ID with the properties provided.\n     *\n     * @param tenantId The tenant identifier of the tenant to update.\n     * @param tenantOptions The properties to update on the existing tenant.\n     * @return A promise that resolves with the modified tenant.\n     */\n    TenantManager.prototype.updateTenant = function (tenantId, tenantOptions) {\n        return this.authRequestHandler.updateTenant(tenantId, tenantOptions)\n            .then(function (response) {\n            return new tenant_1.Tenant(response);\n        });\n    };\n    return TenantManager;\n}());\nexports.TenantManager = TenantManager;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/auth/tenant-manager.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/auth/tenant.js":
/*!************************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/auth/tenant.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\n/*!\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar validator = __webpack_require__(/*! ../utils/validator */ \"./src/node_modules/firebase-admin/lib/utils/validator.js\");\nvar error_1 = __webpack_require__(/*! ../utils/error */ \"./src/node_modules/firebase-admin/lib/utils/error.js\");\nvar auth_config_1 = __webpack_require__(/*! ./auth-config */ \"./src/node_modules/firebase-admin/lib/auth/auth-config.js\");\n/**\n * Tenant class that defines a Firebase Auth tenant.\n */\nvar Tenant = /** @class */ (function () {\n    /**\n     * The Tenant object constructor.\n     *\n     * @param {any} response The server side response used to initialize the Tenant object.\n     * @constructor\n     */\n    function Tenant(response) {\n        var tenantId = Tenant.getTenantIdFromResourceName(response.name);\n        if (!tenantId) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid tenant response');\n        }\n        this.tenantId = tenantId;\n        this.displayName = response.displayName;\n        try {\n            this.emailSignInConfig = new auth_config_1.EmailSignInConfig(response);\n        }\n        catch (e) {\n            // If allowPasswordSignup is undefined, it is disabled by default.\n            this.emailSignInConfig = new auth_config_1.EmailSignInConfig({\n                allowPasswordSignup: false,\n            });\n        }\n    }\n    /**\n     * Builds the corresponding server request for a TenantOptions object.\n     *\n     * @param {TenantOptions} tenantOptions The properties to convert to a server request.\n     * @param {boolean} createRequest Whether this is a create request.\n     * @return {object} The equivalent server request.\n     */\n    Tenant.buildServerRequest = function (tenantOptions, createRequest) {\n        Tenant.validate(tenantOptions, createRequest);\n        var request = {};\n        if (typeof tenantOptions.emailSignInConfig !== 'undefined') {\n            request = auth_config_1.EmailSignInConfig.buildServerRequest(tenantOptions.emailSignInConfig);\n        }\n        if (typeof tenantOptions.displayName !== 'undefined') {\n            request.displayName = tenantOptions.displayName;\n        }\n        return request;\n    };\n    /**\n     * Returns the tenant ID corresponding to the resource name if available.\n     *\n     * @param {string} resourceName The server side resource name\n     * @return {?string} The tenant ID corresponding to the resource, null otherwise.\n     */\n    Tenant.getTenantIdFromResourceName = function (resourceName) {\n        // name is of form projects/project1/tenants/tenant1\n        var matchTenantRes = resourceName.match(/\\/tenants\\/(.*)$/);\n        if (!matchTenantRes || matchTenantRes.length < 2) {\n            return null;\n        }\n        return matchTenantRes[1];\n    };\n    /**\n     * Validates a tenant options object. Throws an error on failure.\n     *\n     * @param {any} request The tenant options object to validate.\n     * @param {boolean} createRequest Whether this is a create request.\n     */\n    Tenant.validate = function (request, createRequest) {\n        var validKeys = {\n            displayName: true,\n            emailSignInConfig: true,\n        };\n        var label = createRequest ? 'CreateTenantRequest' : 'UpdateTenantRequest';\n        if (!validator.isNonNullObject(request)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"\\\"\" + label + \"\\\" must be a valid non-null object.\");\n        }\n        // Check for unsupported top level attributes.\n        for (var key in request) {\n            if (!(key in validKeys)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"\\\"\" + key + \"\\\" is not a valid \" + label + \" parameter.\");\n            }\n        }\n        // Validate displayName type if provided.\n        if (typeof request.displayName !== 'undefined' &&\n            !validator.isNonEmptyString(request.displayName)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"\\\"\" + label + \".displayName\\\" must be a valid non-empty string.\");\n        }\n        // Validate emailSignInConfig type if provided.\n        if (typeof request.emailSignInConfig !== 'undefined') {\n            // This will throw an error if invalid.\n            auth_config_1.EmailSignInConfig.buildServerRequest(request.emailSignInConfig);\n        }\n    };\n    /** @return {object} The plain object representation of the tenant. */\n    Tenant.prototype.toJSON = function () {\n        return {\n            tenantId: this.tenantId,\n            displayName: this.displayName,\n            emailSignInConfig: this.emailSignInConfig && this.emailSignInConfig.toJSON(),\n        };\n    };\n    return Tenant;\n}());\nexports.Tenant = Tenant;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/auth/tenant.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/auth/token-generator.js":
/*!*********************************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/auth/token-generator.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\n/*!\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar credential_1 = __webpack_require__(/*! ./credential */ \"./src/node_modules/firebase-admin/lib/auth/credential.js\");\nvar error_1 = __webpack_require__(/*! ../utils/error */ \"./src/node_modules/firebase-admin/lib/utils/error.js\");\nvar api_request_1 = __webpack_require__(/*! ../utils/api-request */ \"./src/node_modules/firebase-admin/lib/utils/api-request.js\");\nvar validator = __webpack_require__(/*! ../utils/validator */ \"./src/node_modules/firebase-admin/lib/utils/validator.js\");\nvar utils_1 = __webpack_require__(/*! ../utils */ \"./src/node_modules/firebase-admin/lib/utils/index.js\");\nvar ALGORITHM_RS256 = 'RS256';\nvar ONE_HOUR_IN_SECONDS = 60 * 60;\n// List of blacklisted claims which cannot be provided when creating a custom token\nexports.BLACKLISTED_CLAIMS = [\n    'acr', 'amr', 'at_hash', 'aud', 'auth_time', 'azp', 'cnf', 'c_hash', 'exp', 'iat', 'iss', 'jti',\n    'nbf', 'nonce',\n];\n// Audience to use for Firebase Auth Custom tokens\nvar FIREBASE_AUDIENCE = 'https://identitytoolkit.googleapis.com/google.identity.identitytoolkit.v1.IdentityToolkit';\n/**\n * A CryptoSigner implementation that uses an explicitly specified service account private key to\n * sign data. Performs all operations locally, and does not make any RPC calls.\n */\nvar ServiceAccountSigner = /** @class */ (function () {\n    /**\n     * Creates a new CryptoSigner instance from the given service account credential.\n     *\n     * @param {ServiceAccountCredential} credential A service account credential.\n     */\n    function ServiceAccountSigner(credential) {\n        this.credential = credential;\n        if (!credential) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CREDENTIAL, 'INTERNAL ASSERT: Must provide a service account credential to initialize ServiceAccountSigner.');\n        }\n    }\n    /**\n     * @inheritDoc\n     */\n    ServiceAccountSigner.prototype.sign = function (buffer) {\n        var crypto = __webpack_require__(/*! crypto */ \"crypto\"); // eslint-disable-line @typescript-eslint/no-var-requires\n        var sign = crypto.createSign('RSA-SHA256');\n        sign.update(buffer);\n        return Promise.resolve(sign.sign(this.credential.privateKey));\n    };\n    /**\n     * @inheritDoc\n     */\n    ServiceAccountSigner.prototype.getAccountId = function () {\n        return Promise.resolve(this.credential.clientEmail);\n    };\n    return ServiceAccountSigner;\n}());\nexports.ServiceAccountSigner = ServiceAccountSigner;\n/**\n * A CryptoSigner implementation that uses the remote IAM service to sign data. If initialized without\n * a service account ID, attempts to discover a service account ID by consulting the local Metadata\n * service. This will succeed in managed environments like Google Cloud Functions and App Engine.\n *\n * @see https://cloud.google.com/iam/reference/rest/v1/projects.serviceAccounts/signBlob\n * @see https://cloud.google.com/compute/docs/storing-retrieving-metadata\n */\nvar IAMSigner = /** @class */ (function () {\n    function IAMSigner(httpClient, serviceAccountId) {\n        if (!httpClient) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'INTERNAL ASSERT: Must provide a HTTP client to initialize IAMSigner.');\n        }\n        if (typeof serviceAccountId !== 'undefined' && !validator.isNonEmptyString(serviceAccountId)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'INTERNAL ASSERT: Service account ID must be undefined or a non-empty string.');\n        }\n        this.httpClient = httpClient;\n        this.serviceAccountId = serviceAccountId;\n    }\n    /**\n     * @inheritDoc\n     */\n    IAMSigner.prototype.sign = function (buffer) {\n        var _this = this;\n        return this.getAccountId().then(function (serviceAccount) {\n            var request = {\n                method: 'POST',\n                url: \"https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/\" + serviceAccount + \":signBlob\",\n                data: { payload: buffer.toString('base64') },\n            };\n            return _this.httpClient.send(request);\n        }).then(function (response) {\n            // Response from IAM is base64 encoded. Decode it into a buffer and return.\n            return Buffer.from(response.data.signedBlob, 'base64');\n        }).catch(function (err) {\n            if (err instanceof api_request_1.HttpError) {\n                var error = err.response.data;\n                if (validator.isNonNullObject(error) && error.error) {\n                    var errorCode = error.error.status;\n                    var description = 'Please refer to https://firebase.google.com/docs/auth/admin/create-custom-tokens ' +\n                        'for more details on how to use and troubleshoot this feature.';\n                    var errorMsg = error.error.message + \"; \" + description;\n                    throw error_1.FirebaseAuthError.fromServerError(errorCode, errorMsg, error);\n                }\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Error returned from server: ' + error + '. Additionally, an ' +\n                    'internal error occurred while attempting to extract the ' +\n                    'errorcode from the error.');\n            }\n            throw err;\n        });\n    };\n    /**\n     * @inheritDoc\n     */\n    IAMSigner.prototype.getAccountId = function () {\n        var _this = this;\n        if (validator.isNonEmptyString(this.serviceAccountId)) {\n            return Promise.resolve(this.serviceAccountId);\n        }\n        var request = {\n            method: 'GET',\n            url: 'http://metadata/computeMetadata/v1/instance/service-accounts/default/email',\n            headers: {\n                'Metadata-Flavor': 'Google',\n            },\n        };\n        var client = new api_request_1.HttpClient();\n        return client.send(request).then(function (response) {\n            if (!response.text) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'HTTP Response missing payload');\n            }\n            _this.serviceAccountId = response.text;\n            return response.text;\n        }).catch(function (err) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CREDENTIAL, \"Failed to determine service account. Make sure to initialize \" +\n                \"the SDK with a service account credential. Alternatively specify a service \" +\n                (\"account with iam.serviceAccounts.signBlob permission. Original error: \" + err));\n        });\n    };\n    return IAMSigner;\n}());\nexports.IAMSigner = IAMSigner;\n/**\n * Create a new CryptoSigner instance for the given app. If the app has been initialized with a service\n * account credential, creates a ServiceAccountSigner. Otherwise creates an IAMSigner.\n *\n * @param {FirebaseApp} app A FirebaseApp instance.\n * @return {CryptoSigner} A CryptoSigner instance.\n */\nfunction cryptoSignerFromApp(app) {\n    var credential = app.options.credential;\n    if (credential instanceof credential_1.ServiceAccountCredential) {\n        return new ServiceAccountSigner(credential);\n    }\n    return new IAMSigner(new api_request_1.AuthorizedHttpClient(app), app.options.serviceAccountId);\n}\nexports.cryptoSignerFromApp = cryptoSignerFromApp;\n/**\n * Class for generating different types of Firebase Auth tokens (JWTs).\n */\nvar FirebaseTokenGenerator = /** @class */ (function () {\n    /**\n     * @param tenantId The tenant ID to use for the generated Firebase Auth\n     *     Custom token. If absent, then no tenant ID claim will be set in the\n     *     resulting JWT.\n     */\n    function FirebaseTokenGenerator(signer, tenantId) {\n        this.tenantId = tenantId;\n        if (!validator.isNonNullObject(signer)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CREDENTIAL, 'INTERNAL ASSERT: Must provide a CryptoSigner to use FirebaseTokenGenerator.');\n        }\n        if (typeof tenantId !== 'undefined' && !validator.isNonEmptyString(tenantId)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '`tenantId` argument must be a non-empty string.');\n        }\n        this.signer = signer;\n    }\n    /**\n     * Creates a new Firebase Auth Custom token.\n     *\n     * @param uid The user ID to use for the generated Firebase Auth Custom token.\n     * @param developerClaims Optional developer claims to include in the generated Firebase\n     *     Auth Custom token.\n     * @return A Promise fulfilled with a Firebase Auth Custom token signed with a\n     *     service account key and containing the provided payload.\n     */\n    FirebaseTokenGenerator.prototype.createCustomToken = function (uid, developerClaims) {\n        var _this = this;\n        var errorMessage;\n        if (!validator.isNonEmptyString(uid)) {\n            errorMessage = '`uid` argument must be a non-empty string uid.';\n        }\n        else if (uid.length > 128) {\n            errorMessage = '`uid` argument must a uid with less than or equal to 128 characters.';\n        }\n        else if (!this.isDeveloperClaimsValid_(developerClaims)) {\n            errorMessage = '`developerClaims` argument must be a valid, non-null object containing the developer claims.';\n        }\n        if (errorMessage) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, errorMessage);\n        }\n        var claims = {};\n        if (typeof developerClaims !== 'undefined') {\n            for (var key in developerClaims) {\n                /* istanbul ignore else */\n                if (Object.prototype.hasOwnProperty.call(developerClaims, key)) {\n                    if (exports.BLACKLISTED_CLAIMS.indexOf(key) !== -1) {\n                        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"Developer claim \\\"\" + key + \"\\\" is reserved and cannot be specified.\");\n                    }\n                    claims[key] = developerClaims[key];\n                }\n            }\n        }\n        return this.signer.getAccountId().then(function (account) {\n            var header = {\n                alg: ALGORITHM_RS256,\n                typ: 'JWT',\n            };\n            var iat = Math.floor(Date.now() / 1000);\n            var body = {\n                aud: FIREBASE_AUDIENCE,\n                iat: iat,\n                exp: iat + ONE_HOUR_IN_SECONDS,\n                iss: account,\n                sub: account,\n                uid: uid,\n            };\n            if (_this.tenantId) {\n                // eslint-disable-next-line @typescript-eslint/camelcase\n                body.tenant_id = _this.tenantId;\n            }\n            if (Object.keys(claims).length > 0) {\n                body.claims = claims;\n            }\n            var token = _this.encodeSegment(header) + \".\" + _this.encodeSegment(body);\n            var signPromise = _this.signer.sign(Buffer.from(token));\n            return Promise.all([token, signPromise]);\n        }).then(function (_a) {\n            var token = _a[0], signature = _a[1];\n            return token + \".\" + _this.encodeSegment(signature);\n        });\n    };\n    FirebaseTokenGenerator.prototype.encodeSegment = function (segment) {\n        var buffer = (segment instanceof Buffer) ? segment : Buffer.from(JSON.stringify(segment));\n        return utils_1.toWebSafeBase64(buffer).replace(/=+$/, '');\n    };\n    /**\n     * Returns whether or not the provided developer claims are valid.\n     *\n     * @param {object} [developerClaims] Optional developer claims to validate.\n     * @return {boolean} True if the provided claims are valid; otherwise, false.\n     */\n    FirebaseTokenGenerator.prototype.isDeveloperClaimsValid_ = function (developerClaims) {\n        if (typeof developerClaims === 'undefined') {\n            return true;\n        }\n        return validator.isNonNullObject(developerClaims);\n    };\n    return FirebaseTokenGenerator;\n}());\nexports.FirebaseTokenGenerator = FirebaseTokenGenerator;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/auth/token-generator.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/auth/token-verifier.js":
/*!********************************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/auth/token-verifier.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\n/*!\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar error_1 = __webpack_require__(/*! ../utils/error */ \"./src/node_modules/firebase-admin/lib/utils/error.js\");\nvar util = __webpack_require__(/*! ../utils/index */ \"./src/node_modules/firebase-admin/lib/utils/index.js\");\nvar validator = __webpack_require__(/*! ../utils/validator */ \"./src/node_modules/firebase-admin/lib/utils/validator.js\");\nvar jwt = __webpack_require__(/*! jsonwebtoken */ \"jsonwebtoken\");\nvar api_request_1 = __webpack_require__(/*! ../utils/api-request */ \"./src/node_modules/firebase-admin/lib/utils/api-request.js\");\n// Audience to use for Firebase Auth Custom tokens\nvar FIREBASE_AUDIENCE = 'https://identitytoolkit.googleapis.com/google.identity.identitytoolkit.v1.IdentityToolkit';\nexports.ALGORITHM_RS256 = 'RS256';\n// URL containing the public keys for the Google certs (whose private keys are used to sign Firebase\n// Auth ID tokens)\nvar CLIENT_CERT_URL = 'https://www.googleapis.com/robot/v1/metadata/x509/securetoken@system.gserviceaccount.com';\n// URL containing the public keys for Firebase session cookies. This will be updated to a different URL soon.\nvar SESSION_COOKIE_CERT_URL = 'https://www.googleapis.com/identitytoolkit/v3/relyingparty/publicKeys';\n/** User facing token information related to the Firebase ID token. */\nexports.ID_TOKEN_INFO = {\n    url: 'https://firebase.google.com/docs/auth/admin/verify-id-tokens',\n    verifyApiName: 'verifyIdToken()',\n    jwtName: 'Firebase ID token',\n    shortName: 'ID token',\n    expiredErrorCode: error_1.AuthClientErrorCode.ID_TOKEN_EXPIRED,\n};\n/** User facing token information related to the Firebase session cookie. */\nexports.SESSION_COOKIE_INFO = {\n    url: 'https://firebase.google.com/docs/auth/admin/manage-cookies',\n    verifyApiName: 'verifySessionCookie()',\n    jwtName: 'Firebase session cookie',\n    shortName: 'session cookie',\n    expiredErrorCode: error_1.AuthClientErrorCode.SESSION_COOKIE_EXPIRED,\n};\n/**\n * Class for verifying general purpose Firebase JWTs. This verifies ID tokens and session cookies.\n */\nvar FirebaseTokenVerifier = /** @class */ (function () {\n    function FirebaseTokenVerifier(clientCertUrl, algorithm, issuer, tokenInfo, app) {\n        this.clientCertUrl = clientCertUrl;\n        this.algorithm = algorithm;\n        this.issuer = issuer;\n        this.tokenInfo = tokenInfo;\n        this.app = app;\n        if (!validator.isURL(clientCertUrl)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"The provided public client certificate URL is an invalid URL.\");\n        }\n        else if (!validator.isNonEmptyString(algorithm)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"The provided JWT algorithm is an empty string.\");\n        }\n        else if (!validator.isURL(issuer)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"The provided JWT issuer is an invalid URL.\");\n        }\n        else if (!validator.isNonNullObject(tokenInfo)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"The provided JWT information is not an object or null.\");\n        }\n        else if (!validator.isURL(tokenInfo.url)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"The provided JWT verification documentation URL is invalid.\");\n        }\n        else if (!validator.isNonEmptyString(tokenInfo.verifyApiName)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"The JWT verify API name must be a non-empty string.\");\n        }\n        else if (!validator.isNonEmptyString(tokenInfo.jwtName)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"The JWT public full name must be a non-empty string.\");\n        }\n        else if (!validator.isNonEmptyString(tokenInfo.shortName)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"The JWT public short name must be a non-empty string.\");\n        }\n        else if (!validator.isNonNullObject(tokenInfo.expiredErrorCode) || !('code' in tokenInfo.expiredErrorCode)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"The JWT expiration error code must be a non-null ErrorInfo object.\");\n        }\n        this.shortNameArticle = tokenInfo.shortName.charAt(0).match(/[aeiou]/i) ? 'an' : 'a';\n        // For backward compatibility, the project ID is validated in the verification call.\n    }\n    /**\n     * Verifies the format and signature of a Firebase Auth JWT token.\n     *\n     * @param {string} jwtToken The Firebase Auth JWT token to verify.\n     * @return {Promise<DecodedIdToken>} A promise fulfilled with the decoded claims of the Firebase Auth ID\n     *                           token.\n     */\n    FirebaseTokenVerifier.prototype.verifyJWT = function (jwtToken) {\n        var _this = this;\n        if (!validator.isString(jwtToken)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"First argument to \" + this.tokenInfo.verifyApiName + \" must be a \" + this.tokenInfo.jwtName + \" string.\");\n        }\n        return util.findProjectId(this.app)\n            .then(function (projectId) {\n            return _this.verifyJWTWithProjectId(jwtToken, projectId);\n        });\n    };\n    FirebaseTokenVerifier.prototype.verifyJWTWithProjectId = function (jwtToken, projectId) {\n        var _this = this;\n        if (!validator.isNonEmptyString(projectId)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CREDENTIAL, \"Must initialize app with a cert credential or set your Firebase project ID as the \" +\n                (\"GOOGLE_CLOUD_PROJECT environment variable to call \" + this.tokenInfo.verifyApiName + \".\"));\n        }\n        var fullDecodedToken = jwt.decode(jwtToken, {\n            complete: true,\n        });\n        var header = fullDecodedToken && fullDecodedToken.header;\n        var payload = fullDecodedToken && fullDecodedToken.payload;\n        var projectIdMatchMessage = \" Make sure the \" + this.tokenInfo.shortName + \" comes from the same \" +\n            \"Firebase project as the service account used to authenticate this SDK.\";\n        var verifyJwtTokenDocsMessage = \" See \" + this.tokenInfo.url + \" \" +\n            (\"for details on how to retrieve \" + this.shortNameArticle + \" \" + this.tokenInfo.shortName + \".\");\n        var errorMessage;\n        if (!fullDecodedToken) {\n            errorMessage = \"Decoding \" + this.tokenInfo.jwtName + \" failed. Make sure you passed the entire string JWT \" +\n                (\"which represents \" + this.shortNameArticle + \" \" + this.tokenInfo.shortName + \".\") + verifyJwtTokenDocsMessage;\n        }\n        else if (typeof header.kid === 'undefined') {\n            var isCustomToken = (payload.aud === FIREBASE_AUDIENCE);\n            var isLegacyCustomToken = (header.alg === 'HS256' && payload.v === 0 && 'd' in payload && 'uid' in payload.d);\n            if (isCustomToken) {\n                errorMessage = this.tokenInfo.verifyApiName + \" expects \" + this.shortNameArticle + \" \" +\n                    (this.tokenInfo.shortName + \", but was given a custom token.\");\n            }\n            else if (isLegacyCustomToken) {\n                errorMessage = this.tokenInfo.verifyApiName + \" expects \" + this.shortNameArticle + \" \" +\n                    (this.tokenInfo.shortName + \", but was given a legacy custom token.\");\n            }\n            else {\n                errorMessage = 'Firebase ID token has no \"kid\" claim.';\n            }\n            errorMessage += verifyJwtTokenDocsMessage;\n        }\n        else if (header.alg !== this.algorithm) {\n            errorMessage = this.tokenInfo.jwtName + \" has incorrect algorithm. Expected \\\"\" + this.algorithm + \"\\\" but got \" +\n                \"\\\"\" + header.alg + \"\\\".\" + verifyJwtTokenDocsMessage;\n        }\n        else if (payload.aud !== projectId) {\n            errorMessage = this.tokenInfo.jwtName + \" has incorrect \\\"aud\\\" (audience) claim. Expected \\\"\" +\n                projectId + \"\\\" but got \\\"\" + payload.aud + \"\\\".\" + projectIdMatchMessage +\n                verifyJwtTokenDocsMessage;\n        }\n        else if (payload.iss !== this.issuer + projectId) {\n            errorMessage = this.tokenInfo.jwtName + \" has incorrect \\\"iss\\\" (issuer) claim. Expected \" +\n                (\"\\\"\" + this.issuer + \"\\\"\") + projectId + \"\\\" but got \\\"\" +\n                payload.iss + \"\\\".\" + projectIdMatchMessage + verifyJwtTokenDocsMessage;\n        }\n        else if (typeof payload.sub !== 'string') {\n            errorMessage = this.tokenInfo.jwtName + \" has no \\\"sub\\\" (subject) claim.\" + verifyJwtTokenDocsMessage;\n        }\n        else if (payload.sub === '') {\n            errorMessage = this.tokenInfo.jwtName + \" has an empty string \\\"sub\\\" (subject) claim.\" + verifyJwtTokenDocsMessage;\n        }\n        else if (payload.sub.length > 128) {\n            errorMessage = this.tokenInfo.jwtName + \" has \\\"sub\\\" (subject) claim longer than 128 characters.\" +\n                verifyJwtTokenDocsMessage;\n        }\n        if (errorMessage) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, errorMessage));\n        }\n        return this.fetchPublicKeys().then(function (publicKeys) {\n            if (!Object.prototype.hasOwnProperty.call(publicKeys, header.kid)) {\n                return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, _this.tokenInfo.jwtName + \" has \\\"kid\\\" claim which does not correspond to a known public key. \" +\n                    (\"Most likely the \" + _this.tokenInfo.shortName + \" is expired, so get a fresh token from your \") +\n                    \"client app and try again.\"));\n            }\n            else {\n                return _this.verifyJwtSignatureWithKey(jwtToken, publicKeys[header.kid]);\n            }\n        });\n    };\n    /**\n     * Verifies the JWT signature using the provided public key.\n     * @param {string} jwtToken The JWT token to verify.\n     * @param {string} publicKey The public key certificate.\n     * @return {Promise<DecodedIdToken>} A promise that resolves with the decoded JWT claims on successful\n     *     verification.\n     */\n    FirebaseTokenVerifier.prototype.verifyJwtSignatureWithKey = function (jwtToken, publicKey) {\n        var _this = this;\n        var verifyJwtTokenDocsMessage = \" See \" + this.tokenInfo.url + \" \" +\n            (\"for details on how to retrieve \" + this.shortNameArticle + \" \" + this.tokenInfo.shortName + \".\");\n        return new Promise(function (resolve, reject) {\n            jwt.verify(jwtToken, publicKey, {\n                algorithms: [_this.algorithm],\n            }, function (error, decodedToken) {\n                if (error) {\n                    if (error.name === 'TokenExpiredError') {\n                        var errorMessage = _this.tokenInfo.jwtName + \" has expired. Get a fresh \" + _this.tokenInfo.shortName +\n                            (\" from your client app and try again (auth/\" + _this.tokenInfo.expiredErrorCode.code + \").\") +\n                            verifyJwtTokenDocsMessage;\n                        return reject(new error_1.FirebaseAuthError(_this.tokenInfo.expiredErrorCode, errorMessage));\n                    }\n                    else if (error.name === 'JsonWebTokenError') {\n                        var errorMessage = _this.tokenInfo.jwtName + \" has invalid signature.\" + verifyJwtTokenDocsMessage;\n                        return reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, errorMessage));\n                    }\n                    return reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, error.message));\n                }\n                else {\n                    // TODO(rsgowman): I think the typing on jwt.verify is wrong. It claims that this can be either a string or an\n                    // object, but the code always seems to call it as an object. Investigate and upstream typing changes if this\n                    // is actually correct.\n                    if (typeof decodedToken === 'string') {\n                        return reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, \"Unexpected decodedToken. Expected an object but got a string: '\" + decodedToken + \"'\"));\n                    }\n                    else {\n                        var decodedIdToken = decodedToken;\n                        decodedIdToken.uid = decodedIdToken.sub;\n                        resolve(decodedIdToken);\n                    }\n                }\n            });\n        });\n    };\n    /**\n     * Fetches the public keys for the Google certs.\n     *\n     * @return {Promise<object>} A promise fulfilled with public keys for the Google certs.\n     */\n    FirebaseTokenVerifier.prototype.fetchPublicKeys = function () {\n        var _this = this;\n        var publicKeysExist = (typeof this.publicKeys !== 'undefined');\n        var publicKeysExpiredExists = (typeof this.publicKeysExpireAt !== 'undefined');\n        var publicKeysStillValid = (publicKeysExpiredExists && Date.now() < this.publicKeysExpireAt);\n        if (publicKeysExist && publicKeysStillValid) {\n            return Promise.resolve(this.publicKeys);\n        }\n        var client = new api_request_1.HttpClient();\n        var request = {\n            method: 'GET',\n            url: this.clientCertUrl,\n            httpAgent: this.app.options.httpAgent,\n        };\n        return client.send(request).then(function (resp) {\n            if (!resp.isJson() || resp.data.error) {\n                // Treat all non-json messages and messages with an 'error' field as\n                // error responses.\n                throw new api_request_1.HttpError(resp);\n            }\n            if (Object.prototype.hasOwnProperty.call(resp.headers, 'cache-control')) {\n                var cacheControlHeader = resp.headers['cache-control'];\n                var parts = cacheControlHeader.split(',');\n                parts.forEach(function (part) {\n                    var subParts = part.trim().split('=');\n                    if (subParts[0] === 'max-age') {\n                        var maxAge = +subParts[1];\n                        _this.publicKeysExpireAt = Date.now() + (maxAge * 1000);\n                    }\n                });\n            }\n            _this.publicKeys = resp.data;\n            return resp.data;\n        }).catch(function (err) {\n            if (err instanceof api_request_1.HttpError) {\n                var errorMessage = 'Error fetching public keys for Google certs: ';\n                var resp = err.response;\n                if (resp.isJson() && resp.data.error) {\n                    errorMessage += \"\" + resp.data.error;\n                    if (resp.data.error_description) {\n                        errorMessage += ' (' + resp.data.error_description + ')';\n                    }\n                }\n                else {\n                    errorMessage += \"\" + resp.text;\n                }\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, errorMessage);\n            }\n            throw err;\n        });\n    };\n    return FirebaseTokenVerifier;\n}());\nexports.FirebaseTokenVerifier = FirebaseTokenVerifier;\n/**\n * Creates a new FirebaseTokenVerifier to verify Firebase ID tokens.\n *\n * @param {FirebaseApp} app Firebase app instance.\n * @return {FirebaseTokenVerifier}\n */\nfunction createIdTokenVerifier(app) {\n    return new FirebaseTokenVerifier(CLIENT_CERT_URL, exports.ALGORITHM_RS256, 'https://securetoken.google.com/', exports.ID_TOKEN_INFO, app);\n}\nexports.createIdTokenVerifier = createIdTokenVerifier;\n/**\n * Creates a new FirebaseTokenVerifier to verify Firebase session cookies.\n *\n * @param {FirebaseApp} app Firebase app instance.\n * @return {FirebaseTokenVerifier}\n */\nfunction createSessionCookieVerifier(app) {\n    return new FirebaseTokenVerifier(SESSION_COOKIE_CERT_URL, exports.ALGORITHM_RS256, 'https://session.firebase.google.com/', exports.SESSION_COOKIE_INFO, app);\n}\nexports.createSessionCookieVerifier = createSessionCookieVerifier;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/auth/token-verifier.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/auth/user-import-builder.js":
/*!*************************************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/auth/user-import-builder.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\n/*!\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar deep_copy_1 = __webpack_require__(/*! ../utils/deep-copy */ \"./src/node_modules/firebase-admin/lib/utils/deep-copy.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"./src/node_modules/firebase-admin/lib/utils/index.js\");\nvar validator = __webpack_require__(/*! ../utils/validator */ \"./src/node_modules/firebase-admin/lib/utils/validator.js\");\nvar error_1 = __webpack_require__(/*! ../utils/error */ \"./src/node_modules/firebase-admin/lib/utils/error.js\");\n/**\n * Converts a client format second factor object to server format.\n * @param multiFactorInfo The client format second factor.\n * @return The corresponding AuthFactorInfo server request format.\n */\nfunction convertMultiFactorInfoToServerFormat(multiFactorInfo) {\n    var enrolledAt;\n    if (typeof multiFactorInfo.enrollmentTime !== 'undefined') {\n        if (validator.isUTCDateString(multiFactorInfo.enrollmentTime)) {\n            // Convert from UTC date string (client side format) to ISO date string (server side format).\n            enrolledAt = new Date(multiFactorInfo.enrollmentTime).toISOString();\n        }\n        else {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ENROLLMENT_TIME, \"The second factor \\\"enrollmentTime\\\" for \\\"\" + multiFactorInfo.uid + \"\\\" must be a valid \" +\n                \"UTC date string.\");\n        }\n    }\n    // Currently only phone second factors are supported.\n    if (multiFactorInfo.factorId === 'phone') {\n        // If any required field is missing or invalid, validation will still fail later.\n        var authFactorInfo = {\n            mfaEnrollmentId: multiFactorInfo.uid,\n            displayName: multiFactorInfo.displayName,\n            // Required for all phone second factors.\n            phoneInfo: multiFactorInfo.phoneNumber,\n            enrolledAt: enrolledAt,\n        };\n        for (var objKey in authFactorInfo) {\n            if (typeof authFactorInfo[objKey] === 'undefined') {\n                delete authFactorInfo[objKey];\n            }\n        }\n        return authFactorInfo;\n    }\n    else {\n        // Unsupported second factor.\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.UNSUPPORTED_SECOND_FACTOR, \"Unsupported second factor \\\"\" + JSON.stringify(multiFactorInfo) + \"\\\" provided.\");\n    }\n}\nexports.convertMultiFactorInfoToServerFormat = convertMultiFactorInfoToServerFormat;\n/**\n * @param {any} obj The object to check for number field within.\n * @param {string} key The entry key.\n * @return {number} The corresponding number if available. Otherwise, NaN.\n */\nfunction getNumberField(obj, key) {\n    if (typeof obj[key] !== 'undefined' && obj[key] !== null) {\n        return parseInt(obj[key].toString(), 10);\n    }\n    return NaN;\n}\n/**\n * Converts a UserImportRecord to a UploadAccountUser object. Throws an error when invalid\n * fields are provided.\n * @param {UserImportRecord} user The UserImportRecord to conver to UploadAccountUser.\n * @param {ValidatorFunction=} userValidator The user validator function.\n * @return {UploadAccountUser} The corresponding UploadAccountUser to return.\n */\nfunction populateUploadAccountUser(user, userValidator) {\n    var result = {\n        localId: user.uid,\n        email: user.email,\n        emailVerified: user.emailVerified,\n        displayName: user.displayName,\n        disabled: user.disabled,\n        photoUrl: user.photoURL,\n        phoneNumber: user.phoneNumber,\n        providerUserInfo: [],\n        mfaInfo: [],\n        tenantId: user.tenantId,\n        customAttributes: user.customClaims && JSON.stringify(user.customClaims),\n    };\n    if (typeof user.passwordHash !== 'undefined') {\n        if (!validator.isBuffer(user.passwordHash)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_HASH);\n        }\n        result.passwordHash = utils.toWebSafeBase64(user.passwordHash);\n    }\n    if (typeof user.passwordSalt !== 'undefined') {\n        if (!validator.isBuffer(user.passwordSalt)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_SALT);\n        }\n        result.salt = utils.toWebSafeBase64(user.passwordSalt);\n    }\n    if (validator.isNonNullObject(user.metadata)) {\n        if (validator.isNonEmptyString(user.metadata.creationTime)) {\n            result.createdAt = new Date(user.metadata.creationTime).getTime();\n        }\n        if (validator.isNonEmptyString(user.metadata.lastSignInTime)) {\n            result.lastLoginAt = new Date(user.metadata.lastSignInTime).getTime();\n        }\n    }\n    if (validator.isArray(user.providerData)) {\n        user.providerData.forEach(function (providerData) {\n            result.providerUserInfo.push({\n                providerId: providerData.providerId,\n                rawId: providerData.uid,\n                email: providerData.email,\n                displayName: providerData.displayName,\n                photoUrl: providerData.photoURL,\n            });\n        });\n    }\n    // Convert user.multiFactor.enrolledFactors to server format.\n    if (validator.isNonNullObject(user.multiFactor) &&\n        validator.isNonEmptyArray(user.multiFactor.enrolledFactors)) {\n        user.multiFactor.enrolledFactors.forEach(function (multiFactorInfo) {\n            result.mfaInfo.push(convertMultiFactorInfoToServerFormat(multiFactorInfo));\n        });\n    }\n    // Remove blank fields.\n    var key;\n    for (key in result) {\n        if (typeof result[key] === 'undefined') {\n            delete result[key];\n        }\n    }\n    if (result.providerUserInfo.length === 0) {\n        delete result.providerUserInfo;\n    }\n    if (result.mfaInfo.length === 0) {\n        delete result.mfaInfo;\n    }\n    // Validate the constructured user individual request. This will throw if an error\n    // is detected.\n    if (typeof userValidator === 'function') {\n        userValidator(result);\n    }\n    return result;\n}\n/**\n * Class that provides a helper for building/validating uploadAccount requests and\n * UserImportResult responses.\n */\nvar UserImportBuilder = /** @class */ (function () {\n    /**\n     * @param {UserImportRecord[]} users The list of user records to import.\n     * @param {UserImportOptions=} options The import options which includes hashing\n     *     algorithm details.\n     * @param {ValidatorFunction=} userRequestValidator The user request validator function.\n     * @constructor\n     */\n    function UserImportBuilder(users, options, userRequestValidator) {\n        this.requiresHashOptions = false;\n        this.validatedUsers = [];\n        this.userImportResultErrors = [];\n        this.indexMap = {};\n        this.validatedUsers = this.populateUsers(users, userRequestValidator);\n        this.validatedOptions = this.populateOptions(options, this.requiresHashOptions);\n    }\n    /**\n     * Returns the corresponding constructed uploadAccount request.\n     * @return {UploadAccountRequest} The constructed uploadAccount request.\n     */\n    UserImportBuilder.prototype.buildRequest = function () {\n        var users = this.validatedUsers.map(function (user) {\n            return deep_copy_1.deepCopy(user);\n        });\n        return deep_copy_1.deepExtend({ users: users }, deep_copy_1.deepCopy(this.validatedOptions));\n    };\n    /**\n     * Populates the UserImportResult using the client side detected errors and the server\n     * side returned errors.\n     * @return {UserImportResult} The user import result based on the returned failed\n     *     uploadAccount response.\n     */\n    UserImportBuilder.prototype.buildResponse = function (failedUploads) {\n        var _this = this;\n        // Initialize user import result.\n        var importResult = {\n            successCount: this.validatedUsers.length,\n            failureCount: this.userImportResultErrors.length,\n            errors: deep_copy_1.deepCopy(this.userImportResultErrors),\n        };\n        importResult.failureCount += failedUploads.length;\n        importResult.successCount -= failedUploads.length;\n        failedUploads.forEach(function (failedUpload) {\n            importResult.errors.push({\n                // Map backend request index to original developer provided array index.\n                index: _this.indexMap[failedUpload.index],\n                error: new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_USER_IMPORT, failedUpload.message),\n            });\n        });\n        // Sort errors by index.\n        importResult.errors.sort(function (a, b) {\n            return a.index - b.index;\n        });\n        // Return sorted result.\n        return importResult;\n    };\n    /**\n     * Validates and returns the hashing options of the uploadAccount request.\n     * Throws an error whenever an invalid or missing options is detected.\n     * @param {UserImportOptions} options The UserImportOptions.\n     * @param {boolean} requiresHashOptions Whether to require hash options.\n     * @return {UploadAccountOptions} The populated UploadAccount options.\n     */\n    UserImportBuilder.prototype.populateOptions = function (options, requiresHashOptions) {\n        var populatedOptions;\n        if (!requiresHashOptions) {\n            return {};\n        }\n        if (!validator.isNonNullObject(options)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"UserImportOptions\" are required when importing users with passwords.');\n        }\n        if (!validator.isNonNullObject(options.hash)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISSING_HASH_ALGORITHM, \"\\\"hash.algorithm\\\" is missing from the provided \\\"UserImportOptions\\\".\");\n        }\n        if (typeof options.hash.algorithm === 'undefined' ||\n            !validator.isNonEmptyString(options.hash.algorithm)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ALGORITHM, \"\\\"hash.algorithm\\\" must be a string matching the list of supported algorithms.\");\n        }\n        var rounds;\n        switch (options.hash.algorithm) {\n            case 'HMAC_SHA512':\n            case 'HMAC_SHA256':\n            case 'HMAC_SHA1':\n            case 'HMAC_MD5':\n                if (!validator.isBuffer(options.hash.key)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_KEY, \"A non-empty \\\"hash.key\\\" byte buffer must be provided for \" +\n                        (\"hash algorithm \" + options.hash.algorithm + \".\"));\n                }\n                populatedOptions = {\n                    hashAlgorithm: options.hash.algorithm,\n                    signerKey: utils.toWebSafeBase64(options.hash.key),\n                };\n                break;\n            case 'MD5':\n            case 'SHA1':\n            case 'SHA256':\n            case 'SHA512': {\n                // MD5 is [0,8192] but SHA1, SHA256, and SHA512 are [1,8192]\n                rounds = getNumberField(options.hash, 'rounds');\n                var minRounds = options.hash.algorithm === 'MD5' ? 0 : 1;\n                if (isNaN(rounds) || rounds < minRounds || rounds > 8192) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ROUNDS, \"A valid \\\"hash.rounds\\\" number between \" + minRounds + \" and 8192 must be provided for \" +\n                        (\"hash algorithm \" + options.hash.algorithm + \".\"));\n                }\n                populatedOptions = {\n                    hashAlgorithm: options.hash.algorithm,\n                    rounds: rounds,\n                };\n                break;\n            }\n            case 'PBKDF_SHA1':\n            case 'PBKDF2_SHA256':\n                rounds = getNumberField(options.hash, 'rounds');\n                if (isNaN(rounds) || rounds < 0 || rounds > 120000) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ROUNDS, \"A valid \\\"hash.rounds\\\" number between 0 and 120000 must be provided for \" +\n                        (\"hash algorithm \" + options.hash.algorithm + \".\"));\n                }\n                populatedOptions = {\n                    hashAlgorithm: options.hash.algorithm,\n                    rounds: rounds,\n                };\n                break;\n            case 'SCRYPT': {\n                if (!validator.isBuffer(options.hash.key)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_KEY, \"A \\\"hash.key\\\" byte buffer must be provided for \" +\n                        (\"hash algorithm \" + options.hash.algorithm + \".\"));\n                }\n                rounds = getNumberField(options.hash, 'rounds');\n                if (isNaN(rounds) || rounds <= 0 || rounds > 8) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ROUNDS, \"A valid \\\"hash.rounds\\\" number between 1 and 8 must be provided for \" +\n                        (\"hash algorithm \" + options.hash.algorithm + \".\"));\n                }\n                var memoryCost = getNumberField(options.hash, 'memoryCost');\n                if (isNaN(memoryCost) || memoryCost <= 0 || memoryCost > 14) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_MEMORY_COST, \"A valid \\\"hash.memoryCost\\\" number between 1 and 14 must be provided for \" +\n                        (\"hash algorithm \" + options.hash.algorithm + \".\"));\n                }\n                if (typeof options.hash.saltSeparator !== 'undefined' &&\n                    !validator.isBuffer(options.hash.saltSeparator)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_SALT_SEPARATOR, \"\\\"hash.saltSeparator\\\" must be a byte buffer.\");\n                }\n                populatedOptions = {\n                    hashAlgorithm: options.hash.algorithm,\n                    signerKey: utils.toWebSafeBase64(options.hash.key),\n                    rounds: rounds,\n                    memoryCost: memoryCost,\n                    saltSeparator: utils.toWebSafeBase64(options.hash.saltSeparator || Buffer.from('')),\n                };\n                break;\n            }\n            case 'BCRYPT':\n                populatedOptions = {\n                    hashAlgorithm: options.hash.algorithm,\n                };\n                break;\n            case 'STANDARD_SCRYPT': {\n                var cpuMemCost = getNumberField(options.hash, 'memoryCost');\n                if (isNaN(cpuMemCost)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_MEMORY_COST, \"A valid \\\"hash.memoryCost\\\" number must be provided for \" +\n                        (\"hash algorithm \" + options.hash.algorithm + \".\"));\n                }\n                var parallelization = getNumberField(options.hash, 'parallelization');\n                if (isNaN(parallelization)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_PARALLELIZATION, \"A valid \\\"hash.parallelization\\\" number must be provided for \" +\n                        (\"hash algorithm \" + options.hash.algorithm + \".\"));\n                }\n                var blockSize = getNumberField(options.hash, 'blockSize');\n                if (isNaN(blockSize)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_BLOCK_SIZE, \"A valid \\\"hash.blockSize\\\" number must be provided for \" +\n                        (\"hash algorithm \" + options.hash.algorithm + \".\"));\n                }\n                var dkLen = getNumberField(options.hash, 'derivedKeyLength');\n                if (isNaN(dkLen)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_DERIVED_KEY_LENGTH, \"A valid \\\"hash.derivedKeyLength\\\" number must be provided for \" +\n                        (\"hash algorithm \" + options.hash.algorithm + \".\"));\n                }\n                populatedOptions = {\n                    hashAlgorithm: options.hash.algorithm,\n                    cpuMemCost: cpuMemCost,\n                    parallelization: parallelization,\n                    blockSize: blockSize,\n                    dkLen: dkLen,\n                };\n                break;\n            }\n            default:\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ALGORITHM, \"Unsupported hash algorithm provider \\\"\" + options.hash.algorithm + \"\\\".\");\n        }\n        return populatedOptions;\n    };\n    /**\n     * Validates and returns the users list of the uploadAccount request.\n     * Whenever a user with an error is detected, the error is cached and will later be\n     * merged into the user import result. This allows the processing of valid users without\n     * failing early on the first error detected.\n     * @param {UserImportRecord[]} users The UserImportRecords to convert to UnploadAccountUser\n     *     objects.\n     * @param {ValidatorFunction=} userValidator The user validator function.\n     * @return {UploadAccountUser[]} The populated uploadAccount users.\n     */\n    UserImportBuilder.prototype.populateUsers = function (users, userValidator) {\n        var _this = this;\n        var populatedUsers = [];\n        users.forEach(function (user, index) {\n            try {\n                var result = populateUploadAccountUser(user, userValidator);\n                if (typeof result.passwordHash !== 'undefined') {\n                    _this.requiresHashOptions = true;\n                }\n                // Only users that pass client screening will be passed to backend for processing.\n                populatedUsers.push(result);\n                // Map user's index (the one to be sent to backend) to original developer provided array.\n                _this.indexMap[populatedUsers.length - 1] = index;\n            }\n            catch (error) {\n                // Save the client side error with respect to the developer provided array.\n                _this.userImportResultErrors.push({\n                    index: index,\n                    error: error,\n                });\n            }\n        });\n        return populatedUsers;\n    };\n    return UserImportBuilder;\n}());\nexports.UserImportBuilder = UserImportBuilder;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/auth/user-import-builder.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/auth/user-record.js":
/*!*****************************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/auth/user-record.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\n/*!\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar deep_copy_1 = __webpack_require__(/*! ../utils/deep-copy */ \"./src/node_modules/firebase-admin/lib/utils/deep-copy.js\");\nvar validator_1 = __webpack_require__(/*! ../utils/validator */ \"./src/node_modules/firebase-admin/lib/utils/validator.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"./src/node_modules/firebase-admin/lib/utils/index.js\");\nvar error_1 = __webpack_require__(/*! ../utils/error */ \"./src/node_modules/firebase-admin/lib/utils/error.js\");\n/**\n * 'REDACTED', encoded as a base64 string.\n */\nvar B64_REDACTED = Buffer.from('REDACTED').toString('base64');\n/**\n * Parses a time stamp string or number and returns the corresponding date if valid.\n *\n * @param {any} time The unix timestamp string or number in milliseconds.\n * @return {string} The corresponding date as a UTC string, if valid. Otherwise, null.\n */\nfunction parseDate(time) {\n    try {\n        var date = new Date(parseInt(time, 10));\n        if (!isNaN(date.getTime())) {\n            return date.toUTCString();\n        }\n    }\n    catch (e) {\n        // Do nothing. null will be returned.\n    }\n    return null;\n}\n/** Enums for multi-factor identifiers. */\nvar MultiFactorId;\n(function (MultiFactorId) {\n    MultiFactorId[\"Phone\"] = \"phone\";\n})(MultiFactorId = exports.MultiFactorId || (exports.MultiFactorId = {}));\n/**\n * Abstract class representing a multi-factor info interface.\n */\nvar MultiFactorInfo = /** @class */ (function () {\n    /**\n     * Initializes the MultiFactorInfo object using the server side response.\n     *\n     * @param response The server side response.\n     * @constructor\n     */\n    function MultiFactorInfo(response) {\n        this.initFromServerResponse(response);\n    }\n    /**\n     * Initializes the MultiFactorInfo associated subclass using the server side.\n     * If no MultiFactorInfo is associated with the response, null is returned.\n     *\n     * @param response The server side response.\n     * @constructor\n     */\n    MultiFactorInfo.initMultiFactorInfo = function (response) {\n        var multiFactorInfo = null;\n        // Only PhoneMultiFactorInfo currently available.\n        try {\n            multiFactorInfo = new PhoneMultiFactorInfo(response);\n        }\n        catch (e) {\n            // Ignore error.\n        }\n        return multiFactorInfo;\n    };\n    /** @return The plain object representation. */\n    MultiFactorInfo.prototype.toJSON = function () {\n        return {\n            uid: this.uid,\n            displayName: this.displayName,\n            factorId: this.factorId,\n            enrollmentTime: this.enrollmentTime,\n        };\n    };\n    /**\n     * Initializes the MultiFactorInfo object using the provided server response.\n     *\n     * @param response The server side response.\n     */\n    MultiFactorInfo.prototype.initFromServerResponse = function (response) {\n        var factorId = response && this.getFactorId(response);\n        if (!factorId || !response || !response.mfaEnrollmentId) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid multi-factor info response');\n        }\n        utils.addReadonlyGetter(this, 'uid', response.mfaEnrollmentId);\n        utils.addReadonlyGetter(this, 'factorId', factorId);\n        utils.addReadonlyGetter(this, 'displayName', response.displayName || null);\n        // Encoded using [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format.\n        // For example, \"2017-01-15T01:30:15.01Z\".\n        // This can be parsed directly via Date constructor.\n        // This can be computed using Data.prototype.toISOString.\n        if (response.enrolledAt) {\n            utils.addReadonlyGetter(this, 'enrollmentTime', new Date(response.enrolledAt).toUTCString());\n        }\n        else {\n            utils.addReadonlyGetter(this, 'enrollmentTime', null);\n        }\n    };\n    return MultiFactorInfo;\n}());\nexports.MultiFactorInfo = MultiFactorInfo;\n/** Class representing a phone MultiFactorInfo object. */\nvar PhoneMultiFactorInfo = /** @class */ (function (_super) {\n    __extends(PhoneMultiFactorInfo, _super);\n    /**\n     * Initializes the PhoneMultiFactorInfo object using the server side response.\n     *\n     * @param response The server side response.\n     * @constructor\n     */\n    function PhoneMultiFactorInfo(response) {\n        var _this = _super.call(this, response) || this;\n        utils.addReadonlyGetter(_this, 'phoneNumber', response.phoneInfo);\n        return _this;\n    }\n    /** @return The plain object representation. */\n    PhoneMultiFactorInfo.prototype.toJSON = function () {\n        return Object.assign(_super.prototype.toJSON.call(this), {\n            phoneNumber: this.phoneNumber,\n        });\n    };\n    /**\n     * Returns the factor ID based on the response provided.\n     *\n     * @param response The server side response.\n     * @return The multi-factor ID associated with the provided response. If the response is\n     *     not associated with any known multi-factor ID, null is returned.\n     */\n    PhoneMultiFactorInfo.prototype.getFactorId = function (response) {\n        return (response && response.phoneInfo) ? MultiFactorId.Phone : null;\n    };\n    return PhoneMultiFactorInfo;\n}(MultiFactorInfo));\nexports.PhoneMultiFactorInfo = PhoneMultiFactorInfo;\n/** Class representing multi-factor related properties of a user. */\nvar MultiFactor = /** @class */ (function () {\n    /**\n     * Initializes the MultiFactor object using the server side or JWT format response.\n     *\n     * @param response The server side response.\n     * @constructor\n     */\n    function MultiFactor(response) {\n        var parsedEnrolledFactors = [];\n        if (!validator_1.isNonNullObject(response)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid multi-factor response');\n        }\n        else if (response.mfaInfo) {\n            response.mfaInfo.forEach(function (factorResponse) {\n                var multiFactorInfo = MultiFactorInfo.initMultiFactorInfo(factorResponse);\n                if (multiFactorInfo) {\n                    parsedEnrolledFactors.push(multiFactorInfo);\n                }\n            });\n        }\n        // Make enrolled factors immutable.\n        utils.addReadonlyGetter(this, 'enrolledFactors', Object.freeze(parsedEnrolledFactors));\n    }\n    /** @return The plain object representation. */\n    MultiFactor.prototype.toJSON = function () {\n        return {\n            enrolledFactors: this.enrolledFactors.map(function (info) { return info.toJSON(); }),\n        };\n    };\n    return MultiFactor;\n}());\nexports.MultiFactor = MultiFactor;\n/**\n * User metadata class that provides metadata information like user account creation\n * and last sign in time.\n *\n * @param response The server side response returned from the getAccountInfo\n *     endpoint.\n * @constructor\n */\nvar UserMetadata = /** @class */ (function () {\n    function UserMetadata(response) {\n        // Creation date should always be available but due to some backend bugs there\n        // were cases in the past where users did not have creation date properly set.\n        // This included legacy Firebase migrating project users and some anonymous users.\n        // These bugs have already been addressed since then.\n        utils.addReadonlyGetter(this, 'creationTime', parseDate(response.createdAt));\n        utils.addReadonlyGetter(this, 'lastSignInTime', parseDate(response.lastLoginAt));\n        var lastRefreshAt = response.lastRefreshAt ? new Date(response.lastRefreshAt).toUTCString() : null;\n        utils.addReadonlyGetter(this, 'lastRefreshTime', lastRefreshAt);\n    }\n    /** @return The plain object representation of the user's metadata. */\n    UserMetadata.prototype.toJSON = function () {\n        return {\n            lastSignInTime: this.lastSignInTime,\n            creationTime: this.creationTime,\n        };\n    };\n    return UserMetadata;\n}());\nexports.UserMetadata = UserMetadata;\n/**\n * User info class that provides provider user information for different\n * Firebase providers like google.com, facebook.com, password, etc.\n *\n * @param response The server side response returned from the getAccountInfo\n *     endpoint.\n * @constructor\n */\nvar UserInfo = /** @class */ (function () {\n    function UserInfo(response) {\n        // Provider user id and provider id are required.\n        if (!response.rawId || !response.providerId) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid user info response');\n        }\n        utils.addReadonlyGetter(this, 'uid', response.rawId);\n        utils.addReadonlyGetter(this, 'displayName', response.displayName);\n        utils.addReadonlyGetter(this, 'email', response.email);\n        utils.addReadonlyGetter(this, 'photoURL', response.photoUrl);\n        utils.addReadonlyGetter(this, 'providerId', response.providerId);\n        utils.addReadonlyGetter(this, 'phoneNumber', response.phoneNumber);\n    }\n    /** @return The plain object representation of the current provider data. */\n    UserInfo.prototype.toJSON = function () {\n        return {\n            uid: this.uid,\n            displayName: this.displayName,\n            email: this.email,\n            photoURL: this.photoURL,\n            providerId: this.providerId,\n            phoneNumber: this.phoneNumber,\n        };\n    };\n    return UserInfo;\n}());\nexports.UserInfo = UserInfo;\n/**\n * User record class that defines the Firebase user object populated from\n * the Firebase Auth getAccountInfo response.\n *\n * @param response The server side response returned from the getAccountInfo\n *     endpoint.\n * @constructor\n */\nvar UserRecord = /** @class */ (function () {\n    function UserRecord(response) {\n        // The Firebase user id is required.\n        if (!response.localId) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid user response');\n        }\n        utils.addReadonlyGetter(this, 'uid', response.localId);\n        utils.addReadonlyGetter(this, 'email', response.email);\n        utils.addReadonlyGetter(this, 'emailVerified', !!response.emailVerified);\n        utils.addReadonlyGetter(this, 'displayName', response.displayName);\n        utils.addReadonlyGetter(this, 'photoURL', response.photoUrl);\n        utils.addReadonlyGetter(this, 'phoneNumber', response.phoneNumber);\n        // If disabled is not provided, the account is enabled by default.\n        utils.addReadonlyGetter(this, 'disabled', response.disabled || false);\n        utils.addReadonlyGetter(this, 'metadata', new UserMetadata(response));\n        var providerData = [];\n        for (var _i = 0, _a = (response.providerUserInfo || []); _i < _a.length; _i++) {\n            var entry = _a[_i];\n            providerData.push(new UserInfo(entry));\n        }\n        utils.addReadonlyGetter(this, 'providerData', providerData);\n        // If the password hash is redacted (probably due to missing permissions)\n        // then clear it out, similar to how the salt is returned. (Otherwise, it\n        // *looks* like a b64-encoded hash is present, which is confusing.)\n        if (response.passwordHash === B64_REDACTED) {\n            utils.addReadonlyGetter(this, 'passwordHash', undefined);\n        }\n        else {\n            utils.addReadonlyGetter(this, 'passwordHash', response.passwordHash);\n        }\n        utils.addReadonlyGetter(this, 'passwordSalt', response.salt);\n        if (response.customAttributes) {\n            utils.addReadonlyGetter(this, 'customClaims', JSON.parse(response.customAttributes));\n        }\n        var validAfterTime = null;\n        // Convert validSince first to UTC milliseconds and then to UTC date string.\n        if (typeof response.validSince !== 'undefined') {\n            validAfterTime = parseDate(parseInt(response.validSince, 10) * 1000);\n        }\n        utils.addReadonlyGetter(this, 'tokensValidAfterTime', validAfterTime || undefined);\n        utils.addReadonlyGetter(this, 'tenantId', response.tenantId);\n        var multiFactor = new MultiFactor(response);\n        if (multiFactor.enrolledFactors.length > 0) {\n            utils.addReadonlyGetter(this, 'multiFactor', multiFactor);\n        }\n    }\n    /** @return The plain object representation of the user record. */\n    UserRecord.prototype.toJSON = function () {\n        var json = {\n            uid: this.uid,\n            email: this.email,\n            emailVerified: this.emailVerified,\n            displayName: this.displayName,\n            photoURL: this.photoURL,\n            phoneNumber: this.phoneNumber,\n            disabled: this.disabled,\n            // Convert metadata to json.\n            metadata: this.metadata.toJSON(),\n            passwordHash: this.passwordHash,\n            passwordSalt: this.passwordSalt,\n            customClaims: deep_copy_1.deepCopy(this.customClaims),\n            tokensValidAfterTime: this.tokensValidAfterTime,\n            tenantId: this.tenantId,\n        };\n        if (this.multiFactor) {\n            json.multiFactor = this.multiFactor.toJSON();\n        }\n        json.providerData = [];\n        for (var _i = 0, _a = this.providerData; _i < _a.length; _i++) {\n            var entry = _a[_i];\n            // Convert each provider data to json.\n            json.providerData.push(entry.toJSON());\n        }\n        return json;\n    };\n    return UserRecord;\n}());\nexports.UserRecord = UserRecord;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/auth/user-record.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/database/database.js":
/*!******************************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/database/database.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar url_1 = __webpack_require__(/*! url */ \"url\");\nvar path = __webpack_require__(/*! path */ \"path\");\nvar error_1 = __webpack_require__(/*! ../utils/error */ \"./src/node_modules/firebase-admin/lib/utils/error.js\");\nvar validator = __webpack_require__(/*! ../utils/validator */ \"./src/node_modules/firebase-admin/lib/utils/validator.js\");\nvar api_request_1 = __webpack_require__(/*! ../utils/api-request */ \"./src/node_modules/firebase-admin/lib/utils/api-request.js\");\n/**\n * Internals of a Database instance.\n */\nvar DatabaseInternals = /** @class */ (function () {\n    function DatabaseInternals() {\n        this.databases = {};\n    }\n    /**\n     * Deletes the service and its associated resources.\n     *\n     * @return {Promise<()>} An empty Promise that will be fulfilled when the service is deleted.\n     */\n    DatabaseInternals.prototype.delete = function () {\n        for (var _i = 0, _a = Object.keys(this.databases); _i < _a.length; _i++) {\n            var dbUrl = _a[_i];\n            var db = this.databases[dbUrl];\n            db.INTERNAL.delete();\n        }\n        return Promise.resolve(undefined);\n    };\n    return DatabaseInternals;\n}());\nvar DatabaseService = /** @class */ (function () {\n    function DatabaseService(app) {\n        this.INTERNAL = new DatabaseInternals();\n        if (!validator.isNonNullObject(app) || !('options' in app)) {\n            throw new error_1.FirebaseDatabaseError({\n                code: 'invalid-argument',\n                message: 'First argument passed to admin.database() must be a valid Firebase app instance.',\n            });\n        }\n        this.appInternal = app;\n    }\n    Object.defineProperty(DatabaseService.prototype, \"app\", {\n        /**\n         * Returns the app associated with this DatabaseService instance.\n         *\n         * @return {FirebaseApp} The app associated with this DatabaseService instance.\n         */\n        get: function () {\n            return this.appInternal;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    DatabaseService.prototype.getDatabase = function (url) {\n        var dbUrl = this.ensureUrl(url);\n        if (!validator.isNonEmptyString(dbUrl)) {\n            throw new error_1.FirebaseDatabaseError({\n                code: 'invalid-argument',\n                message: 'Database URL must be a valid, non-empty URL string.',\n            });\n        }\n        var db = this.INTERNAL.databases[dbUrl];\n        if (typeof db === 'undefined') {\n            var rtdb = __webpack_require__(/*! @firebase/database */ \"./src/node_modules/@firebase/database/dist/index.esm.js\"); // eslint-disable-line @typescript-eslint/no-var-requires\n            var version = __webpack_require__(/*! ../../package.json */ \"./src/node_modules/firebase-admin/package.json\").version; // eslint-disable-line @typescript-eslint/no-var-requires\n            db = rtdb.initStandalone(this.appInternal, dbUrl, version).instance;\n            var rulesClient_1 = new DatabaseRulesClient(this.app, dbUrl);\n            db.getRules = function () {\n                return rulesClient_1.getRules();\n            };\n            db.getRulesJSON = function () {\n                return rulesClient_1.getRulesJSON();\n            };\n            db.setRules = function (source) {\n                return rulesClient_1.setRules(source);\n            };\n            this.INTERNAL.databases[dbUrl] = db;\n        }\n        return db;\n    };\n    DatabaseService.prototype.ensureUrl = function (url) {\n        if (typeof url !== 'undefined') {\n            return url;\n        }\n        else if (typeof this.appInternal.options.databaseURL !== 'undefined') {\n            return this.appInternal.options.databaseURL;\n        }\n        throw new error_1.FirebaseDatabaseError({\n            code: 'invalid-argument',\n            message: 'Can\\'t determine Firebase Database URL.',\n        });\n    };\n    return DatabaseService;\n}());\nexports.DatabaseService = DatabaseService;\nvar RULES_URL_PATH = '.settings/rules.json';\n/**\n * A helper client for managing RTDB security rules.\n */\nvar DatabaseRulesClient = /** @class */ (function () {\n    function DatabaseRulesClient(app, dbUrl) {\n        var parsedUrl = new url_1.URL(dbUrl);\n        parsedUrl.pathname = path.join(parsedUrl.pathname, RULES_URL_PATH);\n        this.dbUrl = parsedUrl.toString();\n        this.httpClient = new api_request_1.AuthorizedHttpClient(app);\n    }\n    /**\n     * Gets the currently applied security rules as a string. The return value consists of\n     * the rules source including comments.\n     *\n     * @return {Promise<string>} A promise fulfilled with the rules as a raw string.\n     */\n    DatabaseRulesClient.prototype.getRules = function () {\n        var _this = this;\n        var req = {\n            method: 'GET',\n            url: this.dbUrl,\n        };\n        return this.httpClient.send(req)\n            .then(function (resp) {\n            if (!resp.text) {\n                throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, 'HTTP response missing data.');\n            }\n            return resp.text;\n        })\n            .catch(function (err) {\n            throw _this.handleError(err);\n        });\n    };\n    /**\n     * Gets the currently applied security rules as a parsed JSON object. Any comments in\n     * the original source are stripped away.\n     *\n     * @return {Promise<object>} A promise fulfilled with the parsed rules source.\n     */\n    DatabaseRulesClient.prototype.getRulesJSON = function () {\n        var _this = this;\n        var req = {\n            method: 'GET',\n            url: this.dbUrl,\n            data: { format: 'strict' },\n        };\n        return this.httpClient.send(req)\n            .then(function (resp) {\n            return resp.data;\n        })\n            .catch(function (err) {\n            throw _this.handleError(err);\n        });\n    };\n    /**\n     * Sets the specified rules on the Firebase Database instance. If the rules source is\n     * specified as a string or a Buffer, it may include comments.\n     *\n     * @param {string|Buffer|object} source Source of the rules to apply. Must not be `null`\n     *  or empty.\n     * @return {Promise<void>} Resolves when the rules are set on the Database.\n     */\n    DatabaseRulesClient.prototype.setRules = function (source) {\n        var _this = this;\n        if (!validator.isNonEmptyString(source) &&\n            !validator.isBuffer(source) &&\n            !validator.isNonNullObject(source)) {\n            var error = new error_1.FirebaseDatabaseError({\n                code: 'invalid-argument',\n                message: 'Source must be a non-empty string, Buffer or an object.',\n            });\n            return Promise.reject(error);\n        }\n        var req = {\n            method: 'PUT',\n            url: this.dbUrl,\n            data: source,\n            headers: {\n                'content-type': 'application/json; charset=utf-8',\n            },\n        };\n        return this.httpClient.send(req)\n            .then(function () {\n            return;\n        })\n            .catch(function (err) {\n            throw _this.handleError(err);\n        });\n    };\n    DatabaseRulesClient.prototype.handleError = function (err) {\n        if (err instanceof api_request_1.HttpError) {\n            return new error_1.FirebaseDatabaseError({\n                code: error_1.AppErrorCodes.INTERNAL_ERROR,\n                message: this.getErrorMessage(err),\n            });\n        }\n        return err;\n    };\n    DatabaseRulesClient.prototype.getErrorMessage = function (err) {\n        var intro = 'Error while accessing security rules';\n        try {\n            var body = err.response.data;\n            if (body && body.error) {\n                return intro + \": \" + body.error.trim();\n            }\n        }\n        catch (_a) {\n            // Ignore parsing errors\n        }\n        return intro + \": \" + err.response.text;\n    };\n    return DatabaseRulesClient;\n}());\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/database/database.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/default-namespace.js":
/*!******************************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/default-namespace.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\n/*!\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar firebase_namespace_1 = __webpack_require__(/*! ./firebase-namespace */ \"./src/node_modules/firebase-admin/lib/firebase-namespace.js\");\nvar firebaseAdmin = new firebase_namespace_1.FirebaseNamespace();\n// Inject a circular default export to allow users to use both:\n//\n//   import firebaseAdmin from 'firebase-admin';\n//   which becomes: var firebaseAdmin = require('firebase-admin').default;\n//\n// as well as the more correct:\n//\n//   import * as firebaseAdmin from 'firebase-admin';\n//   which becomes: var firebaseAdmin = require('firebase-admin');\nfirebaseAdmin.default = firebaseAdmin;\nmodule.exports = firebaseAdmin;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/default-namespace.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/firebase-app.js":
/*!*************************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/firebase-app.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\n/*!\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar credential_1 = __webpack_require__(/*! ./auth/credential */ \"./src/node_modules/firebase-admin/lib/auth/credential.js\");\nvar validator = __webpack_require__(/*! ./utils/validator */ \"./src/node_modules/firebase-admin/lib/utils/validator.js\");\nvar deep_copy_1 = __webpack_require__(/*! ./utils/deep-copy */ \"./src/node_modules/firebase-admin/lib/utils/deep-copy.js\");\nvar error_1 = __webpack_require__(/*! ./utils/error */ \"./src/node_modules/firebase-admin/lib/utils/error.js\");\n/**\n * Internals of a FirebaseApp instance.\n */\nvar FirebaseAppInternals = /** @class */ (function () {\n    function FirebaseAppInternals(credential_) {\n        this.credential_ = credential_;\n        this.isDeleted_ = false;\n        this.tokenListeners_ = [];\n    }\n    /**\n     * Gets an auth token for the associated app.\n     *\n     * @param {boolean} forceRefresh Whether or not to force a token refresh.\n     * @return {Promise<FirebaseAccessToken>} A Promise that will be fulfilled with the current or\n     *   new token.\n     */\n    FirebaseAppInternals.prototype.getToken = function (forceRefresh) {\n        var _this = this;\n        var expired = this.cachedToken_ && this.cachedToken_.expirationTime < Date.now();\n        if (this.cachedTokenPromise_ && !forceRefresh && !expired) {\n            return this.cachedTokenPromise_\n                .catch(function (error) {\n                // Update the cached token promise to avoid caching errors. Set it to resolve with the\n                // cached token if we have one (and return that promise since the token has still not\n                // expired).\n                if (_this.cachedToken_) {\n                    _this.cachedTokenPromise_ = Promise.resolve(_this.cachedToken_);\n                    return _this.cachedTokenPromise_;\n                }\n                // Otherwise, set the cached token promise to null so that it will force a refresh next\n                // time getToken() is called.\n                _this.cachedTokenPromise_ = null;\n                // And re-throw the caught error.\n                throw error;\n            });\n        }\n        else {\n            // Clear the outstanding token refresh timeout. This is a noop if the timeout is undefined.\n            clearTimeout(this.tokenRefreshTimeout_);\n            // this.credential_ may be an external class; resolving it in a promise helps us\n            // protect against exceptions and upgrades the result to a promise in all cases.\n            this.cachedTokenPromise_ = Promise.resolve(this.credential_.getAccessToken())\n                .then(function (result) {\n                // Since the developer can provide the credential implementation, we want to weakly verify\n                // the return type until the type is properly exported.\n                if (!validator.isNonNullObject(result) ||\n                    typeof result.expires_in !== 'number' ||\n                    typeof result.access_token !== 'string') {\n                    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, \"Invalid access token generated: \\\"\" + JSON.stringify(result) + \"\\\". Valid access \" +\n                        'tokens must be an object with the \"expires_in\" (number) and \"access_token\" ' +\n                        '(string) properties.');\n                }\n                var token = {\n                    accessToken: result.access_token,\n                    expirationTime: Date.now() + (result.expires_in * 1000),\n                };\n                var hasAccessTokenChanged = (_this.cachedToken_ && _this.cachedToken_.accessToken !== token.accessToken);\n                var hasExpirationChanged = (_this.cachedToken_ && _this.cachedToken_.expirationTime !== token.expirationTime);\n                if (!_this.cachedToken_ || hasAccessTokenChanged || hasExpirationChanged) {\n                    _this.cachedToken_ = token;\n                    _this.tokenListeners_.forEach(function (listener) {\n                        listener(token.accessToken);\n                    });\n                }\n                // Establish a timeout to proactively refresh the token every minute starting at five\n                // minutes before it expires. Once a token refresh succeeds, no further retries are\n                // needed; if it fails, retry every minute until the token expires (resulting in a total\n                // of four retries: at 4, 3, 2, and 1 minutes).\n                var refreshTimeInSeconds = (result.expires_in - (5 * 60));\n                var numRetries = 4;\n                // In the rare cases the token is short-lived (that is, it expires in less than five\n                // minutes from when it was fetched), establish the timeout to refresh it after the\n                // current minute ends and update the number of retries that should be attempted before\n                // the token expires.\n                if (refreshTimeInSeconds <= 0) {\n                    refreshTimeInSeconds = result.expires_in % 60;\n                    numRetries = Math.floor(result.expires_in / 60) - 1;\n                }\n                // The token refresh timeout keeps the Node.js process alive, so only create it if this\n                // instance has not already been deleted.\n                if (numRetries && !_this.isDeleted_) {\n                    _this.setTokenRefreshTimeout(refreshTimeInSeconds * 1000, numRetries);\n                }\n                return token;\n            })\n                .catch(function (error) {\n                var errorMessage = (typeof error === 'string') ? error : error.message;\n                errorMessage = 'Credential implementation provided to initializeApp() via the ' +\n                    '\"credential\" property failed to fetch a valid Google OAuth2 access token with the ' +\n                    (\"following error: \\\"\" + errorMessage + \"\\\".\");\n                if (errorMessage.indexOf('invalid_grant') !== -1) {\n                    errorMessage += ' There are two likely causes: (1) your server time is not properly ' +\n                        'synced or (2) your certificate key file has been revoked. To solve (1), re-sync the ' +\n                        'time on your server. To solve (2), make sure the key ID for your key file is still ' +\n                        'present at https://console.firebase.google.com/iam-admin/serviceaccounts/project. If ' +\n                        'not, generate a new key file at ' +\n                        'https://console.firebase.google.com/project/_/settings/serviceaccounts/adminsdk.';\n                }\n                throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);\n            });\n            return this.cachedTokenPromise_;\n        }\n    };\n    /**\n     * Adds a listener that is called each time a token changes.\n     *\n     * @param {function(string)} listener The listener that will be called with each new token.\n     */\n    FirebaseAppInternals.prototype.addAuthTokenListener = function (listener) {\n        this.tokenListeners_.push(listener);\n        if (this.cachedToken_) {\n            listener(this.cachedToken_.accessToken);\n        }\n    };\n    /**\n     * Removes a token listener.\n     *\n     * @param {function(string)} listener The listener to remove.\n     */\n    FirebaseAppInternals.prototype.removeAuthTokenListener = function (listener) {\n        this.tokenListeners_ = this.tokenListeners_.filter(function (other) { return other !== listener; });\n    };\n    /**\n     * Deletes the FirebaseAppInternals instance.\n     */\n    FirebaseAppInternals.prototype.delete = function () {\n        this.isDeleted_ = true;\n        // Clear the token refresh timeout so it doesn't keep the Node.js process alive.\n        clearTimeout(this.tokenRefreshTimeout_);\n    };\n    /**\n     * Establishes timeout to refresh the Google OAuth2 access token used by the SDK.\n     *\n     * @param {number} delayInMilliseconds The delay to use for the timeout.\n     * @param {number} numRetries The number of times to retry fetching a new token if the prior fetch\n     *   failed.\n     */\n    FirebaseAppInternals.prototype.setTokenRefreshTimeout = function (delayInMilliseconds, numRetries) {\n        var _this = this;\n        this.tokenRefreshTimeout_ = setTimeout(function () {\n            _this.getToken(/* forceRefresh */ true)\n                .catch(function () {\n                // Ignore the error since this might just be an intermittent failure. If we really cannot\n                // refresh the token, an error will be logged once the existing token expires and we try\n                // to fetch a fresh one.\n                if (numRetries > 0) {\n                    _this.setTokenRefreshTimeout(60 * 1000, numRetries - 1);\n                }\n            });\n        }, delayInMilliseconds);\n    };\n    return FirebaseAppInternals;\n}());\nexports.FirebaseAppInternals = FirebaseAppInternals;\n/**\n * Global context object for a collection of services using a shared authentication state.\n */\nvar FirebaseApp = /** @class */ (function () {\n    function FirebaseApp(options, name, firebaseInternals_) {\n        var _this = this;\n        this.firebaseInternals_ = firebaseInternals_;\n        this.services_ = {};\n        this.isDeleted_ = false;\n        this.name_ = name;\n        this.options_ = deep_copy_1.deepCopy(options);\n        if (!validator.isNonNullObject(this.options_)) {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_OPTIONS, \"Invalid Firebase app options passed as the first argument to initializeApp() for the \" +\n                (\"app named \\\"\" + this.name_ + \"\\\". Options must be a non-null object.\"));\n        }\n        var hasCredential = ('credential' in this.options_);\n        if (!hasCredential) {\n            this.options_.credential = credential_1.getApplicationDefault(this.options_.httpAgent);\n        }\n        var credential = this.options_.credential;\n        if (typeof credential !== 'object' || credential === null || typeof credential.getAccessToken !== 'function') {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_OPTIONS, \"Invalid Firebase app options passed as the first argument to initializeApp() for the \" +\n                (\"app named \\\"\" + this.name_ + \"\\\". The \\\"credential\\\" property must be an object which implements \") +\n                \"the Credential interface.\");\n        }\n        Object.keys(firebaseInternals_.serviceFactories).forEach(function (serviceName) {\n            // Defer calling createService() until the service is accessed\n            _this[serviceName] = _this.getService_.bind(_this, serviceName);\n        });\n        this.INTERNAL = new FirebaseAppInternals(credential);\n    }\n    /**\n     * Returns the Auth service instance associated with this app.\n     *\n     * @return {Auth} The Auth service instance of this app.\n     */\n    FirebaseApp.prototype.auth = function () {\n        var _this = this;\n        return this.ensureService_('auth', function () {\n            var authService = __webpack_require__(/*! ./auth/auth */ \"./src/node_modules/firebase-admin/lib/auth/auth.js\").Auth;\n            return new authService(_this);\n        });\n    };\n    /**\n     * Returns the Database service for the specified URL, and the current app.\n     *\n     * @return {Database} The Database service instance of this app.\n     */\n    FirebaseApp.prototype.database = function (url) {\n        var _this = this;\n        var service = this.ensureService_('database', function () {\n            var dbService = __webpack_require__(/*! ./database/database */ \"./src/node_modules/firebase-admin/lib/database/database.js\").DatabaseService;\n            return new dbService(_this);\n        });\n        return service.getDatabase(url);\n    };\n    /**\n     * Returns the Messaging service instance associated with this app.\n     *\n     * @return {Messaging} The Messaging service instance of this app.\n     */\n    FirebaseApp.prototype.messaging = function () {\n        var _this = this;\n        return this.ensureService_('messaging', function () {\n            var messagingService = __webpack_require__(/*! ./messaging/messaging */ \"./src/node_modules/firebase-admin/lib/messaging/messaging.js\").Messaging;\n            return new messagingService(_this);\n        });\n    };\n    /**\n     * Returns the Storage service instance associated with this app.\n     *\n     * @return {Storage} The Storage service instance of this app.\n     */\n    FirebaseApp.prototype.storage = function () {\n        var _this = this;\n        return this.ensureService_('storage', function () {\n            var storageService = __webpack_require__(/*! ./storage/storage */ \"./src/node_modules/firebase-admin/lib/storage/storage.js\").Storage;\n            return new storageService(_this);\n        });\n    };\n    FirebaseApp.prototype.firestore = function () {\n        var _this = this;\n        var service = this.ensureService_('firestore', function () {\n            var firestoreService = __webpack_require__(/*! ./firestore/firestore */ \"./src/node_modules/firebase-admin/lib/firestore/firestore.js\").FirestoreService;\n            return new firestoreService(_this);\n        });\n        return service.client;\n    };\n    /**\n     * Returns the InstanceId service instance associated with this app.\n     *\n     * @return {InstanceId} The InstanceId service instance of this app.\n     */\n    FirebaseApp.prototype.instanceId = function () {\n        var _this = this;\n        return this.ensureService_('iid', function () {\n            var iidService = __webpack_require__(/*! ./instance-id/instance-id */ \"./src/node_modules/firebase-admin/lib/instance-id/instance-id.js\").InstanceId;\n            return new iidService(_this);\n        });\n    };\n    /**\n     * Returns the MachineLearning service instance associated with this app.\n     *\n     * @return {MachineLearning} The Machine Learning service instance of this app\n     */\n    FirebaseApp.prototype.machineLearning = function () {\n        var _this = this;\n        return this.ensureService_('machine-learning', function () {\n            var machineLearningService = __webpack_require__(/*! ./machine-learning/machine-learning */ \"./src/node_modules/firebase-admin/lib/machine-learning/machine-learning.js\").MachineLearning;\n            return new machineLearningService(_this);\n        });\n    };\n    /**\n     * Returns the ProjectManagement service instance associated with this app.\n     *\n     * @return {ProjectManagement} The ProjectManagement service instance of this app.\n     */\n    FirebaseApp.prototype.projectManagement = function () {\n        var _this = this;\n        return this.ensureService_('project-management', function () {\n            var projectManagementService = __webpack_require__(/*! ./project-management/project-management */ \"./src/node_modules/firebase-admin/lib/project-management/project-management.js\").ProjectManagement;\n            return new projectManagementService(_this);\n        });\n    };\n    /**\n     * Returns the SecurityRules service instance associated with this app.\n     *\n     * @return {SecurityRules} The SecurityRules service instance of this app.\n     */\n    FirebaseApp.prototype.securityRules = function () {\n        var _this = this;\n        return this.ensureService_('security-rules', function () {\n            var securityRulesService = __webpack_require__(/*! ./security-rules/security-rules */ \"./src/node_modules/firebase-admin/lib/security-rules/security-rules.js\").SecurityRules;\n            return new securityRulesService(_this);\n        });\n    };\n    /**\n     * Returns the RemoteConfig service instance associated with this app.\n     *\n     * @return {RemoteConfig} The RemoteConfig service instance of this app.\n     */\n    FirebaseApp.prototype.remoteConfig = function () {\n        var _this = this;\n        return this.ensureService_('remoteConfig', function () {\n            var remoteConfigService = __webpack_require__(/*! ./remote-config/remote-config */ \"./src/node_modules/firebase-admin/lib/remote-config/remote-config.js\").RemoteConfig;\n            return new remoteConfigService(_this);\n        });\n    };\n    Object.defineProperty(FirebaseApp.prototype, \"name\", {\n        /**\n         * Returns the name of the FirebaseApp instance.\n         *\n         * @return {string} The name of the FirebaseApp instance.\n         */\n        get: function () {\n            this.checkDestroyed_();\n            return this.name_;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FirebaseApp.prototype, \"options\", {\n        /**\n         * Returns the options for the FirebaseApp instance.\n         *\n         * @return {FirebaseAppOptions} The options for the FirebaseApp instance.\n         */\n        get: function () {\n            this.checkDestroyed_();\n            return deep_copy_1.deepCopy(this.options_);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Deletes the FirebaseApp instance.\n     *\n     * @return {Promise<void>} An empty Promise fulfilled once the FirebaseApp instance is deleted.\n     */\n    FirebaseApp.prototype.delete = function () {\n        var _this = this;\n        this.checkDestroyed_();\n        this.firebaseInternals_.removeApp(this.name_);\n        this.INTERNAL.delete();\n        return Promise.all(Object.keys(this.services_).map(function (serviceName) {\n            return _this.services_[serviceName].INTERNAL.delete();\n        })).then(function () {\n            _this.services_ = {};\n            _this.isDeleted_ = true;\n        });\n    };\n    FirebaseApp.prototype.ensureService_ = function (serviceName, initializer) {\n        this.checkDestroyed_();\n        var service;\n        if (serviceName in this.services_) {\n            service = this.services_[serviceName];\n        }\n        else {\n            service = initializer();\n            this.services_[serviceName] = service;\n        }\n        return service;\n    };\n    /**\n     * Returns the service instance associated with this FirebaseApp instance (creating it on demand\n     * if needed). This is used for looking up monkeypatched service instances.\n     *\n     * @param {string} serviceName The name of the service instance to return.\n     * @return {FirebaseServiceInterface} The service instance with the provided name.\n     */\n    FirebaseApp.prototype.getService_ = function (serviceName) {\n        this.checkDestroyed_();\n        if (!(serviceName in this.services_)) {\n            this.services_[serviceName] = this.firebaseInternals_.serviceFactories[serviceName](this, this.extendApp_.bind(this));\n        }\n        return this.services_[serviceName];\n    };\n    /**\n     * Callback function used to extend an App instance at the time of service instance creation.\n     */\n    FirebaseApp.prototype.extendApp_ = function (props) {\n        deep_copy_1.deepExtend(this, props);\n    };\n    /**\n     * Throws an Error if the FirebaseApp instance has already been deleted.\n     */\n    FirebaseApp.prototype.checkDestroyed_ = function () {\n        if (this.isDeleted_) {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.APP_DELETED, \"Firebase app named \\\"\" + this.name_ + \"\\\" has already been deleted.\");\n        }\n    };\n    return FirebaseApp;\n}());\nexports.FirebaseApp = FirebaseApp;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/firebase-app.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/firebase-namespace.js":
/*!*******************************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/firebase-namespace.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\n/*!\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar deep_copy_1 = __webpack_require__(/*! ./utils/deep-copy */ \"./src/node_modules/firebase-admin/lib/utils/deep-copy.js\");\nvar error_1 = __webpack_require__(/*! ./utils/error */ \"./src/node_modules/firebase-admin/lib/utils/error.js\");\nvar firebase_app_1 = __webpack_require__(/*! ./firebase-app */ \"./src/node_modules/firebase-admin/lib/firebase-app.js\");\nvar credential_1 = __webpack_require__(/*! ./auth/credential */ \"./src/node_modules/firebase-admin/lib/auth/credential.js\");\nvar validator = __webpack_require__(/*! ./utils/validator */ \"./src/node_modules/firebase-admin/lib/utils/validator.js\");\nvar DEFAULT_APP_NAME = '[DEFAULT]';\n/**\n * Constant holding the environment variable name with the default config.\n * If the environment variable contains a string that starts with '{' it will be parsed as JSON,\n * otherwise it will be assumed to be pointing to a file.\n */\nexports.FIREBASE_CONFIG_VAR = 'FIREBASE_CONFIG';\nvar globalAppDefaultCred;\nvar globalCertCreds = {};\nvar globalRefreshTokenCreds = {};\n/**\n * Internals of a FirebaseNamespace instance.\n */\nvar FirebaseNamespaceInternals = /** @class */ (function () {\n    function FirebaseNamespaceInternals(firebase_) {\n        this.firebase_ = firebase_;\n        this.serviceFactories = {};\n        this.apps_ = {};\n        this.appHooks_ = {};\n    }\n    /**\n     * Initializes the FirebaseApp instance.\n     *\n     * @param {FirebaseAppOptions} options Optional options for the FirebaseApp instance. If none present\n     *                             will try to initialize from the FIREBASE_CONFIG environment variable.\n     *                             If the environment variable contains a string that starts with '{'\n     *                             it will be parsed as JSON,\n     *                             otherwise it will be assumed to be pointing to a file.\n     * @param {string} [appName] Optional name of the FirebaseApp instance.\n     *\n     * @return {FirebaseApp} A new FirebaseApp instance.\n     */\n    FirebaseNamespaceInternals.prototype.initializeApp = function (options, appName) {\n        if (appName === void 0) { appName = DEFAULT_APP_NAME; }\n        if (typeof options === 'undefined') {\n            options = this.loadOptionsFromEnvVar();\n            options.credential = credential_1.getApplicationDefault();\n        }\n        if (typeof appName !== 'string' || appName === '') {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_NAME, \"Invalid Firebase app name \\\"\" + appName + \"\\\" provided. App name must be a non-empty string.\");\n        }\n        else if (appName in this.apps_) {\n            if (appName === DEFAULT_APP_NAME) {\n                throw new error_1.FirebaseAppError(error_1.AppErrorCodes.DUPLICATE_APP, 'The default Firebase app already exists. This means you called initializeApp() ' +\n                    'more than once without providing an app name as the second argument. In most cases ' +\n                    'you only need to call initializeApp() once. But if you do want to initialize ' +\n                    'multiple apps, pass a second argument to initializeApp() to give each app a unique ' +\n                    'name.');\n            }\n            else {\n                throw new error_1.FirebaseAppError(error_1.AppErrorCodes.DUPLICATE_APP, \"Firebase app named \\\"\" + appName + \"\\\" already exists. This means you called initializeApp() \" +\n                    'more than once with the same app name as the second argument. Make sure you provide a ' +\n                    'unique name every time you call initializeApp().');\n            }\n        }\n        var app = new firebase_app_1.FirebaseApp(options, appName, this);\n        this.apps_[appName] = app;\n        this.callAppHooks_(app, 'create');\n        return app;\n    };\n    /**\n     * Returns the FirebaseApp instance with the provided name (or the default FirebaseApp instance\n     * if no name is provided).\n     *\n     * @param {string} [appName=DEFAULT_APP_NAME] Optional name of the FirebaseApp instance to return.\n     * @return {FirebaseApp} The FirebaseApp instance which has the provided name.\n     */\n    FirebaseNamespaceInternals.prototype.app = function (appName) {\n        if (appName === void 0) { appName = DEFAULT_APP_NAME; }\n        if (typeof appName !== 'string' || appName === '') {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_NAME, \"Invalid Firebase app name \\\"\" + appName + \"\\\" provided. App name must be a non-empty string.\");\n        }\n        else if (!(appName in this.apps_)) {\n            var errorMessage = (appName === DEFAULT_APP_NAME)\n                ? 'The default Firebase app does not exist. ' : \"Firebase app named \\\"\" + appName + \"\\\" does not exist. \";\n            errorMessage += 'Make sure you call initializeApp() before using any of the Firebase services.';\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NO_APP, errorMessage);\n        }\n        return this.apps_[appName];\n    };\n    Object.defineProperty(FirebaseNamespaceInternals.prototype, \"apps\", {\n        /*\n         * Returns an array of all the non-deleted FirebaseApp instances.\n         *\n         * @return {Array<FirebaseApp>} An array of all the non-deleted FirebaseApp instances\n         */\n        get: function () {\n            var _this = this;\n            // Return a copy so the caller cannot mutate the array\n            return Object.keys(this.apps_).map(function (appName) { return _this.apps_[appName]; });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /*\n     * Removes the specified FirebaseApp instance.\n     *\n     * @param {string} appName The name of the FirebaseApp instance to remove.\n     */\n    FirebaseNamespaceInternals.prototype.removeApp = function (appName) {\n        if (typeof appName === 'undefined') {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_NAME, \"No Firebase app name provided. App name must be a non-empty string.\");\n        }\n        var appToRemove = this.app(appName);\n        this.callAppHooks_(appToRemove, 'delete');\n        delete this.apps_[appName];\n    };\n    /*\n     * Registers a new service on this Firebase namespace.\n     *\n     * @param {string} serviceName The name of the Firebase service to register.\n     * @param {FirebaseServiceFactory} createService A factory method to generate an instance of the Firebase service.\n     * @param {object} [serviceProperties] Optional properties to extend this Firebase namespace with.\n     * @param {AppHook} [appHook] Optional callback that handles app-related events like app creation and deletion.\n     * @return {FirebaseServiceNamespace<FirebaseServiceInterface>} The Firebase service's namespace.\n     */\n    FirebaseNamespaceInternals.prototype.registerService = function (serviceName, createService, serviceProperties, appHook) {\n        var _this = this;\n        var errorMessage;\n        if (typeof serviceName === 'undefined') {\n            errorMessage = \"No service name provided. Service name must be a non-empty string.\";\n        }\n        else if (typeof serviceName !== 'string' || serviceName === '') {\n            errorMessage = \"Invalid service name \\\"\" + serviceName + \"\\\" provided. Service name must be a non-empty string.\";\n        }\n        else if (serviceName in this.serviceFactories) {\n            errorMessage = \"Firebase service named \\\"\" + serviceName + \"\\\" has already been registered.\";\n        }\n        if (typeof errorMessage !== 'undefined') {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, \"INTERNAL ASSERT FAILED: \" + errorMessage);\n        }\n        this.serviceFactories[serviceName] = createService;\n        if (appHook) {\n            this.appHooks_[serviceName] = appHook;\n        }\n        // The service namespace is an accessor function which takes a FirebaseApp instance\n        // or uses the default app if no FirebaseApp instance is provided\n        var serviceNamespace = function (appArg) {\n            if (typeof appArg === 'undefined') {\n                appArg = _this.app();\n            }\n            // Forward service instance lookup to the FirebaseApp\n            return appArg[serviceName]();\n        };\n        // ... and a container for service-level properties.\n        if (serviceProperties !== undefined) {\n            deep_copy_1.deepExtend(serviceNamespace, serviceProperties);\n        }\n        // Monkey-patch the service namespace onto the Firebase namespace\n        this.firebase_[serviceName] = serviceNamespace;\n        return serviceNamespace;\n    };\n    /**\n     * Calls the app hooks corresponding to the provided event name for each service within the\n     * provided FirebaseApp instance.\n     *\n     * @param {FirebaseApp} app The FirebaseApp instance whose app hooks to call.\n     * @param {string} eventName The event name representing which app hooks to call.\n     */\n    FirebaseNamespaceInternals.prototype.callAppHooks_ = function (app, eventName) {\n        var _this = this;\n        Object.keys(this.serviceFactories).forEach(function (serviceName) {\n            if (_this.appHooks_[serviceName]) {\n                _this.appHooks_[serviceName](eventName, app);\n            }\n        });\n    };\n    /**\n     * Parse the file pointed to by the FIREBASE_CONFIG_VAR, if it exists.\n     * Or if the FIREBASE_CONFIG_ENV contains a valid JSON object, parse it directly.\n     * If the environment variable contains a string that starts with '{' it will be parsed as JSON,\n     * otherwise it will be assumed to be pointing to a file.\n     */\n    FirebaseNamespaceInternals.prototype.loadOptionsFromEnvVar = function () {\n        var config = process.env[exports.FIREBASE_CONFIG_VAR];\n        if (!validator.isNonEmptyString(config)) {\n            return {};\n        }\n        try {\n            var contents = config.startsWith('{') ? config : fs.readFileSync(config, 'utf8');\n            return JSON.parse(contents);\n        }\n        catch (error) {\n            // Throw a nicely formed error message if the file contents cannot be parsed\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_OPTIONS, 'Failed to parse app options file: ' + error);\n        }\n    };\n    return FirebaseNamespaceInternals;\n}());\nexports.FirebaseNamespaceInternals = FirebaseNamespaceInternals;\nvar firebaseCredential = {\n    cert: function (serviceAccountPathOrObject, httpAgent) {\n        var stringifiedServiceAccount = JSON.stringify(serviceAccountPathOrObject);\n        if (!(stringifiedServiceAccount in globalCertCreds)) {\n            globalCertCreds[stringifiedServiceAccount] = new credential_1.ServiceAccountCredential(serviceAccountPathOrObject, httpAgent);\n        }\n        return globalCertCreds[stringifiedServiceAccount];\n    },\n    refreshToken: function (refreshTokenPathOrObject, httpAgent) {\n        var stringifiedRefreshToken = JSON.stringify(refreshTokenPathOrObject);\n        if (!(stringifiedRefreshToken in globalRefreshTokenCreds)) {\n            globalRefreshTokenCreds[stringifiedRefreshToken] = new credential_1.RefreshTokenCredential(refreshTokenPathOrObject, httpAgent);\n        }\n        return globalRefreshTokenCreds[stringifiedRefreshToken];\n    },\n    applicationDefault: function (httpAgent) {\n        if (typeof globalAppDefaultCred === 'undefined') {\n            globalAppDefaultCred = credential_1.getApplicationDefault(httpAgent);\n        }\n        return globalAppDefaultCred;\n    },\n};\n/**\n * Global Firebase context object.\n */\nvar FirebaseNamespace = /** @class */ (function () {\n    /* tslint:enable */\n    function FirebaseNamespace() {\n        // Hack to prevent Babel from modifying the object returned as the default admin namespace.\n        /* tslint:disable:variable-name */\n        this.__esModule = true;\n        /* tslint:enable:variable-name */\n        this.credential = firebaseCredential;\n        this.SDK_VERSION = '8.13.0';\n        /* tslint:disable */\n        // TODO(jwenger): Database is the only consumer of firebase.Promise. We should update it to use\n        // use the native Promise and then remove this.\n        this.Promise = Promise;\n        this.INTERNAL = new FirebaseNamespaceInternals(this);\n    }\n    Object.defineProperty(FirebaseNamespace.prototype, \"auth\", {\n        /**\n         * Gets the `Auth` service namespace. The returned namespace can be used to get the\n         * `Auth` service for the default app or an explicitly specified app.\n         */\n        get: function () {\n            var _this = this;\n            var fn = function (app) {\n                return _this.ensureApp(app).auth();\n            };\n            var auth = __webpack_require__(/*! ./auth/auth */ \"./src/node_modules/firebase-admin/lib/auth/auth.js\").Auth;\n            return Object.assign(fn, { Auth: auth });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FirebaseNamespace.prototype, \"database\", {\n        /**\n         * Gets the `Database` service namespace. The returned namespace can be used to get the\n         * `Database` service for the default app or an explicitly specified app.\n         */\n        get: function () {\n            var _this = this;\n            var fn = function (app) {\n                return _this.ensureApp(app).database();\n            };\n            // eslint-disable-next-line @typescript-eslint/no-var-requires\n            return Object.assign(fn, __webpack_require__(/*! @firebase/database */ \"./src/node_modules/@firebase/database/dist/index.esm.js\"));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FirebaseNamespace.prototype, \"messaging\", {\n        /**\n         * Gets the `Messaging` service namespace. The returned namespace can be used to get the\n         * `Messaging` service for the default app or an explicitly specified app.\n         */\n        get: function () {\n            var _this = this;\n            var fn = function (app) {\n                return _this.ensureApp(app).messaging();\n            };\n            var messaging = __webpack_require__(/*! ./messaging/messaging */ \"./src/node_modules/firebase-admin/lib/messaging/messaging.js\").Messaging;\n            return Object.assign(fn, { Messaging: messaging });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FirebaseNamespace.prototype, \"storage\", {\n        /**\n         * Gets the `Storage` service namespace. The returned namespace can be used to get the\n         * `Storage` service for the default app or an explicitly specified app.\n         */\n        get: function () {\n            var _this = this;\n            var fn = function (app) {\n                return _this.ensureApp(app).storage();\n            };\n            var storage = __webpack_require__(/*! ./storage/storage */ \"./src/node_modules/firebase-admin/lib/storage/storage.js\").Storage;\n            return Object.assign(fn, { Storage: storage });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FirebaseNamespace.prototype, \"firestore\", {\n        /**\n         * Gets the `Firestore` service namespace. The returned namespace can be used to get the\n         * `Firestore` service for the default app or an explicitly specified app.\n         */\n        get: function () {\n            var _this = this;\n            var fn = function (app) {\n                return _this.ensureApp(app).firestore();\n            };\n            // eslint-disable-next-line @typescript-eslint/no-var-requires\n            var firestore = __webpack_require__(/*! @google-cloud/firestore */ \"./src/node_modules/@google-cloud/firestore/build/src/index.js\");\n            fn = Object.assign(fn, firestore.Firestore);\n            // `v1beta1` and `v1` are lazy-loaded in the Firestore SDK. We use the same trick here\n            // to avoid triggering this lazy-loading upon initialization.\n            Object.defineProperty(fn, 'v1beta1', {\n                get: function () {\n                    return firestore.v1beta1;\n                },\n            });\n            Object.defineProperty(fn, 'v1', {\n                get: function () {\n                    return firestore.v1;\n                },\n            });\n            return fn;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FirebaseNamespace.prototype, \"machineLearning\", {\n        /**\n         * Gets the `MachineLearning` service namespace. The returned namespace can be\n         * used to get the `MachineLearning` service for the default app or an\n         * explicityly specified app.\n         */\n        get: function () {\n            var _this = this;\n            var fn = function (app) {\n                return _this.ensureApp(app).machineLearning();\n            };\n            var machineLearning = __webpack_require__(/*! ./machine-learning/machine-learning */ \"./src/node_modules/firebase-admin/lib/machine-learning/machine-learning.js\").MachineLearning;\n            return Object.assign(fn, { MachineLearning: machineLearning });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FirebaseNamespace.prototype, \"instanceId\", {\n        /**\n         * Gets the `InstanceId` service namespace. The returned namespace can be used to get the\n         * `Instance` service for the default app or an explicitly specified app.\n         */\n        get: function () {\n            var _this = this;\n            var fn = function (app) {\n                return _this.ensureApp(app).instanceId();\n            };\n            var instanceId = __webpack_require__(/*! ./instance-id/instance-id */ \"./src/node_modules/firebase-admin/lib/instance-id/instance-id.js\").InstanceId;\n            return Object.assign(fn, { InstanceId: instanceId });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FirebaseNamespace.prototype, \"projectManagement\", {\n        /**\n         * Gets the `ProjectManagement` service namespace. The returned namespace can be used to get the\n         * `ProjectManagement` service for the default app or an explicitly specified app.\n         */\n        get: function () {\n            var _this = this;\n            var fn = function (app) {\n                return _this.ensureApp(app).projectManagement();\n            };\n            var projectManagement = __webpack_require__(/*! ./project-management/project-management */ \"./src/node_modules/firebase-admin/lib/project-management/project-management.js\").ProjectManagement;\n            return Object.assign(fn, { ProjectManagement: projectManagement });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FirebaseNamespace.prototype, \"securityRules\", {\n        /**\n         * Gets the `SecurityRules` service namespace. The returned namespace can be used to get the\n         * `SecurityRules` service for the default app or an explicitly specified app.\n         */\n        get: function () {\n            var _this = this;\n            var fn = function (app) {\n                return _this.ensureApp(app).securityRules();\n            };\n            var securityRules = __webpack_require__(/*! ./security-rules/security-rules */ \"./src/node_modules/firebase-admin/lib/security-rules/security-rules.js\").SecurityRules;\n            return Object.assign(fn, { SecurityRules: securityRules });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FirebaseNamespace.prototype, \"remoteConfig\", {\n        /**\n         * Gets the `RemoteConfig` service namespace. The returned namespace can be used to get the\n         * `RemoteConfig` service for the default app or an explicitly specified app.\n         */\n        get: function () {\n            var _this = this;\n            var fn = function (app) {\n                return _this.ensureApp(app).remoteConfig();\n            };\n            var remoteConfig = __webpack_require__(/*! ./remote-config/remote-config */ \"./src/node_modules/firebase-admin/lib/remote-config/remote-config.js\").RemoteConfig;\n            return Object.assign(fn, { RemoteConfig: remoteConfig });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Initializes the FirebaseApp instance.\n     *\n     * @param {FirebaseAppOptions} [options] Optional options for the FirebaseApp instance.\n     *   If none present will try to initialize from the FIREBASE_CONFIG environment variable.\n     *   If the environment variable contains a string that starts with '{' it will be parsed as JSON,\n     *   otherwise it will be assumed to be pointing to a file.\n     * @param {string} [appName] Optional name of the FirebaseApp instance.\n     *\n     * @return {FirebaseApp} A new FirebaseApp instance.\n     */\n    FirebaseNamespace.prototype.initializeApp = function (options, appName) {\n        return this.INTERNAL.initializeApp(options, appName);\n    };\n    /**\n     * Returns the FirebaseApp instance with the provided name (or the default FirebaseApp instance\n     * if no name is provided).\n     *\n     * @param {string} [appName] Optional name of the FirebaseApp instance to return.\n     * @return {FirebaseApp} The FirebaseApp instance which has the provided name.\n     */\n    FirebaseNamespace.prototype.app = function (appName) {\n        return this.INTERNAL.app(appName);\n    };\n    Object.defineProperty(FirebaseNamespace.prototype, \"apps\", {\n        /*\n         * Returns an array of all the non-deleted FirebaseApp instances.\n         *\n         * @return {Array<FirebaseApp>} An array of all the non-deleted FirebaseApp instances\n         */\n        get: function () {\n            return this.INTERNAL.apps;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    FirebaseNamespace.prototype.ensureApp = function (app) {\n        if (typeof app === 'undefined') {\n            app = this.app();\n        }\n        return app;\n    };\n    return FirebaseNamespace;\n}());\nexports.FirebaseNamespace = FirebaseNamespace;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/firebase-namespace.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/firestore/firestore.js":
/*!********************************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/firestore/firestore.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\n/*!\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar error_1 = __webpack_require__(/*! ../utils/error */ \"./src/node_modules/firebase-admin/lib/utils/error.js\");\nvar credential_1 = __webpack_require__(/*! ../auth/credential */ \"./src/node_modules/firebase-admin/lib/auth/credential.js\");\nvar validator = __webpack_require__(/*! ../utils/validator */ \"./src/node_modules/firebase-admin/lib/utils/validator.js\");\nvar utils = __webpack_require__(/*! ../utils/index */ \"./src/node_modules/firebase-admin/lib/utils/index.js\");\n/**\n * Internals of a Firestore instance.\n */\nvar FirestoreInternals = /** @class */ (function () {\n    function FirestoreInternals() {\n    }\n    /**\n     * Deletes the service and its associated resources.\n     *\n     * @return {Promise<()>} An empty Promise that will be fulfilled when the service is deleted.\n     */\n    FirestoreInternals.prototype.delete = function () {\n        // There are no resources to clean up.\n        return Promise.resolve();\n    };\n    return FirestoreInternals;\n}());\nvar FirestoreService = /** @class */ (function () {\n    function FirestoreService(app) {\n        this.INTERNAL = new FirestoreInternals();\n        this.firestoreClient = initFirestore(app);\n        this.appInternal = app;\n    }\n    Object.defineProperty(FirestoreService.prototype, \"app\", {\n        /**\n         * Returns the app associated with this Storage instance.\n         *\n         * @return {FirebaseApp} The app associated with this Storage instance.\n         */\n        get: function () {\n            return this.appInternal;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FirestoreService.prototype, \"client\", {\n        get: function () {\n            return this.firestoreClient;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return FirestoreService;\n}());\nexports.FirestoreService = FirestoreService;\nfunction getFirestoreOptions(app) {\n    if (!validator.isNonNullObject(app) || !('options' in app)) {\n        throw new error_1.FirebaseFirestoreError({\n            code: 'invalid-argument',\n            message: 'First argument passed to admin.firestore() must be a valid Firebase app instance.',\n        });\n    }\n    var projectId = utils.getExplicitProjectId(app);\n    var credential = app.options.credential;\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    var firebaseVersion = __webpack_require__(/*! ../../package.json */ \"./src/node_modules/firebase-admin/package.json\").version;\n    if (credential instanceof credential_1.ServiceAccountCredential) {\n        return {\n            credentials: {\n                private_key: credential.privateKey,\n                client_email: credential.clientEmail,\n            },\n            // When the SDK is initialized with ServiceAccountCredentials an explicit projectId is\n            // guaranteed to be available.\n            projectId: projectId,\n            firebaseVersion: firebaseVersion,\n        };\n    }\n    else if (credential_1.isApplicationDefault(app.options.credential)) {\n        // Try to use the Google application default credentials.\n        // If an explicit project ID is not available, let Firestore client discover one from the\n        // environment. This prevents the users from having to set GOOGLE_CLOUD_PROJECT in GCP runtimes.\n        return validator.isNonEmptyString(projectId) ? { projectId: projectId, firebaseVersion: firebaseVersion } : { firebaseVersion: firebaseVersion };\n    }\n    throw new error_1.FirebaseFirestoreError({\n        code: 'invalid-credential',\n        message: 'Failed to initialize Google Cloud Firestore client with the available credentials. ' +\n            'Must initialize the SDK with a certificate credential or application default credentials ' +\n            'to use Cloud Firestore API.',\n    });\n}\nexports.getFirestoreOptions = getFirestoreOptions;\nfunction initFirestore(app) {\n    var options = getFirestoreOptions(app);\n    var firestoreDatabase;\n    try {\n        // Lazy-load the Firestore implementation here, which in turns loads gRPC.\n        firestoreDatabase = __webpack_require__(/*! @google-cloud/firestore */ \"./src/node_modules/@google-cloud/firestore/build/src/index.js\").Firestore;\n    }\n    catch (err) {\n        throw new error_1.FirebaseFirestoreError({\n            code: 'missing-dependencies',\n            message: 'Failed to import the Cloud Firestore client library for Node.js. '\n                + 'Make sure to install the \"@google-cloud/firestore\" npm package. '\n                + (\"Original error: \" + err),\n        });\n    }\n    return new firestoreDatabase(options);\n}\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/firestore/firestore.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/index.js":
/*!******************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\n/*!\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar firebase = __webpack_require__(/*! ./default-namespace */ \"./src/node_modules/firebase-admin/lib/default-namespace.js\");\n// Only Node.js has a process variable that is of [[Class]] process\nvar processGlobal = typeof process !== 'undefined' ? process : 0;\nif (Object.prototype.toString.call(processGlobal) !== '[object process]') {\n    var message = \"\\n======== WARNING! ========\\n\\nfirebase-admin appears to have been installed in an unsupported environment.\\nThis package should only be used in server-side or backend Node.js environments,\\nand should not be used in web browsers or other client-side environments.\\n\\nUse the Firebase JS SDK for client-side Firebase integrations:\\n\\nhttps://firebase.google.com/docs/web/setup\\n\";\n    // tslint:disable-next-line:no-console\n    console.error(message);\n}\nmodule.exports = firebase;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/index.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/instance-id/instance-id-request.js":
/*!********************************************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/instance-id/instance-id-request.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\n/*!\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar error_1 = __webpack_require__(/*! ../utils/error */ \"./src/node_modules/firebase-admin/lib/utils/error.js\");\nvar api_request_1 = __webpack_require__(/*! ../utils/api-request */ \"./src/node_modules/firebase-admin/lib/utils/api-request.js\");\nvar utils = __webpack_require__(/*! ../utils/index */ \"./src/node_modules/firebase-admin/lib/utils/index.js\");\nvar validator = __webpack_require__(/*! ../utils/validator */ \"./src/node_modules/firebase-admin/lib/utils/validator.js\");\n/** Firebase IID backend host. */\nvar FIREBASE_IID_HOST = 'console.firebase.google.com';\n/** Firebase IID backend path. */\nvar FIREBASE_IID_PATH = '/v1/';\n/** Firebase IID request timeout duration in milliseconds. */\nvar FIREBASE_IID_TIMEOUT = 10000;\n/** HTTP error codes raised by the backend server. */\nvar ERROR_CODES = {\n    400: 'Malformed instance ID argument.',\n    401: 'Request not authorized.',\n    403: 'Project does not match instance ID or the client does not have sufficient privileges.',\n    404: 'Failed to find the instance ID.',\n    409: 'Already deleted.',\n    429: 'Request throttled out by the backend server.',\n    500: 'Internal server error.',\n    503: 'Backend servers are over capacity. Try again later.',\n};\n/**\n * Class that provides mechanism to send requests to the Firebase Instance ID backend endpoints.\n */\nvar FirebaseInstanceIdRequestHandler = /** @class */ (function () {\n    /**\n     * @param {FirebaseApp} app The app used to fetch access tokens to sign API requests.\n     *\n     * @constructor\n     */\n    function FirebaseInstanceIdRequestHandler(app) {\n        this.app = app;\n        this.host = FIREBASE_IID_HOST;\n        this.timeout = FIREBASE_IID_TIMEOUT;\n        this.httpClient = new api_request_1.AuthorizedHttpClient(app);\n    }\n    FirebaseInstanceIdRequestHandler.prototype.deleteInstanceId = function (instanceId) {\n        if (!validator.isNonEmptyString(instanceId)) {\n            return Promise.reject(new error_1.FirebaseInstanceIdError(error_1.InstanceIdClientErrorCode.INVALID_INSTANCE_ID, 'Instance ID must be a non-empty string.'));\n        }\n        return this.invokeRequestHandler(new api_request_1.ApiSettings(instanceId, 'DELETE'));\n    };\n    /**\n     * Invokes the request handler based on the API settings object passed.\n     *\n     * @param {ApiSettings} apiSettings The API endpoint settings to apply to request and response.\n     * @return {Promise<void>} A promise that resolves when the request is complete.\n     */\n    FirebaseInstanceIdRequestHandler.prototype.invokeRequestHandler = function (apiSettings) {\n        var _this = this;\n        return this.getPathPrefix()\n            .then(function (path) {\n            var req = {\n                url: \"https://\" + _this.host + path + apiSettings.getEndpoint(),\n                method: apiSettings.getHttpMethod(),\n                timeout: _this.timeout,\n            };\n            return _this.httpClient.send(req);\n        })\n            .then(function () {\n            // return nothing on success\n        })\n            .catch(function (err) {\n            if (err instanceof api_request_1.HttpError) {\n                var response = err.response;\n                var errorMessage = (response.isJson() && 'error' in response.data) ?\n                    response.data.error : response.text;\n                var template = ERROR_CODES[response.status];\n                var message = template ?\n                    \"Instance ID \\\"\" + apiSettings.getEndpoint() + \"\\\": \" + template : errorMessage;\n                throw new error_1.FirebaseInstanceIdError(error_1.InstanceIdClientErrorCode.API_ERROR, message);\n            }\n            // In case of timeouts and other network errors, the HttpClient returns a\n            // FirebaseError wrapped in the response. Simply throw it here.\n            throw err;\n        });\n    };\n    FirebaseInstanceIdRequestHandler.prototype.getPathPrefix = function () {\n        var _this = this;\n        if (this.path) {\n            return Promise.resolve(this.path);\n        }\n        return utils.findProjectId(this.app)\n            .then(function (projectId) {\n            if (!validator.isNonEmptyString(projectId)) {\n                // Assert for an explicit projct ID (either via AppOptions or the cert itself).\n                throw new error_1.FirebaseInstanceIdError(error_1.InstanceIdClientErrorCode.INVALID_PROJECT_ID, 'Failed to determine project ID for InstanceId. Initialize the '\n                    + 'SDK with service account credentials or set project ID as an app option. '\n                    + 'Alternatively set the GOOGLE_CLOUD_PROJECT environment variable.');\n            }\n            _this.path = FIREBASE_IID_PATH + (\"project/\" + projectId + \"/instanceId/\");\n            return _this.path;\n        });\n    };\n    return FirebaseInstanceIdRequestHandler;\n}());\nexports.FirebaseInstanceIdRequestHandler = FirebaseInstanceIdRequestHandler;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/instance-id/instance-id-request.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/instance-id/instance-id.js":
/*!************************************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/instance-id/instance-id.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\n/*!\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar error_1 = __webpack_require__(/*! ../utils/error */ \"./src/node_modules/firebase-admin/lib/utils/error.js\");\nvar instance_id_request_1 = __webpack_require__(/*! ./instance-id-request */ \"./src/node_modules/firebase-admin/lib/instance-id/instance-id-request.js\");\nvar validator = __webpack_require__(/*! ../utils/validator */ \"./src/node_modules/firebase-admin/lib/utils/validator.js\");\n/**\n * Internals of an InstanceId service instance.\n */\nvar InstanceIdInternals = /** @class */ (function () {\n    function InstanceIdInternals() {\n    }\n    /**\n     * Deletes the service and its associated resources.\n     *\n     * @return {Promise<()>} An empty Promise that will be fulfilled when the service is deleted.\n     */\n    InstanceIdInternals.prototype.delete = function () {\n        // There are no resources to clean up\n        return Promise.resolve(undefined);\n    };\n    return InstanceIdInternals;\n}());\nvar InstanceId = /** @class */ (function () {\n    /**\n     * @param {FirebaseApp} app The app for this InstanceId service.\n     * @constructor\n     */\n    function InstanceId(app) {\n        this.INTERNAL = new InstanceIdInternals();\n        if (!validator.isNonNullObject(app) || !('options' in app)) {\n            throw new error_1.FirebaseInstanceIdError(error_1.InstanceIdClientErrorCode.INVALID_ARGUMENT, 'First argument passed to admin.instanceId() must be a valid Firebase app instance.');\n        }\n        this.app_ = app;\n        this.requestHandler = new instance_id_request_1.FirebaseInstanceIdRequestHandler(app);\n    }\n    /**\n     * Deletes the specified instance ID from Firebase. This can be used to delete an instance ID\n     * and associated user data from a Firebase project, pursuant to the General Data Protection\n     * Regulation (GDPR).\n     *\n     * @param {string} instanceId The instance ID to be deleted\n     * @return {Promise<void>} A promise that resolves when the instance ID is successfully deleted.\n     */\n    InstanceId.prototype.deleteInstanceId = function (instanceId) {\n        return this.requestHandler.deleteInstanceId(instanceId)\n            .then(function () {\n            // Return nothing on success\n        });\n    };\n    Object.defineProperty(InstanceId.prototype, \"app\", {\n        /**\n         * Returns the app associated with this InstanceId instance.\n         *\n         * @return {FirebaseApp} The app associated with this InstanceId instance.\n         */\n        get: function () {\n            return this.app_;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return InstanceId;\n}());\nexports.InstanceId = InstanceId;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/instance-id/instance-id.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/machine-learning/machine-learning-api-client.js":
/*!*********************************************************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/machine-learning/machine-learning-api-client.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\n/*!\n * Copyright 2020 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar api_request_1 = __webpack_require__(/*! ../utils/api-request */ \"./src/node_modules/firebase-admin/lib/utils/api-request.js\");\nvar error_1 = __webpack_require__(/*! ../utils/error */ \"./src/node_modules/firebase-admin/lib/utils/error.js\");\nvar machine_learning_utils_1 = __webpack_require__(/*! ./machine-learning-utils */ \"./src/node_modules/firebase-admin/lib/machine-learning/machine-learning-utils.js\");\nvar utils = __webpack_require__(/*! ../utils/index */ \"./src/node_modules/firebase-admin/lib/utils/index.js\");\nvar validator = __webpack_require__(/*! ../utils/validator */ \"./src/node_modules/firebase-admin/lib/utils/validator.js\");\nvar ML_V1BETA2_API = 'https://firebaseml.googleapis.com/v1beta2';\nvar FIREBASE_VERSION_HEADER = {\n    'X-Firebase-Client': 'fire-admin-node/8.13.0',\n};\n/**\n * Class that facilitates sending requests to the Firebase ML backend API.\n *\n * @private\n */\nvar MachineLearningApiClient = /** @class */ (function () {\n    function MachineLearningApiClient(app) {\n        this.app = app;\n        if (!validator.isNonNullObject(app) || !('options' in app)) {\n            throw new machine_learning_utils_1.FirebaseMachineLearningError('invalid-argument', 'First argument passed to admin.machineLearning() must be a valid '\n                + 'Firebase app instance.');\n        }\n        this.httpClient = new api_request_1.AuthorizedHttpClient(app);\n    }\n    MachineLearningApiClient.prototype.createModel = function (model) {\n        var _this = this;\n        if (!validator.isNonNullObject(model) ||\n            !validator.isNonEmptyString(model.displayName)) {\n            var err = new machine_learning_utils_1.FirebaseMachineLearningError('invalid-argument', 'Invalid model content.');\n            return Promise.reject(err);\n        }\n        return this.getUrl()\n            .then(function (url) {\n            var request = {\n                method: 'POST',\n                url: url + \"/models\",\n                data: model,\n            };\n            return _this.sendRequest(request);\n        });\n    };\n    MachineLearningApiClient.prototype.updateModel = function (modelId, model, updateMask) {\n        var _this = this;\n        if (!validator.isNonEmptyString(modelId) ||\n            !validator.isNonNullObject(model) ||\n            !validator.isNonEmptyArray(updateMask)) {\n            var err = new machine_learning_utils_1.FirebaseMachineLearningError('invalid-argument', 'Invalid model or mask content.');\n            return Promise.reject(err);\n        }\n        return this.getUrl()\n            .then(function (url) {\n            var request = {\n                method: 'PATCH',\n                url: url + \"/models/\" + modelId + \"?updateMask=\" + updateMask.join(),\n                data: model,\n            };\n            return _this.sendRequest(request);\n        });\n    };\n    MachineLearningApiClient.prototype.getModel = function (modelId) {\n        var _this = this;\n        return Promise.resolve()\n            .then(function () {\n            return _this.getModelName(modelId);\n        })\n            .then(function (modelName) {\n            return _this.getResource(modelName);\n        });\n    };\n    MachineLearningApiClient.prototype.listModels = function (options) {\n        var _this = this;\n        if (options === void 0) { options = {}; }\n        if (!validator.isNonNullObject(options)) {\n            var err = new machine_learning_utils_1.FirebaseMachineLearningError('invalid-argument', 'Invalid ListModelsOptions');\n            return Promise.reject(err);\n        }\n        if (typeof options.filter !== 'undefined' && !validator.isNonEmptyString(options.filter)) {\n            var err = new machine_learning_utils_1.FirebaseMachineLearningError('invalid-argument', 'Invalid list filter.');\n            return Promise.reject(err);\n        }\n        if (typeof options.pageSize !== 'undefined') {\n            if (!validator.isNumber(options.pageSize)) {\n                var err = new machine_learning_utils_1.FirebaseMachineLearningError('invalid-argument', 'Invalid page size.');\n                return Promise.reject(err);\n            }\n            if (options.pageSize < 1 || options.pageSize > 100) {\n                var err = new machine_learning_utils_1.FirebaseMachineLearningError('invalid-argument', 'Page size must be between 1 and 100.');\n                return Promise.reject(err);\n            }\n        }\n        if (typeof options.pageToken !== 'undefined' && !validator.isNonEmptyString(options.pageToken)) {\n            var err = new machine_learning_utils_1.FirebaseMachineLearningError('invalid-argument', 'Next page token must be a non-empty string.');\n            return Promise.reject(err);\n        }\n        return this.getUrl()\n            .then(function (url) {\n            var request = {\n                method: 'GET',\n                url: url + \"/models\",\n                data: options,\n            };\n            return _this.sendRequest(request);\n        });\n    };\n    MachineLearningApiClient.prototype.deleteModel = function (modelId) {\n        var _this = this;\n        return this.getUrl()\n            .then(function (url) {\n            var modelName = _this.getModelName(modelId);\n            var request = {\n                method: 'DELETE',\n                url: url + \"/\" + modelName,\n            };\n            return _this.sendRequest(request);\n        });\n    };\n    /**\n     * Gets the specified resource from the ML API. Resource names must be the short names without project\n     * ID prefix (e.g. `models/123456789`).\n     *\n     * @param {string} name Full qualified name of the resource to get.\n     * @returns {Promise<T>} A promise that fulfills with the resource.\n     */\n    MachineLearningApiClient.prototype.getResource = function (name) {\n        var _this = this;\n        return this.getUrl()\n            .then(function (url) {\n            var request = {\n                method: 'GET',\n                url: url + \"/\" + name,\n            };\n            return _this.sendRequest(request);\n        });\n    };\n    MachineLearningApiClient.prototype.sendRequest = function (request) {\n        var _this = this;\n        request.headers = FIREBASE_VERSION_HEADER;\n        return this.httpClient.send(request)\n            .then(function (resp) {\n            return resp.data;\n        })\n            .catch(function (err) {\n            throw _this.toFirebaseError(err);\n        });\n    };\n    MachineLearningApiClient.prototype.toFirebaseError = function (err) {\n        if (err instanceof error_1.PrefixedFirebaseError) {\n            return err;\n        }\n        var response = err.response;\n        if (!response.isJson()) {\n            return new machine_learning_utils_1.FirebaseMachineLearningError('unknown-error', \"Unexpected response with status: \" + response.status + \" and body: \" + response.text);\n        }\n        var error = response.data.error || {};\n        var code = 'unknown-error';\n        if (error.status && error.status in ERROR_CODE_MAPPING) {\n            code = ERROR_CODE_MAPPING[error.status];\n        }\n        var message = error.message || \"Unknown server error: \" + response.text;\n        return new machine_learning_utils_1.FirebaseMachineLearningError(code, message);\n    };\n    MachineLearningApiClient.prototype.getUrl = function () {\n        return this.getProjectIdPrefix()\n            .then(function (projectIdPrefix) {\n            return ML_V1BETA2_API + \"/\" + projectIdPrefix;\n        });\n    };\n    MachineLearningApiClient.prototype.getProjectIdPrefix = function () {\n        var _this = this;\n        if (this.projectIdPrefix) {\n            return Promise.resolve(this.projectIdPrefix);\n        }\n        return utils.findProjectId(this.app)\n            .then(function (projectId) {\n            if (!validator.isNonEmptyString(projectId)) {\n                throw new machine_learning_utils_1.FirebaseMachineLearningError('invalid-argument', 'Failed to determine project ID. Initialize the SDK with service account credentials, or '\n                    + 'set project ID as an app option. Alternatively, set the GOOGLE_CLOUD_PROJECT '\n                    + 'environment variable.');\n            }\n            _this.projectIdPrefix = \"projects/\" + projectId;\n            return _this.projectIdPrefix;\n        });\n    };\n    MachineLearningApiClient.prototype.getModelName = function (modelId) {\n        if (!validator.isNonEmptyString(modelId)) {\n            throw new machine_learning_utils_1.FirebaseMachineLearningError('invalid-argument', 'Model ID must be a non-empty string.');\n        }\n        if (modelId.indexOf('/') !== -1) {\n            throw new machine_learning_utils_1.FirebaseMachineLearningError('invalid-argument', 'Model ID must not contain any \"/\" characters.');\n        }\n        return \"models/\" + modelId;\n    };\n    return MachineLearningApiClient;\n}());\nexports.MachineLearningApiClient = MachineLearningApiClient;\nvar ERROR_CODE_MAPPING = {\n    INVALID_ARGUMENT: 'invalid-argument',\n    NOT_FOUND: 'not-found',\n    RESOURCE_EXHAUSTED: 'resource-exhausted',\n    UNAUTHENTICATED: 'authentication-error',\n    UNKNOWN: 'unknown-error',\n};\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/machine-learning/machine-learning-api-client.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/machine-learning/machine-learning-utils.js":
/*!****************************************************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/machine-learning/machine-learning-utils.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\n/*!\n * Copyright 2020 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar error_1 = __webpack_require__(/*! ../utils/error */ \"./src/node_modules/firebase-admin/lib/utils/error.js\");\nvar FirebaseMachineLearningError = /** @class */ (function (_super) {\n    __extends(FirebaseMachineLearningError, _super);\n    function FirebaseMachineLearningError(code, message) {\n        return _super.call(this, 'machine-learning', code, message) || this;\n    }\n    FirebaseMachineLearningError.fromOperationError = function (code, message) {\n        switch (code) {\n            case 1: return new FirebaseMachineLearningError('cancelled', message);\n            case 2: return new FirebaseMachineLearningError('unknown-error', message);\n            case 3: return new FirebaseMachineLearningError('invalid-argument', message);\n            case 4: return new FirebaseMachineLearningError('deadline-exceeded', message);\n            case 5: return new FirebaseMachineLearningError('not-found', message);\n            case 6: return new FirebaseMachineLearningError('already-exists', message);\n            case 7: return new FirebaseMachineLearningError('permission-denied', message);\n            case 8: return new FirebaseMachineLearningError('resource-exhausted', message);\n            case 9: return new FirebaseMachineLearningError('failed-precondition', message);\n            case 10: return new FirebaseMachineLearningError('aborted', message);\n            case 11: return new FirebaseMachineLearningError('out-of-range', message);\n            case 13: return new FirebaseMachineLearningError('internal-error', message);\n            case 14: return new FirebaseMachineLearningError('service-unavailable', message);\n            case 15: return new FirebaseMachineLearningError('data-loss', message);\n            case 16: return new FirebaseMachineLearningError('unauthenticated', message);\n            default:\n                return new FirebaseMachineLearningError('unknown-error', message);\n        }\n    };\n    return FirebaseMachineLearningError;\n}(error_1.PrefixedFirebaseError));\nexports.FirebaseMachineLearningError = FirebaseMachineLearningError;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/machine-learning/machine-learning-utils.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/machine-learning/machine-learning.js":
/*!**********************************************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/machine-learning/machine-learning.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\n/*!\n * Copyright 2020 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar machine_learning_api_client_1 = __webpack_require__(/*! ./machine-learning-api-client */ \"./src/node_modules/firebase-admin/lib/machine-learning/machine-learning-api-client.js\");\nvar error_1 = __webpack_require__(/*! ../utils/error */ \"./src/node_modules/firebase-admin/lib/utils/error.js\");\nvar validator = __webpack_require__(/*! ../utils/validator */ \"./src/node_modules/firebase-admin/lib/utils/validator.js\");\nvar machine_learning_utils_1 = __webpack_require__(/*! ./machine-learning-utils */ \"./src/node_modules/firebase-admin/lib/machine-learning/machine-learning-utils.js\");\nvar deep_copy_1 = __webpack_require__(/*! ../utils/deep-copy */ \"./src/node_modules/firebase-admin/lib/utils/deep-copy.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"./src/node_modules/firebase-admin/lib/utils/index.js\");\n/**\n * Internals of an ML instance.\n */\nvar MachineLearningInternals = /** @class */ (function () {\n    function MachineLearningInternals() {\n    }\n    /**\n     * Deletes the service and its associated resources.\n     *\n     * @return {Promise<void>} An empty Promise that will be resolved when the\n     *     service is deleted.\n     */\n    MachineLearningInternals.prototype.delete = function () {\n        // There are no resources to clean up.\n        return Promise.resolve();\n    };\n    return MachineLearningInternals;\n}());\n/**\n * The Firebase Machine Learning class\n */\nvar MachineLearning = /** @class */ (function () {\n    /**\n     * @param {FirebaseApp} app The app for this ML service.\n     * @constructor\n     */\n    function MachineLearning(app) {\n        this.INTERNAL = new MachineLearningInternals();\n        if (!validator.isNonNullObject(app) || !('options' in app)) {\n            throw new error_1.FirebaseError({\n                code: 'machine-learning/invalid-argument',\n                message: 'First argument passed to admin.machineLearning() must be a ' +\n                    'valid Firebase app instance.',\n            });\n        }\n        this.appInternal = app;\n        this.client = new machine_learning_api_client_1.MachineLearningApiClient(app);\n    }\n    Object.defineProperty(MachineLearning.prototype, \"app\", {\n        /**\n         * Returns the app associated with this ML instance.\n         *\n         * @return {FirebaseApp} The app associated with this ML instance.\n         */\n        get: function () {\n            return this.appInternal;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Creates a model in Firebase ML.\n     *\n     * @param {ModelOptions} model The model to create.\n     *\n     * @return {Promise<Model>} A Promise fulfilled with the created model.\n     */\n    MachineLearning.prototype.createModel = function (model) {\n        var _this = this;\n        return this.signUrlIfPresent(model)\n            .then(function (modelContent) { return _this.client.createModel(modelContent); })\n            .then(function (operation) { return handleOperation(operation); });\n    };\n    /**\n     * Updates a model in Firebase ML.\n     *\n     * @param {string} modelId The id of the model to update.\n     * @param {ModelOptions} model The model fields to update.\n     *\n     * @return {Promise<Model>} A Promise fulfilled with the updated model.\n     */\n    MachineLearning.prototype.updateModel = function (modelId, model) {\n        var _this = this;\n        var updateMask = utils.generateUpdateMask(model);\n        return this.signUrlIfPresent(model)\n            .then(function (modelContent) { return _this.client.updateModel(modelId, modelContent, updateMask); })\n            .then(function (operation) { return handleOperation(operation); });\n    };\n    /**\n     * Publishes a model in Firebase ML.\n     *\n     * @param {string} modelId The id of the model to publish.\n     *\n     * @return {Promise<Model>} A Promise fulfilled with the published model.\n     */\n    MachineLearning.prototype.publishModel = function (modelId) {\n        return this.setPublishStatus(modelId, true);\n    };\n    /**\n     * Unpublishes a model in Firebase ML.\n     *\n     * @param {string} modelId The id of the model to unpublish.\n     *\n     * @return {Promise<Model>} A Promise fulfilled with the unpublished model.\n     */\n    MachineLearning.prototype.unpublishModel = function (modelId) {\n        return this.setPublishStatus(modelId, false);\n    };\n    /**\n     * Gets a model from Firebase ML.\n     *\n     * @param {string} modelId The id of the model to get.\n     *\n     * @return {Promise<Model>} A Promise fulfilled with the unpublished model.\n     */\n    MachineLearning.prototype.getModel = function (modelId) {\n        return this.client.getModel(modelId)\n            .then(function (modelResponse) { return new Model(modelResponse); });\n    };\n    /**\n     * Lists models from Firebase ML.\n     *\n     * @param {ListModelsOptions} options The listing options.\n     *\n     * @return {Promise<{models: Model[], pageToken?: string}>} A promise that\n     *     resolves with the current (filtered) list of models and the next page\n     *     token. For the last page, an empty list of models and no page token are\n     *     returned.\n     */\n    MachineLearning.prototype.listModels = function (options) {\n        if (options === void 0) { options = {}; }\n        return this.client.listModels(options)\n            .then(function (resp) {\n            if (!validator.isNonNullObject(resp)) {\n                throw new machine_learning_utils_1.FirebaseMachineLearningError('invalid-argument', \"Invalid ListModels response: \" + JSON.stringify(resp));\n            }\n            var models = [];\n            if (resp.models) {\n                models = resp.models.map(function (rs) { return new Model(rs); });\n            }\n            var result = { models: models };\n            if (resp.nextPageToken) {\n                result.pageToken = resp.nextPageToken;\n            }\n            return result;\n        });\n    };\n    /**\n     * Deletes a model from Firebase ML.\n     *\n     * @param {string} modelId The id of the model to delete.\n     */\n    MachineLearning.prototype.deleteModel = function (modelId) {\n        return this.client.deleteModel(modelId);\n    };\n    MachineLearning.prototype.setPublishStatus = function (modelId, publish) {\n        var updateMask = ['state.published'];\n        var options = { state: { published: publish } };\n        return this.client.updateModel(modelId, options, updateMask)\n            .then(function (operation) { return handleOperation(operation); });\n    };\n    MachineLearning.prototype.signUrlIfPresent = function (options) {\n        var _a;\n        var modelOptions = deep_copy_1.deepCopy(options);\n        if ((_a = modelOptions.tfliteModel) === null || _a === void 0 ? void 0 : _a.gcsTfliteUri) {\n            return this.signUrl(modelOptions.tfliteModel.gcsTfliteUri)\n                .then(function (uri) {\n                modelOptions.tfliteModel.gcsTfliteUri = uri;\n                return modelOptions;\n            })\n                .catch(function (err) {\n                throw new machine_learning_utils_1.FirebaseMachineLearningError('internal-error', \"Error during signing upload url: \" + err.message);\n            });\n        }\n        return Promise.resolve(modelOptions);\n    };\n    MachineLearning.prototype.signUrl = function (unsignedUrl) {\n        var MINUTES_IN_MILLIS = 60 * 1000;\n        var URL_VALID_DURATION = 10 * MINUTES_IN_MILLIS;\n        var gcsRegex = /^gs:\\/\\/([a-z0-9_.-]{3,63})\\/(.+)$/;\n        var matches = gcsRegex.exec(unsignedUrl);\n        if (!matches) {\n            throw new machine_learning_utils_1.FirebaseMachineLearningError('invalid-argument', \"Invalid unsigned url: \" + unsignedUrl);\n        }\n        var bucketName = matches[1];\n        var blobName = matches[2];\n        var bucket = this.appInternal.storage().bucket(bucketName);\n        var blob = bucket.file(blobName);\n        return blob.getSignedUrl({\n            action: 'read',\n            expires: Date.now() + URL_VALID_DURATION,\n        }).then(function (signUrl) { return signUrl[0]; });\n    };\n    return MachineLearning;\n}());\nexports.MachineLearning = MachineLearning;\n/**\n * A Firebase ML Model output object.\n */\nvar Model = /** @class */ (function () {\n    function Model(model) {\n        var _a, _b, _c, _d, _e;\n        if (!validator.isNonNullObject(model) ||\n            !validator.isNonEmptyString(model.name) ||\n            !validator.isNonEmptyString(model.createTime) ||\n            !validator.isNonEmptyString(model.updateTime) ||\n            !validator.isNonEmptyString(model.displayName) ||\n            !validator.isNonEmptyString(model.etag)) {\n            throw new machine_learning_utils_1.FirebaseMachineLearningError('invalid-server-response', \"Invalid Model response: \" + JSON.stringify(model));\n        }\n        this.modelId = extractModelId(model.name);\n        this.displayName = model.displayName;\n        this.tags = model.tags || [];\n        this.createTime = new Date(model.createTime).toUTCString();\n        this.updateTime = new Date(model.updateTime).toUTCString();\n        if ((_b = (_a = model.state) === null || _a === void 0 ? void 0 : _a.validationError) === null || _b === void 0 ? void 0 : _b.message) {\n            this.validationError = (_d = (_c = model.state) === null || _c === void 0 ? void 0 : _c.validationError) === null || _d === void 0 ? void 0 : _d.message;\n        }\n        this.published = ((_e = model.state) === null || _e === void 0 ? void 0 : _e.published) || false;\n        this.etag = model.etag;\n        if (model.modelHash) {\n            this.modelHash = model.modelHash;\n        }\n        if (model.tfliteModel) {\n            this.tfliteModel = {\n                gcsTfliteUri: model.tfliteModel.gcsTfliteUri,\n                sizeBytes: model.tfliteModel.sizeBytes,\n            };\n        }\n    }\n    Object.defineProperty(Model.prototype, \"locked\", {\n        get: function () {\n            // Backend does not currently return locked models.\n            // This will likely change in future.\n            return false;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /* eslint-disable-next-line @typescript-eslint/no-unused-vars */\n    Model.prototype.waitForUnlocked = function (maxTimeSeconds) {\n        // Backend does not currently return locked models.\n        // This will likely change in future.\n        return Promise.resolve();\n    };\n    return Model;\n}());\nexports.Model = Model;\nfunction extractModelId(resourceName) {\n    return resourceName.split('/').pop();\n}\nfunction handleOperation(op) {\n    // Backend currently does not return operations that are not done.\n    if (op.done) {\n        // Done operations must have either a response or an error.\n        if (op.response) {\n            return new Model(op.response);\n        }\n        else if (op.error) {\n            throw machine_learning_utils_1.FirebaseMachineLearningError.fromOperationError(op.error.code, op.error.message);\n        }\n    }\n    throw new machine_learning_utils_1.FirebaseMachineLearningError('invalid-server-response', \"Invalid Operation response: \" + JSON.stringify(op));\n}\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/machine-learning/machine-learning.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/messaging/batch-request.js":
/*!************************************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/messaging/batch-request.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\n/*!\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar api_request_1 = __webpack_require__(/*! ../utils/api-request */ \"./src/node_modules/firebase-admin/lib/utils/api-request.js\");\nvar error_1 = __webpack_require__(/*! ../utils/error */ \"./src/node_modules/firebase-admin/lib/utils/error.js\");\nvar PART_BOUNDARY = '__END_OF_PART__';\nvar TEN_SECONDS_IN_MILLIS = 10000;\n/**\n * An HTTP client that can be used to make batch requests. This client is not tied to any service\n * (FCM or otherwise). Therefore it can be used to make batch requests to any service that allows\n * it. If this requirement ever arises we can move this implementation to the utils module\n * where it can be easily shared among other modules.\n */\nvar BatchRequestClient = /** @class */ (function () {\n    /**\n     * @param {HttpClient} httpClient The client that will be used to make HTTP calls.\n     * @param {string} batchUrl The URL that accepts batch requests.\n     * @param {object=} commonHeaders Optional headers that will be included in all requests.\n     *\n     * @constructor\n     */\n    function BatchRequestClient(httpClient, batchUrl, commonHeaders) {\n        this.httpClient = httpClient;\n        this.batchUrl = batchUrl;\n        this.commonHeaders = commonHeaders;\n    }\n    /**\n     * Sends the given array of sub requests as a single batch, and parses the results into an array\n     * of HttpResponse objects.\n     *\n     * @param {SubRequest[]} requests An array of sub requests to send.\n     * @return {Promise<HttpResponse[]>} A promise that resolves when the send operation is complete.\n     */\n    BatchRequestClient.prototype.send = function (requests) {\n        var _this = this;\n        requests = requests.map(function (req) {\n            req.headers = Object.assign({}, _this.commonHeaders, req.headers);\n            return req;\n        });\n        var requestHeaders = {\n            'Content-Type': \"multipart/mixed; boundary=\" + PART_BOUNDARY,\n        };\n        var request = {\n            method: 'POST',\n            url: this.batchUrl,\n            data: this.getMultipartPayload(requests),\n            headers: Object.assign({}, this.commonHeaders, requestHeaders),\n            timeout: TEN_SECONDS_IN_MILLIS,\n        };\n        return this.httpClient.send(request).then(function (response) {\n            if (!response.multipart) {\n                throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, 'Expected a multipart response.');\n            }\n            return response.multipart.map(function (buff) {\n                return api_request_1.parseHttpResponse(buff, request);\n            });\n        });\n    };\n    BatchRequestClient.prototype.getMultipartPayload = function (requests) {\n        var buffer = '';\n        requests.forEach(function (request, idx) {\n            buffer += createPart(request, PART_BOUNDARY, idx);\n        });\n        buffer += \"--\" + PART_BOUNDARY + \"--\\r\\n\";\n        return Buffer.from(buffer, 'utf-8');\n    };\n    return BatchRequestClient;\n}());\nexports.BatchRequestClient = BatchRequestClient;\n/**\n * Creates a single part in a multipart HTTP request body. The part consists of several headers\n * followed by the serialized sub request as the body. As per the requirements of the FCM batch\n * API, sets the content-type header to application/http, and the content-transfer-encoding to\n * binary.\n *\n * @param {SubRequest} request A sub request that will be used to populate the part.\n * @param {string} boundary Multipart boundary string.\n * @param {number} idx An index number that is used to set the content-id header.\n * @return {string} The part as a string that can be included in the HTTP body.\n */\nfunction createPart(request, boundary, idx) {\n    var serializedRequest = serializeSubRequest(request);\n    var part = \"--\" + boundary + \"\\r\\n\";\n    part += \"Content-Length: \" + serializedRequest.length + \"\\r\\n\";\n    part += 'Content-Type: application/http\\r\\n';\n    part += \"content-id: \" + (idx + 1) + \"\\r\\n\";\n    part += 'content-transfer-encoding: binary\\r\\n';\n    part += '\\r\\n';\n    part += serializedRequest + \"\\r\\n\";\n    return part;\n}\n/**\n * Serializes a sub request into a string that can be embedded in a multipart HTTP request. The\n * format of the string is the wire format of a typical HTTP request, consisting of a header and a\n * body.\n *\n * @param request {SubRequest} The sub request to be serialized.\n * @return {string} String representation of the SubRequest.\n */\nfunction serializeSubRequest(request) {\n    var requestBody = JSON.stringify(request.body);\n    var messagePayload = \"POST \" + request.url + \" HTTP/1.1\\r\\n\";\n    messagePayload += \"Content-Length: \" + requestBody.length + \"\\r\\n\";\n    messagePayload += 'Content-Type: application/json; charset=UTF-8\\r\\n';\n    if (request.headers) {\n        Object.keys(request.headers).forEach(function (key) {\n            messagePayload += key + \": \" + request.headers[key] + \"\\r\\n\";\n        });\n    }\n    messagePayload += '\\r\\n';\n    messagePayload += requestBody;\n    return messagePayload;\n}\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/messaging/batch-request.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/messaging/messaging-api-request.js":
/*!********************************************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/messaging/messaging-api-request.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\n/*!\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar api_request_1 = __webpack_require__(/*! ../utils/api-request */ \"./src/node_modules/firebase-admin/lib/utils/api-request.js\");\nvar messaging_errors_1 = __webpack_require__(/*! ./messaging-errors */ \"./src/node_modules/firebase-admin/lib/messaging/messaging-errors.js\");\nvar batch_request_1 = __webpack_require__(/*! ./batch-request */ \"./src/node_modules/firebase-admin/lib/messaging/batch-request.js\");\n// FCM backend constants\nvar FIREBASE_MESSAGING_TIMEOUT = 10000;\nvar FIREBASE_MESSAGING_BATCH_URL = 'https://fcm.googleapis.com/batch';\nvar FIREBASE_MESSAGING_HTTP_METHOD = 'POST';\nvar FIREBASE_MESSAGING_HEADERS = {\n    'X-Firebase-Client': 'fire-admin-node/8.13.0',\n};\nvar LEGACY_FIREBASE_MESSAGING_HEADERS = {\n    'X-Firebase-Client': 'fire-admin-node/8.13.0',\n    'access_token_auth': 'true',\n};\n/**\n * Class that provides a mechanism to send requests to the Firebase Cloud Messaging backend.\n */\nvar FirebaseMessagingRequestHandler = /** @class */ (function () {\n    /**\n     * @param {FirebaseApp} app The app used to fetch access tokens to sign API requests.\n     * @constructor\n     */\n    function FirebaseMessagingRequestHandler(app) {\n        this.httpClient = new api_request_1.AuthorizedHttpClient(app);\n        this.batchClient = new batch_request_1.BatchRequestClient(this.httpClient, FIREBASE_MESSAGING_BATCH_URL, FIREBASE_MESSAGING_HEADERS);\n    }\n    /**\n     * Invokes the request handler with the provided request data.\n     *\n     * @param {string} host The host to which to send the request.\n     * @param {string} path The path to which to send the request.\n     * @param {object} requestData The request data.\n     * @return {Promise<object>} A promise that resolves with the response.\n     */\n    FirebaseMessagingRequestHandler.prototype.invokeRequestHandler = function (host, path, requestData) {\n        var request = {\n            method: FIREBASE_MESSAGING_HTTP_METHOD,\n            url: \"https://\" + host + path,\n            data: requestData,\n            headers: LEGACY_FIREBASE_MESSAGING_HEADERS,\n            timeout: FIREBASE_MESSAGING_TIMEOUT,\n        };\n        return this.httpClient.send(request).then(function (response) {\n            // Send non-JSON responses to the catch() below where they will be treated as errors.\n            if (!response.isJson()) {\n                throw new api_request_1.HttpError(response);\n            }\n            // Check for backend errors in the response.\n            var errorCode = messaging_errors_1.getErrorCode(response.data);\n            if (errorCode) {\n                throw new api_request_1.HttpError(response);\n            }\n            // Return entire response.\n            return response.data;\n        })\n            .catch(function (err) {\n            if (err instanceof api_request_1.HttpError) {\n                throw messaging_errors_1.createFirebaseError(err);\n            }\n            // Re-throw the error if it already has the proper format.\n            throw err;\n        });\n    };\n    /**\n     * Sends the given array of sub requests as a single batch to FCM, and parses the result into\n     * a BatchResponse object.\n     *\n     * @param {SubRequest[]} requests An array of sub requests to send.\n     * @return {Promise<BatchResponse>} A promise that resolves when the send operation is complete.\n     */\n    FirebaseMessagingRequestHandler.prototype.sendBatchRequest = function (requests) {\n        var _this = this;\n        return this.batchClient.send(requests)\n            .then(function (responses) {\n            return responses.map(function (part) {\n                return _this.buildSendResponse(part);\n            });\n        }).then(function (responses) {\n            var successCount = responses.filter(function (resp) { return resp.success; }).length;\n            return {\n                responses: responses,\n                successCount: successCount,\n                failureCount: responses.length - successCount,\n            };\n        }).catch(function (err) {\n            if (err instanceof api_request_1.HttpError) {\n                throw messaging_errors_1.createFirebaseError(err);\n            }\n            // Re-throw the error if it already has the proper format.\n            throw err;\n        });\n    };\n    FirebaseMessagingRequestHandler.prototype.buildSendResponse = function (response) {\n        var result = {\n            success: response.status === 200,\n        };\n        if (result.success) {\n            result.messageId = response.data.name;\n        }\n        else {\n            result.error = messaging_errors_1.createFirebaseError(new api_request_1.HttpError(response));\n        }\n        return result;\n    };\n    return FirebaseMessagingRequestHandler;\n}());\nexports.FirebaseMessagingRequestHandler = FirebaseMessagingRequestHandler;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/messaging/messaging-api-request.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/messaging/messaging-errors.js":
/*!***************************************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/messaging/messaging-errors.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\n/*!\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar error_1 = __webpack_require__(/*! ../utils/error */ \"./src/node_modules/firebase-admin/lib/utils/error.js\");\nvar validator = __webpack_require__(/*! ../utils/validator */ \"./src/node_modules/firebase-admin/lib/utils/validator.js\");\n/**\n * Creates a new FirebaseMessagingError by extracting the error code, message and other relevant\n * details from an HTTP error response.\n *\n * @param {HttpError} err The HttpError to convert into a Firebase error\n * @return {FirebaseMessagingError} A Firebase error that can be returned to the user.\n */\nfunction createFirebaseError(err) {\n    if (err.response.isJson()) {\n        // For JSON responses, map the server response to a client-side error.\n        var json = err.response.data;\n        var errorCode = getErrorCode(json);\n        var errorMessage = getErrorMessage(json);\n        return error_1.FirebaseMessagingError.fromServerError(errorCode, errorMessage, json);\n    }\n    // Non-JSON response\n    var error;\n    switch (err.response.status) {\n        case 400:\n            error = error_1.MessagingClientErrorCode.INVALID_ARGUMENT;\n            break;\n        case 401:\n        case 403:\n            error = error_1.MessagingClientErrorCode.AUTHENTICATION_ERROR;\n            break;\n        case 500:\n            error = error_1.MessagingClientErrorCode.INTERNAL_ERROR;\n            break;\n        case 503:\n            error = error_1.MessagingClientErrorCode.SERVER_UNAVAILABLE;\n            break;\n        default:\n            // Treat non-JSON responses with unexpected status codes as unknown errors.\n            error = error_1.MessagingClientErrorCode.UNKNOWN_ERROR;\n    }\n    return new error_1.FirebaseMessagingError({\n        code: error.code,\n        message: error.message + \" Raw server response: \\\"\" + err.response.text + \"\\\". Status code: \" +\n            (err.response.status + \".\"),\n    });\n}\nexports.createFirebaseError = createFirebaseError;\n/**\n * @param {object} response The response to check for errors.\n * @return {string|null} The error code if present; null otherwise.\n */\nfunction getErrorCode(response) {\n    if (validator.isNonNullObject(response) && 'error' in response) {\n        var error = response.error;\n        if (validator.isString(error)) {\n            return error;\n        }\n        if (validator.isArray(error.details)) {\n            var fcmErrorType = 'type.googleapis.com/google.firebase.fcm.v1.FcmError';\n            for (var _i = 0, _a = error.details; _i < _a.length; _i++) {\n                var element = _a[_i];\n                if (element['@type'] === fcmErrorType) {\n                    return element.errorCode;\n                }\n            }\n        }\n        if ('status' in error) {\n            return error.status;\n        }\n        else {\n            return error.message;\n        }\n    }\n    return null;\n}\nexports.getErrorCode = getErrorCode;\n/**\n * Extracts error message from the given response object.\n *\n * @param {object} response The response to check for errors.\n * @return {string|null} The error message if present; null otherwise.\n */\nfunction getErrorMessage(response) {\n    if (validator.isNonNullObject(response) &&\n        'error' in response &&\n        validator.isNonEmptyString(response.error.message)) {\n        return response.error.message;\n    }\n    return null;\n}\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/messaging/messaging-errors.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/messaging/messaging-types.js":
/*!**************************************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/messaging/messaging-types.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\n/*!\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar index_1 = __webpack_require__(/*! ../utils/index */ \"./src/node_modules/firebase-admin/lib/utils/index.js\");\nvar error_1 = __webpack_require__(/*! ../utils/error */ \"./src/node_modules/firebase-admin/lib/utils/error.js\");\nvar validator = __webpack_require__(/*! ../utils/validator */ \"./src/node_modules/firebase-admin/lib/utils/validator.js\");\n/**\n * Checks if the given Message object is valid. Recursively validates all the child objects\n * included in the message (android, apns, data etc.). If successful, transforms the message\n * in place by renaming the keys to what's expected by the remote FCM service.\n *\n * @param {Message} Message An object to be validated.\n */\nfunction validateMessage(message) {\n    if (!validator.isNonNullObject(message)) {\n        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'Message must be a non-null object');\n    }\n    var anyMessage = message;\n    if (anyMessage.topic) {\n        // If the topic name is prefixed, remove it.\n        if (anyMessage.topic.startsWith('/topics/')) {\n            anyMessage.topic = anyMessage.topic.replace(/^\\/topics\\//, '');\n        }\n        // Checks for illegal characters and empty string.\n        if (!/^[a-zA-Z0-9-_.~%]+$/.test(anyMessage.topic)) {\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'Malformed topic name');\n        }\n    }\n    var targets = [anyMessage.token, anyMessage.topic, anyMessage.condition];\n    if (targets.filter(function (v) { return validator.isNonEmptyString(v); }).length !== 1) {\n        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'Exactly one of topic, token or condition is required');\n    }\n    validateStringMap(message.data, 'data');\n    validateAndroidConfig(message.android);\n    validateWebpushConfig(message.webpush);\n    validateApnsConfig(message.apns);\n    validateFcmOptions(message.fcmOptions);\n    validateNotification(message.notification);\n}\nexports.validateMessage = validateMessage;\n/**\n * Checks if the given object only contains strings as child values.\n *\n * @param {object} map An object to be validated.\n * @param {string} label A label to be included in the errors thrown.\n */\nfunction validateStringMap(map, label) {\n    if (typeof map === 'undefined') {\n        return;\n    }\n    else if (!validator.isNonNullObject(map)) {\n        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, label + \" must be a non-null object\");\n    }\n    Object.keys(map).forEach(function (key) {\n        if (!validator.isString(map[key])) {\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, label + \" must only contain string values\");\n        }\n    });\n}\n/**\n * Checks if the given WebpushConfig object is valid. The object must have valid headers and data.\n *\n * @param {WebpushConfig} config An object to be validated.\n */\nfunction validateWebpushConfig(config) {\n    if (typeof config === 'undefined') {\n        return;\n    }\n    else if (!validator.isNonNullObject(config)) {\n        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'webpush must be a non-null object');\n    }\n    validateStringMap(config.headers, 'webpush.headers');\n    validateStringMap(config.data, 'webpush.data');\n}\n/**\n * Checks if the given ApnsConfig object is valid. The object must have valid headers and a\n * payload.\n *\n * @param {ApnsConfig} config An object to be validated.\n */\nfunction validateApnsConfig(config) {\n    if (typeof config === 'undefined') {\n        return;\n    }\n    else if (!validator.isNonNullObject(config)) {\n        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'apns must be a non-null object');\n    }\n    validateStringMap(config.headers, 'apns.headers');\n    validateApnsPayload(config.payload);\n    validateApnsFcmOptions(config.fcmOptions);\n}\n/**\n * Checks if the given ApnsFcmOptions object is valid.\n *\n * @param {ApnsFcmOptions} fcmOptions An object to be validated.\n */\nfunction validateApnsFcmOptions(fcmOptions) {\n    if (typeof fcmOptions === 'undefined') {\n        return;\n    }\n    else if (!validator.isNonNullObject(fcmOptions)) {\n        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'fcmOptions must be a non-null object');\n    }\n    if (typeof fcmOptions.imageUrl !== 'undefined' &&\n        !validator.isURL(fcmOptions.imageUrl)) {\n        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'imageUrl must be a valid URL string');\n    }\n    if (typeof fcmOptions.analyticsLabel !== 'undefined' && !validator.isString(fcmOptions.analyticsLabel)) {\n        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'analyticsLabel must be a string value');\n    }\n    var propertyMappings = {\n        imageUrl: 'image',\n    };\n    Object.keys(propertyMappings).forEach(function (key) {\n        if (key in fcmOptions && propertyMappings[key] in fcmOptions) {\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, \"Multiple specifications for \" + key + \" in ApnsFcmOptions\");\n        }\n    });\n    index_1.renameProperties(fcmOptions, propertyMappings);\n}\n/**\n * Checks if the given FcmOptions object is valid.\n *\n * @param {FcmOptions} fcmOptions An object to be validated.\n */\nfunction validateFcmOptions(fcmOptions) {\n    if (typeof fcmOptions === 'undefined') {\n        return;\n    }\n    else if (!validator.isNonNullObject(fcmOptions)) {\n        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'fcmOptions must be a non-null object');\n    }\n    if (typeof fcmOptions.analyticsLabel !== 'undefined' && !validator.isString(fcmOptions.analyticsLabel)) {\n        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'analyticsLabel must be a string value');\n    }\n}\n/**\n * Checks if the given Notification object is valid.\n *\n * @param {Notification} notification An object to be validated.\n */\nfunction validateNotification(notification) {\n    if (typeof notification === 'undefined') {\n        return;\n    }\n    else if (!validator.isNonNullObject(notification)) {\n        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'notification must be a non-null object');\n    }\n    if (typeof notification.imageUrl !== 'undefined' && !validator.isURL(notification.imageUrl)) {\n        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'notification.imageUrl must be a valid URL string');\n    }\n    var propertyMappings = {\n        imageUrl: 'image',\n    };\n    Object.keys(propertyMappings).forEach(function (key) {\n        if (key in notification && propertyMappings[key] in notification) {\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, \"Multiple specifications for \" + key + \" in Notification\");\n        }\n    });\n    index_1.renameProperties(notification, propertyMappings);\n}\n/**\n * Checks if the given ApnsPayload object is valid. The object must have a valid aps value.\n *\n * @param {ApnsPayload} payload An object to be validated.\n */\nfunction validateApnsPayload(payload) {\n    if (typeof payload === 'undefined') {\n        return;\n    }\n    else if (!validator.isNonNullObject(payload)) {\n        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'apns.payload must be a non-null object');\n    }\n    validateAps(payload.aps);\n}\n/**\n * Checks if the given Aps object is valid. The object must have a valid alert. If the validation\n * is successful, transforms the input object by renaming the keys to valid APNS payload keys.\n *\n * @param {Aps} aps An object to be validated.\n */\nfunction validateAps(aps) {\n    if (typeof aps === 'undefined') {\n        return;\n    }\n    else if (!validator.isNonNullObject(aps)) {\n        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'apns.payload.aps must be a non-null object');\n    }\n    validateApsAlert(aps.alert);\n    validateApsSound(aps.sound);\n    var propertyMappings = {\n        contentAvailable: 'content-available',\n        mutableContent: 'mutable-content',\n        threadId: 'thread-id',\n    };\n    Object.keys(propertyMappings).forEach(function (key) {\n        if (key in aps && propertyMappings[key] in aps) {\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, \"Multiple specifications for \" + key + \" in Aps\");\n        }\n    });\n    index_1.renameProperties(aps, propertyMappings);\n    var contentAvailable = aps['content-available'];\n    if (typeof contentAvailable !== 'undefined' && contentAvailable !== 1) {\n        if (contentAvailable === true) {\n            aps['content-available'] = 1;\n        }\n        else {\n            delete aps['content-available'];\n        }\n    }\n    var mutableContent = aps['mutable-content'];\n    if (typeof mutableContent !== 'undefined' && mutableContent !== 1) {\n        if (mutableContent === true) {\n            aps['mutable-content'] = 1;\n        }\n        else {\n            delete aps['mutable-content'];\n        }\n    }\n}\nfunction validateApsSound(sound) {\n    if (typeof sound === 'undefined' || validator.isNonEmptyString(sound)) {\n        return;\n    }\n    else if (!validator.isNonNullObject(sound)) {\n        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'apns.payload.aps.sound must be a non-empty string or a non-null object');\n    }\n    if (!validator.isNonEmptyString(sound.name)) {\n        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'apns.payload.aps.sound.name must be a non-empty string');\n    }\n    var volume = sound.volume;\n    if (typeof volume !== 'undefined') {\n        if (!validator.isNumber(volume)) {\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'apns.payload.aps.sound.volume must be a number');\n        }\n        if (volume < 0 || volume > 1) {\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'apns.payload.aps.sound.volume must be in the interval [0, 1]');\n        }\n    }\n    var soundObject = sound;\n    var key = 'critical';\n    var critical = soundObject[key];\n    if (typeof critical !== 'undefined' && critical !== 1) {\n        if (critical === true) {\n            soundObject[key] = 1;\n        }\n        else {\n            delete soundObject[key];\n        }\n    }\n}\n/**\n * Checks if the given alert object is valid. Alert could be a string or a complex object.\n * If specified as an object, it must have valid localization parameters. If successful, transforms\n * the input object by renaming the keys to valid APNS payload keys.\n *\n * @param {string | ApsAlert} alert An alert string or an object to be validated.\n */\nfunction validateApsAlert(alert) {\n    if (typeof alert === 'undefined' || validator.isString(alert)) {\n        return;\n    }\n    else if (!validator.isNonNullObject(alert)) {\n        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'apns.payload.aps.alert must be a string or a non-null object');\n    }\n    var apsAlert = alert;\n    if (validator.isNonEmptyArray(apsAlert.locArgs) &&\n        !validator.isNonEmptyString(apsAlert.locKey)) {\n        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'apns.payload.aps.alert.locKey is required when specifying locArgs');\n    }\n    if (validator.isNonEmptyArray(apsAlert.titleLocArgs) &&\n        !validator.isNonEmptyString(apsAlert.titleLocKey)) {\n        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'apns.payload.aps.alert.titleLocKey is required when specifying titleLocArgs');\n    }\n    if (validator.isNonEmptyArray(apsAlert.subtitleLocArgs) &&\n        !validator.isNonEmptyString(apsAlert.subtitleLocKey)) {\n        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'apns.payload.aps.alert.subtitleLocKey is required when specifying subtitleLocArgs');\n    }\n    var propertyMappings = {\n        locKey: 'loc-key',\n        locArgs: 'loc-args',\n        titleLocKey: 'title-loc-key',\n        titleLocArgs: 'title-loc-args',\n        subtitleLocKey: 'subtitle-loc-key',\n        subtitleLocArgs: 'subtitle-loc-args',\n        actionLocKey: 'action-loc-key',\n        launchImage: 'launch-image',\n    };\n    index_1.renameProperties(apsAlert, propertyMappings);\n}\n/**\n * Checks if the given AndroidConfig object is valid. The object must have valid ttl, data,\n * and notification fields. If successful, transforms the input object by renaming keys to valid\n * Android keys. Also transforms the ttl value to the format expected by FCM service.\n *\n * @param {AndroidConfig} config An object to be validated.\n */\nfunction validateAndroidConfig(config) {\n    if (typeof config === 'undefined') {\n        return;\n    }\n    else if (!validator.isNonNullObject(config)) {\n        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'android must be a non-null object');\n    }\n    if (typeof config.ttl !== 'undefined') {\n        if (!validator.isNumber(config.ttl) || config.ttl < 0) {\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'TTL must be a non-negative duration in milliseconds');\n        }\n        var duration = transformMillisecondsToSecondsString(config.ttl);\n        config.ttl = duration;\n    }\n    validateStringMap(config.data, 'android.data');\n    validateAndroidNotification(config.notification);\n    validateAndroidFcmOptions(config.fcmOptions);\n    var propertyMappings = {\n        collapseKey: 'collapse_key',\n        restrictedPackageName: 'restricted_package_name',\n    };\n    index_1.renameProperties(config, propertyMappings);\n}\n/**\n * Checks if the given AndroidNotification object is valid. The object must have valid color and\n * localization parameters. If successful, transforms the input object by renaming keys to valid\n * Android keys.\n *\n * @param {AndroidNotification} notification An object to be validated.\n */\nfunction validateAndroidNotification(notification) {\n    if (typeof notification === 'undefined') {\n        return;\n    }\n    else if (!validator.isNonNullObject(notification)) {\n        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'android.notification must be a non-null object');\n    }\n    if (typeof notification.color !== 'undefined' && !/^#[0-9a-fA-F]{6}$/.test(notification.color)) {\n        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'android.notification.color must be in the form #RRGGBB');\n    }\n    if (validator.isNonEmptyArray(notification.bodyLocArgs) &&\n        !validator.isNonEmptyString(notification.bodyLocKey)) {\n        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'android.notification.bodyLocKey is required when specifying bodyLocArgs');\n    }\n    if (validator.isNonEmptyArray(notification.titleLocArgs) &&\n        !validator.isNonEmptyString(notification.titleLocKey)) {\n        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'android.notification.titleLocKey is required when specifying titleLocArgs');\n    }\n    if (typeof notification.imageUrl !== 'undefined' &&\n        !validator.isURL(notification.imageUrl)) {\n        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'android.notification.imageUrl must be a valid URL string');\n    }\n    if (typeof notification.eventTimestamp !== 'undefined') {\n        if (!(notification.eventTimestamp instanceof Date)) {\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'android.notification.eventTimestamp must be a valid `Date` object');\n        }\n        // Convert timestamp to RFC3339 UTC \"Zulu\" format, example \"2014-10-02T15:01:23.045123456Z\"\n        var zuluTimestamp = notification.eventTimestamp.toISOString();\n        notification.eventTimestamp = zuluTimestamp;\n    }\n    if (typeof notification.vibrateTimingsMillis !== 'undefined') {\n        if (!validator.isNonEmptyArray(notification.vibrateTimingsMillis)) {\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'android.notification.vibrateTimingsMillis must be a non-empty array of numbers');\n        }\n        var vibrateTimings_1 = [];\n        notification.vibrateTimingsMillis.forEach(function (value) {\n            if (!validator.isNumber(value) || value < 0) {\n                throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'android.notification.vibrateTimingsMillis must be non-negative durations in milliseconds');\n            }\n            var duration = transformMillisecondsToSecondsString(value);\n            vibrateTimings_1.push(duration);\n        });\n        notification.vibrateTimingsMillis = vibrateTimings_1;\n    }\n    if (typeof notification.priority !== 'undefined') {\n        var priority = 'PRIORITY_' + notification.priority.toUpperCase();\n        notification.priority = priority;\n    }\n    if (typeof notification.visibility !== 'undefined') {\n        var visibility = notification.visibility.toUpperCase();\n        notification.visibility = visibility;\n    }\n    validateLightSettings(notification.lightSettings);\n    var propertyMappings = {\n        clickAction: 'click_action',\n        bodyLocKey: 'body_loc_key',\n        bodyLocArgs: 'body_loc_args',\n        titleLocKey: 'title_loc_key',\n        titleLocArgs: 'title_loc_args',\n        channelId: 'channel_id',\n        imageUrl: 'image',\n        eventTimestamp: 'event_time',\n        localOnly: 'local_only',\n        priority: 'notification_priority',\n        vibrateTimingsMillis: 'vibrate_timings',\n        defaultVibrateTimings: 'default_vibrate_timings',\n        defaultSound: 'default_sound',\n        lightSettings: 'light_settings',\n        defaultLightSettings: 'default_light_settings',\n        notificationCount: 'notification_count',\n    };\n    index_1.renameProperties(notification, propertyMappings);\n}\n/**\n * Checks if the given LightSettings object is valid. The object must have valid color and\n * light on/off duration parameters. If successful, transforms the input object by renaming\n * keys to valid Android keys.\n *\n * @param {LightSettings} lightSettings An object to be validated.\n */\nfunction validateLightSettings(lightSettings) {\n    if (typeof lightSettings === 'undefined') {\n        return;\n    }\n    else if (!validator.isNonNullObject(lightSettings)) {\n        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'android.notification.lightSettings must be a non-null object');\n    }\n    if (!validator.isNumber(lightSettings.lightOnDurationMillis) || lightSettings.lightOnDurationMillis < 0) {\n        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'android.notification.lightSettings.lightOnDurationMillis must be a non-negative duration in milliseconds');\n    }\n    var durationOn = transformMillisecondsToSecondsString(lightSettings.lightOnDurationMillis);\n    lightSettings.lightOnDurationMillis = durationOn;\n    if (!validator.isNumber(lightSettings.lightOffDurationMillis) || lightSettings.lightOffDurationMillis < 0) {\n        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'android.notification.lightSettings.lightOffDurationMillis must be a non-negative duration in milliseconds');\n    }\n    var durationOff = transformMillisecondsToSecondsString(lightSettings.lightOffDurationMillis);\n    lightSettings.lightOffDurationMillis = durationOff;\n    if (!validator.isString(lightSettings.color) ||\n        (!/^#[0-9a-fA-F]{6}$/.test(lightSettings.color) && !/^#[0-9a-fA-F]{8}$/.test(lightSettings.color))) {\n        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'android.notification.lightSettings.color must be in the form #RRGGBB or #RRGGBBAA format');\n    }\n    var colorString = lightSettings.color.length === 7 ? lightSettings.color + 'FF' : lightSettings.color;\n    var rgb = /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/i.exec(colorString);\n    if (!rgb || rgb.length < 4) {\n        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INTERNAL_ERROR, 'regex to extract rgba values from ' + colorString + ' failed.');\n    }\n    var color = {\n        red: parseInt(rgb[1], 16) / 255.0,\n        green: parseInt(rgb[2], 16) / 255.0,\n        blue: parseInt(rgb[3], 16) / 255.0,\n        alpha: parseInt(rgb[4], 16) / 255.0,\n    };\n    lightSettings.color = color;\n    var propertyMappings = {\n        lightOnDurationMillis: 'light_on_duration',\n        lightOffDurationMillis: 'light_off_duration',\n    };\n    index_1.renameProperties(lightSettings, propertyMappings);\n}\n/**\n * Checks if the given AndroidFcmOptions object is valid.\n *\n * @param {AndroidFcmOptions} fcmOptions An object to be validated.\n */\nfunction validateAndroidFcmOptions(fcmOptions) {\n    if (typeof fcmOptions === 'undefined') {\n        return;\n    }\n    else if (!validator.isNonNullObject(fcmOptions)) {\n        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'fcmOptions must be a non-null object');\n    }\n    if (typeof fcmOptions.analyticsLabel !== 'undefined' && !validator.isString(fcmOptions.analyticsLabel)) {\n        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'analyticsLabel must be a string value');\n    }\n}\n/**\n * Transforms milliseconds to the format expected by FCM service.\n * Returns the duration in seconds with up to nine fractional\n * digits, terminated by 's'. Example: \"3.5s\".\n *\n * @param {number} milliseconds The duration in milliseconds.\n * @return {string} The resulting formatted string in seconds with up to nine fractional\n * digits, terminated by 's'.\n */\nfunction transformMillisecondsToSecondsString(milliseconds) {\n    var duration;\n    var seconds = Math.floor(milliseconds / 1000);\n    var nanos = (milliseconds - seconds * 1000) * 1000000;\n    if (nanos > 0) {\n        var nanoString = nanos.toString();\n        while (nanoString.length < 9) {\n            nanoString = '0' + nanoString;\n        }\n        duration = seconds + \".\" + nanoString + \"s\";\n    }\n    else {\n        duration = seconds + \"s\";\n    }\n    return duration;\n}\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/messaging/messaging-types.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/messaging/messaging.js":
/*!********************************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/messaging/messaging.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\n/*!\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar deep_copy_1 = __webpack_require__(/*! ../utils/deep-copy */ \"./src/node_modules/firebase-admin/lib/utils/deep-copy.js\");\nvar messaging_types_1 = __webpack_require__(/*! ./messaging-types */ \"./src/node_modules/firebase-admin/lib/messaging/messaging-types.js\");\nvar messaging_api_request_1 = __webpack_require__(/*! ./messaging-api-request */ \"./src/node_modules/firebase-admin/lib/messaging/messaging-api-request.js\");\nvar error_1 = __webpack_require__(/*! ../utils/error */ \"./src/node_modules/firebase-admin/lib/utils/error.js\");\nvar utils = __webpack_require__(/*! ../utils */ \"./src/node_modules/firebase-admin/lib/utils/index.js\");\nvar validator = __webpack_require__(/*! ../utils/validator */ \"./src/node_modules/firebase-admin/lib/utils/validator.js\");\n/* eslint-disable @typescript-eslint/camelcase */\n// FCM endpoints\nvar FCM_SEND_HOST = 'fcm.googleapis.com';\nvar FCM_SEND_PATH = '/fcm/send';\nvar FCM_TOPIC_MANAGEMENT_HOST = 'iid.googleapis.com';\nvar FCM_TOPIC_MANAGEMENT_ADD_PATH = '/iid/v1:batchAdd';\nvar FCM_TOPIC_MANAGEMENT_REMOVE_PATH = '/iid/v1:batchRemove';\n// Maximum messages that can be included in a batch request.\nvar FCM_MAX_BATCH_SIZE = 500;\n// Key renames for the messaging notification payload object.\nvar CAMELCASED_NOTIFICATION_PAYLOAD_KEYS_MAP = {\n    bodyLocArgs: 'body_loc_args',\n    bodyLocKey: 'body_loc_key',\n    clickAction: 'click_action',\n    titleLocArgs: 'title_loc_args',\n    titleLocKey: 'title_loc_key',\n};\n// Key renames for the messaging options object.\nvar CAMELCASE_OPTIONS_KEYS_MAP = {\n    dryRun: 'dry_run',\n    timeToLive: 'time_to_live',\n    collapseKey: 'collapse_key',\n    mutableContent: 'mutable_content',\n    contentAvailable: 'content_available',\n    restrictedPackageName: 'restricted_package_name',\n};\n// Key renames for the MessagingDeviceResult object.\nvar MESSAGING_DEVICE_RESULT_KEYS_MAP = {\n    message_id: 'messageId',\n    registration_id: 'canonicalRegistrationToken',\n};\n// Key renames for the MessagingDevicesResponse object.\nvar MESSAGING_DEVICES_RESPONSE_KEYS_MAP = {\n    canonical_ids: 'canonicalRegistrationTokenCount',\n    failure: 'failureCount',\n    success: 'successCount',\n    multicast_id: 'multicastId',\n};\n// Key renames for the MessagingDeviceGroupResponse object.\nvar MESSAGING_DEVICE_GROUP_RESPONSE_KEYS_MAP = {\n    success: 'successCount',\n    failure: 'failureCount',\n    failed_registration_ids: 'failedRegistrationTokens',\n};\n// Key renames for the MessagingTopicResponse object.\nvar MESSAGING_TOPIC_RESPONSE_KEYS_MAP = {\n    message_id: 'messageId',\n};\n// Key renames for the MessagingConditionResponse object.\nvar MESSAGING_CONDITION_RESPONSE_KEYS_MAP = {\n    message_id: 'messageId',\n};\n// Keys which are not allowed in the messaging data payload object.\nexports.BLACKLISTED_DATA_PAYLOAD_KEYS = ['from'];\n// Keys which are not allowed in the messaging options object.\nexports.BLACKLISTED_OPTIONS_KEYS = [\n    'condition', 'data', 'notification', 'registrationIds', 'registration_ids', 'to',\n];\n/**\n * Maps a raw FCM server response to a MessagingDevicesResponse object.\n *\n * @param {object} response The raw FCM server response to map.\n *\n * @return {MessagingDeviceGroupResponse} The mapped MessagingDevicesResponse object.\n */\nfunction mapRawResponseToDevicesResponse(response) {\n    // Rename properties on the server response\n    utils.renameProperties(response, MESSAGING_DEVICES_RESPONSE_KEYS_MAP);\n    if ('results' in response) {\n        response.results.forEach(function (messagingDeviceResult) {\n            utils.renameProperties(messagingDeviceResult, MESSAGING_DEVICE_RESULT_KEYS_MAP);\n            // Map the FCM server's error strings to actual error objects.\n            if ('error' in messagingDeviceResult) {\n                var newError = error_1.FirebaseMessagingError.fromServerError(messagingDeviceResult.error, /* message */ undefined, messagingDeviceResult.error);\n                messagingDeviceResult.error = newError;\n            }\n        });\n    }\n    return response;\n}\n/**\n * Maps a raw FCM server response to a MessagingDeviceGroupResponse object.\n *\n * @param {object} response The raw FCM server response to map.\n *\n * @return {MessagingDeviceGroupResponse} The mapped MessagingDeviceGroupResponse object.\n */\nfunction mapRawResponseToDeviceGroupResponse(response) {\n    // Rename properties on the server response\n    utils.renameProperties(response, MESSAGING_DEVICE_GROUP_RESPONSE_KEYS_MAP);\n    // Add the 'failedRegistrationTokens' property if it does not exist on the response, which\n    // it won't when the 'failureCount' property has a value of 0)\n    response.failedRegistrationTokens = response.failedRegistrationTokens || [];\n    return response;\n}\n/**\n * Maps a raw FCM server response to a MessagingTopicManagementResponse object.\n *\n * @param {object} response The raw FCM server response to map.\n *\n * @return {MessagingTopicManagementResponse} The mapped MessagingTopicManagementResponse object.\n */\nfunction mapRawResponseToTopicManagementResponse(response) {\n    // Add the success and failure counts.\n    var result = {\n        successCount: 0,\n        failureCount: 0,\n        errors: [],\n    };\n    if ('results' in response) {\n        response.results.forEach(function (tokenManagementResult, index) {\n            // Map the FCM server's error strings to actual error objects.\n            if ('error' in tokenManagementResult) {\n                result.failureCount += 1;\n                var newError = error_1.FirebaseMessagingError.fromTopicManagementServerError(tokenManagementResult.error, /* message */ undefined, tokenManagementResult.error);\n                result.errors.push({\n                    index: index,\n                    error: newError,\n                });\n            }\n            else {\n                result.successCount += 1;\n            }\n        });\n    }\n    return result;\n}\n/**\n * Internals of a Messaging instance.\n */\nvar MessagingInternals = /** @class */ (function () {\n    function MessagingInternals() {\n    }\n    /**\n     * Deletes the service and its associated resources.\n     *\n     * @return {Promise<()>} An empty Promise that will be fulfilled when the service is deleted.\n     */\n    MessagingInternals.prototype.delete = function () {\n        // There are no resources to clean up.\n        return Promise.resolve(undefined);\n    };\n    return MessagingInternals;\n}());\n/**\n * Messaging service bound to the provided app.\n */\nvar Messaging = /** @class */ (function () {\n    /**\n     * @param {FirebaseApp} app The app for this Messaging service.\n     * @constructor\n     */\n    function Messaging(app) {\n        this.INTERNAL = new MessagingInternals();\n        if (!validator.isNonNullObject(app) || !('options' in app)) {\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'First argument passed to admin.messaging() must be a valid Firebase app instance.');\n        }\n        this.appInternal = app;\n        this.messagingRequestHandler = new messaging_api_request_1.FirebaseMessagingRequestHandler(app);\n    }\n    Object.defineProperty(Messaging.prototype, \"app\", {\n        /**\n         * Returns the app associated with this Messaging instance.\n         *\n         * @return {FirebaseApp} The app associated with this Messaging instance.\n         */\n        get: function () {\n            return this.appInternal;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Sends a message via Firebase Cloud Messaging (FCM).\n     *\n     * @param {Message} message The message to be sent.\n     * @param {boolean=} dryRun Whether to send the message in the dry-run (validation only) mode.\n     *\n     * @return {Promise<string>} A Promise fulfilled with a message ID string.\n     */\n    Messaging.prototype.send = function (message, dryRun) {\n        var _this = this;\n        var copy = deep_copy_1.deepCopy(message);\n        messaging_types_1.validateMessage(copy);\n        if (typeof dryRun !== 'undefined' && !validator.isBoolean(dryRun)) {\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'dryRun must be a boolean');\n        }\n        return this.getUrlPath()\n            .then(function (urlPath) {\n            var request = { message: copy };\n            if (dryRun) {\n                request.validate_only = true;\n            }\n            return _this.messagingRequestHandler.invokeRequestHandler(FCM_SEND_HOST, urlPath, request);\n        })\n            .then(function (response) {\n            return response.name;\n        });\n    };\n    /**\n     * Sends all the messages in the given array via Firebase Cloud Messaging. Employs batching to\n     * send the entire list as a single RPC call. Compared to the send() method, this method is a\n     * significantly more efficient way to send multiple messages.\n     *\n     * The responses list obtained from the return value corresponds to the order of input messages.\n     * An error from this method indicates a total failure -- i.e. none of the messages in the\n     * list could be sent. Partial failures are indicated by a BatchResponse return value.\n     *\n     * @param {Message[]} messages A non-empty array containing up to 500 messages.\n     * @param {boolean=} dryRun Whether to send the message in the dry-run (validation only) mode.\n     *\n     * @return {Promise<BatchResponse>} A Promise fulfilled with an object representing the result\n     *     of the send operation.\n     */\n    Messaging.prototype.sendAll = function (messages, dryRun) {\n        var _this = this;\n        if (validator.isArray(messages) && messages.constructor !== Array) {\n            // In more recent JS specs, an array-like object might have a constructor that is not of\n            // Array type. Our deepCopy() method doesn't handle them properly. Convert such objects to\n            // a regular array here before calling deepCopy(). See issue #566 for details.\n            messages = Array.from(messages);\n        }\n        var copy = deep_copy_1.deepCopy(messages);\n        if (!validator.isNonEmptyArray(copy)) {\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'messages must be a non-empty array');\n        }\n        if (copy.length > FCM_MAX_BATCH_SIZE) {\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, \"messages list must not contain more than \" + FCM_MAX_BATCH_SIZE + \" items\");\n        }\n        if (typeof dryRun !== 'undefined' && !validator.isBoolean(dryRun)) {\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'dryRun must be a boolean');\n        }\n        return this.getUrlPath()\n            .then(function (urlPath) {\n            var requests = copy.map(function (message) {\n                messaging_types_1.validateMessage(message);\n                var request = { message: message };\n                if (dryRun) {\n                    request.validate_only = true;\n                }\n                return {\n                    url: \"https://\" + FCM_SEND_HOST + urlPath,\n                    body: request,\n                };\n            });\n            return _this.messagingRequestHandler.sendBatchRequest(requests);\n        });\n    };\n    /**\n     * Sends the given multicast message to all the FCM registration tokens specified in it.\n     *\n     * This method uses the sendAll() API under the hood to send the given\n     * message to all the target recipients. The responses list obtained from the return value\n     * corresponds to the order of tokens in the MulticastMessage. An error from this method\n     * indicates a total failure -- i.e. none of the tokens in the list could be sent to. Partial\n     * failures are indicated by a BatchResponse return value.\n     *\n     * @param {MulticastMessage} message A multicast message containing up to 500 tokens.\n     * @param {boolean=} dryRun Whether to send the message in the dry-run (validation only) mode.\n     *\n     * @return {Promise<BatchResponse>} A Promise fulfilled with an object representing the result\n     *     of the send operation.\n     */\n    Messaging.prototype.sendMulticast = function (message, dryRun) {\n        var copy = deep_copy_1.deepCopy(message);\n        if (!validator.isNonNullObject(copy)) {\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'MulticastMessage must be a non-null object');\n        }\n        if (!validator.isNonEmptyArray(copy.tokens)) {\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'tokens must be a non-empty array');\n        }\n        if (copy.tokens.length > FCM_MAX_BATCH_SIZE) {\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, \"tokens list must not contain more than \" + FCM_MAX_BATCH_SIZE + \" items\");\n        }\n        var messages = copy.tokens.map(function (token) {\n            return {\n                token: token,\n                android: copy.android,\n                apns: copy.apns,\n                data: copy.data,\n                notification: copy.notification,\n                webpush: copy.webpush,\n                fcmOptions: copy.fcmOptions,\n            };\n        });\n        return this.sendAll(messages, dryRun);\n    };\n    /**\n     * Sends an FCM message to a single device or an array of devices.\n     *\n     * @param {string|string[]} registrationTokenOrTokens The registration token or an array of\n     *     registration tokens for the device(s) to which to send the message.\n     * @param {MessagingPayload} payload The message payload.\n     * @param {MessagingOptions} [options = {}] Optional options to alter the message.\n     *\n     * @return {Promise<MessagingDevicesResponse|MessagingDeviceGroupResponse>} A Promise fulfilled\n     *     with the server's response after the message has been sent.\n     */\n    Messaging.prototype.sendToDevice = function (registrationTokenOrTokens, payload, options) {\n        var _this = this;\n        if (options === void 0) { options = {}; }\n        // Validate the input argument types. Since these are common developer errors when getting\n        // started, throw an error instead of returning a rejected promise.\n        this.validateRegistrationTokensType(registrationTokenOrTokens, 'sendToDevice', error_1.MessagingClientErrorCode.INVALID_RECIPIENT);\n        this.validateMessagingPayloadAndOptionsTypes(payload, options);\n        return Promise.resolve()\n            .then(function () {\n            // Validate the contents of the input arguments. Because we are now in a promise, any thrown\n            // error will cause this method to return a rejected promise.\n            _this.validateRegistrationTokens(registrationTokenOrTokens, 'sendToDevice', error_1.MessagingClientErrorCode.INVALID_RECIPIENT);\n            var payloadCopy = _this.validateMessagingPayload(payload);\n            var optionsCopy = _this.validateMessagingOptions(options);\n            var request = deep_copy_1.deepCopy(payloadCopy);\n            deep_copy_1.deepExtend(request, optionsCopy);\n            if (validator.isString(registrationTokenOrTokens)) {\n                request.to = registrationTokenOrTokens;\n            }\n            else {\n                request.registration_ids = registrationTokenOrTokens;\n            }\n            return _this.messagingRequestHandler.invokeRequestHandler(FCM_SEND_HOST, FCM_SEND_PATH, request);\n        })\n            .then(function (response) {\n            // The sendToDevice() and sendToDeviceGroup() methods both set the `to` query parameter in\n            // the underlying FCM request. If the provided registration token argument is actually a\n            // valid notification key, the response from the FCM server will be a device group response.\n            // If that is the case, we map the response to a MessagingDeviceGroupResponse.\n            // See b/35394951 for more context.\n            if ('multicast_id' in response) {\n                return mapRawResponseToDevicesResponse(response);\n            }\n            else {\n                return mapRawResponseToDeviceGroupResponse(response);\n            }\n        });\n    };\n    /**\n     * Sends an FCM message to a device group.\n     *\n     * @param {string} notificationKey The notification key representing the device group to which to\n     *     send the message.\n     * @param {MessagingPayload} payload The message payload.\n     * @param {MessagingOptions} [options = {}] Optional options to alter the message.\n     *\n     * @return {Promise<MessagingDeviceGroupResponse|MessagingDevicesResponse>} A Promise fulfilled\n     *     with the server's response after the message has been sent.\n     */\n    Messaging.prototype.sendToDeviceGroup = function (notificationKey, payload, options) {\n        var _this = this;\n        if (options === void 0) { options = {}; }\n        if (!validator.isNonEmptyString(notificationKey)) {\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_RECIPIENT, 'Notification key provided to sendToDeviceGroup() must be a non-empty string.');\n        }\n        else if (notificationKey.indexOf(':') !== -1) {\n            // It is possible the developer provides a registration token instead of a notification key\n            // to this method. We can detect some of those cases by checking to see if the string contains\n            // a colon. Not all registration tokens will contain a colon (only newer ones will), but no\n            // notification keys will contain a colon, so we can use it as a rough heuristic.\n            // See b/35394951 for more context.\n            return Promise.reject(new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_RECIPIENT, 'Notification key provided to sendToDeviceGroup() has the format of a registration token. ' +\n                'You should use sendToDevice() instead.'));\n        }\n        // Validate the types of the payload and options arguments. Since these are common developer\n        // errors, throw an error instead of returning a rejected promise.\n        this.validateMessagingPayloadAndOptionsTypes(payload, options);\n        return Promise.resolve()\n            .then(function () {\n            // Validate the contents of the payload and options objects. Because we are now in a\n            // promise, any thrown error will cause this method to return a rejected promise.\n            var payloadCopy = _this.validateMessagingPayload(payload);\n            var optionsCopy = _this.validateMessagingOptions(options);\n            var request = deep_copy_1.deepCopy(payloadCopy);\n            deep_copy_1.deepExtend(request, optionsCopy);\n            request.to = notificationKey;\n            return _this.messagingRequestHandler.invokeRequestHandler(FCM_SEND_HOST, FCM_SEND_PATH, request);\n        })\n            .then(function (response) {\n            // The sendToDevice() and sendToDeviceGroup() methods both set the `to` query parameter in\n            // the underlying FCM request. If the provided notification key argument has an invalid\n            // format (that is, it is either a registration token or some random string), the response\n            // from the FCM server will default to a devices response (which we detect by looking for\n            // the `multicast_id` property). If that is the case, we either throw an error saying the\n            // provided notification key is invalid (if the message failed to send) or map the response\n            // to a MessagingDevicesResponse (if the message succeeded).\n            // See b/35394951 for more context.\n            if ('multicast_id' in response) {\n                if (response.success === 0) {\n                    throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_RECIPIENT, 'Notification key provided to sendToDeviceGroup() is invalid.');\n                }\n                else {\n                    return mapRawResponseToDevicesResponse(response);\n                }\n            }\n            return mapRawResponseToDeviceGroupResponse(response);\n        });\n    };\n    /**\n     * Sends an FCM message to a topic.\n     *\n     * @param {string} topic The name of the topic to which to send the message.\n     * @param {MessagingPayload} payload The message payload.\n     * @param {MessagingOptions} [options = {}] Optional options to alter the message.\n     *\n     * @return {Promise<MessagingTopicResponse>} A Promise fulfilled with the server's response after\n     *     the message has been sent.\n     */\n    Messaging.prototype.sendToTopic = function (topic, payload, options) {\n        var _this = this;\n        if (options === void 0) { options = {}; }\n        // Validate the input argument types. Since these are common developer errors when getting\n        // started, throw an error instead of returning a rejected promise.\n        this.validateTopicType(topic, 'sendToTopic', error_1.MessagingClientErrorCode.INVALID_RECIPIENT);\n        this.validateMessagingPayloadAndOptionsTypes(payload, options);\n        // Prepend the topic with /topics/ if necessary.\n        topic = this.normalizeTopic(topic);\n        return Promise.resolve()\n            .then(function () {\n            // Validate the contents of the payload and options objects. Because we are now in a\n            // promise, any thrown error will cause this method to return a rejected promise.\n            var payloadCopy = _this.validateMessagingPayload(payload);\n            var optionsCopy = _this.validateMessagingOptions(options);\n            _this.validateTopic(topic, 'sendToTopic', error_1.MessagingClientErrorCode.INVALID_RECIPIENT);\n            var request = deep_copy_1.deepCopy(payloadCopy);\n            deep_copy_1.deepExtend(request, optionsCopy);\n            request.to = topic;\n            return _this.messagingRequestHandler.invokeRequestHandler(FCM_SEND_HOST, FCM_SEND_PATH, request);\n        })\n            .then(function (response) {\n            // Rename properties on the server response\n            utils.renameProperties(response, MESSAGING_TOPIC_RESPONSE_KEYS_MAP);\n            return response;\n        });\n    };\n    /**\n     * Sends an FCM message to a condition.\n     *\n     * @param {string} condition The condition to which to send the message.\n     * @param {MessagingPayload} payload The message payload.\n     * @param {MessagingOptions} [options = {}] Optional options to alter the message.\n     *\n     * @return {Promise<MessagingConditionResponse>} A Promise fulfilled with the server's response\n     *     after the message has been sent.\n     */\n    Messaging.prototype.sendToCondition = function (condition, payload, options) {\n        var _this = this;\n        if (options === void 0) { options = {}; }\n        if (!validator.isNonEmptyString(condition)) {\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_RECIPIENT, 'Condition provided to sendToCondition() must be a non-empty string.');\n        }\n        // Validate the types of the payload and options arguments. Since these are common developer\n        // errors, throw an error instead of returning a rejected promise.\n        this.validateMessagingPayloadAndOptionsTypes(payload, options);\n        // The FCM server rejects conditions which are surrounded in single quotes. When the condition\n        // is stringified over the wire, double quotes in it get converted to \\\" which the FCM server\n        // does not properly handle. We can get around this by replacing internal double quotes with\n        // single quotes.\n        condition = condition.replace(/\"/g, '\\'');\n        return Promise.resolve()\n            .then(function () {\n            // Validate the contents of the payload and options objects. Because we are now in a\n            // promise, any thrown error will cause this method to return a rejected promise.\n            var payloadCopy = _this.validateMessagingPayload(payload);\n            var optionsCopy = _this.validateMessagingOptions(options);\n            var request = deep_copy_1.deepCopy(payloadCopy);\n            deep_copy_1.deepExtend(request, optionsCopy);\n            request.condition = condition;\n            return _this.messagingRequestHandler.invokeRequestHandler(FCM_SEND_HOST, FCM_SEND_PATH, request);\n        })\n            .then(function (response) {\n            // Rename properties on the server response\n            utils.renameProperties(response, MESSAGING_CONDITION_RESPONSE_KEYS_MAP);\n            return response;\n        });\n    };\n    /**\n     * Subscribes a single device or an array of devices to a topic.\n     *\n     * @param {string|string[]} registrationTokenOrTokens The registration token or an array of\n     *     registration tokens to subscribe to the topic.\n     * @param {string} topic The topic to which to subscribe.\n     *\n     * @return {Promise<MessagingTopicManagementResponse>} A Promise fulfilled with the parsed FCM\n     *   server response.\n     */\n    Messaging.prototype.subscribeToTopic = function (registrationTokenOrTokens, topic) {\n        return this.sendTopicManagementRequest(registrationTokenOrTokens, topic, 'subscribeToTopic', FCM_TOPIC_MANAGEMENT_ADD_PATH);\n    };\n    /**\n     * Unsubscribes a single device or an array of devices from a topic.\n     *\n     * @param {string|string[]} registrationTokenOrTokens The registration token or an array of\n     *     registration tokens to unsubscribe from the topic.\n     * @param {string} topic The topic to which to subscribe.\n     *\n     * @return {Promise<MessagingTopicManagementResponse>} A Promise fulfilled with the parsed FCM\n     *   server response.\n     */\n    Messaging.prototype.unsubscribeFromTopic = function (registrationTokenOrTokens, topic) {\n        return this.sendTopicManagementRequest(registrationTokenOrTokens, topic, 'unsubscribeFromTopic', FCM_TOPIC_MANAGEMENT_REMOVE_PATH);\n    };\n    Messaging.prototype.getUrlPath = function () {\n        var _this = this;\n        if (this.urlPath) {\n            return Promise.resolve(this.urlPath);\n        }\n        return utils.findProjectId(this.app)\n            .then(function (projectId) {\n            if (!validator.isNonEmptyString(projectId)) {\n                // Assert for an explicit project ID (either via AppOptions or the cert itself).\n                throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'Failed to determine project ID for Messaging. Initialize the '\n                    + 'SDK with service account credentials or set project ID as an app option. '\n                    + 'Alternatively set the GOOGLE_CLOUD_PROJECT environment variable.');\n            }\n            _this.urlPath = \"/v1/projects/\" + projectId + \"/messages:send\";\n            return _this.urlPath;\n        });\n    };\n    /**\n     * Helper method which sends and handles topic subscription management requests.\n     *\n     * @param {string|string[]} registrationTokenOrTokens The registration token or an array of\n     *     registration tokens to unsubscribe from the topic.\n     * @param {string} topic The topic to which to subscribe.\n     * @param {string} methodName The name of the original method called.\n     * @param {string} path The endpoint path to use for the request.\n     *\n     * @return {Promise<MessagingTopicManagementResponse>} A Promise fulfilled with the parsed server\n     *   response.\n     */\n    Messaging.prototype.sendTopicManagementRequest = function (registrationTokenOrTokens, topic, methodName, path) {\n        var _this = this;\n        this.validateRegistrationTokensType(registrationTokenOrTokens, methodName);\n        this.validateTopicType(topic, methodName);\n        // Prepend the topic with /topics/ if necessary.\n        topic = this.normalizeTopic(topic);\n        return Promise.resolve()\n            .then(function () {\n            // Validate the contents of the input arguments. Because we are now in a promise, any thrown\n            // error will cause this method to return a rejected promise.\n            _this.validateRegistrationTokens(registrationTokenOrTokens, methodName);\n            _this.validateTopic(topic, methodName);\n            // Ensure the registration token(s) input argument is an array.\n            var registrationTokensArray = registrationTokenOrTokens;\n            if (validator.isString(registrationTokenOrTokens)) {\n                registrationTokensArray = [registrationTokenOrTokens];\n            }\n            var request = {\n                to: topic,\n                registration_tokens: registrationTokensArray,\n            };\n            return _this.messagingRequestHandler.invokeRequestHandler(FCM_TOPIC_MANAGEMENT_HOST, path, request);\n        })\n            .then(function (response) {\n            return mapRawResponseToTopicManagementResponse(response);\n        });\n    };\n    /**\n     * Validates the types of the messaging payload and options. If invalid, an error will be thrown.\n     *\n     * @param {MessagingPayload} payload The messaging payload to validate.\n     * @param {MessagingOptions} options The messaging options to validate.\n     */\n    Messaging.prototype.validateMessagingPayloadAndOptionsTypes = function (payload, options) {\n        // Validate the payload is an object\n        if (!validator.isNonNullObject(payload)) {\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'Messaging payload must be an object with at least one of the \"data\" or \"notification\" properties.');\n        }\n        // Validate the options argument is an object\n        if (!validator.isNonNullObject(options)) {\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, 'Messaging options must be an object.');\n        }\n    };\n    /**\n     * Validates the messaging payload. If invalid, an error will be thrown.\n     *\n     * @param {MessagingPayload} payload The messaging payload to validate.\n     *\n     * @return {MessagingPayload} A copy of the provided payload with whitelisted properties switched\n     *     from camelCase to underscore_case.\n     */\n    Messaging.prototype.validateMessagingPayload = function (payload) {\n        var payloadCopy = deep_copy_1.deepCopy(payload);\n        var payloadKeys = Object.keys(payloadCopy);\n        var validPayloadKeys = ['data', 'notification'];\n        var containsDataOrNotificationKey = false;\n        payloadKeys.forEach(function (payloadKey) {\n            // Validate the payload does not contain any invalid keys\n            if (validPayloadKeys.indexOf(payloadKey) === -1) {\n                throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, \"Messaging payload contains an invalid \\\"\" + payloadKey + \"\\\" property. Valid properties are \" +\n                    \"\\\"data\\\" and \\\"notification\\\".\");\n            }\n            else {\n                containsDataOrNotificationKey = true;\n            }\n        });\n        // Validate the payload contains at least one of the \"data\" and \"notification\" keys\n        if (!containsDataOrNotificationKey) {\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'Messaging payload must contain at least one of the \"data\" or \"notification\" properties.');\n        }\n        var validatePayload = function (payloadKey, value) {\n            // Validate each top-level key in the payload is an object\n            if (!validator.isNonNullObject(value)) {\n                throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, \"Messaging payload contains an invalid value for the \\\"\" + payloadKey + \"\\\" property. \" +\n                    \"Value must be an object.\");\n            }\n            Object.keys(value).forEach(function (subKey) {\n                if (!validator.isString(value[subKey])) {\n                    // Validate all sub-keys have a string value\n                    throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, \"Messaging payload contains an invalid value for the \\\"\" + payloadKey + \".\" + subKey + \"\\\" \" +\n                        \"property. Values must be strings.\");\n                }\n                else if (payloadKey === 'data' && /^google\\./.test(subKey)) {\n                    // Validate the data payload does not contain keys which start with 'google.'.\n                    throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, \"Messaging payload contains the blacklisted \\\"data.\" + subKey + \"\\\" property.\");\n                }\n            });\n        };\n        if (payloadCopy.data !== undefined) {\n            validatePayload('data', payloadCopy.data);\n        }\n        if (payloadCopy.notification !== undefined) {\n            validatePayload('notification', payloadCopy.notification);\n        }\n        // Validate the data payload object does not contain blacklisted properties\n        if ('data' in payloadCopy) {\n            exports.BLACKLISTED_DATA_PAYLOAD_KEYS.forEach(function (blacklistedKey) {\n                if (blacklistedKey in payloadCopy.data) {\n                    throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, \"Messaging payload contains the blacklisted \\\"data.\" + blacklistedKey + \"\\\" property.\");\n                }\n            });\n        }\n        // Convert whitelisted camelCase keys to underscore_case\n        if (payloadCopy.notification) {\n            utils.renameProperties(payloadCopy.notification, CAMELCASED_NOTIFICATION_PAYLOAD_KEYS_MAP);\n        }\n        return payloadCopy;\n    };\n    /**\n     * Validates the messaging options. If invalid, an error will be thrown.\n     *\n     * @param {MessagingOptions} options The messaging options to validate.\n     *\n     * @return {MessagingOptions} A copy of the provided options with whitelisted properties switched\n     *   from camelCase to underscore_case.\n     */\n    Messaging.prototype.validateMessagingOptions = function (options) {\n        var optionsCopy = deep_copy_1.deepCopy(options);\n        // Validate the options object does not contain blacklisted properties\n        exports.BLACKLISTED_OPTIONS_KEYS.forEach(function (blacklistedKey) {\n            if (blacklistedKey in optionsCopy) {\n                throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, \"Messaging options contains the blacklisted \\\"\" + blacklistedKey + \"\\\" property.\");\n            }\n        });\n        // Convert whitelisted camelCase keys to underscore_case\n        utils.renameProperties(optionsCopy, CAMELCASE_OPTIONS_KEYS_MAP);\n        // Validate the options object contains valid values for whitelisted properties\n        if ('collapse_key' in optionsCopy && !validator.isNonEmptyString(optionsCopy.collapse_key)) {\n            var keyName = ('collapseKey' in options) ? 'collapseKey' : 'collapse_key';\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, \"Messaging options contains an invalid value for the \\\"\" + keyName + \"\\\" property. Value must \" +\n                'be a non-empty string.');\n        }\n        else if ('dry_run' in optionsCopy && !validator.isBoolean(optionsCopy.dry_run)) {\n            var keyName = ('dryRun' in options) ? 'dryRun' : 'dry_run';\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, \"Messaging options contains an invalid value for the \\\"\" + keyName + \"\\\" property. Value must \" +\n                'be a boolean.');\n        }\n        else if ('priority' in optionsCopy && !validator.isNonEmptyString(optionsCopy.priority)) {\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, 'Messaging options contains an invalid value for the \"priority\" property. Value must ' +\n                'be a non-empty string.');\n        }\n        else if ('restricted_package_name' in optionsCopy &&\n            !validator.isNonEmptyString(optionsCopy.restricted_package_name)) {\n            var keyName = ('restrictedPackageName' in options) ? 'restrictedPackageName' : 'restricted_package_name';\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, \"Messaging options contains an invalid value for the \\\"\" + keyName + \"\\\" property. Value must \" +\n                'be a non-empty string.');\n        }\n        else if ('time_to_live' in optionsCopy && !validator.isNumber(optionsCopy.time_to_live)) {\n            var keyName = ('timeToLive' in options) ? 'timeToLive' : 'time_to_live';\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, \"Messaging options contains an invalid value for the \\\"\" + keyName + \"\\\" property. Value must \" +\n                'be a number.');\n        }\n        else if ('content_available' in optionsCopy && !validator.isBoolean(optionsCopy.content_available)) {\n            var keyName = ('contentAvailable' in options) ? 'contentAvailable' : 'content_available';\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, \"Messaging options contains an invalid value for the \\\"\" + keyName + \"\\\" property. Value must \" +\n                'be a boolean.');\n        }\n        else if ('mutable_content' in optionsCopy && !validator.isBoolean(optionsCopy.mutable_content)) {\n            var keyName = ('mutableContent' in options) ? 'mutableContent' : 'mutable_content';\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, \"Messaging options contains an invalid value for the \\\"\" + keyName + \"\\\" property. Value must \" +\n                'be a boolean.');\n        }\n        return optionsCopy;\n    };\n    /**\n     * Validates the type of the provided registration token(s). If invalid, an error will be thrown.\n     *\n     * @param {string|string[]} registrationTokenOrTokens The registration token(s) to validate.\n     * @param {string} method The method name to use in error messages.\n     * @param {ErrorInfo?} [errorInfo] The error info to use if the registration tokens are invalid.\n     */\n    Messaging.prototype.validateRegistrationTokensType = function (registrationTokenOrTokens, methodName, errorInfo) {\n        if (errorInfo === void 0) { errorInfo = error_1.MessagingClientErrorCode.INVALID_ARGUMENT; }\n        if (!validator.isNonEmptyArray(registrationTokenOrTokens) &&\n            !validator.isNonEmptyString(registrationTokenOrTokens)) {\n            throw new error_1.FirebaseMessagingError(errorInfo, \"Registration token(s) provided to \" + methodName + \"() must be a non-empty string or a \" +\n                'non-empty array.');\n        }\n    };\n    /**\n     * Validates the provided registration tokens. If invalid, an error will be thrown.\n     *\n     * @param {string|string[]} registrationTokenOrTokens The registration token or an array of\n     *     registration tokens to validate.\n     * @param {string} method The method name to use in error messages.\n     * @param {errorInfo?} [ErrorInfo] The error info to use if the registration tokens are invalid.\n     */\n    Messaging.prototype.validateRegistrationTokens = function (registrationTokenOrTokens, methodName, errorInfo) {\n        if (errorInfo === void 0) { errorInfo = error_1.MessagingClientErrorCode.INVALID_ARGUMENT; }\n        if (validator.isArray(registrationTokenOrTokens)) {\n            // Validate the array contains no more than 1,000 registration tokens.\n            if (registrationTokenOrTokens.length > 1000) {\n                throw new error_1.FirebaseMessagingError(errorInfo, \"Too many registration tokens provided in a single request to \" + methodName + \"(). Batch \" +\n                    'your requests to contain no more than 1,000 registration tokens per request.');\n            }\n            // Validate the array contains registration tokens which are non-empty strings.\n            registrationTokenOrTokens.forEach(function (registrationToken, index) {\n                if (!validator.isNonEmptyString(registrationToken)) {\n                    throw new error_1.FirebaseMessagingError(errorInfo, \"Registration token provided to \" + methodName + \"() at index \" + index + \" must be a \" +\n                        'non-empty string.');\n                }\n            });\n        }\n    };\n    /**\n     * Validates the type of the provided topic. If invalid, an error will be thrown.\n     *\n     * @param {string} topic The topic to validate.\n     * @param {string} method The method name to use in error messages.\n     * @param {ErrorInfo?} [errorInfo] The error info to use if the topic is invalid.\n     */\n    Messaging.prototype.validateTopicType = function (topic, methodName, errorInfo) {\n        if (errorInfo === void 0) { errorInfo = error_1.MessagingClientErrorCode.INVALID_ARGUMENT; }\n        if (!validator.isNonEmptyString(topic)) {\n            throw new error_1.FirebaseMessagingError(errorInfo, \"Topic provided to \" + methodName + \"() must be a string which matches the format \" +\n                '\"/topics/[a-zA-Z0-9-_.~%]+\".');\n        }\n    };\n    /**\n     * Validates the provided topic. If invalid, an error will be thrown.\n     *\n     * @param {string} topic The topic to validate.\n     * @param {string} method The method name to use in error messages.\n     * @param {ErrorInfo?} [errorInfo] The error info to use if the topic is invalid.\n     */\n    Messaging.prototype.validateTopic = function (topic, methodName, errorInfo) {\n        if (errorInfo === void 0) { errorInfo = error_1.MessagingClientErrorCode.INVALID_ARGUMENT; }\n        if (!validator.isTopic(topic)) {\n            throw new error_1.FirebaseMessagingError(errorInfo, \"Topic provided to \" + methodName + \"() must be a string which matches the format \" +\n                '\"/topics/[a-zA-Z0-9-_.~%]+\".');\n        }\n    };\n    /**\n     * Normalizes the provided topic name by prepending it with '/topics/', if necessary.\n     *\n     * @param {string} topic The topic name to normalize.\n     *\n     * @return {string} The normalized topic name.\n     */\n    Messaging.prototype.normalizeTopic = function (topic) {\n        if (!/^\\/topics\\//.test(topic)) {\n            topic = \"/topics/\" + topic;\n        }\n        return topic;\n    };\n    return Messaging;\n}());\nexports.Messaging = Messaging;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/messaging/messaging.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/project-management/android-app.js":
/*!*******************************************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/project-management/android-app.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\n/*!\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar error_1 = __webpack_require__(/*! ../utils/error */ \"./src/node_modules/firebase-admin/lib/utils/error.js\");\nvar validator = __webpack_require__(/*! ../utils/validator */ \"./src/node_modules/firebase-admin/lib/utils/validator.js\");\nvar project_management_api_request_1 = __webpack_require__(/*! ./project-management-api-request */ \"./src/node_modules/firebase-admin/lib/project-management/project-management-api-request.js\");\nvar app_metadata_1 = __webpack_require__(/*! ./app-metadata */ \"./src/node_modules/firebase-admin/lib/project-management/app-metadata.js\");\nvar AndroidApp = /** @class */ (function () {\n    function AndroidApp(appId, requestHandler) {\n        this.appId = appId;\n        this.requestHandler = requestHandler;\n        if (!validator.isNonEmptyString(appId)) {\n            throw new error_1.FirebaseProjectManagementError('invalid-argument', 'appId must be a non-empty string.');\n        }\n        this.resourceName = \"projects/-/androidApps/\" + appId;\n    }\n    AndroidApp.prototype.getMetadata = function () {\n        return this.requestHandler.getResource(this.resourceName)\n            .then(function (responseData) {\n            project_management_api_request_1.assertServerResponse(validator.isNonNullObject(responseData), responseData, 'getMetadata()\\'s responseData must be a non-null object.');\n            var requiredFieldsList = ['name', 'appId', 'projectId', 'packageName'];\n            requiredFieldsList.forEach(function (requiredField) {\n                project_management_api_request_1.assertServerResponse(validator.isNonEmptyString(responseData[requiredField]), responseData, \"getMetadata()'s responseData.\" + requiredField + \" must be a non-empty string.\");\n            });\n            var metadata = {\n                platform: app_metadata_1.AppPlatform.ANDROID,\n                resourceName: responseData.name,\n                appId: responseData.appId,\n                displayName: responseData.displayName || null,\n                projectId: responseData.projectId,\n                packageName: responseData.packageName,\n            };\n            return metadata;\n        });\n    };\n    AndroidApp.prototype.setDisplayName = function (newDisplayName) {\n        return this.requestHandler.setDisplayName(this.resourceName, newDisplayName);\n    };\n    AndroidApp.prototype.getShaCertificates = function () {\n        return this.requestHandler.getAndroidShaCertificates(this.resourceName)\n            .then(function (responseData) {\n            project_management_api_request_1.assertServerResponse(validator.isNonNullObject(responseData), responseData, 'getShaCertificates()\\'s responseData must be a non-null object.');\n            if (!responseData.certificates) {\n                return [];\n            }\n            project_management_api_request_1.assertServerResponse(validator.isArray(responseData.certificates), responseData, '\"certificates\" field must be present in the getShaCertificates() response data.');\n            var requiredFieldsList = ['name', 'shaHash'];\n            return responseData.certificates.map(function (certificateJson) {\n                requiredFieldsList.forEach(function (requiredField) {\n                    project_management_api_request_1.assertServerResponse(validator.isNonEmptyString(certificateJson[requiredField]), responseData, \"getShaCertificates()'s responseData.certificates[].\" + requiredField + \" must be a \"\n                        + \"non-empty string.\");\n                });\n                return new ShaCertificate(certificateJson.shaHash, certificateJson.name);\n            });\n        });\n    };\n    AndroidApp.prototype.addShaCertificate = function (certificateToAdd) {\n        return this.requestHandler.addAndroidShaCertificate(this.resourceName, certificateToAdd);\n    };\n    AndroidApp.prototype.deleteShaCertificate = function (certificateToDelete) {\n        if (!certificateToDelete.resourceName) {\n            throw new error_1.FirebaseProjectManagementError('invalid-argument', 'Specified certificate does not include a resourceName. (Use AndroidApp.getShaCertificates() to retrieve ' +\n                'certificates with a resourceName.');\n        }\n        return this.requestHandler.deleteResource(certificateToDelete.resourceName);\n    };\n    /**\n     * @return {Promise<string>} A promise that resolves to a UTF-8 JSON string, typically intended to\n     *     be written to a JSON file.\n     */\n    AndroidApp.prototype.getConfig = function () {\n        return this.requestHandler.getConfig(this.resourceName)\n            .then(function (responseData) {\n            project_management_api_request_1.assertServerResponse(validator.isNonNullObject(responseData), responseData, 'getConfig()\\'s responseData must be a non-null object.');\n            var base64ConfigFileContents = responseData.configFileContents;\n            project_management_api_request_1.assertServerResponse(validator.isBase64String(base64ConfigFileContents), responseData, \"getConfig()'s responseData.configFileContents must be a base64 string.\");\n            return Buffer.from(base64ConfigFileContents, 'base64').toString('utf8');\n        });\n    };\n    return AndroidApp;\n}());\nexports.AndroidApp = AndroidApp;\nvar ShaCertificate = /** @class */ (function () {\n    /**\n     * Creates a ShaCertificate using the given hash. The ShaCertificate's type (eg. 'sha256') is\n     * automatically determined from the hash itself.\n     *\n     * @param shaHash The sha256 or sha1 hash for this certificate.\n     * @param resourceName The Firebase resource name for this certificate. This does not need to be\n     *     set when creating a new certificate.\n     */\n    function ShaCertificate(shaHash, resourceName) {\n        this.shaHash = shaHash;\n        this.resourceName = resourceName;\n        if (/^[a-fA-F0-9]{40}$/.test(shaHash)) {\n            this.certType = 'sha1';\n        }\n        else if (/^[a-fA-F0-9]{64}$/.test(shaHash)) {\n            this.certType = 'sha256';\n        }\n        else {\n            throw new error_1.FirebaseProjectManagementError('invalid-argument', 'shaHash must be either a sha256 hash or a sha1 hash.');\n        }\n    }\n    return ShaCertificate;\n}());\nexports.ShaCertificate = ShaCertificate;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/project-management/android-app.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/project-management/app-metadata.js":
/*!********************************************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/project-management/app-metadata.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\n/*!\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar AppPlatform;\n(function (AppPlatform) {\n    AppPlatform[\"PLATFORM_UNKNOWN\"] = \"PLATFORM_UNKNOWN\";\n    AppPlatform[\"IOS\"] = \"IOS\";\n    AppPlatform[\"ANDROID\"] = \"ANDROID\";\n})(AppPlatform = exports.AppPlatform || (exports.AppPlatform = {}));\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/project-management/app-metadata.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/project-management/ios-app.js":
/*!***************************************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/project-management/ios-app.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\n/*!\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar error_1 = __webpack_require__(/*! ../utils/error */ \"./src/node_modules/firebase-admin/lib/utils/error.js\");\nvar validator = __webpack_require__(/*! ../utils/validator */ \"./src/node_modules/firebase-admin/lib/utils/validator.js\");\nvar project_management_api_request_1 = __webpack_require__(/*! ./project-management-api-request */ \"./src/node_modules/firebase-admin/lib/project-management/project-management-api-request.js\");\nvar app_metadata_1 = __webpack_require__(/*! ./app-metadata */ \"./src/node_modules/firebase-admin/lib/project-management/app-metadata.js\");\nvar IosApp = /** @class */ (function () {\n    function IosApp(appId, requestHandler) {\n        this.appId = appId;\n        this.requestHandler = requestHandler;\n        if (!validator.isNonEmptyString(appId)) {\n            throw new error_1.FirebaseProjectManagementError('invalid-argument', 'appId must be a non-empty string.');\n        }\n        this.resourceName = \"projects/-/iosApps/\" + appId;\n    }\n    IosApp.prototype.getMetadata = function () {\n        return this.requestHandler.getResource(this.resourceName)\n            .then(function (responseData) {\n            project_management_api_request_1.assertServerResponse(validator.isNonNullObject(responseData), responseData, 'getMetadata()\\'s responseData must be a non-null object.');\n            var requiredFieldsList = ['name', 'appId', 'projectId', 'bundleId'];\n            requiredFieldsList.forEach(function (requiredField) {\n                project_management_api_request_1.assertServerResponse(validator.isNonEmptyString(responseData[requiredField]), responseData, \"getMetadata()'s responseData.\" + requiredField + \" must be a non-empty string.\");\n            });\n            var metadata = {\n                platform: app_metadata_1.AppPlatform.IOS,\n                resourceName: responseData.name,\n                appId: responseData.appId,\n                displayName: responseData.displayName || null,\n                projectId: responseData.projectId,\n                bundleId: responseData.bundleId,\n            };\n            return metadata;\n        });\n    };\n    IosApp.prototype.setDisplayName = function (newDisplayName) {\n        return this.requestHandler.setDisplayName(this.resourceName, newDisplayName);\n    };\n    /**\n     * @return {Promise<string>} A promise that resolves to a UTF-8 XML string, typically intended to\n     *     be written to a plist file.\n     */\n    IosApp.prototype.getConfig = function () {\n        return this.requestHandler.getConfig(this.resourceName)\n            .then(function (responseData) {\n            project_management_api_request_1.assertServerResponse(validator.isNonNullObject(responseData), responseData, 'getConfig()\\'s responseData must be a non-null object.');\n            var base64ConfigFileContents = responseData.configFileContents;\n            project_management_api_request_1.assertServerResponse(validator.isBase64String(base64ConfigFileContents), responseData, \"getConfig()'s responseData.configFileContents must be a base64 string.\");\n            return Buffer.from(base64ConfigFileContents, 'base64').toString('utf8');\n        });\n    };\n    return IosApp;\n}());\nexports.IosApp = IosApp;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/project-management/ios-app.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/project-management/project-management-api-request.js":
/*!**************************************************************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/project-management/project-management-api-request.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\n/*!\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar api_request_1 = __webpack_require__(/*! ../utils/api-request */ \"./src/node_modules/firebase-admin/lib/utils/api-request.js\");\nvar error_1 = __webpack_require__(/*! ../utils/error */ \"./src/node_modules/firebase-admin/lib/utils/error.js\");\nvar validator = __webpack_require__(/*! ../utils/validator */ \"./src/node_modules/firebase-admin/lib/utils/validator.js\");\n/** Project management backend host and port. */\nvar PROJECT_MANAGEMENT_HOST_AND_PORT = 'firebase.googleapis.com:443';\n/** Project management backend path. */\nvar PROJECT_MANAGEMENT_PATH = '/v1/';\n/** Project management beta backend path. */\nvar PROJECT_MANAGEMENT_BETA_PATH = '/v1beta1/';\n/** Project management request header. */\nvar PROJECT_MANAGEMENT_HEADERS = {\n    'X-Client-Version': 'Node/Admin/8.13.0',\n};\n/** Project management request timeout duration in milliseconds. */\nvar PROJECT_MANAGEMENT_TIMEOUT_MILLIS = 10000;\nvar LIST_APPS_MAX_PAGE_SIZE = 100;\nvar CERT_TYPE_API_MAP = {\n    sha1: 'SHA_1',\n    sha256: 'SHA_256',\n};\nfunction assertServerResponse(condition, responseData, message) {\n    if (!condition) {\n        throw new error_1.FirebaseProjectManagementError('invalid-server-response', message + \" Response data: \" + JSON.stringify(responseData, null, 2));\n    }\n}\nexports.assertServerResponse = assertServerResponse;\n/**\n * Class that provides mechanism to send requests to the Firebase project management backend\n * endpoints.\n *\n * @private\n */\nvar ProjectManagementRequestHandler = /** @class */ (function () {\n    /**\n     * @param {FirebaseApp} app The app used to fetch access tokens to sign API requests.\n     * @constructor\n     */\n    function ProjectManagementRequestHandler(app) {\n        this.baseUrl = \"https://\" + PROJECT_MANAGEMENT_HOST_AND_PORT + PROJECT_MANAGEMENT_PATH;\n        this.baseBetaUrl = \"https://\" + PROJECT_MANAGEMENT_HOST_AND_PORT + PROJECT_MANAGEMENT_BETA_PATH;\n        this.httpClient = new api_request_1.AuthorizedHttpClient(app);\n    }\n    ProjectManagementRequestHandler.wrapAndRethrowHttpError = function (errStatusCode, errText) {\n        var errorCode;\n        var errorMessage;\n        switch (errStatusCode) {\n            case 400:\n                errorCode = 'invalid-argument';\n                errorMessage = 'Invalid argument provided.';\n                break;\n            case 401:\n            case 403:\n                errorCode = 'authentication-error';\n                errorMessage = 'An error occurred when trying to authenticate. Make sure the credential '\n                    + 'used to authenticate this SDK has the proper permissions. See '\n                    + 'https://firebase.google.com/docs/admin/setup for setup instructions.';\n                break;\n            case 404:\n                errorCode = 'not-found';\n                errorMessage = 'The specified entity could not be found.';\n                break;\n            case 409:\n                errorCode = 'already-exists';\n                errorMessage = 'The specified entity already exists.';\n                break;\n            case 500:\n                errorCode = 'internal-error';\n                errorMessage = 'An internal error has occurred. Please retry the request.';\n                break;\n            case 503:\n                errorCode = 'service-unavailable';\n                errorMessage = 'The server could not process the request in time. See the error '\n                    + 'documentation for more details.';\n                break;\n            default:\n                errorCode = 'unknown-error';\n                errorMessage = 'An unknown server error was returned.';\n        }\n        if (!errText) {\n            errText = '<missing>';\n        }\n        throw new error_1.FirebaseProjectManagementError(errorCode, errorMessage + \" Status code: \" + errStatusCode + \". Raw server response: \\\"\" + errText + \"\\\".\");\n    };\n    /**\n     * @param {string} parentResourceName Fully-qualified resource name of the project whose Android\n     *     apps you want to list.\n     */\n    ProjectManagementRequestHandler.prototype.listAndroidApps = function (parentResourceName) {\n        return this.invokeRequestHandler('GET', parentResourceName + \"/androidApps?page_size=\" + LIST_APPS_MAX_PAGE_SIZE, \n        /* requestData */ null, 'v1beta1');\n    };\n    /**\n     * @param {string} parentResourceName Fully-qualified resource name of the project whose iOS apps\n     *     you want to list.\n     */\n    ProjectManagementRequestHandler.prototype.listIosApps = function (parentResourceName) {\n        return this.invokeRequestHandler('GET', parentResourceName + \"/iosApps?page_size=\" + LIST_APPS_MAX_PAGE_SIZE, \n        /* requestData */ null, 'v1beta1');\n    };\n    /**\n     * @param {string} parentResourceName Fully-qualified resource name of the project whose iOS apps\n     *     you want to list.\n     */\n    ProjectManagementRequestHandler.prototype.listAppMetadata = function (parentResourceName) {\n        return this.invokeRequestHandler('GET', parentResourceName + \":searchApps?page_size=\" + LIST_APPS_MAX_PAGE_SIZE, \n        /* requestData */ null, 'v1beta1');\n    };\n    /**\n     * @param {string} parentResourceName Fully-qualified resource name of the project that you want\n     *     to create the Android app within.\n     */\n    ProjectManagementRequestHandler.prototype.createAndroidApp = function (parentResourceName, packageName, displayName) {\n        var _this = this;\n        var requestData = {\n            packageName: packageName,\n        };\n        if (validator.isNonEmptyString(displayName)) {\n            requestData.displayName = displayName;\n        }\n        return this\n            .invokeRequestHandler('POST', parentResourceName + \"/androidApps\", requestData, 'v1beta1')\n            .then(function (responseData) {\n            assertServerResponse(validator.isNonNullObject(responseData), responseData, \"createAndroidApp's responseData must be a non-null object.\");\n            assertServerResponse(validator.isNonEmptyString(responseData.name), responseData, \"createAndroidApp's responseData.name must be a non-empty string.\");\n            return _this.pollRemoteOperationWithExponentialBackoff(responseData.name);\n        });\n    };\n    /**\n     * @param {string} parentResourceName Fully-qualified resource name of the project that you want\n     *     to create the iOS app within.\n     */\n    ProjectManagementRequestHandler.prototype.createIosApp = function (parentResourceName, bundleId, displayName) {\n        var _this = this;\n        var requestData = {\n            bundleId: bundleId,\n        };\n        if (validator.isNonEmptyString(displayName)) {\n            requestData.displayName = displayName;\n        }\n        return this\n            .invokeRequestHandler('POST', parentResourceName + \"/iosApps\", requestData, 'v1beta1')\n            .then(function (responseData) {\n            assertServerResponse(validator.isNonNullObject(responseData), responseData, \"createIosApp's responseData must be a non-null object.\");\n            assertServerResponse(validator.isNonEmptyString(responseData.name), responseData, \"createIosApp's responseData.name must be a non-empty string.\");\n            return _this.pollRemoteOperationWithExponentialBackoff(responseData.name);\n        });\n    };\n    /**\n     * @param {string} resourceName Fully-qualified resource name of the entity whose display name you\n     *     want to set.\n     */\n    ProjectManagementRequestHandler.prototype.setDisplayName = function (resourceName, newDisplayName) {\n        var requestData = {\n            displayName: newDisplayName,\n        };\n        return this\n            .invokeRequestHandler('PATCH', resourceName + \"?update_mask=display_name\", requestData, 'v1beta1')\n            .then(function () { return undefined; });\n    };\n    /**\n     * @param {string} parentResourceName Fully-qualified resource name of the Android app whose SHA\n     *     certificates you want to get.\n     */\n    ProjectManagementRequestHandler.prototype.getAndroidShaCertificates = function (parentResourceName) {\n        return this.invokeRequestHandler('GET', parentResourceName + \"/sha\", /* requestData */ null, 'v1beta1');\n    };\n    /**\n     * @param {string} parentResourceName Fully-qualified resource name of the Android app that you\n     *     want to add the given SHA certificate to.\n     */\n    ProjectManagementRequestHandler.prototype.addAndroidShaCertificate = function (parentResourceName, certificate) {\n        var requestData = {\n            shaHash: certificate.shaHash,\n            certType: CERT_TYPE_API_MAP[certificate.certType],\n        };\n        return this\n            .invokeRequestHandler('POST', parentResourceName + \"/sha\", requestData, 'v1beta1')\n            .then(function () { return undefined; });\n    };\n    /**\n     * @param {string} parentResourceName Fully-qualified resource name of the app whose config you\n     *     want to get.\n     */\n    ProjectManagementRequestHandler.prototype.getConfig = function (parentResourceName) {\n        return this.invokeRequestHandler('GET', parentResourceName + \"/config\", /* requestData */ null, 'v1beta1');\n    };\n    /**\n     * @param {string} parentResourceName Fully-qualified resource name of the entity that you want to\n     *     get.\n     */\n    ProjectManagementRequestHandler.prototype.getResource = function (parentResourceName) {\n        return this.invokeRequestHandler('GET', parentResourceName, /* requestData */ null, 'v1beta1');\n    };\n    /**\n     * @param {string} resourceName Fully-qualified resource name of the entity that you want to\n     *     delete.\n     */\n    ProjectManagementRequestHandler.prototype.deleteResource = function (resourceName) {\n        return this\n            .invokeRequestHandler('DELETE', resourceName, /* requestData */ null, 'v1beta1')\n            .then(function () { return undefined; });\n    };\n    ProjectManagementRequestHandler.prototype.pollRemoteOperationWithExponentialBackoff = function (operationResourceName) {\n        var _this = this;\n        var poller = new api_request_1.ExponentialBackoffPoller();\n        return poller.poll(function () {\n            return _this.invokeRequestHandler('GET', operationResourceName, /* requestData */ null)\n                .then(function (responseData) {\n                if (responseData.error) {\n                    var errStatusCode = responseData.error.code || 500;\n                    var errText = responseData.error.message || JSON.stringify(responseData.error);\n                    ProjectManagementRequestHandler.wrapAndRethrowHttpError(errStatusCode, errText);\n                }\n                if (!responseData.done) {\n                    // Continue polling.\n                    return null;\n                }\n                // Polling complete. Resolve with operation response JSON.\n                return responseData.response;\n            });\n        });\n    };\n    /**\n     * Invokes the request handler with the provided request data.\n     */\n    ProjectManagementRequestHandler.prototype.invokeRequestHandler = function (method, path, requestData, apiVersion) {\n        if (apiVersion === void 0) { apiVersion = 'v1'; }\n        var baseUrlToUse = (apiVersion === 'v1') ? this.baseUrl : this.baseBetaUrl;\n        var request = {\n            method: method,\n            url: \"\" + baseUrlToUse + path,\n            headers: PROJECT_MANAGEMENT_HEADERS,\n            data: requestData,\n            timeout: PROJECT_MANAGEMENT_TIMEOUT_MILLIS,\n        };\n        return this.httpClient.send(request)\n            .then(function (response) {\n            // Send non-JSON responses to the catch() below, where they will be treated as errors.\n            if (!response.isJson()) {\n                throw new api_request_1.HttpError(response);\n            }\n            return response.data;\n        })\n            .catch(function (err) {\n            if (err instanceof api_request_1.HttpError) {\n                ProjectManagementRequestHandler.wrapAndRethrowHttpError(err.response.status, err.response.text);\n            }\n            throw err;\n        });\n    };\n    return ProjectManagementRequestHandler;\n}());\nexports.ProjectManagementRequestHandler = ProjectManagementRequestHandler;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/project-management/project-management-api-request.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/project-management/project-management.js":
/*!**************************************************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/project-management/project-management.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\n/*!\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar error_1 = __webpack_require__(/*! ../utils/error */ \"./src/node_modules/firebase-admin/lib/utils/error.js\");\nvar utils = __webpack_require__(/*! ../utils/index */ \"./src/node_modules/firebase-admin/lib/utils/index.js\");\nvar validator = __webpack_require__(/*! ../utils/validator */ \"./src/node_modules/firebase-admin/lib/utils/validator.js\");\nvar android_app_1 = __webpack_require__(/*! ./android-app */ \"./src/node_modules/firebase-admin/lib/project-management/android-app.js\");\nvar ios_app_1 = __webpack_require__(/*! ./ios-app */ \"./src/node_modules/firebase-admin/lib/project-management/ios-app.js\");\nvar project_management_api_request_1 = __webpack_require__(/*! ./project-management-api-request */ \"./src/node_modules/firebase-admin/lib/project-management/project-management-api-request.js\");\nvar app_metadata_1 = __webpack_require__(/*! ./app-metadata */ \"./src/node_modules/firebase-admin/lib/project-management/app-metadata.js\");\n/**\n * Internals of a Project Management instance.\n */\nvar ProjectManagementInternals = /** @class */ (function () {\n    function ProjectManagementInternals() {\n    }\n    /**\n     * Deletes the service and its associated resources.\n     *\n     * @return {Promise<void>} An empty Promise that will be resolved when the service is deleted.\n     */\n    ProjectManagementInternals.prototype.delete = function () {\n        // There are no resources to clean up.\n        return Promise.resolve();\n    };\n    return ProjectManagementInternals;\n}());\n/**\n * ProjectManagement service bound to the provided app.\n */\nvar ProjectManagement = /** @class */ (function () {\n    /**\n     * @param {object} app The app for this ProjectManagement service.\n     * @constructor\n     */\n    function ProjectManagement(app) {\n        this.app = app;\n        this.INTERNAL = new ProjectManagementInternals();\n        if (!validator.isNonNullObject(app) || !('options' in app)) {\n            throw new error_1.FirebaseProjectManagementError('invalid-argument', 'First argument passed to admin.projectManagement() must be a valid Firebase app '\n                + 'instance.');\n        }\n        this.requestHandler = new project_management_api_request_1.ProjectManagementRequestHandler(app);\n    }\n    /**\n     * Lists up to 100 Firebase Android apps associated with this Firebase project.\n     */\n    ProjectManagement.prototype.listAndroidApps = function () {\n        return this.listPlatformApps('android', 'listAndroidApps()');\n    };\n    /**\n     * Lists up to 100 Firebase iOS apps associated with this Firebase project.\n     */\n    ProjectManagement.prototype.listIosApps = function () {\n        return this.listPlatformApps('ios', 'listIosApps()');\n    };\n    /**\n     * Returns an AndroidApp object for the given appId. No RPC is made.\n     */\n    ProjectManagement.prototype.androidApp = function (appId) {\n        return new android_app_1.AndroidApp(appId, this.requestHandler);\n    };\n    /**\n     * Returns an IosApp object for the given appId. No RPC is made.\n     */\n    ProjectManagement.prototype.iosApp = function (appId) {\n        return new ios_app_1.IosApp(appId, this.requestHandler);\n    };\n    /**\n     * Returns a ShaCertificate object for the given shaHash. No RPC is made.\n     */\n    ProjectManagement.prototype.shaCertificate = function (shaHash) {\n        return new android_app_1.ShaCertificate(shaHash);\n    };\n    /**\n     * Creates a new Firebase Android app, associated with this Firebase project.\n     */\n    ProjectManagement.prototype.createAndroidApp = function (packageName, displayName) {\n        var _this = this;\n        return this.getResourceName()\n            .then(function (resourceName) {\n            return _this.requestHandler.createAndroidApp(resourceName, packageName, displayName);\n        })\n            .then(function (responseData) {\n            project_management_api_request_1.assertServerResponse(validator.isNonNullObject(responseData), responseData, 'createAndroidApp()\\'s responseData must be a non-null object.');\n            project_management_api_request_1.assertServerResponse(validator.isNonEmptyString(responseData.appId), responseData, \"\\\"responseData.appId\\\" field must be present in createAndroidApp()'s response data.\");\n            return new android_app_1.AndroidApp(responseData.appId, _this.requestHandler);\n        });\n    };\n    /**\n     * Creates a new Firebase iOS app, associated with this Firebase project.\n     */\n    ProjectManagement.prototype.createIosApp = function (bundleId, displayName) {\n        var _this = this;\n        return this.getResourceName()\n            .then(function (resourceName) {\n            return _this.requestHandler.createIosApp(resourceName, bundleId, displayName);\n        })\n            .then(function (responseData) {\n            project_management_api_request_1.assertServerResponse(validator.isNonNullObject(responseData), responseData, 'createIosApp()\\'s responseData must be a non-null object.');\n            project_management_api_request_1.assertServerResponse(validator.isNonEmptyString(responseData.appId), responseData, \"\\\"responseData.appId\\\" field must be present in createIosApp()'s response data.\");\n            return new ios_app_1.IosApp(responseData.appId, _this.requestHandler);\n        });\n    };\n    /**\n     * Lists up to 100 Firebase apps associated with this Firebase project.\n     */\n    ProjectManagement.prototype.listAppMetadata = function () {\n        var _this = this;\n        return this.getResourceName()\n            .then(function (resourceName) {\n            return _this.requestHandler.listAppMetadata(resourceName);\n        })\n            .then(function (responseData) {\n            return _this.getProjectId()\n                .then(function (projectId) {\n                return _this.transformResponseToAppMetadata(responseData, projectId);\n            });\n        });\n    };\n    /**\n     * Update display name of the project\n     */\n    ProjectManagement.prototype.setDisplayName = function (newDisplayName) {\n        var _this = this;\n        return this.getResourceName()\n            .then(function (resourceName) {\n            return _this.requestHandler.setDisplayName(resourceName, newDisplayName);\n        });\n    };\n    ProjectManagement.prototype.transformResponseToAppMetadata = function (responseData, projectId) {\n        this.assertListAppsResponseData(responseData, 'listAppMetadata()');\n        if (!responseData.apps) {\n            return [];\n        }\n        return responseData.apps.map(function (appJson) {\n            project_management_api_request_1.assertServerResponse(validator.isNonEmptyString(appJson.appId), responseData, \"\\\"apps[].appId\\\" field must be present in the listAppMetadata() response data.\");\n            project_management_api_request_1.assertServerResponse(validator.isNonEmptyString(appJson.platform), responseData, \"\\\"apps[].platform\\\" field must be present in the listAppMetadata() response data.\");\n            var metadata = {\n                appId: appJson.appId,\n                platform: app_metadata_1.AppPlatform[appJson.platform] || app_metadata_1.AppPlatform.PLATFORM_UNKNOWN,\n                projectId: projectId,\n                resourceName: appJson.name,\n            };\n            if (appJson.displayName) {\n                metadata.displayName = appJson.displayName;\n            }\n            return metadata;\n        });\n    };\n    ProjectManagement.prototype.getResourceName = function () {\n        return this.getProjectId()\n            .then(function (projectId) {\n            return \"projects/\" + projectId;\n        });\n    };\n    ProjectManagement.prototype.getProjectId = function () {\n        var _this = this;\n        if (this.projectId) {\n            return Promise.resolve(this.projectId);\n        }\n        return utils.findProjectId(this.app)\n            .then(function (projectId) {\n            // Assert that a specific project ID was provided within the app.\n            if (!validator.isNonEmptyString(projectId)) {\n                throw new error_1.FirebaseProjectManagementError('invalid-project-id', 'Failed to determine project ID. Initialize the SDK with service account credentials, or '\n                    + 'set project ID as an app option. Alternatively, set the GOOGLE_CLOUD_PROJECT '\n                    + 'environment variable.');\n            }\n            _this.projectId = projectId;\n            return _this.projectId;\n        });\n    };\n    /**\n     * Lists up to 100 Firebase apps for a specified platform, associated with this Firebase project.\n     */\n    ProjectManagement.prototype.listPlatformApps = function (platform, callerName) {\n        var _this = this;\n        return this.getResourceName()\n            .then(function (resourceName) {\n            return (platform === 'android') ?\n                _this.requestHandler.listAndroidApps(resourceName)\n                : _this.requestHandler.listIosApps(resourceName);\n        })\n            .then(function (responseData) {\n            _this.assertListAppsResponseData(responseData, callerName);\n            if (!responseData.apps) {\n                return [];\n            }\n            return responseData.apps.map(function (appJson) {\n                project_management_api_request_1.assertServerResponse(validator.isNonEmptyString(appJson.appId), responseData, \"\\\"apps[].appId\\\" field must be present in the \" + callerName + \" response data.\");\n                if (platform === 'android') {\n                    return new android_app_1.AndroidApp(appJson.appId, _this.requestHandler);\n                }\n                else {\n                    return new ios_app_1.IosApp(appJson.appId, _this.requestHandler);\n                }\n            });\n        });\n    };\n    ProjectManagement.prototype.assertListAppsResponseData = function (responseData, callerName) {\n        project_management_api_request_1.assertServerResponse(validator.isNonNullObject(responseData), responseData, callerName + \"'s responseData must be a non-null object.\");\n        if (responseData.apps) {\n            project_management_api_request_1.assertServerResponse(validator.isArray(responseData.apps), responseData, \"\\\"apps\\\" field must be present in the \" + callerName + \" response data.\");\n        }\n    };\n    return ProjectManagement;\n}());\nexports.ProjectManagement = ProjectManagement;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/project-management/project-management.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/remote-config/remote-config-api-client.js":
/*!***************************************************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/remote-config/remote-config-api-client.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\n/*!\n * Copyright 2020 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar api_request_1 = __webpack_require__(/*! ../utils/api-request */ \"./src/node_modules/firebase-admin/lib/utils/api-request.js\");\nvar error_1 = __webpack_require__(/*! ../utils/error */ \"./src/node_modules/firebase-admin/lib/utils/error.js\");\nvar remote_config_utils_1 = __webpack_require__(/*! ./remote-config-utils */ \"./src/node_modules/firebase-admin/lib/remote-config/remote-config-utils.js\");\nvar utils = __webpack_require__(/*! ../utils/index */ \"./src/node_modules/firebase-admin/lib/utils/index.js\");\nvar validator = __webpack_require__(/*! ../utils/validator */ \"./src/node_modules/firebase-admin/lib/utils/validator.js\");\nvar deep_copy_1 = __webpack_require__(/*! ../utils/deep-copy */ \"./src/node_modules/firebase-admin/lib/utils/deep-copy.js\");\n// Remote Config backend constants\nvar FIREBASE_REMOTE_CONFIG_V1_API = 'https://firebaseremoteconfig.googleapis.com/v1';\nvar FIREBASE_REMOTE_CONFIG_HEADERS = {\n    'X-Firebase-Client': 'fire-admin-node/8.13.0',\n    // There is a known issue in which the ETag is not properly returned in cases where the request\n    // does not specify a compression type. Currently, it is required to include the header\n    // `Accept-Encoding: gzip` or equivalent in all requests.\n    // https://firebase.google.com/docs/remote-config/use-config-rest#etag_usage_and_forced_updates\n    'Accept-Encoding': 'gzip',\n};\nvar TagColor;\n(function (TagColor) {\n    TagColor[\"BLUE\"] = \"Blue\";\n    TagColor[\"BROWN\"] = \"Brown\";\n    TagColor[\"CYAN\"] = \"Cyan\";\n    TagColor[\"DEEP_ORANGE\"] = \"Red Orange\";\n    TagColor[\"GREEN\"] = \"Green\";\n    TagColor[\"INDIGO\"] = \"Indigo\";\n    TagColor[\"LIME\"] = \"Lime\";\n    TagColor[\"ORANGE\"] = \"Orange\";\n    TagColor[\"PINK\"] = \"Pink\";\n    TagColor[\"PURPLE\"] = \"Purple\";\n    TagColor[\"TEAL\"] = \"Teal\";\n})(TagColor = exports.TagColor || (exports.TagColor = {}));\n/**\n * Class that facilitates sending requests to the Firebase Remote Config backend API.\n *\n * @private\n */\nvar RemoteConfigApiClient = /** @class */ (function () {\n    function RemoteConfigApiClient(app) {\n        this.app = app;\n        if (!validator.isNonNullObject(app) || !('options' in app)) {\n            throw new remote_config_utils_1.FirebaseRemoteConfigError('invalid-argument', 'First argument passed to admin.remoteConfig() must be a valid Firebase app instance.');\n        }\n        this.httpClient = new api_request_1.AuthorizedHttpClient(app);\n    }\n    RemoteConfigApiClient.prototype.getTemplate = function () {\n        var _this = this;\n        return this.getUrl()\n            .then(function (url) {\n            var request = {\n                method: 'GET',\n                url: url + \"/remoteConfig\",\n                headers: FIREBASE_REMOTE_CONFIG_HEADERS\n            };\n            return _this.httpClient.send(request);\n        })\n            .then(function (resp) {\n            return _this.toRemoteConfigTemplate(resp);\n        })\n            .catch(function (err) {\n            throw _this.toFirebaseError(err);\n        });\n    };\n    RemoteConfigApiClient.prototype.getTemplateAtVersion = function (versionNumber) {\n        var _this = this;\n        var data = { versionNumber: this.validateVersionNumber(versionNumber) };\n        return this.getUrl()\n            .then(function (url) {\n            var request = {\n                method: 'GET',\n                url: url + \"/remoteConfig\",\n                headers: FIREBASE_REMOTE_CONFIG_HEADERS,\n                data: data\n            };\n            return _this.httpClient.send(request);\n        })\n            .then(function (resp) {\n            return _this.toRemoteConfigTemplate(resp);\n        })\n            .catch(function (err) {\n            throw _this.toFirebaseError(err);\n        });\n    };\n    RemoteConfigApiClient.prototype.validateTemplate = function (template) {\n        var _this = this;\n        template = this.validateInputRemoteConfigTemplate(template);\n        return this.sendPutRequest(template, template.etag, true)\n            .then(function (resp) {\n            // validating a template returns an etag with the suffix -0 means that your update \n            // was successfully validated. We set the etag back to the original etag of the template\n            // to allow future operations.\n            _this.validateEtag(resp.headers['etag']);\n            return _this.toRemoteConfigTemplate(resp, template.etag);\n        })\n            .catch(function (err) {\n            throw _this.toFirebaseError(err);\n        });\n    };\n    RemoteConfigApiClient.prototype.publishTemplate = function (template, options) {\n        var _this = this;\n        template = this.validateInputRemoteConfigTemplate(template);\n        var ifMatch = template.etag;\n        if (options && options.force == true) {\n            // setting `If-Match: *` forces the Remote Config template to be updated\n            // and circumvent the ETag, and the protection from that it provides.\n            ifMatch = '*';\n        }\n        return this.sendPutRequest(template, ifMatch)\n            .then(function (resp) {\n            return _this.toRemoteConfigTemplate(resp);\n        })\n            .catch(function (err) {\n            throw _this.toFirebaseError(err);\n        });\n    };\n    RemoteConfigApiClient.prototype.rollback = function (versionNumber) {\n        var _this = this;\n        var data = { versionNumber: this.validateVersionNumber(versionNumber) };\n        return this.getUrl()\n            .then(function (url) {\n            var request = {\n                method: 'POST',\n                url: url + \"/remoteConfig:rollback\",\n                headers: FIREBASE_REMOTE_CONFIG_HEADERS,\n                data: data\n            };\n            return _this.httpClient.send(request);\n        })\n            .then(function (resp) {\n            return _this.toRemoteConfigTemplate(resp);\n        })\n            .catch(function (err) {\n            throw _this.toFirebaseError(err);\n        });\n    };\n    RemoteConfigApiClient.prototype.listVersions = function (options) {\n        var _this = this;\n        if (typeof options !== 'undefined') {\n            options = this.validateListVersionsOptions(options);\n        }\n        return this.getUrl()\n            .then(function (url) {\n            var request = {\n                method: 'GET',\n                url: url + \"/remoteConfig:listVersions\",\n                headers: FIREBASE_REMOTE_CONFIG_HEADERS,\n                data: options\n            };\n            return _this.httpClient.send(request);\n        })\n            .then(function (resp) {\n            return resp.data;\n        })\n            .catch(function (err) {\n            throw _this.toFirebaseError(err);\n        });\n    };\n    RemoteConfigApiClient.prototype.sendPutRequest = function (template, etag, validateOnly) {\n        var _this = this;\n        var path = 'remoteConfig';\n        if (validateOnly) {\n            path += '?validate_only=true';\n        }\n        return this.getUrl()\n            .then(function (url) {\n            var request = {\n                method: 'PUT',\n                url: url + \"/\" + path,\n                headers: __assign(__assign({}, FIREBASE_REMOTE_CONFIG_HEADERS), { 'If-Match': etag }),\n                data: {\n                    conditions: template.conditions,\n                    parameters: template.parameters,\n                    parameterGroups: template.parameterGroups,\n                    version: template.version,\n                }\n            };\n            return _this.httpClient.send(request);\n        });\n    };\n    RemoteConfigApiClient.prototype.getUrl = function () {\n        return this.getProjectIdPrefix()\n            .then(function (projectIdPrefix) {\n            return FIREBASE_REMOTE_CONFIG_V1_API + \"/\" + projectIdPrefix;\n        });\n    };\n    RemoteConfigApiClient.prototype.getProjectIdPrefix = function () {\n        var _this = this;\n        if (this.projectIdPrefix) {\n            return Promise.resolve(this.projectIdPrefix);\n        }\n        return utils.findProjectId(this.app)\n            .then(function (projectId) {\n            if (!validator.isNonEmptyString(projectId)) {\n                throw new remote_config_utils_1.FirebaseRemoteConfigError('unknown-error', 'Failed to determine project ID. Initialize the SDK with service account credentials, or '\n                    + 'set project ID as an app option. Alternatively, set the GOOGLE_CLOUD_PROJECT '\n                    + 'environment variable.');\n            }\n            _this.projectIdPrefix = \"projects/\" + projectId;\n            return _this.projectIdPrefix;\n        });\n    };\n    RemoteConfigApiClient.prototype.toFirebaseError = function (err) {\n        if (err instanceof error_1.PrefixedFirebaseError) {\n            return err;\n        }\n        var response = err.response;\n        if (!response.isJson()) {\n            return new remote_config_utils_1.FirebaseRemoteConfigError('unknown-error', \"Unexpected response with status: \" + response.status + \" and body: \" + response.text);\n        }\n        var error = response.data.error || {};\n        var code = 'unknown-error';\n        if (error.status && error.status in ERROR_CODE_MAPPING) {\n            code = ERROR_CODE_MAPPING[error.status];\n        }\n        var message = error.message || \"Unknown server error: \" + response.text;\n        return new remote_config_utils_1.FirebaseRemoteConfigError(code, message);\n    };\n    /**\n     * Creates a RemoteConfigTemplate from the API response.\n     * If provided, customEtag is used instead of the etag returned in the API response.\n     *\n     * @param {HttpResponse} resp API response object.\n     * @param {string} customEtag A custom etag to replace the etag fom the API response (Optional).\n     */\n    RemoteConfigApiClient.prototype.toRemoteConfigTemplate = function (resp, customEtag) {\n        var etag = (typeof customEtag == 'undefined') ? resp.headers['etag'] : customEtag;\n        this.validateEtag(etag);\n        return {\n            conditions: resp.data.conditions,\n            parameters: resp.data.parameters,\n            parameterGroups: resp.data.parameterGroups,\n            etag: etag,\n            version: resp.data.version,\n        };\n    };\n    /**\n     * Checks if the given RemoteConfigTemplate object is valid.\n     * The object must have valid parameters, parameter groups, conditions, and an etag.\n     * Removes output only properties from version metadata.\n     *\n     * @param {RemoteConfigTemplate} template A RemoteConfigTemplate object to be validated.\n     *\n     * @returns {RemoteConfigTemplate} The validated RemoteConfigTemplate object.\n     */\n    RemoteConfigApiClient.prototype.validateInputRemoteConfigTemplate = function (template) {\n        var templateCopy = deep_copy_1.deepCopy(template);\n        if (!validator.isNonNullObject(templateCopy)) {\n            throw new remote_config_utils_1.FirebaseRemoteConfigError('invalid-argument', \"Invalid Remote Config template: \" + JSON.stringify(templateCopy));\n        }\n        if (!validator.isNonEmptyString(templateCopy.etag)) {\n            throw new remote_config_utils_1.FirebaseRemoteConfigError('invalid-argument', 'ETag must be a non-empty string.');\n        }\n        if (!validator.isNonNullObject(templateCopy.parameters)) {\n            throw new remote_config_utils_1.FirebaseRemoteConfigError('invalid-argument', 'Remote Config parameters must be a non-null object');\n        }\n        if (!validator.isNonNullObject(templateCopy.parameterGroups)) {\n            throw new remote_config_utils_1.FirebaseRemoteConfigError('invalid-argument', 'Remote Config parameter groups must be a non-null object');\n        }\n        if (!validator.isArray(templateCopy.conditions)) {\n            throw new remote_config_utils_1.FirebaseRemoteConfigError('invalid-argument', 'Remote Config conditions must be an array');\n        }\n        if (typeof templateCopy.version !== 'undefined') {\n            // exclude output only properties and keep the only input property: description\n            templateCopy.version = { description: templateCopy.version.description };\n        }\n        return templateCopy;\n    };\n    /**\n     * Checks if a given version number is valid.\n     * A version number must be an integer or a string in int64 format.\n     * If valid, returns the string representation of the provided version number.\n     *\n     * @param {string|number} versionNumber A version number to be validated.\n     *\n     * @returns {string} The validated version number as a string.\n     */\n    RemoteConfigApiClient.prototype.validateVersionNumber = function (versionNumber, propertyName) {\n        if (propertyName === void 0) { propertyName = 'versionNumber'; }\n        if (!validator.isNonEmptyString(versionNumber) &&\n            !validator.isNumber(versionNumber)) {\n            throw new remote_config_utils_1.FirebaseRemoteConfigError('invalid-argument', propertyName + \" must be a non-empty string in int64 format or a number\");\n        }\n        if (!Number.isInteger(Number(versionNumber))) {\n            throw new remote_config_utils_1.FirebaseRemoteConfigError('invalid-argument', propertyName + \" must be an integer or a string in int64 format\");\n        }\n        return versionNumber.toString();\n    };\n    RemoteConfigApiClient.prototype.validateEtag = function (etag) {\n        if (!validator.isNonEmptyString(etag)) {\n            throw new remote_config_utils_1.FirebaseRemoteConfigError('invalid-argument', 'ETag header is not present in the server response.');\n        }\n    };\n    /**\n     * Checks if a given `ListVersionsOptions` object is valid. If successful, creates a copy of the\n     * options object and convert `startTime` and `endTime` to RFC3339 UTC \"Zulu\" format, if present.\n     *\n     * @param {ListVersionsOptions} options An options object to be validated.\n     *\n     * @return {ListVersionsOptions} A copy of the provided options object with timestamps converted\n     * to UTC Zulu format.\n     */\n    RemoteConfigApiClient.prototype.validateListVersionsOptions = function (options) {\n        var optionsCopy = deep_copy_1.deepCopy(options);\n        if (!validator.isNonNullObject(optionsCopy)) {\n            throw new remote_config_utils_1.FirebaseRemoteConfigError('invalid-argument', 'ListVersionsOptions must be a non-null object.');\n        }\n        if (typeof optionsCopy.pageSize !== 'undefined') {\n            if (!validator.isNumber(optionsCopy.pageSize)) {\n                throw new remote_config_utils_1.FirebaseRemoteConfigError('invalid-argument', 'pageSize must be a number.');\n            }\n            if (optionsCopy.pageSize < 1 || optionsCopy.pageSize > 300) {\n                throw new remote_config_utils_1.FirebaseRemoteConfigError('invalid-argument', 'pageSize must be a number between 1 and 300 (inclusive).');\n            }\n        }\n        if (typeof optionsCopy.pageToken !== 'undefined' && !validator.isNonEmptyString(optionsCopy.pageToken)) {\n            throw new remote_config_utils_1.FirebaseRemoteConfigError('invalid-argument', 'pageToken must be a string value.');\n        }\n        if (typeof optionsCopy.endVersionNumber !== 'undefined') {\n            optionsCopy.endVersionNumber = this.validateVersionNumber(optionsCopy.endVersionNumber, 'endVersionNumber');\n        }\n        if (typeof optionsCopy.startTime !== 'undefined') {\n            if (!(optionsCopy.startTime instanceof Date) && !validator.isUTCDateString(optionsCopy.startTime)) {\n                throw new remote_config_utils_1.FirebaseRemoteConfigError('invalid-argument', 'startTime must be a valid Date object or a UTC date string.');\n            }\n            // Convert startTime to RFC3339 UTC \"Zulu\" format.\n            if (optionsCopy.startTime instanceof Date) {\n                optionsCopy.startTime = optionsCopy.startTime.toISOString();\n            }\n            else {\n                optionsCopy.startTime = new Date(optionsCopy.startTime).toISOString();\n            }\n        }\n        if (typeof optionsCopy.endTime !== 'undefined') {\n            if (!(optionsCopy.endTime instanceof Date) && !validator.isUTCDateString(optionsCopy.endTime)) {\n                throw new remote_config_utils_1.FirebaseRemoteConfigError('invalid-argument', 'endTime must be a valid Date object or a UTC date string.');\n            }\n            // Convert endTime to RFC3339 UTC \"Zulu\" format.\n            if (optionsCopy.endTime instanceof Date) {\n                optionsCopy.endTime = optionsCopy.endTime.toISOString();\n            }\n            else {\n                optionsCopy.endTime = new Date(optionsCopy.endTime).toISOString();\n            }\n        }\n        // Remove undefined fields from optionsCopy\n        Object.keys(optionsCopy).forEach(function (key) {\n            return (typeof optionsCopy[key] === 'undefined') && delete optionsCopy[key];\n        });\n        return optionsCopy;\n    };\n    return RemoteConfigApiClient;\n}());\nexports.RemoteConfigApiClient = RemoteConfigApiClient;\nvar ERROR_CODE_MAPPING = {\n    ABORTED: 'aborted',\n    ALREADY_EXISTS: \"already-exists\",\n    INVALID_ARGUMENT: 'invalid-argument',\n    INTERNAL: 'internal-error',\n    FAILED_PRECONDITION: 'failed-precondition',\n    NOT_FOUND: 'not-found',\n    OUT_OF_RANGE: 'out-of-range',\n    PERMISSION_DENIED: 'permission-denied',\n    RESOURCE_EXHAUSTED: 'resource-exhausted',\n    UNAUTHENTICATED: 'unauthenticated',\n    UNKNOWN: 'unknown-error',\n};\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/remote-config/remote-config-api-client.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/remote-config/remote-config-utils.js":
/*!**********************************************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/remote-config/remote-config-utils.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\n/*!\n * Copyright 2020 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar error_1 = __webpack_require__(/*! ../utils/error */ \"./src/node_modules/firebase-admin/lib/utils/error.js\");\n/**\n * Firebase Remote Config error code structure. This extends PrefixedFirebaseError.\n *\n * @param {RemoteConfigErrorCode} code The error code.\n * @param {string} message The error message.\n * @constructor\n */\nvar FirebaseRemoteConfigError = /** @class */ (function (_super) {\n    __extends(FirebaseRemoteConfigError, _super);\n    function FirebaseRemoteConfigError(code, message) {\n        return _super.call(this, 'remote-config', code, message) || this;\n    }\n    return FirebaseRemoteConfigError;\n}(error_1.PrefixedFirebaseError));\nexports.FirebaseRemoteConfigError = FirebaseRemoteConfigError;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/remote-config/remote-config-utils.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/remote-config/remote-config.js":
/*!****************************************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/remote-config/remote-config.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\n/*!\n * Copyright 2020 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar validator = __webpack_require__(/*! ../utils/validator */ \"./src/node_modules/firebase-admin/lib/utils/validator.js\");\nvar remote_config_utils_1 = __webpack_require__(/*! ./remote-config-utils */ \"./src/node_modules/firebase-admin/lib/remote-config/remote-config-utils.js\");\nvar remote_config_api_client_1 = __webpack_require__(/*! ./remote-config-api-client */ \"./src/node_modules/firebase-admin/lib/remote-config/remote-config-api-client.js\");\n/**\n * Internals of an RemoteConfig service instance.\n */\nvar RemoteConfigInternals = /** @class */ (function () {\n    function RemoteConfigInternals() {\n    }\n    /**\n     * Deletes the service and its associated resources.\n     *\n     * @return {Promise<()>} An empty Promise that will be fulfilled when the service is deleted.\n     */\n    RemoteConfigInternals.prototype.delete = function () {\n        // There are no resources to clean up\n        return Promise.resolve(undefined);\n    };\n    return RemoteConfigInternals;\n}());\n/**\n * Remote Config service bound to the provided app.\n */\nvar RemoteConfig = /** @class */ (function () {\n    /**\n     * @param {FirebaseApp} app The app for this RemoteConfig service.\n     * @constructor\n     */\n    function RemoteConfig(app) {\n        this.app = app;\n        this.INTERNAL = new RemoteConfigInternals();\n        this.client = new remote_config_api_client_1.RemoteConfigApiClient(app);\n    }\n    /**\n    * Gets the current active version of the Remote Config template of the project.\n    *\n    * @return {Promise<RemoteConfigTemplate>} A Promise that fulfills when the template is available.\n    */\n    RemoteConfig.prototype.getTemplate = function () {\n        return this.client.getTemplate()\n            .then(function (templateResponse) {\n            return new RemoteConfigTemplateImpl(templateResponse);\n        });\n    };\n    /**\n    * Gets the requested version of the Remote Config template of the project.\n    *\n    * @param {number | string} versionNumber Version number of the Remote Config template to look up.\n    *\n    * @return {Promise<RemoteConfigTemplate>} A Promise that fulfills when the template is available.\n    */\n    RemoteConfig.prototype.getTemplateAtVersion = function (versionNumber) {\n        return this.client.getTemplateAtVersion(versionNumber)\n            .then(function (templateResponse) {\n            return new RemoteConfigTemplateImpl(templateResponse);\n        });\n    };\n    /**\n     * Validates a Remote Config template.\n     *\n     * @param {RemoteConfigTemplate} template The Remote Config template to be validated.\n     *\n     * @return {Promise<RemoteConfigTemplate>} A Promise that fulfills when a template is validated.\n     */\n    RemoteConfig.prototype.validateTemplate = function (template) {\n        return this.client.validateTemplate(template)\n            .then(function (templateResponse) {\n            return new RemoteConfigTemplateImpl(templateResponse);\n        });\n    };\n    /**\n     * Publishes a Remote Config template.\n     *\n     * @param {RemoteConfigTemplate} template The Remote Config template to be validated.\n     * @param {any=} options Optional options object when publishing a Remote Config template.\n     *\n     * @return {Promise<RemoteConfigTemplate>} A Promise that fulfills when a template is published.\n     */\n    RemoteConfig.prototype.publishTemplate = function (template, options) {\n        return this.client.publishTemplate(template, options)\n            .then(function (templateResponse) {\n            return new RemoteConfigTemplateImpl(templateResponse);\n        });\n    };\n    /**\n     * Rollbacks a project's published Remote Config template to the specified version.\n     * A rollback is equivalent to getting a previously published Remote Config\n     * template, and re-publishing it using a force update.\n     *\n     * @param {number | string} versionNumber The version number of the Remote Config template\n     *    to rollback to.\n     * @return {Promise<RemoteConfigTemplate>} A Promise that fulfills with the published template.\n     */\n    RemoteConfig.prototype.rollback = function (versionNumber) {\n        return this.client.rollback(versionNumber)\n            .then(function (templateResponse) {\n            return new RemoteConfigTemplateImpl(templateResponse);\n        });\n    };\n    /**\n    * Gets a list of Remote Config template versions that have been published, sorted in reverse\n    * chronological order. Only the last 300 versions are stored.\n    * All versions that correspond to non-active Remote Config templates (i.e., all except the\n    * template that is being fetched by clients) are also deleted if they are older than 90 days.\n    *\n    * @param {ListVersionsOptions} options Optional options object for getting a list of versions.\n    * @return A promise that fulfills with a `ListVersionsResult`.\n    */\n    RemoteConfig.prototype.listVersions = function (options) {\n        return this.client.listVersions(options)\n            .then(function (listVersionsResponse) {\n            var _a, _b;\n            return {\n                versions: (_b = (_a = listVersionsResponse.versions) === null || _a === void 0 ? void 0 : _a.map(function (version) { return new VersionImpl(version); }), (_b !== null && _b !== void 0 ? _b : [])),\n                nextPageToken: listVersionsResponse.nextPageToken,\n            };\n        });\n    };\n    /**\n     * Creates and returns a new Remote Config template from a JSON string.\n     *\n     * @param {string} json The JSON string to populate a Remote Config template.\n     *\n     * @return {RemoteConfigTemplate} A new template instance.\n     */\n    RemoteConfig.prototype.createTemplateFromJSON = function (json) {\n        if (!validator.isNonEmptyString(json)) {\n            throw new remote_config_utils_1.FirebaseRemoteConfigError('invalid-argument', 'JSON string must be a valid non-empty string');\n        }\n        var template;\n        try {\n            template = JSON.parse(json);\n        }\n        catch (e) {\n            throw new remote_config_utils_1.FirebaseRemoteConfigError('invalid-argument', \"Failed to parse the JSON string: \" + json + \". \" + e);\n        }\n        return new RemoteConfigTemplateImpl(template);\n    };\n    return RemoteConfig;\n}());\nexports.RemoteConfig = RemoteConfig;\n/**\n * Remote Config template internal implementation.\n */\nvar RemoteConfigTemplateImpl = /** @class */ (function () {\n    function RemoteConfigTemplateImpl(config) {\n        if (!validator.isNonNullObject(config) ||\n            !validator.isNonEmptyString(config.etag)) {\n            throw new remote_config_utils_1.FirebaseRemoteConfigError('invalid-argument', \"Invalid Remote Config template: \" + JSON.stringify(config));\n        }\n        this.etagInternal = config.etag;\n        if (typeof config.parameters !== 'undefined') {\n            if (!validator.isNonNullObject(config.parameters)) {\n                throw new remote_config_utils_1.FirebaseRemoteConfigError('invalid-argument', 'Remote Config parameters must be a non-null object');\n            }\n            this.parameters = config.parameters;\n        }\n        else {\n            this.parameters = {};\n        }\n        if (typeof config.parameterGroups !== 'undefined') {\n            if (!validator.isNonNullObject(config.parameterGroups)) {\n                throw new remote_config_utils_1.FirebaseRemoteConfigError('invalid-argument', 'Remote Config parameter groups must be a non-null object');\n            }\n            this.parameterGroups = config.parameterGroups;\n        }\n        else {\n            this.parameterGroups = {};\n        }\n        if (typeof config.conditions !== 'undefined') {\n            if (!validator.isArray(config.conditions)) {\n                throw new remote_config_utils_1.FirebaseRemoteConfigError('invalid-argument', 'Remote Config conditions must be an array');\n            }\n            this.conditions = config.conditions;\n        }\n        else {\n            this.conditions = [];\n        }\n        if (typeof config.version !== 'undefined') {\n            this.version = new VersionImpl(config.version);\n        }\n    }\n    Object.defineProperty(RemoteConfigTemplateImpl.prototype, \"etag\", {\n        /**\n         * Gets the ETag of the template.\n         *\n         * @return {string} The ETag of the Remote Config template.\n         */\n        get: function () {\n            return this.etagInternal;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {RemoteConfigTemplate} A JSON-serializable representation of this object.\n     */\n    RemoteConfigTemplateImpl.prototype.toJSON = function () {\n        return {\n            conditions: this.conditions,\n            parameters: this.parameters,\n            parameterGroups: this.parameterGroups,\n            etag: this.etag,\n            version: this.version,\n        };\n    };\n    return RemoteConfigTemplateImpl;\n}());\n/**\n* Remote Config Version internal implementation.\n*/\nvar VersionImpl = /** @class */ (function () {\n    function VersionImpl(version) {\n        if (!validator.isNonNullObject(version)) {\n            throw new remote_config_utils_1.FirebaseRemoteConfigError('invalid-argument', \"Invalid Remote Config version instance: \" + JSON.stringify(version));\n        }\n        if (typeof version.versionNumber !== 'undefined') {\n            if (!validator.isNonEmptyString(version.versionNumber) &&\n                !validator.isNumber(version.versionNumber)) {\n                throw new remote_config_utils_1.FirebaseRemoteConfigError('invalid-argument', 'Version number must be a non-empty string in int64 format or a number');\n            }\n            if (!Number.isInteger(Number(version.versionNumber))) {\n                throw new remote_config_utils_1.FirebaseRemoteConfigError('invalid-argument', 'Version number must be an integer or a string in int64 format');\n            }\n            this.versionNumber = version.versionNumber;\n        }\n        if (typeof version.updateOrigin !== 'undefined') {\n            if (!validator.isNonEmptyString(version.updateOrigin)) {\n                throw new remote_config_utils_1.FirebaseRemoteConfigError('invalid-argument', 'Version update origin must be a non-empty string');\n            }\n            this.updateOrigin = version.updateOrigin;\n        }\n        if (typeof version.updateType !== 'undefined') {\n            if (!validator.isNonEmptyString(version.updateType)) {\n                throw new remote_config_utils_1.FirebaseRemoteConfigError('invalid-argument', 'Version update type must be a non-empty string');\n            }\n            this.updateType = version.updateType;\n        }\n        if (typeof version.updateUser !== 'undefined') {\n            if (!validator.isNonNullObject(version.updateUser)) {\n                throw new remote_config_utils_1.FirebaseRemoteConfigError('invalid-argument', 'Version update user must be a non-null object');\n            }\n            this.updateUser = version.updateUser;\n        }\n        if (typeof version.description !== 'undefined') {\n            if (!validator.isNonEmptyString(version.description)) {\n                throw new remote_config_utils_1.FirebaseRemoteConfigError('invalid-argument', 'Version description must be a non-empty string');\n            }\n            this.description = version.description;\n        }\n        if (typeof version.rollbackSource !== 'undefined') {\n            if (!validator.isNonEmptyString(version.rollbackSource)) {\n                throw new remote_config_utils_1.FirebaseRemoteConfigError('invalid-argument', 'Version rollback source must be a non-empty string');\n            }\n            this.rollbackSource = version.rollbackSource;\n        }\n        if (typeof version.isLegacy !== 'undefined') {\n            if (!validator.isBoolean(version.isLegacy)) {\n                throw new remote_config_utils_1.FirebaseRemoteConfigError('invalid-argument', 'Version.isLegacy must be a boolean');\n            }\n            this.isLegacy = version.isLegacy;\n        }\n        // The backend API provides timestamps as ISO date strings. The Admin SDK exposes timestamps\n        // as UTC date strings. If a developer uses a previously obtained template with UTC timestamps\n        // we could still validate it below.\n        if (typeof version.updateTime !== 'undefined') {\n            if (!validator.isISODateString(version.updateTime) &&\n                !validator.isUTCDateString(version.updateTime)) {\n                throw new remote_config_utils_1.FirebaseRemoteConfigError('invalid-argument', 'Version update time must be a valid date string');\n            }\n            if (validator.isISODateString(version.updateTime)) {\n                // timestamps in output `Version` obtained from the API should be in UTC.\n                this.updateTime = new Date(version.updateTime).toUTCString();\n            }\n        }\n    }\n    /**\n     * @return {Version} A JSON-serializable representation of this object.\n     */\n    VersionImpl.prototype.toJSON = function () {\n        return {\n            versionNumber: this.versionNumber,\n            updateOrigin: this.updateOrigin,\n            updateType: this.updateType,\n            updateUser: this.updateUser,\n            description: this.description,\n            rollbackSource: this.rollbackSource,\n            isLegacy: this.isLegacy,\n            updateTime: this.updateTime,\n        };\n    };\n    return VersionImpl;\n}());\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/remote-config/remote-config.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/security-rules/security-rules-api-client.js":
/*!*****************************************************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/security-rules/security-rules-api-client.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\n/*!\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar api_request_1 = __webpack_require__(/*! ../utils/api-request */ \"./src/node_modules/firebase-admin/lib/utils/api-request.js\");\nvar error_1 = __webpack_require__(/*! ../utils/error */ \"./src/node_modules/firebase-admin/lib/utils/error.js\");\nvar security_rules_utils_1 = __webpack_require__(/*! ./security-rules-utils */ \"./src/node_modules/firebase-admin/lib/security-rules/security-rules-utils.js\");\nvar utils = __webpack_require__(/*! ../utils/index */ \"./src/node_modules/firebase-admin/lib/utils/index.js\");\nvar validator = __webpack_require__(/*! ../utils/validator */ \"./src/node_modules/firebase-admin/lib/utils/validator.js\");\nvar RULES_V1_API = 'https://firebaserules.googleapis.com/v1';\nvar FIREBASE_VERSION_HEADER = {\n    'X-Firebase-Client': 'fire-admin-node/8.13.0',\n};\n/**\n * Class that facilitates sending requests to the Firebase security rules backend API.\n *\n * @private\n */\nvar SecurityRulesApiClient = /** @class */ (function () {\n    function SecurityRulesApiClient(app) {\n        this.app = app;\n        if (!validator.isNonNullObject(app) || !('options' in app)) {\n            throw new security_rules_utils_1.FirebaseSecurityRulesError('invalid-argument', 'First argument passed to admin.securityRules() must be a valid Firebase app '\n                + 'instance.');\n        }\n        this.httpClient = new api_request_1.AuthorizedHttpClient(app);\n    }\n    SecurityRulesApiClient.prototype.getRuleset = function (name) {\n        var _this = this;\n        return Promise.resolve()\n            .then(function () {\n            return _this.getRulesetName(name);\n        })\n            .then(function (rulesetName) {\n            return _this.getResource(rulesetName);\n        });\n    };\n    SecurityRulesApiClient.prototype.createRuleset = function (ruleset) {\n        var _this = this;\n        if (!validator.isNonNullObject(ruleset) ||\n            !validator.isNonNullObject(ruleset.source) ||\n            !validator.isNonEmptyArray(ruleset.source.files)) {\n            var err = new security_rules_utils_1.FirebaseSecurityRulesError('invalid-argument', 'Invalid rules content.');\n            return Promise.reject(err);\n        }\n        for (var _i = 0, _a = ruleset.source.files; _i < _a.length; _i++) {\n            var rf = _a[_i];\n            if (!validator.isNonNullObject(rf) ||\n                !validator.isNonEmptyString(rf.name) ||\n                !validator.isNonEmptyString(rf.content)) {\n                var err = new security_rules_utils_1.FirebaseSecurityRulesError('invalid-argument', \"Invalid rules file argument: \" + JSON.stringify(rf));\n                return Promise.reject(err);\n            }\n        }\n        return this.getUrl()\n            .then(function (url) {\n            var request = {\n                method: 'POST',\n                url: url + \"/rulesets\",\n                data: ruleset,\n            };\n            return _this.sendRequest(request);\n        });\n    };\n    SecurityRulesApiClient.prototype.deleteRuleset = function (name) {\n        var _this = this;\n        return this.getUrl()\n            .then(function (url) {\n            var rulesetName = _this.getRulesetName(name);\n            var request = {\n                method: 'DELETE',\n                url: url + \"/\" + rulesetName,\n            };\n            return _this.sendRequest(request);\n        });\n    };\n    SecurityRulesApiClient.prototype.listRulesets = function (pageSize, pageToken) {\n        var _this = this;\n        if (pageSize === void 0) { pageSize = 100; }\n        if (!validator.isNumber(pageSize)) {\n            var err = new security_rules_utils_1.FirebaseSecurityRulesError('invalid-argument', 'Invalid page size.');\n            return Promise.reject(err);\n        }\n        if (pageSize < 1 || pageSize > 100) {\n            var err = new security_rules_utils_1.FirebaseSecurityRulesError('invalid-argument', 'Page size must be between 1 and 100.');\n            return Promise.reject(err);\n        }\n        if (typeof pageToken !== 'undefined' && !validator.isNonEmptyString(pageToken)) {\n            var err = new security_rules_utils_1.FirebaseSecurityRulesError('invalid-argument', 'Next page token must be a non-empty string.');\n            return Promise.reject(err);\n        }\n        var data = {\n            pageSize: pageSize,\n            pageToken: pageToken,\n        };\n        if (!pageToken) {\n            delete data.pageToken;\n        }\n        return this.getUrl()\n            .then(function (url) {\n            var request = {\n                method: 'GET',\n                url: url + \"/rulesets\",\n                data: data,\n            };\n            return _this.sendRequest(request);\n        });\n    };\n    SecurityRulesApiClient.prototype.getRelease = function (name) {\n        return this.getResource(\"releases/\" + name);\n    };\n    SecurityRulesApiClient.prototype.updateRelease = function (name, rulesetName) {\n        var _this = this;\n        return this.getUrl()\n            .then(function (url) {\n            return _this.getReleaseDescription(name, rulesetName)\n                .then(function (release) {\n                var request = {\n                    method: 'PATCH',\n                    url: url + \"/releases/\" + name,\n                    data: { release: release },\n                };\n                return _this.sendRequest(request);\n            });\n        });\n    };\n    SecurityRulesApiClient.prototype.getUrl = function () {\n        return this.getProjectIdPrefix()\n            .then(function (projectIdPrefix) {\n            return RULES_V1_API + \"/\" + projectIdPrefix;\n        });\n    };\n    SecurityRulesApiClient.prototype.getProjectIdPrefix = function () {\n        var _this = this;\n        if (this.projectIdPrefix) {\n            return Promise.resolve(this.projectIdPrefix);\n        }\n        return utils.findProjectId(this.app)\n            .then(function (projectId) {\n            if (!validator.isNonEmptyString(projectId)) {\n                throw new security_rules_utils_1.FirebaseSecurityRulesError('invalid-argument', 'Failed to determine project ID. Initialize the SDK with service account credentials, or '\n                    + 'set project ID as an app option. Alternatively, set the GOOGLE_CLOUD_PROJECT '\n                    + 'environment variable.');\n            }\n            _this.projectIdPrefix = \"projects/\" + projectId;\n            return _this.projectIdPrefix;\n        });\n    };\n    /**\n     * Gets the specified resource from the rules API. Resource names must be the short names without project\n     * ID prefix (e.g. `rulesets/ruleset-name`).\n     *\n     * @param {string} name Full qualified name of the resource to get.\n     * @returns {Promise<T>} A promise that fulfills with the resource.\n     */\n    SecurityRulesApiClient.prototype.getResource = function (name) {\n        var _this = this;\n        return this.getUrl()\n            .then(function (url) {\n            var request = {\n                method: 'GET',\n                url: url + \"/\" + name,\n            };\n            return _this.sendRequest(request);\n        });\n    };\n    SecurityRulesApiClient.prototype.getReleaseDescription = function (name, rulesetName) {\n        var _this = this;\n        return this.getProjectIdPrefix()\n            .then(function (projectIdPrefix) {\n            return {\n                name: projectIdPrefix + \"/releases/\" + name,\n                rulesetName: projectIdPrefix + \"/\" + _this.getRulesetName(rulesetName),\n            };\n        });\n    };\n    SecurityRulesApiClient.prototype.getRulesetName = function (name) {\n        if (!validator.isNonEmptyString(name)) {\n            throw new security_rules_utils_1.FirebaseSecurityRulesError('invalid-argument', 'Ruleset name must be a non-empty string.');\n        }\n        if (name.indexOf('/') !== -1) {\n            throw new security_rules_utils_1.FirebaseSecurityRulesError('invalid-argument', 'Ruleset name must not contain any \"/\" characters.');\n        }\n        return \"rulesets/\" + name;\n    };\n    SecurityRulesApiClient.prototype.sendRequest = function (request) {\n        var _this = this;\n        request.headers = FIREBASE_VERSION_HEADER;\n        return this.httpClient.send(request)\n            .then(function (resp) {\n            return resp.data;\n        })\n            .catch(function (err) {\n            throw _this.toFirebaseError(err);\n        });\n    };\n    SecurityRulesApiClient.prototype.toFirebaseError = function (err) {\n        if (err instanceof error_1.PrefixedFirebaseError) {\n            return err;\n        }\n        var response = err.response;\n        if (!response.isJson()) {\n            return new security_rules_utils_1.FirebaseSecurityRulesError('unknown-error', \"Unexpected response with status: \" + response.status + \" and body: \" + response.text);\n        }\n        var error = response.data.error || {};\n        var code = 'unknown-error';\n        if (error.status && error.status in ERROR_CODE_MAPPING) {\n            code = ERROR_CODE_MAPPING[error.status];\n        }\n        var message = error.message || \"Unknown server error: \" + response.text;\n        return new security_rules_utils_1.FirebaseSecurityRulesError(code, message);\n    };\n    return SecurityRulesApiClient;\n}());\nexports.SecurityRulesApiClient = SecurityRulesApiClient;\nvar ERROR_CODE_MAPPING = {\n    INVALID_ARGUMENT: 'invalid-argument',\n    NOT_FOUND: 'not-found',\n    RESOURCE_EXHAUSTED: 'resource-exhausted',\n    UNAUTHENTICATED: 'authentication-error',\n    UNKNOWN: 'unknown-error',\n};\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/security-rules/security-rules-api-client.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/security-rules/security-rules-utils.js":
/*!************************************************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/security-rules/security-rules-utils.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\n/*!\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar error_1 = __webpack_require__(/*! ../utils/error */ \"./src/node_modules/firebase-admin/lib/utils/error.js\");\nvar FirebaseSecurityRulesError = /** @class */ (function (_super) {\n    __extends(FirebaseSecurityRulesError, _super);\n    function FirebaseSecurityRulesError(code, message) {\n        return _super.call(this, 'security-rules', code, message) || this;\n    }\n    return FirebaseSecurityRulesError;\n}(error_1.PrefixedFirebaseError));\nexports.FirebaseSecurityRulesError = FirebaseSecurityRulesError;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/security-rules/security-rules-utils.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/security-rules/security-rules.js":
/*!******************************************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/security-rules/security-rules.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\n/*!\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar validator = __webpack_require__(/*! ../utils/validator */ \"./src/node_modules/firebase-admin/lib/utils/validator.js\");\nvar security_rules_api_client_1 = __webpack_require__(/*! ./security-rules-api-client */ \"./src/node_modules/firebase-admin/lib/security-rules/security-rules-api-client.js\");\nvar security_rules_utils_1 = __webpack_require__(/*! ./security-rules-utils */ \"./src/node_modules/firebase-admin/lib/security-rules/security-rules-utils.js\");\nvar RulesetMetadataListImpl = /** @class */ (function () {\n    function RulesetMetadataListImpl(response) {\n        if (!validator.isNonNullObject(response) || !validator.isArray(response.rulesets)) {\n            throw new security_rules_utils_1.FirebaseSecurityRulesError('invalid-argument', \"Invalid ListRulesets response: \" + JSON.stringify(response));\n        }\n        this.rulesets = response.rulesets.map(function (rs) {\n            return {\n                name: stripProjectIdPrefix(rs.name),\n                createTime: new Date(rs.createTime).toUTCString(),\n            };\n        });\n        if (response.nextPageToken) {\n            this.nextPageToken = response.nextPageToken;\n        }\n    }\n    return RulesetMetadataListImpl;\n}());\n/**\n * Represents a set of Firebase security rules.\n */\nvar Ruleset = /** @class */ (function () {\n    function Ruleset(ruleset) {\n        if (!validator.isNonNullObject(ruleset) ||\n            !validator.isNonEmptyString(ruleset.name) ||\n            !validator.isNonEmptyString(ruleset.createTime) ||\n            !validator.isNonNullObject(ruleset.source)) {\n            throw new security_rules_utils_1.FirebaseSecurityRulesError('invalid-argument', \"Invalid Ruleset response: \" + JSON.stringify(ruleset));\n        }\n        this.name = stripProjectIdPrefix(ruleset.name);\n        this.createTime = new Date(ruleset.createTime).toUTCString();\n        this.source = ruleset.source.files || [];\n    }\n    return Ruleset;\n}());\nexports.Ruleset = Ruleset;\n/**\n * SecurityRules service bound to the provided app.\n */\nvar SecurityRules = /** @class */ (function () {\n    /**\n     * @param {object} app The app for this SecurityRules service.\n     * @constructor\n     */\n    function SecurityRules(app) {\n        this.app = app;\n        this.INTERNAL = new SecurityRulesInternals();\n        this.client = new security_rules_api_client_1.SecurityRulesApiClient(app);\n    }\n    /**\n     * Gets the Ruleset identified by the given name. The input name should be the short name string without\n     * the project ID prefix. For example, to retrieve the `projects/project-id/rulesets/my-ruleset`, pass the\n     * short name \"my-ruleset\". Rejects with a `not-found` error if the specified Ruleset cannot be found.\n     *\n     * @param {string} name Name of the Ruleset to retrieve.\n     * @returns {Promise<Ruleset>} A promise that fulfills with the specified Ruleset.\n     */\n    SecurityRules.prototype.getRuleset = function (name) {\n        return this.client.getRuleset(name)\n            .then(function (rulesetResponse) {\n            return new Ruleset(rulesetResponse);\n        });\n    };\n    /**\n     * Gets the Ruleset currently applied to Cloud Firestore. Rejects with a `not-found` error if no Ruleset is\n     * applied on Firestore.\n     *\n     * @returns {Promise<Ruleset>} A promise that fulfills with the Firestore Ruleset.\n     */\n    SecurityRules.prototype.getFirestoreRuleset = function () {\n        return this.getRulesetForRelease(SecurityRules.CLOUD_FIRESTORE);\n    };\n    /**\n     * Creates a new ruleset from the given source, and applies it to Cloud Firestore.\n     *\n     * @param {string|Buffer} source Rules source to apply.\n     * @returns {Promise<Ruleset>} A promise that fulfills when the ruleset is created and released.\n     */\n    SecurityRules.prototype.releaseFirestoreRulesetFromSource = function (source) {\n        var _this = this;\n        return Promise.resolve()\n            .then(function () {\n            var rulesFile = _this.createRulesFileFromSource('firestore.rules', source);\n            return _this.createRuleset(rulesFile);\n        })\n            .then(function (ruleset) {\n            return _this.releaseFirestoreRuleset(ruleset)\n                .then(function () {\n                return ruleset;\n            });\n        });\n    };\n    /**\n     * Makes the specified ruleset the currently applied ruleset for Cloud Firestore.\n     *\n     * @param {string|RulesetMetadata} ruleset Name of the ruleset to apply or a RulesetMetadata object containing\n     *   the name.\n     * @returns {Promise<void>} A promise that fulfills when the ruleset is released.\n     */\n    SecurityRules.prototype.releaseFirestoreRuleset = function (ruleset) {\n        return this.releaseRuleset(ruleset, SecurityRules.CLOUD_FIRESTORE);\n    };\n    /**\n     * Gets the Ruleset currently applied to a Cloud Storage bucket. Rejects with a `not-found` error if no Ruleset is\n     * applied on the bucket.\n     *\n     * @param {string=} bucket Optional name of the Cloud Storage bucket to be retrieved. If not specified,\n     *   retrieves the ruleset applied on the default bucket configured via `AppOptions`.\n     * @returns {Promise<Ruleset>} A promise that fulfills with the Cloud Storage Ruleset.\n     */\n    SecurityRules.prototype.getStorageRuleset = function (bucket) {\n        var _this = this;\n        return Promise.resolve()\n            .then(function () {\n            return _this.getBucketName(bucket);\n        })\n            .then(function (bucketName) {\n            return _this.getRulesetForRelease(SecurityRules.FIREBASE_STORAGE + \"/\" + bucketName);\n        });\n    };\n    /**\n     * Creates a new ruleset from the given source, and applies it to a Cloud Storage bucket.\n     *\n     * @param {string|Buffer} source Rules source to apply.\n     * @param {string=} bucket Optional name of the Cloud Storage bucket to apply the rules on. If not specified,\n     *   applies the ruleset on the default bucket configured via `AppOptions`.\n     * @returns {Promise<Ruleset>} A promise that fulfills when the ruleset is created and released.\n     */\n    SecurityRules.prototype.releaseStorageRulesetFromSource = function (source, bucket) {\n        var _this = this;\n        return Promise.resolve()\n            .then(function () {\n            // Bucket name is not required until the last step. But since there's a createRuleset step\n            // before then, make sure to run this check and fail early if the bucket name is invalid.\n            _this.getBucketName(bucket);\n            var rulesFile = _this.createRulesFileFromSource('storage.rules', source);\n            return _this.createRuleset(rulesFile);\n        })\n            .then(function (ruleset) {\n            return _this.releaseStorageRuleset(ruleset, bucket)\n                .then(function () {\n                return ruleset;\n            });\n        });\n    };\n    /**\n     * Makes the specified ruleset the currently applied ruleset for a Cloud Storage bucket.\n     *\n     * @param {string|RulesetMetadata} ruleset Name of the ruleset to apply or a RulesetMetadata object containing\n     *   the name.\n     * @param {string=} bucket Optional name of the Cloud Storage bucket to apply the rules on. If not specified,\n     *   applies the ruleset on the default bucket configured via `AppOptions`.\n     * @returns {Promise<void>} A promise that fulfills when the ruleset is released.\n     */\n    SecurityRules.prototype.releaseStorageRuleset = function (ruleset, bucket) {\n        var _this = this;\n        return Promise.resolve()\n            .then(function () {\n            return _this.getBucketName(bucket);\n        })\n            .then(function (bucketName) {\n            return _this.releaseRuleset(ruleset, SecurityRules.FIREBASE_STORAGE + \"/\" + bucketName);\n        });\n    };\n    /**\n     * Creates a `RulesFile` with the given name and source. Throws if any of the arguments are invalid. This is a\n     * local operation, and does not involve any network API calls.\n     *\n     * @param {string} name Name to assign to the rules file.\n     * @param {string|Buffer} source Contents of the rules file.\n     * @returns {RulesFile} A new rules file instance.\n     */\n    SecurityRules.prototype.createRulesFileFromSource = function (name, source) {\n        if (!validator.isNonEmptyString(name)) {\n            throw new security_rules_utils_1.FirebaseSecurityRulesError('invalid-argument', 'Name must be a non-empty string.');\n        }\n        var content;\n        if (validator.isNonEmptyString(source)) {\n            content = source;\n        }\n        else if (validator.isBuffer(source)) {\n            content = source.toString('utf-8');\n        }\n        else {\n            throw new security_rules_utils_1.FirebaseSecurityRulesError('invalid-argument', 'Source must be a non-empty string or a Buffer.');\n        }\n        return {\n            name: name,\n            content: content,\n        };\n    };\n    /**\n     * Creates a new `Ruleset` from the given `RulesFile`.\n     *\n     * @param {RulesFile} file Rules file to include in the new Ruleset.\n     * @returns {Promise<Ruleset>} A promise that fulfills with the newly created Ruleset.\n     */\n    SecurityRules.prototype.createRuleset = function (file) {\n        var ruleset = {\n            source: {\n                files: [file],\n            },\n        };\n        return this.client.createRuleset(ruleset)\n            .then(function (rulesetResponse) {\n            return new Ruleset(rulesetResponse);\n        });\n    };\n    /**\n     * Deletes the Ruleset identified by the given name. The input name should be the short name string without\n     * the project ID prefix. For example, to delete the `projects/project-id/rulesets/my-ruleset`, pass the\n     * short name \"my-ruleset\". Rejects with a `not-found` error if the specified Ruleset cannot be found.\n     *\n     * @param {string} name Name of the Ruleset to delete.\n     * @returns {Promise<Ruleset>} A promise that fulfills when the Ruleset is deleted.\n     */\n    SecurityRules.prototype.deleteRuleset = function (name) {\n        return this.client.deleteRuleset(name);\n    };\n    /**\n     * Retrieves a page of rulesets.\n     *\n     * @param {number=} pageSize The page size, 100 if undefined. This is also the maximum allowed limit.\n     * @param {string=} nextPageToken The next page token. If not specified, returns rulesets starting\n     *   without any offset.\n     * @returns {Promise<RulesetMetadataList>} A promise that fulfills a page of rulesets.\n     */\n    SecurityRules.prototype.listRulesetMetadata = function (pageSize, nextPageToken) {\n        if (pageSize === void 0) { pageSize = 100; }\n        return this.client.listRulesets(pageSize, nextPageToken)\n            .then(function (response) {\n            return new RulesetMetadataListImpl(response);\n        });\n    };\n    SecurityRules.prototype.getRulesetForRelease = function (releaseName) {\n        var _this = this;\n        return this.client.getRelease(releaseName)\n            .then(function (release) {\n            var rulesetName = release.rulesetName;\n            if (!validator.isNonEmptyString(rulesetName)) {\n                throw new security_rules_utils_1.FirebaseSecurityRulesError('not-found', \"Ruleset name not found for \" + releaseName + \".\");\n            }\n            return _this.getRuleset(stripProjectIdPrefix(rulesetName));\n        });\n    };\n    SecurityRules.prototype.releaseRuleset = function (ruleset, releaseName) {\n        if (!validator.isNonEmptyString(ruleset) &&\n            (!validator.isNonNullObject(ruleset) || !validator.isNonEmptyString(ruleset.name))) {\n            var err = new security_rules_utils_1.FirebaseSecurityRulesError('invalid-argument', 'ruleset must be a non-empty name or a RulesetMetadata object.');\n            return Promise.reject(err);\n        }\n        var rulesetName = validator.isString(ruleset) ? ruleset : ruleset.name;\n        return this.client.updateRelease(releaseName, rulesetName)\n            .then(function () {\n            return;\n        });\n    };\n    SecurityRules.prototype.getBucketName = function (bucket) {\n        var bucketName = (typeof bucket !== 'undefined') ? bucket : this.app.options.storageBucket;\n        if (!validator.isNonEmptyString(bucketName)) {\n            throw new security_rules_utils_1.FirebaseSecurityRulesError('invalid-argument', 'Bucket name not specified or invalid. Specify a default bucket name via the ' +\n                'storageBucket option when initializing the app, or specify the bucket name ' +\n                'explicitly when calling the rules API.');\n        }\n        return bucketName;\n    };\n    SecurityRules.CLOUD_FIRESTORE = 'cloud.firestore';\n    SecurityRules.FIREBASE_STORAGE = 'firebase.storage';\n    return SecurityRules;\n}());\nexports.SecurityRules = SecurityRules;\nvar SecurityRulesInternals = /** @class */ (function () {\n    function SecurityRulesInternals() {\n    }\n    SecurityRulesInternals.prototype.delete = function () {\n        return Promise.resolve();\n    };\n    return SecurityRulesInternals;\n}());\nfunction stripProjectIdPrefix(name) {\n    return name.split('/').pop();\n}\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/security-rules/security-rules.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/storage/storage.js":
/*!****************************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/storage/storage.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\n/*!\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar error_1 = __webpack_require__(/*! ../utils/error */ \"./src/node_modules/firebase-admin/lib/utils/error.js\");\nvar credential_1 = __webpack_require__(/*! ../auth/credential */ \"./src/node_modules/firebase-admin/lib/auth/credential.js\");\nvar utils = __webpack_require__(/*! ../utils/index */ \"./src/node_modules/firebase-admin/lib/utils/index.js\");\nvar validator = __webpack_require__(/*! ../utils/validator */ \"./src/node_modules/firebase-admin/lib/utils/validator.js\");\n/**\n * Internals of a Storage instance.\n */\nvar StorageInternals = /** @class */ (function () {\n    function StorageInternals() {\n    }\n    /**\n     * Deletes the service and its associated resources.\n     *\n     * @return {Promise<()>} An empty Promise that will be fulfilled when the service is deleted.\n     */\n    StorageInternals.prototype.delete = function () {\n        // There are no resources to clean up.\n        return Promise.resolve();\n    };\n    return StorageInternals;\n}());\n/**\n * Storage service bound to the provided app.\n */\nvar Storage = /** @class */ (function () {\n    /**\n     * @param {FirebaseApp} app The app for this Storage service.\n     * @constructor\n     */\n    function Storage(app) {\n        this.INTERNAL = new StorageInternals();\n        if (!validator.isNonNullObject(app) || !('options' in app)) {\n            throw new error_1.FirebaseError({\n                code: 'storage/invalid-argument',\n                message: 'First argument passed to admin.storage() must be a valid Firebase app instance.',\n            });\n        }\n        var storage;\n        try {\n            storage = __webpack_require__(/*! @google-cloud/storage */ \"./src/node_modules/@google-cloud/storage/build/src/index.js\").Storage;\n        }\n        catch (err) {\n            throw new error_1.FirebaseError({\n                code: 'storage/missing-dependencies',\n                message: 'Failed to import the Cloud Storage client library for Node.js. '\n                    + 'Make sure to install the \"@google-cloud/storage\" npm package. '\n                    + (\"Original error: \" + err),\n            });\n        }\n        var projectId = utils.getExplicitProjectId(app);\n        var credential = app.options.credential;\n        if (credential instanceof credential_1.ServiceAccountCredential) {\n            this.storageClient = new storage({\n                // When the SDK is initialized with ServiceAccountCredentials an explicit projectId is\n                // guaranteed to be available.\n                projectId: projectId,\n                credentials: {\n                    private_key: credential.privateKey,\n                    client_email: credential.clientEmail,\n                },\n            });\n        }\n        else if (credential_1.isApplicationDefault(app.options.credential)) {\n            // Try to use the Google application default credentials.\n            this.storageClient = new storage();\n        }\n        else {\n            throw new error_1.FirebaseError({\n                code: 'storage/invalid-credential',\n                message: 'Failed to initialize Google Cloud Storage client with the available credential. ' +\n                    'Must initialize the SDK with a certificate credential or application default credentials ' +\n                    'to use Cloud Storage API.',\n            });\n        }\n        this.appInternal = app;\n    }\n    /**\n     * Returns a reference to a Google Cloud Storage bucket. Returned reference can be used to upload\n     * and download content from Google Cloud Storage.\n     *\n     * @param {string=} name Optional name of the bucket to be retrieved. If name is not specified,\n     *   retrieves a reference to the default bucket.\n     * @return {Bucket} A Bucket object from the @google-cloud/storage library.\n     */\n    Storage.prototype.bucket = function (name) {\n        var bucketName = (typeof name !== 'undefined')\n            ? name : this.appInternal.options.storageBucket;\n        if (validator.isNonEmptyString(bucketName)) {\n            return this.storageClient.bucket(bucketName);\n        }\n        throw new error_1.FirebaseError({\n            code: 'storage/invalid-argument',\n            message: 'Bucket name not specified or invalid. Specify a valid bucket name via the ' +\n                'storageBucket option when initializing the app, or specify the bucket name ' +\n                'explicitly when calling the getBucket() method.',\n        });\n    };\n    Object.defineProperty(Storage.prototype, \"app\", {\n        /**\n         * Returns the app associated with this Storage instance.\n         *\n         * @return {FirebaseApp} The app associated with this Storage instance.\n         */\n        get: function () {\n            return this.appInternal;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return Storage;\n}());\nexports.Storage = Storage;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/storage/storage.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/utils/api-request.js":
/*!******************************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/utils/api-request.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\n/*!\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar error_1 = __webpack_require__(/*! ./error */ \"./src/node_modules/firebase-admin/lib/utils/error.js\");\nvar validator = __webpack_require__(/*! ./validator */ \"./src/node_modules/firebase-admin/lib/utils/validator.js\");\nvar http = __webpack_require__(/*! http */ \"http\");\nvar https = __webpack_require__(/*! https */ \"https\");\nvar url = __webpack_require__(/*! url */ \"url\");\nvar events_1 = __webpack_require__(/*! events */ \"events\");\nvar DefaultHttpResponse = /** @class */ (function () {\n    /**\n     * Constructs a new HttpResponse from the given LowLevelResponse.\n     */\n    function DefaultHttpResponse(resp) {\n        this.status = resp.status;\n        this.headers = resp.headers;\n        this.text = resp.data;\n        try {\n            if (!resp.data) {\n                throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, 'HTTP response missing data.');\n            }\n            this.parsedData = JSON.parse(resp.data);\n        }\n        catch (err) {\n            this.parsedData = undefined;\n            this.parseError = err;\n        }\n        this.request = resp.config.method + \" \" + resp.config.url;\n    }\n    Object.defineProperty(DefaultHttpResponse.prototype, \"data\", {\n        get: function () {\n            if (this.isJson()) {\n                return this.parsedData;\n            }\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.UNABLE_TO_PARSE_RESPONSE, \"Error while parsing response data: \\\"\" + this.parseError.toString() + \"\\\". Raw server \" +\n                (\"response: \\\"\" + this.text + \"\\\". Status code: \\\"\" + this.status + \"\\\". Outgoing \") +\n                (\"request: \\\"\" + this.request + \".\\\"\"));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    DefaultHttpResponse.prototype.isJson = function () {\n        return typeof this.parsedData !== 'undefined';\n    };\n    return DefaultHttpResponse;\n}());\n/**\n * Represents a multipart HTTP response. Parts that constitute the response body can be accessed\n * via the multipart getter. Getters for text and data throw errors.\n */\nvar MultipartHttpResponse = /** @class */ (function () {\n    function MultipartHttpResponse(resp) {\n        this.status = resp.status;\n        this.headers = resp.headers;\n        this.multipart = resp.multipart;\n    }\n    Object.defineProperty(MultipartHttpResponse.prototype, \"text\", {\n        get: function () {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.UNABLE_TO_PARSE_RESPONSE, 'Unable to parse multipart payload as text');\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MultipartHttpResponse.prototype, \"data\", {\n        get: function () {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.UNABLE_TO_PARSE_RESPONSE, 'Unable to parse multipart payload as JSON');\n        },\n        enumerable: true,\n        configurable: true\n    });\n    MultipartHttpResponse.prototype.isJson = function () {\n        return false;\n    };\n    return MultipartHttpResponse;\n}());\nvar HttpError = /** @class */ (function (_super) {\n    __extends(HttpError, _super);\n    function HttpError(response) {\n        var _this = _super.call(this, \"Server responded with status \" + response.status + \".\") || this;\n        _this.response = response;\n        // Set the prototype so that instanceof checks will work correctly.\n        // See: https://github.com/Microsoft/TypeScript/issues/13965\n        Object.setPrototypeOf(_this, HttpError.prototype);\n        return _this;\n    }\n    return HttpError;\n}(Error));\nexports.HttpError = HttpError;\n/**\n * Default retry configuration for HTTP requests. Retries up to 4 times on connection reset and timeout errors\n * as well as HTTP 503 errors. Exposed as a function to ensure that every HttpClient gets its own RetryConfig\n * instance.\n */\nfunction defaultRetryConfig() {\n    return {\n        maxRetries: 4,\n        statusCodes: [503],\n        ioErrorCodes: ['ECONNRESET', 'ETIMEDOUT'],\n        backOffFactor: 0.5,\n        maxDelayInMillis: 60 * 1000,\n    };\n}\nexports.defaultRetryConfig = defaultRetryConfig;\n/**\n * Ensures that the given RetryConfig object is valid.\n *\n * @param retry The configuration to be validated.\n */\nfunction validateRetryConfig(retry) {\n    if (!validator.isNumber(retry.maxRetries) || retry.maxRetries < 0) {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, 'maxRetries must be a non-negative integer');\n    }\n    if (typeof retry.backOffFactor !== 'undefined') {\n        if (!validator.isNumber(retry.backOffFactor) || retry.backOffFactor < 0) {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, 'backOffFactor must be a non-negative number');\n        }\n    }\n    if (!validator.isNumber(retry.maxDelayInMillis) || retry.maxDelayInMillis < 0) {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, 'maxDelayInMillis must be a non-negative integer');\n    }\n    if (typeof retry.statusCodes !== 'undefined' && !validator.isArray(retry.statusCodes)) {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, 'statusCodes must be an array');\n    }\n    if (typeof retry.ioErrorCodes !== 'undefined' && !validator.isArray(retry.ioErrorCodes)) {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, 'ioErrorCodes must be an array');\n    }\n}\nvar HttpClient = /** @class */ (function () {\n    function HttpClient(retry) {\n        if (retry === void 0) { retry = defaultRetryConfig(); }\n        this.retry = retry;\n        if (this.retry) {\n            validateRetryConfig(this.retry);\n        }\n    }\n    /**\n     * Sends an HTTP request to a remote server. If the server responds with a successful response (2xx), the returned\n     * promise resolves with an HttpResponse. If the server responds with an error (3xx, 4xx, 5xx), the promise rejects\n     * with an HttpError. In case of all other errors, the promise rejects with a FirebaseAppError. If a request fails\n     * due to a low-level network error, transparently retries the request once before rejecting the promise.\n     *\n     * If the request data is specified as an object, it will be serialized into a JSON string. The application/json\n     * content-type header will also be automatically set in this case. For all other payload types, the content-type\n     * header should be explicitly set by the caller. To send a JSON leaf value (e.g. \"foo\", 5), parse it into JSON,\n     * and pass as a string or a Buffer along with the appropriate content-type header.\n     *\n     * @param {HttpRequest} config HTTP request to be sent.\n     * @return {Promise<HttpResponse>} A promise that resolves with the response details.\n     */\n    HttpClient.prototype.send = function (config) {\n        return this.sendWithRetry(config);\n    };\n    /**\n     * Sends an HTTP request. In the event of an error, retries the HTTP request according to the\n     * RetryConfig set on the HttpClient.\n     *\n     * @param {HttpRequestConfig} config HTTP request to be sent.\n     * @param {number} retryAttempts Number of retries performed up to now.\n     * @return {Promise<HttpResponse>} A promise that resolves with the response details.\n     */\n    HttpClient.prototype.sendWithRetry = function (config, retryAttempts) {\n        var _this = this;\n        if (retryAttempts === void 0) { retryAttempts = 0; }\n        return AsyncHttpCall.invoke(config)\n            .then(function (resp) {\n            return _this.createHttpResponse(resp);\n        })\n            .catch(function (err) {\n            var _a = _this.getRetryDelayMillis(retryAttempts, err), delayMillis = _a[0], canRetry = _a[1];\n            if (canRetry && _this.retry && delayMillis <= _this.retry.maxDelayInMillis) {\n                return _this.waitForRetry(delayMillis).then(function () {\n                    return _this.sendWithRetry(config, retryAttempts + 1);\n                });\n            }\n            if (err.response) {\n                throw new HttpError(_this.createHttpResponse(err.response));\n            }\n            if (err.code === 'ETIMEDOUT') {\n                throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NETWORK_TIMEOUT, \"Error while making request: \" + err.message + \".\");\n            }\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NETWORK_ERROR, \"Error while making request: \" + err.message + \". Error code: \" + err.code);\n        });\n    };\n    HttpClient.prototype.createHttpResponse = function (resp) {\n        if (resp.multipart) {\n            return new MultipartHttpResponse(resp);\n        }\n        return new DefaultHttpResponse(resp);\n    };\n    HttpClient.prototype.waitForRetry = function (delayMillis) {\n        if (delayMillis > 0) {\n            return new Promise(function (resolve) {\n                setTimeout(resolve, delayMillis);\n            });\n        }\n        return Promise.resolve();\n    };\n    /**\n     * Checks if a failed request is eligible for a retry, and if so returns the duration to wait before initiating\n     * the retry.\n     *\n     * @param {number} retryAttempts Number of retries completed up to now.\n     * @param {LowLevelError} err The last encountered error.\n     * @returns {[number, boolean]} A 2-tuple where the 1st element is the duration to wait before another retry, and the\n     *     2nd element is a boolean indicating whether the request is eligible for a retry or not.\n     */\n    HttpClient.prototype.getRetryDelayMillis = function (retryAttempts, err) {\n        if (!this.isRetryEligible(retryAttempts, err)) {\n            return [0, false];\n        }\n        var response = err.response;\n        if (response && response.headers['retry-after']) {\n            var delayMillis = this.parseRetryAfterIntoMillis(response.headers['retry-after']);\n            if (delayMillis > 0) {\n                return [delayMillis, true];\n            }\n        }\n        return [this.backOffDelayMillis(retryAttempts), true];\n    };\n    HttpClient.prototype.isRetryEligible = function (retryAttempts, err) {\n        if (!this.retry) {\n            return false;\n        }\n        if (retryAttempts >= this.retry.maxRetries) {\n            return false;\n        }\n        if (err.response) {\n            var statusCodes = this.retry.statusCodes || [];\n            return statusCodes.indexOf(err.response.status) !== -1;\n        }\n        if (err.code) {\n            var retryCodes = this.retry.ioErrorCodes || [];\n            return retryCodes.indexOf(err.code) !== -1;\n        }\n        return false;\n    };\n    /**\n     * Parses the Retry-After HTTP header as a milliseconds value. Return value is negative if the Retry-After header\n     * contains an expired timestamp or otherwise malformed.\n     */\n    HttpClient.prototype.parseRetryAfterIntoMillis = function (retryAfter) {\n        var delaySeconds = parseInt(retryAfter, 10);\n        if (!isNaN(delaySeconds)) {\n            return delaySeconds * 1000;\n        }\n        var date = new Date(retryAfter);\n        if (!isNaN(date.getTime())) {\n            return date.getTime() - Date.now();\n        }\n        return -1;\n    };\n    HttpClient.prototype.backOffDelayMillis = function (retryAttempts) {\n        if (retryAttempts === 0) {\n            return 0;\n        }\n        if (!this.retry) {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, 'Expected this.retry to exist.');\n        }\n        var backOffFactor = this.retry.backOffFactor || 0;\n        var delayInSeconds = (Math.pow(2, retryAttempts)) * backOffFactor;\n        return Math.min(delayInSeconds * 1000, this.retry.maxDelayInMillis);\n    };\n    return HttpClient;\n}());\nexports.HttpClient = HttpClient;\n/**\n * Parses a full HTTP response message containing both a header and a body.\n *\n * @param {string|Buffer} response The HTTP response to be parsed.\n * @param {HttpRequestConfig} config The request configuration that resulted in the HTTP response.\n * @return {HttpResponse} An object containing the parsed HTTP status, headers and the body.\n */\nfunction parseHttpResponse(response, config) {\n    var responseText = validator.isBuffer(response) ?\n        response.toString('utf-8') : response;\n    var endOfHeaderPos = responseText.indexOf('\\r\\n\\r\\n');\n    var headerLines = responseText.substring(0, endOfHeaderPos).split('\\r\\n');\n    var statusLine = headerLines[0];\n    var status = statusLine.trim().split(/\\s/)[1];\n    var headers = {};\n    headerLines.slice(1).forEach(function (line) {\n        var colonPos = line.indexOf(':');\n        var name = line.substring(0, colonPos).trim().toLowerCase();\n        var value = line.substring(colonPos + 1).trim();\n        headers[name] = value;\n    });\n    var data = responseText.substring(endOfHeaderPos + 4);\n    if (data.endsWith('\\n')) {\n        data = data.slice(0, -1);\n    }\n    if (data.endsWith('\\r')) {\n        data = data.slice(0, -1);\n    }\n    var lowLevelResponse = {\n        status: parseInt(status, 10),\n        headers: headers,\n        data: data,\n        config: config,\n        request: null,\n    };\n    if (!validator.isNumber(lowLevelResponse.status)) {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, 'Malformed HTTP status line.');\n    }\n    return new DefaultHttpResponse(lowLevelResponse);\n}\nexports.parseHttpResponse = parseHttpResponse;\n/**\n * A helper class for sending HTTP requests over the wire. This is a wrapper around the standard\n * http and https packages of Node.js, providing content processing, timeouts and error handling.\n * It also wraps the callback API of the Node.js standard library in a more flexible Promise API.\n */\nvar AsyncHttpCall = /** @class */ (function () {\n    function AsyncHttpCall(config) {\n        var _this = this;\n        try {\n            this.config = new HttpRequestConfigImpl(config);\n            this.options = this.config.buildRequestOptions();\n            this.entity = this.config.buildEntity(this.options.headers);\n            this.promise = new Promise(function (resolve, reject) {\n                _this.resolve = resolve;\n                _this.reject = reject;\n                _this.execute();\n            });\n        }\n        catch (err) {\n            this.promise = Promise.reject(this.enhanceError(err, null));\n        }\n    }\n    /**\n     * Sends an HTTP request based on the provided configuration.\n     */\n    AsyncHttpCall.invoke = function (config) {\n        return new AsyncHttpCall(config).promise;\n    };\n    AsyncHttpCall.prototype.execute = function () {\n        var _this = this;\n        var transport = this.options.protocol === 'https:' ? https : http;\n        var req = transport.request(this.options, function (res) {\n            _this.handleResponse(res, req);\n        });\n        // Handle errors\n        req.on('error', function (err) {\n            if (req.aborted) {\n                return;\n            }\n            _this.enhanceAndReject(err, null, req);\n        });\n        var timeout = this.config.timeout;\n        if (timeout) {\n            // Listen to timeouts and throw an error.\n            req.setTimeout(timeout, function () {\n                req.abort();\n                _this.rejectWithError(\"timeout of \" + timeout + \"ms exceeded\", 'ETIMEDOUT', req);\n            });\n        }\n        // Send the request\n        req.end(this.entity);\n    };\n    AsyncHttpCall.prototype.handleResponse = function (res, req) {\n        if (req.aborted) {\n            return;\n        }\n        if (!res.statusCode) {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, 'Expected a statusCode on the response from a ClientRequest');\n        }\n        var response = {\n            status: res.statusCode,\n            headers: res.headers,\n            request: req,\n            data: undefined,\n            config: this.config,\n        };\n        var boundary = this.getMultipartBoundary(res.headers);\n        var respStream = this.uncompressResponse(res);\n        if (boundary) {\n            this.handleMultipartResponse(response, respStream, boundary);\n        }\n        else {\n            this.handleRegularResponse(response, respStream);\n        }\n    };\n    /**\n     * Extracts multipart boundary from the HTTP header. The content-type header of a multipart\n     * response has the form 'multipart/subtype; boundary=string'.\n     *\n     * If the content-type header does not exist, or does not start with\n     * 'multipart/', then null will be returned.\n     */\n    AsyncHttpCall.prototype.getMultipartBoundary = function (headers) {\n        var contentType = headers['content-type'];\n        if (!contentType || !contentType.startsWith('multipart/')) {\n            return null;\n        }\n        var segments = contentType.split(';');\n        var emptyObject = {};\n        var headerParams = segments.slice(1)\n            .map(function (segment) { return segment.trim().split('='); })\n            .reduce(function (curr, params) {\n            // Parse key=value pairs in the content-type header into properties of an object.\n            if (params.length === 2) {\n                var keyValuePair = {};\n                keyValuePair[params[0]] = params[1];\n                return Object.assign(curr, keyValuePair);\n            }\n            return curr;\n        }, emptyObject);\n        return headerParams.boundary;\n    };\n    AsyncHttpCall.prototype.uncompressResponse = function (res) {\n        // Uncompress the response body transparently if required.\n        var respStream = res;\n        var encodings = ['gzip', 'compress', 'deflate'];\n        if (res.headers['content-encoding'] && encodings.indexOf(res.headers['content-encoding']) !== -1) {\n            // Add the unzipper to the body stream processing pipeline.\n            var zlib = __webpack_require__(/*! zlib */ \"zlib\"); // eslint-disable-line @typescript-eslint/no-var-requires\n            respStream = respStream.pipe(zlib.createUnzip());\n            // Remove the content-encoding in order to not confuse downstream operations.\n            delete res.headers['content-encoding'];\n        }\n        return respStream;\n    };\n    AsyncHttpCall.prototype.handleMultipartResponse = function (response, respStream, boundary) {\n        var _this = this;\n        var dicer = __webpack_require__(/*! dicer */ \"./src/node_modules/dicer/lib/Dicer.js\"); // eslint-disable-line @typescript-eslint/no-var-requires\n        var multipartParser = new dicer({ boundary: boundary });\n        var responseBuffer = [];\n        multipartParser.on('part', function (part) {\n            var tempBuffers = [];\n            part.on('data', function (partData) {\n                tempBuffers.push(partData);\n            });\n            part.on('end', function () {\n                responseBuffer.push(Buffer.concat(tempBuffers));\n            });\n        });\n        multipartParser.on('finish', function () {\n            response.data = undefined;\n            response.multipart = responseBuffer;\n            _this.finalizeResponse(response);\n        });\n        respStream.pipe(multipartParser);\n    };\n    AsyncHttpCall.prototype.handleRegularResponse = function (response, respStream) {\n        var _this = this;\n        var responseBuffer = [];\n        respStream.on('data', function (chunk) {\n            responseBuffer.push(chunk);\n        });\n        respStream.on('error', function (err) {\n            var req = response.request;\n            if (req && req.aborted) {\n                return;\n            }\n            _this.enhanceAndReject(err, null, req);\n        });\n        respStream.on('end', function () {\n            response.data = Buffer.concat(responseBuffer).toString();\n            _this.finalizeResponse(response);\n        });\n    };\n    /**\n     * Finalizes the current HTTP call in-flight by either resolving or rejecting the associated\n     * promise. In the event of an error, adds additional useful information to the returned error.\n     */\n    AsyncHttpCall.prototype.finalizeResponse = function (response) {\n        if (response.status >= 200 && response.status < 300) {\n            this.resolve(response);\n        }\n        else {\n            this.rejectWithError('Request failed with status code ' + response.status, null, response.request, response);\n        }\n    };\n    /**\n     * Creates a new error from the given message, and enhances it with other information available.\n     * Then the promise associated with this HTTP call is rejected with the resulting error.\n     */\n    AsyncHttpCall.prototype.rejectWithError = function (message, code, request, response) {\n        var error = new Error(message);\n        this.enhanceAndReject(error, code, request, response);\n    };\n    AsyncHttpCall.prototype.enhanceAndReject = function (error, code, request, response) {\n        this.reject(this.enhanceError(error, code, request, response));\n    };\n    /**\n     * Enhances the given error by adding more information to it. Specifically, the HttpRequestConfig,\n     * the underlying request and response will be attached to the error.\n     */\n    AsyncHttpCall.prototype.enhanceError = function (error, code, request, response) {\n        error.config = this.config;\n        if (code) {\n            error.code = code;\n        }\n        error.request = request;\n        error.response = response;\n        return error;\n    };\n    return AsyncHttpCall;\n}());\n/**\n * An adapter class for extracting options and entity data from an HttpRequestConfig.\n */\nvar HttpRequestConfigImpl = /** @class */ (function () {\n    function HttpRequestConfigImpl(config) {\n        this.config = config;\n    }\n    Object.defineProperty(HttpRequestConfigImpl.prototype, \"method\", {\n        get: function () {\n            return this.config.method;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(HttpRequestConfigImpl.prototype, \"url\", {\n        get: function () {\n            return this.config.url;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(HttpRequestConfigImpl.prototype, \"headers\", {\n        get: function () {\n            return this.config.headers;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(HttpRequestConfigImpl.prototype, \"data\", {\n        get: function () {\n            return this.config.data;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(HttpRequestConfigImpl.prototype, \"timeout\", {\n        get: function () {\n            return this.config.timeout;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(HttpRequestConfigImpl.prototype, \"httpAgent\", {\n        get: function () {\n            return this.config.httpAgent;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    HttpRequestConfigImpl.prototype.buildRequestOptions = function () {\n        var parsed = this.buildUrl();\n        var protocol = parsed.protocol;\n        var port = parsed.port;\n        if (!port) {\n            var isHttps = protocol === 'https:';\n            port = isHttps ? '443' : '80';\n        }\n        return {\n            protocol: protocol,\n            hostname: parsed.hostname,\n            port: port,\n            path: parsed.path,\n            method: this.method,\n            agent: this.httpAgent,\n            headers: Object.assign({}, this.headers),\n        };\n    };\n    HttpRequestConfigImpl.prototype.buildEntity = function (headers) {\n        var data;\n        if (!this.hasEntity() || !this.isEntityEnclosingRequest()) {\n            return data;\n        }\n        if (validator.isBuffer(this.data)) {\n            data = this.data;\n        }\n        else if (validator.isObject(this.data)) {\n            data = Buffer.from(JSON.stringify(this.data), 'utf-8');\n            if (typeof headers['content-type'] === 'undefined') {\n                headers['content-type'] = 'application/json;charset=utf-8';\n            }\n        }\n        else if (validator.isString(this.data)) {\n            data = Buffer.from(this.data, 'utf-8');\n        }\n        else {\n            throw new Error('Request data must be a string, a Buffer or a json serializable object');\n        }\n        // Add Content-Length header if data exists.\n        headers['Content-Length'] = data.length.toString();\n        return data;\n    };\n    HttpRequestConfigImpl.prototype.buildUrl = function () {\n        var fullUrl = this.urlWithProtocol();\n        if (!this.hasEntity() || this.isEntityEnclosingRequest()) {\n            return url.parse(fullUrl);\n        }\n        if (!validator.isObject(this.data)) {\n            throw new Error(this.method + \" requests cannot have a body\");\n        }\n        // Parse URL and append data to query string.\n        var parsedUrl = new url.URL(fullUrl);\n        var dataObj = this.data;\n        for (var key in dataObj) {\n            if (Object.prototype.hasOwnProperty.call(dataObj, key)) {\n                parsedUrl.searchParams.append(key, dataObj[key]);\n            }\n        }\n        return url.parse(parsedUrl.toString());\n    };\n    HttpRequestConfigImpl.prototype.urlWithProtocol = function () {\n        var fullUrl = this.url;\n        if (fullUrl.startsWith('http://') || fullUrl.startsWith('https://')) {\n            return fullUrl;\n        }\n        return \"https://\" + fullUrl;\n    };\n    HttpRequestConfigImpl.prototype.hasEntity = function () {\n        return !!this.data;\n    };\n    HttpRequestConfigImpl.prototype.isEntityEnclosingRequest = function () {\n        // GET and HEAD requests do not support entity (body) in request.\n        return this.method !== 'GET' && this.method !== 'HEAD';\n    };\n    return HttpRequestConfigImpl;\n}());\nvar AuthorizedHttpClient = /** @class */ (function (_super) {\n    __extends(AuthorizedHttpClient, _super);\n    function AuthorizedHttpClient(app) {\n        var _this = _super.call(this) || this;\n        _this.app = app;\n        return _this;\n    }\n    AuthorizedHttpClient.prototype.send = function (request) {\n        var _this = this;\n        return this.app.INTERNAL.getToken().then(function (accessTokenObj) {\n            var requestCopy = Object.assign({}, request);\n            requestCopy.headers = Object.assign({}, request.headers);\n            var authHeader = 'Authorization';\n            requestCopy.headers[authHeader] = \"Bearer \" + accessTokenObj.accessToken;\n            if (!requestCopy.httpAgent && _this.app.options.httpAgent) {\n                requestCopy.httpAgent = _this.app.options.httpAgent;\n            }\n            return _super.prototype.send.call(_this, requestCopy);\n        });\n    };\n    return AuthorizedHttpClient;\n}(HttpClient));\nexports.AuthorizedHttpClient = AuthorizedHttpClient;\n/**\n * Class that defines all the settings for the backend API endpoint.\n *\n * @param {string} endpoint The Firebase Auth backend endpoint.\n * @param {HttpMethod} httpMethod The http method for that endpoint.\n * @constructor\n */\nvar ApiSettings = /** @class */ (function () {\n    function ApiSettings(endpoint, httpMethod) {\n        if (httpMethod === void 0) { httpMethod = 'POST'; }\n        this.endpoint = endpoint;\n        this.httpMethod = httpMethod;\n        this.setRequestValidator(null)\n            .setResponseValidator(null);\n    }\n    /** @return {string} The backend API endpoint. */\n    ApiSettings.prototype.getEndpoint = function () {\n        return this.endpoint;\n    };\n    /** @return {HttpMethod} The request HTTP method. */\n    ApiSettings.prototype.getHttpMethod = function () {\n        return this.httpMethod;\n    };\n    /**\n     * @param {ApiCallbackFunction} requestValidator The request validator.\n     * @return {ApiSettings} The current API settings instance.\n     */\n    ApiSettings.prototype.setRequestValidator = function (requestValidator) {\n        var nullFunction = function () { return undefined; };\n        this.requestValidator = requestValidator || nullFunction;\n        return this;\n    };\n    /** @return {ApiCallbackFunction} The request validator. */\n    ApiSettings.prototype.getRequestValidator = function () {\n        return this.requestValidator;\n    };\n    /**\n     * @param {ApiCallbackFunction} responseValidator The response validator.\n     * @return {ApiSettings} The current API settings instance.\n     */\n    ApiSettings.prototype.setResponseValidator = function (responseValidator) {\n        var nullFunction = function () { return undefined; };\n        this.responseValidator = responseValidator || nullFunction;\n        return this;\n    };\n    /** @return {ApiCallbackFunction} The response validator. */\n    ApiSettings.prototype.getResponseValidator = function () {\n        return this.responseValidator;\n    };\n    return ApiSettings;\n}());\nexports.ApiSettings = ApiSettings;\n/**\n * Class used for polling an endpoint with exponential backoff.\n *\n * Example usage:\n * ```\n * const poller = new ExponentialBackoffPoller();\n * poller\n *     .poll(() => {\n *       return myRequestToPoll()\n *           .then((responseData: any) => {\n *             if (!isValid(responseData)) {\n *               // Continue polling.\n *               return null;\n *             }\n *\n *             // Polling complete. Resolve promise with final response data.\n *             return responseData;\n *           });\n *     })\n *     .then((responseData: any) => {\n *       console.log(`Final response: ${responseData}`);\n *     });\n * ```\n */\nvar ExponentialBackoffPoller = /** @class */ (function (_super) {\n    __extends(ExponentialBackoffPoller, _super);\n    function ExponentialBackoffPoller(initialPollingDelayMillis, maxPollingDelayMillis, masterTimeoutMillis) {\n        if (initialPollingDelayMillis === void 0) { initialPollingDelayMillis = 1000; }\n        if (maxPollingDelayMillis === void 0) { maxPollingDelayMillis = 10000; }\n        if (masterTimeoutMillis === void 0) { masterTimeoutMillis = 60000; }\n        var _this = _super.call(this) || this;\n        _this.initialPollingDelayMillis = initialPollingDelayMillis;\n        _this.maxPollingDelayMillis = maxPollingDelayMillis;\n        _this.masterTimeoutMillis = masterTimeoutMillis;\n        _this.numTries = 0;\n        _this.completed = false;\n        return _this;\n    }\n    /**\n     * Poll the provided callback with exponential backoff.\n     *\n     * @param {() => Promise<object>} callback The callback to be called for each poll. If the\n     *     callback resolves to a falsey value, polling will continue. Otherwise, the truthy\n     *     resolution will be used to resolve the promise returned by this method.\n     * @return {Promise<object>} A Promise which resolves to the truthy value returned by the provided\n     *     callback when polling is complete.\n     */\n    ExponentialBackoffPoller.prototype.poll = function (callback) {\n        var _this = this;\n        if (this.pollCallback) {\n            throw new Error('poll() can only be called once per instance of ExponentialBackoffPoller');\n        }\n        this.pollCallback = callback;\n        this.on('poll', this.repoll);\n        this.masterTimer = setTimeout(function () {\n            if (_this.completed) {\n                return;\n            }\n            _this.markCompleted();\n            _this.reject(new Error('ExponentialBackoffPoller deadline exceeded - Master timeout reached'));\n        }, this.masterTimeoutMillis);\n        return new Promise(function (resolve, reject) {\n            _this.resolve = resolve;\n            _this.reject = reject;\n            _this.repoll();\n        });\n    };\n    ExponentialBackoffPoller.prototype.repoll = function () {\n        var _this = this;\n        this.pollCallback()\n            .then(function (result) {\n            if (_this.completed) {\n                return;\n            }\n            if (!result) {\n                _this.repollTimer =\n                    setTimeout(function () { return _this.emit('poll'); }, _this.getPollingDelayMillis());\n                _this.numTries++;\n                return;\n            }\n            _this.markCompleted();\n            _this.resolve(result);\n        })\n            .catch(function (err) {\n            if (_this.completed) {\n                return;\n            }\n            _this.markCompleted();\n            _this.reject(err);\n        });\n    };\n    ExponentialBackoffPoller.prototype.getPollingDelayMillis = function () {\n        var increasedPollingDelay = Math.pow(2, this.numTries) * this.initialPollingDelayMillis;\n        return Math.min(increasedPollingDelay, this.maxPollingDelayMillis);\n    };\n    ExponentialBackoffPoller.prototype.markCompleted = function () {\n        this.completed = true;\n        if (this.masterTimer) {\n            clearTimeout(this.masterTimer);\n        }\n        if (this.repollTimer) {\n            clearTimeout(this.repollTimer);\n        }\n    };\n    return ExponentialBackoffPoller;\n}(events_1.EventEmitter));\nexports.ExponentialBackoffPoller = ExponentialBackoffPoller;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/utils/api-request.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/utils/deep-copy.js":
/*!****************************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/utils/deep-copy.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\n/*!\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Returns a deep copy of an object or array.\n *\n * @param {object|array} value The object or array to deep copy.\n * @return {object|array} A deep copy of the provided object or array.\n */\nfunction deepCopy(value) {\n    return deepExtend(undefined, value);\n}\nexports.deepCopy = deepCopy;\n/**\n * Copies properties from source to target (recursively allows extension of objects and arrays).\n * Scalar values in the target are over-written. If target is undefined, an object of the\n * appropriate type will be created (and returned).\n *\n * We recursively copy all child properties of plain objects in the source - so that namespace-like\n * objects are merged.\n *\n * Note that the target can be a function, in which case the properties in the source object are\n * copied onto it as static properties of the function.\n *\n * @param {any} target The value which is being extended.\n * @param {any} source The value whose properties are extending the target.\n * @return {any} The target value.\n */\nfunction deepExtend(target, source) {\n    if (!(source instanceof Object)) {\n        return source;\n    }\n    switch (source.constructor) {\n        case Date: {\n            // Treat Dates like scalars; if the target date object had any child\n            // properties - they will be lost!\n            var dateValue = source;\n            return new Date(dateValue.getTime());\n        }\n        case Object:\n            if (target === undefined) {\n                target = {};\n            }\n            break;\n        case Array:\n            // Always copy the array source and overwrite the target.\n            target = [];\n            break;\n        default:\n            // Not a plain Object - treat it as a scalar.\n            return source;\n    }\n    for (var prop in source) {\n        if (!Object.prototype.hasOwnProperty.call(source, prop)) {\n            continue;\n        }\n        target[prop] = deepExtend(target[prop], source[prop]);\n    }\n    return target;\n}\nexports.deepExtend = deepExtend;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/utils/deep-copy.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/utils/error.js":
/*!************************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/utils/error.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\n/*!\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar deep_copy_1 = __webpack_require__(/*! ../utils/deep-copy */ \"./src/node_modules/firebase-admin/lib/utils/deep-copy.js\");\n/**\n * Firebase error code structure. This extends Error.\n *\n * @param {ErrorInfo} errorInfo The error information (code and message).\n * @constructor\n */\nvar FirebaseError = /** @class */ (function (_super) {\n    __extends(FirebaseError, _super);\n    function FirebaseError(errorInfo) {\n        var _this = _super.call(this, errorInfo.message) || this;\n        _this.errorInfo = errorInfo;\n        /* tslint:disable:max-line-length */\n        // Set the prototype explicitly. See the following link for more details:\n        // https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\n        /* tslint:enable:max-line-length */\n        _this.__proto__ = FirebaseError.prototype;\n        return _this;\n    }\n    Object.defineProperty(FirebaseError.prototype, \"code\", {\n        /** @return {string} The error code. */\n        get: function () {\n            return this.errorInfo.code;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FirebaseError.prototype, \"message\", {\n        /** @return {string} The error message. */\n        get: function () {\n            return this.errorInfo.message;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** @return {object} The object representation of the error. */\n    FirebaseError.prototype.toJSON = function () {\n        return {\n            code: this.code,\n            message: this.message,\n        };\n    };\n    return FirebaseError;\n}(Error));\nexports.FirebaseError = FirebaseError;\n/**\n * A FirebaseError with a prefix in front of the error code.\n *\n * @param {string} codePrefix The prefix to apply to the error code.\n * @param {string} code The error code.\n * @param {string} message The error message.\n * @constructor\n */\nvar PrefixedFirebaseError = /** @class */ (function (_super) {\n    __extends(PrefixedFirebaseError, _super);\n    function PrefixedFirebaseError(codePrefix, code, message) {\n        var _this = _super.call(this, {\n            code: codePrefix + \"/\" + code,\n            message: message,\n        }) || this;\n        _this.codePrefix = codePrefix;\n        /* tslint:disable:max-line-length */\n        // Set the prototype explicitly. See the following link for more details:\n        // https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\n        /* tslint:enable:max-line-length */\n        _this.__proto__ = PrefixedFirebaseError.prototype;\n        return _this;\n    }\n    /**\n     * Allows the error type to be checked without needing to know implementation details\n     * of the code prefixing.\n     *\n     * @param {string} code The non-prefixed error code to test against.\n     * @return {boolean} True if the code matches, false otherwise.\n     */\n    PrefixedFirebaseError.prototype.hasCode = function (code) {\n        return this.codePrefix + \"/\" + code === this.code;\n    };\n    return PrefixedFirebaseError;\n}(FirebaseError));\nexports.PrefixedFirebaseError = PrefixedFirebaseError;\n/**\n * Firebase App error code structure. This extends PrefixedFirebaseError.\n *\n * @param {string} code The error code.\n * @param {string} message The error message.\n * @constructor\n */\nvar FirebaseAppError = /** @class */ (function (_super) {\n    __extends(FirebaseAppError, _super);\n    function FirebaseAppError(code, message) {\n        var _this = _super.call(this, 'app', code, message) || this;\n        /* tslint:disable:max-line-length */\n        // Set the prototype explicitly. See the following link for more details:\n        // https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\n        /* tslint:enable:max-line-length */\n        _this.__proto__ = FirebaseAppError.prototype;\n        return _this;\n    }\n    return FirebaseAppError;\n}(PrefixedFirebaseError));\nexports.FirebaseAppError = FirebaseAppError;\n/**\n * Firebase Auth error code structure. This extends PrefixedFirebaseError.\n *\n * @param {ErrorInfo} info The error code info.\n * @param {string} [message] The error message. This will override the default\n *     message if provided.\n * @constructor\n */\nvar FirebaseAuthError = /** @class */ (function (_super) {\n    __extends(FirebaseAuthError, _super);\n    function FirebaseAuthError(info, message) {\n        var _this = \n        // Override default message if custom message provided.\n        _super.call(this, 'auth', info.code, message || info.message) || this;\n        /* tslint:disable:max-line-length */\n        // Set the prototype explicitly. See the following link for more details:\n        // https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\n        /* tslint:enable:max-line-length */\n        _this.__proto__ = FirebaseAuthError.prototype;\n        return _this;\n    }\n    /**\n     * Creates the developer-facing error corresponding to the backend error code.\n     *\n     * @param {string} serverErrorCode The server error code.\n     * @param {string} [message] The error message. The default message is used\n     *     if not provided.\n     * @param {object} [rawServerResponse] The error's raw server response.\n     * @return {FirebaseAuthError} The corresponding developer-facing error.\n     */\n    FirebaseAuthError.fromServerError = function (serverErrorCode, message, rawServerResponse) {\n        // serverErrorCode could contain additional details:\n        // ERROR_CODE : Detailed message which can also contain colons\n        var colonSeparator = (serverErrorCode || '').indexOf(':');\n        var customMessage = null;\n        if (colonSeparator !== -1) {\n            customMessage = serverErrorCode.substring(colonSeparator + 1).trim();\n            serverErrorCode = serverErrorCode.substring(0, colonSeparator).trim();\n        }\n        // If not found, default to internal error.\n        var clientCodeKey = AUTH_SERVER_TO_CLIENT_CODE[serverErrorCode] || 'INTERNAL_ERROR';\n        var error = deep_copy_1.deepCopy(AuthClientErrorCode[clientCodeKey]);\n        // Server detailed message should have highest priority.\n        error.message = customMessage || message || error.message;\n        if (clientCodeKey === 'INTERNAL_ERROR' && typeof rawServerResponse !== 'undefined') {\n            try {\n                error.message += \" Raw server response: \\\"\" + JSON.stringify(rawServerResponse) + \"\\\"\";\n            }\n            catch (e) {\n                // Ignore JSON parsing error.\n            }\n        }\n        return new FirebaseAuthError(error);\n    };\n    return FirebaseAuthError;\n}(PrefixedFirebaseError));\nexports.FirebaseAuthError = FirebaseAuthError;\n/**\n * Firebase Database error code structure. This extends FirebaseError.\n *\n * @param {ErrorInfo} info The error code info.\n * @param {string} [message] The error message. This will override the default\n *     message if provided.\n * @constructor\n */\nvar FirebaseDatabaseError = /** @class */ (function (_super) {\n    __extends(FirebaseDatabaseError, _super);\n    function FirebaseDatabaseError(info, message) {\n        // Override default message if custom message provided.\n        return _super.call(this, { code: 'database/' + info.code, message: message || info.message }) || this;\n    }\n    return FirebaseDatabaseError;\n}(FirebaseError));\nexports.FirebaseDatabaseError = FirebaseDatabaseError;\n/**\n * Firebase Firestore error code structure. This extends FirebaseError.\n *\n * @param {ErrorInfo} info The error code info.\n * @param {string} [message] The error message. This will override the default\n *     message if provided.\n * @constructor\n */\nvar FirebaseFirestoreError = /** @class */ (function (_super) {\n    __extends(FirebaseFirestoreError, _super);\n    function FirebaseFirestoreError(info, message) {\n        // Override default message if custom message provided.\n        return _super.call(this, { code: 'firestore/' + info.code, message: message || info.message }) || this;\n    }\n    return FirebaseFirestoreError;\n}(FirebaseError));\nexports.FirebaseFirestoreError = FirebaseFirestoreError;\n/**\n * Firebase instance ID error code structure. This extends FirebaseError.\n *\n * @param {ErrorInfo} info The error code info.\n * @param {string} [message] The error message. This will override the default\n *     message if provided.\n * @constructor\n */\nvar FirebaseInstanceIdError = /** @class */ (function (_super) {\n    __extends(FirebaseInstanceIdError, _super);\n    function FirebaseInstanceIdError(info, message) {\n        // Override default message if custom message provided.\n        return _super.call(this, { code: 'instance-id/' + info.code, message: message || info.message }) || this;\n    }\n    return FirebaseInstanceIdError;\n}(FirebaseError));\nexports.FirebaseInstanceIdError = FirebaseInstanceIdError;\n/**\n * Firebase Messaging error code structure. This extends PrefixedFirebaseError.\n *\n * @param {ErrorInfo} info The error code info.\n * @param {string} [message] The error message. This will override the default message if provided.\n * @constructor\n */\nvar FirebaseMessagingError = /** @class */ (function (_super) {\n    __extends(FirebaseMessagingError, _super);\n    function FirebaseMessagingError(info, message) {\n        var _this = \n        // Override default message if custom message provided.\n        _super.call(this, 'messaging', info.code, message || info.message) || this;\n        /* tslint:disable:max-line-length */\n        // Set the prototype explicitly. See the following link for more details:\n        // https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\n        /* tslint:enable:max-line-length */\n        _this.__proto__ = FirebaseMessagingError.prototype;\n        return _this;\n    }\n    /**\n     * Creates the developer-facing error corresponding to the backend error code.\n     *\n     * @param {string} serverErrorCode The server error code.\n     * @param {string} [message] The error message. The default message is used\n     *     if not provided.\n     * @param {object} [rawServerResponse] The error's raw server response.\n     * @return {FirebaseMessagingError} The corresponding developer-facing error.\n     */\n    FirebaseMessagingError.fromServerError = function (serverErrorCode, message, rawServerResponse) {\n        // If not found, default to unknown error.\n        var clientCodeKey = 'UNKNOWN_ERROR';\n        if (serverErrorCode && serverErrorCode in MESSAGING_SERVER_TO_CLIENT_CODE) {\n            clientCodeKey = MESSAGING_SERVER_TO_CLIENT_CODE[serverErrorCode];\n        }\n        var error = deep_copy_1.deepCopy(MessagingClientErrorCode[clientCodeKey]);\n        error.message = message || error.message;\n        if (clientCodeKey === 'UNKNOWN_ERROR' && typeof rawServerResponse !== 'undefined') {\n            try {\n                error.message += \" Raw server response: \\\"\" + JSON.stringify(rawServerResponse) + \"\\\"\";\n            }\n            catch (e) {\n                // Ignore JSON parsing error.\n            }\n        }\n        return new FirebaseMessagingError(error);\n    };\n    FirebaseMessagingError.fromTopicManagementServerError = function (serverErrorCode, message, rawServerResponse) {\n        // If not found, default to unknown error.\n        var clientCodeKey = TOPIC_MGT_SERVER_TO_CLIENT_CODE[serverErrorCode] || 'UNKNOWN_ERROR';\n        var error = deep_copy_1.deepCopy(MessagingClientErrorCode[clientCodeKey]);\n        error.message = message || error.message;\n        if (clientCodeKey === 'UNKNOWN_ERROR' && typeof rawServerResponse !== 'undefined') {\n            try {\n                error.message += \" Raw server response: \\\"\" + JSON.stringify(rawServerResponse) + \"\\\"\";\n            }\n            catch (e) {\n                // Ignore JSON parsing error.\n            }\n        }\n        return new FirebaseMessagingError(error);\n    };\n    return FirebaseMessagingError;\n}(PrefixedFirebaseError));\nexports.FirebaseMessagingError = FirebaseMessagingError;\n/**\n * Firebase project management error code structure. This extends PrefixedFirebaseError.\n *\n * @param {ProjectManagementErrorCode} code The error code.\n * @param {string} message The error message.\n * @constructor\n */\nvar FirebaseProjectManagementError = /** @class */ (function (_super) {\n    __extends(FirebaseProjectManagementError, _super);\n    function FirebaseProjectManagementError(code, message) {\n        var _this = _super.call(this, 'project-management', code, message) || this;\n        /* tslint:disable:max-line-length */\n        // Set the prototype explicitly. See the following link for more details:\n        // https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\n        /* tslint:enable:max-line-length */\n        _this.__proto__ = FirebaseProjectManagementError.prototype;\n        return _this;\n    }\n    return FirebaseProjectManagementError;\n}(PrefixedFirebaseError));\nexports.FirebaseProjectManagementError = FirebaseProjectManagementError;\n/**\n * App client error codes and their default messages.\n */\nvar AppErrorCodes = /** @class */ (function () {\n    function AppErrorCodes() {\n    }\n    AppErrorCodes.APP_DELETED = 'app-deleted';\n    AppErrorCodes.DUPLICATE_APP = 'duplicate-app';\n    AppErrorCodes.INVALID_ARGUMENT = 'invalid-argument';\n    AppErrorCodes.INTERNAL_ERROR = 'internal-error';\n    AppErrorCodes.INVALID_APP_NAME = 'invalid-app-name';\n    AppErrorCodes.INVALID_APP_OPTIONS = 'invalid-app-options';\n    AppErrorCodes.INVALID_CREDENTIAL = 'invalid-credential';\n    AppErrorCodes.NETWORK_ERROR = 'network-error';\n    AppErrorCodes.NETWORK_TIMEOUT = 'network-timeout';\n    AppErrorCodes.NO_APP = 'no-app';\n    AppErrorCodes.UNABLE_TO_PARSE_RESPONSE = 'unable-to-parse-response';\n    return AppErrorCodes;\n}());\nexports.AppErrorCodes = AppErrorCodes;\n/**\n * Auth client error codes and their default messages.\n */\nvar AuthClientErrorCode = /** @class */ (function () {\n    function AuthClientErrorCode() {\n    }\n    AuthClientErrorCode.BILLING_NOT_ENABLED = {\n        code: 'billing-not-enabled',\n        message: 'Feature requires billing to be enabled.',\n    };\n    AuthClientErrorCode.CLAIMS_TOO_LARGE = {\n        code: 'claims-too-large',\n        message: 'Developer claims maximum payload size exceeded.',\n    };\n    AuthClientErrorCode.CONFIGURATION_EXISTS = {\n        code: 'configuration-exists',\n        message: 'A configuration already exists with the provided identifier.',\n    };\n    AuthClientErrorCode.CONFIGURATION_NOT_FOUND = {\n        code: 'configuration-not-found',\n        message: 'There is no configuration corresponding to the provided identifier.',\n    };\n    AuthClientErrorCode.ID_TOKEN_EXPIRED = {\n        code: 'id-token-expired',\n        message: 'The provided Firebase ID token is expired.',\n    };\n    AuthClientErrorCode.INVALID_ARGUMENT = {\n        code: 'argument-error',\n        message: 'Invalid argument provided.',\n    };\n    AuthClientErrorCode.INVALID_CONFIG = {\n        code: 'invalid-config',\n        message: 'The provided configuration is invalid.',\n    };\n    AuthClientErrorCode.EMAIL_ALREADY_EXISTS = {\n        code: 'email-already-exists',\n        message: 'The email address is already in use by another account.',\n    };\n    AuthClientErrorCode.FORBIDDEN_CLAIM = {\n        code: 'reserved-claim',\n        message: 'The specified developer claim is reserved and cannot be specified.',\n    };\n    AuthClientErrorCode.INVALID_ID_TOKEN = {\n        code: 'invalid-id-token',\n        message: 'The provided ID token is not a valid Firebase ID token.',\n    };\n    AuthClientErrorCode.ID_TOKEN_REVOKED = {\n        code: 'id-token-revoked',\n        message: 'The Firebase ID token has been revoked.',\n    };\n    AuthClientErrorCode.INTERNAL_ERROR = {\n        code: 'internal-error',\n        message: 'An internal error has occurred.',\n    };\n    AuthClientErrorCode.INVALID_CLAIMS = {\n        code: 'invalid-claims',\n        message: 'The provided custom claim attributes are invalid.',\n    };\n    AuthClientErrorCode.INVALID_CONTINUE_URI = {\n        code: 'invalid-continue-uri',\n        message: 'The continue URL must be a valid URL string.',\n    };\n    AuthClientErrorCode.INVALID_CREATION_TIME = {\n        code: 'invalid-creation-time',\n        message: 'The creation time must be a valid UTC date string.',\n    };\n    AuthClientErrorCode.INVALID_CREDENTIAL = {\n        code: 'invalid-credential',\n        message: 'Invalid credential object provided.',\n    };\n    AuthClientErrorCode.INVALID_DISABLED_FIELD = {\n        code: 'invalid-disabled-field',\n        message: 'The disabled field must be a boolean.',\n    };\n    AuthClientErrorCode.INVALID_DISPLAY_NAME = {\n        code: 'invalid-display-name',\n        message: 'The displayName field must be a valid string.',\n    };\n    AuthClientErrorCode.INVALID_DYNAMIC_LINK_DOMAIN = {\n        code: 'invalid-dynamic-link-domain',\n        message: 'The provided dynamic link domain is not configured or authorized ' +\n            'for the current project.',\n    };\n    AuthClientErrorCode.INVALID_EMAIL_VERIFIED = {\n        code: 'invalid-email-verified',\n        message: 'The emailVerified field must be a boolean.',\n    };\n    AuthClientErrorCode.INVALID_EMAIL = {\n        code: 'invalid-email',\n        message: 'The email address is improperly formatted.',\n    };\n    AuthClientErrorCode.INVALID_ENROLLED_FACTORS = {\n        code: 'invalid-enrolled-factors',\n        message: 'The enrolled factors must be a valid array of MultiFactorInfo objects.',\n    };\n    AuthClientErrorCode.INVALID_ENROLLMENT_TIME = {\n        code: 'invalid-enrollment-time',\n        message: 'The second factor enrollment time must be a valid UTC date string.',\n    };\n    AuthClientErrorCode.INVALID_HASH_ALGORITHM = {\n        code: 'invalid-hash-algorithm',\n        message: 'The hash algorithm must match one of the strings in the list of ' +\n            'supported algorithms.',\n    };\n    AuthClientErrorCode.INVALID_HASH_BLOCK_SIZE = {\n        code: 'invalid-hash-block-size',\n        message: 'The hash block size must be a valid number.',\n    };\n    AuthClientErrorCode.INVALID_HASH_DERIVED_KEY_LENGTH = {\n        code: 'invalid-hash-derived-key-length',\n        message: 'The hash derived key length must be a valid number.',\n    };\n    AuthClientErrorCode.INVALID_HASH_KEY = {\n        code: 'invalid-hash-key',\n        message: 'The hash key must a valid byte buffer.',\n    };\n    AuthClientErrorCode.INVALID_HASH_MEMORY_COST = {\n        code: 'invalid-hash-memory-cost',\n        message: 'The hash memory cost must be a valid number.',\n    };\n    AuthClientErrorCode.INVALID_HASH_PARALLELIZATION = {\n        code: 'invalid-hash-parallelization',\n        message: 'The hash parallelization must be a valid number.',\n    };\n    AuthClientErrorCode.INVALID_HASH_ROUNDS = {\n        code: 'invalid-hash-rounds',\n        message: 'The hash rounds must be a valid number.',\n    };\n    AuthClientErrorCode.INVALID_HASH_SALT_SEPARATOR = {\n        code: 'invalid-hash-salt-separator',\n        message: 'The hashing algorithm salt separator field must be a valid byte buffer.',\n    };\n    AuthClientErrorCode.INVALID_LAST_SIGN_IN_TIME = {\n        code: 'invalid-last-sign-in-time',\n        message: 'The last sign-in time must be a valid UTC date string.',\n    };\n    AuthClientErrorCode.INVALID_NAME = {\n        code: 'invalid-name',\n        message: 'The resource name provided is invalid.',\n    };\n    AuthClientErrorCode.INVALID_OAUTH_CLIENT_ID = {\n        code: 'invalid-oauth-client-id',\n        message: 'The provided OAuth client ID is invalid.',\n    };\n    AuthClientErrorCode.INVALID_PAGE_TOKEN = {\n        code: 'invalid-page-token',\n        message: 'The page token must be a valid non-empty string.',\n    };\n    AuthClientErrorCode.INVALID_PASSWORD = {\n        code: 'invalid-password',\n        message: 'The password must be a string with at least 6 characters.',\n    };\n    AuthClientErrorCode.INVALID_PASSWORD_HASH = {\n        code: 'invalid-password-hash',\n        message: 'The password hash must be a valid byte buffer.',\n    };\n    AuthClientErrorCode.INVALID_PASSWORD_SALT = {\n        code: 'invalid-password-salt',\n        message: 'The password salt must be a valid byte buffer.',\n    };\n    AuthClientErrorCode.INVALID_PHONE_NUMBER = {\n        code: 'invalid-phone-number',\n        message: 'The phone number must be a non-empty E.164 standard compliant identifier ' +\n            'string.',\n    };\n    AuthClientErrorCode.INVALID_PHOTO_URL = {\n        code: 'invalid-photo-url',\n        message: 'The photoURL field must be a valid URL.',\n    };\n    AuthClientErrorCode.INVALID_PROJECT_ID = {\n        code: 'invalid-project-id',\n        message: 'Invalid parent project. Either parent project doesn\\'t exist or didn\\'t enable multi-tenancy.',\n    };\n    AuthClientErrorCode.INVALID_PROVIDER_DATA = {\n        code: 'invalid-provider-data',\n        message: 'The providerData must be a valid array of UserInfo objects.',\n    };\n    AuthClientErrorCode.INVALID_PROVIDER_ID = {\n        code: 'invalid-provider-id',\n        message: 'The providerId must be a valid supported provider identifier string.',\n    };\n    AuthClientErrorCode.INVALID_PROVIDER_UID = {\n        code: 'invalid-provider-uid',\n        message: 'The providerUid must be a valid provider uid string.',\n    };\n    AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION = {\n        code: 'invalid-session-cookie-duration',\n        message: 'The session cookie duration must be a valid number in milliseconds ' +\n            'between 5 minutes and 2 weeks.',\n    };\n    AuthClientErrorCode.INVALID_TENANT_ID = {\n        code: 'invalid-tenant-id',\n        message: 'The tenant ID must be a valid non-empty string.',\n    };\n    AuthClientErrorCode.INVALID_TENANT_TYPE = {\n        code: 'invalid-tenant-type',\n        message: 'Tenant type must be either \"full_service\" or \"lightweight\".',\n    };\n    AuthClientErrorCode.INVALID_UID = {\n        code: 'invalid-uid',\n        message: 'The uid must be a non-empty string with at most 128 characters.',\n    };\n    AuthClientErrorCode.INVALID_USER_IMPORT = {\n        code: 'invalid-user-import',\n        message: 'The user record to import is invalid.',\n    };\n    AuthClientErrorCode.INVALID_TOKENS_VALID_AFTER_TIME = {\n        code: 'invalid-tokens-valid-after-time',\n        message: 'The tokensValidAfterTime must be a valid UTC number in seconds.',\n    };\n    AuthClientErrorCode.MISMATCHING_TENANT_ID = {\n        code: 'mismatching-tenant-id',\n        message: 'User tenant ID does not match with the current TenantAwareAuth tenant ID.',\n    };\n    AuthClientErrorCode.MISSING_ANDROID_PACKAGE_NAME = {\n        code: 'missing-android-pkg-name',\n        message: 'An Android Package Name must be provided if the Android App is ' +\n            'required to be installed.',\n    };\n    AuthClientErrorCode.MISSING_CONFIG = {\n        code: 'missing-config',\n        message: 'The provided configuration is missing required attributes.',\n    };\n    AuthClientErrorCode.MISSING_CONTINUE_URI = {\n        code: 'missing-continue-uri',\n        message: 'A valid continue URL must be provided in the request.',\n    };\n    AuthClientErrorCode.MISSING_DISPLAY_NAME = {\n        code: 'missing-display-name',\n        message: 'The resource being created or edited is missing a valid display name.',\n    };\n    AuthClientErrorCode.MISSING_EMAIL = {\n        code: 'missing-email',\n        message: 'The email is required for the specified action. For example, a multi-factor user ' +\n            'requires a verified email.',\n    };\n    AuthClientErrorCode.MISSING_IOS_BUNDLE_ID = {\n        code: 'missing-ios-bundle-id',\n        message: 'The request is missing an iOS Bundle ID.',\n    };\n    AuthClientErrorCode.MISSING_ISSUER = {\n        code: 'missing-issuer',\n        message: 'The OAuth/OIDC configuration issuer must not be empty.',\n    };\n    AuthClientErrorCode.MISSING_HASH_ALGORITHM = {\n        code: 'missing-hash-algorithm',\n        message: 'Importing users with password hashes requires that the hashing ' +\n            'algorithm and its parameters be provided.',\n    };\n    AuthClientErrorCode.MISSING_OAUTH_CLIENT_ID = {\n        code: 'missing-oauth-client-id',\n        message: 'The OAuth/OIDC configuration client ID must not be empty.',\n    };\n    AuthClientErrorCode.MISSING_PROVIDER_ID = {\n        code: 'missing-provider-id',\n        message: 'A valid provider ID must be provided in the request.',\n    };\n    AuthClientErrorCode.MISSING_SAML_RELYING_PARTY_CONFIG = {\n        code: 'missing-saml-relying-party-config',\n        message: 'The SAML configuration provided is missing a relying party configuration.',\n    };\n    AuthClientErrorCode.MAXIMUM_USER_COUNT_EXCEEDED = {\n        code: 'maximum-user-count-exceeded',\n        message: 'The maximum allowed number of users to import has been exceeded.',\n    };\n    AuthClientErrorCode.MISSING_UID = {\n        code: 'missing-uid',\n        message: 'A uid identifier is required for the current operation.',\n    };\n    AuthClientErrorCode.OPERATION_NOT_ALLOWED = {\n        code: 'operation-not-allowed',\n        message: 'The given sign-in provider is disabled for this Firebase project. ' +\n            'Enable it in the Firebase console, under the sign-in method tab of the ' +\n            'Auth section.',\n    };\n    AuthClientErrorCode.PHONE_NUMBER_ALREADY_EXISTS = {\n        code: 'phone-number-already-exists',\n        message: 'The user with the provided phone number already exists.',\n    };\n    AuthClientErrorCode.PROJECT_NOT_FOUND = {\n        code: 'project-not-found',\n        message: 'No Firebase project was found for the provided credential.',\n    };\n    AuthClientErrorCode.INSUFFICIENT_PERMISSION = {\n        code: 'insufficient-permission',\n        message: 'Credential implementation provided to initializeApp() via the \"credential\" property ' +\n            'has insufficient permission to access the requested resource. See ' +\n            'https://firebase.google.com/docs/admin/setup for details on how to authenticate this SDK ' +\n            'with appropriate permissions.',\n    };\n    AuthClientErrorCode.QUOTA_EXCEEDED = {\n        code: 'quota-exceeded',\n        message: 'The project quota for the specified operation has been exceeded.',\n    };\n    AuthClientErrorCode.SECOND_FACTOR_LIMIT_EXCEEDED = {\n        code: 'second-factor-limit-exceeded',\n        message: 'The maximum number of allowed second factors on a user has been exceeded.',\n    };\n    AuthClientErrorCode.SECOND_FACTOR_UID_ALREADY_EXISTS = {\n        code: 'second-factor-uid-already-exists',\n        message: 'The specified second factor \"uid\" already exists.',\n    };\n    AuthClientErrorCode.SESSION_COOKIE_EXPIRED = {\n        code: 'session-cookie-expired',\n        message: 'The Firebase session cookie is expired.',\n    };\n    AuthClientErrorCode.SESSION_COOKIE_REVOKED = {\n        code: 'session-cookie-revoked',\n        message: 'The Firebase session cookie has been revoked.',\n    };\n    AuthClientErrorCode.TENANT_NOT_FOUND = {\n        code: 'tenant-not-found',\n        message: 'There is no tenant corresponding to the provided identifier.',\n    };\n    AuthClientErrorCode.UID_ALREADY_EXISTS = {\n        code: 'uid-already-exists',\n        message: 'The user with the provided uid already exists.',\n    };\n    AuthClientErrorCode.UNAUTHORIZED_DOMAIN = {\n        code: 'unauthorized-continue-uri',\n        message: 'The domain of the continue URL is not whitelisted. Whitelist the domain in the ' +\n            'Firebase console.',\n    };\n    AuthClientErrorCode.UNSUPPORTED_FIRST_FACTOR = {\n        code: 'unsupported-first-factor',\n        message: 'A multi-factor user requires a supported first factor.',\n    };\n    AuthClientErrorCode.UNSUPPORTED_SECOND_FACTOR = {\n        code: 'unsupported-second-factor',\n        message: 'The request specified an unsupported type of second factor.',\n    };\n    AuthClientErrorCode.UNSUPPORTED_TENANT_OPERATION = {\n        code: 'unsupported-tenant-operation',\n        message: 'This operation is not supported in a multi-tenant context.',\n    };\n    AuthClientErrorCode.UNVERIFIED_EMAIL = {\n        code: 'unverified-email',\n        message: 'A verified email is required for the specified action. For example, a multi-factor user ' +\n            'requires a verified email.',\n    };\n    AuthClientErrorCode.USER_NOT_FOUND = {\n        code: 'user-not-found',\n        message: 'There is no user record corresponding to the provided identifier.',\n    };\n    AuthClientErrorCode.NOT_FOUND = {\n        code: 'not-found',\n        message: 'The requested resource was not found.',\n    };\n    AuthClientErrorCode.USER_NOT_DISABLED = {\n        code: 'user-not-disabled',\n        message: 'The user must be disabled in order to bulk delete it (or you must pass force=true).',\n    };\n    return AuthClientErrorCode;\n}());\nexports.AuthClientErrorCode = AuthClientErrorCode;\n/**\n * Messaging client error codes and their default messages.\n */\nvar MessagingClientErrorCode = /** @class */ (function () {\n    function MessagingClientErrorCode() {\n    }\n    MessagingClientErrorCode.INVALID_ARGUMENT = {\n        code: 'invalid-argument',\n        message: 'Invalid argument provided.',\n    };\n    MessagingClientErrorCode.INVALID_RECIPIENT = {\n        code: 'invalid-recipient',\n        message: 'Invalid message recipient provided.',\n    };\n    MessagingClientErrorCode.INVALID_PAYLOAD = {\n        code: 'invalid-payload',\n        message: 'Invalid message payload provided.',\n    };\n    MessagingClientErrorCode.INVALID_DATA_PAYLOAD_KEY = {\n        code: 'invalid-data-payload-key',\n        message: 'The data message payload contains an invalid key. See the reference documentation ' +\n            'for the DataMessagePayload type for restricted keys.',\n    };\n    MessagingClientErrorCode.PAYLOAD_SIZE_LIMIT_EXCEEDED = {\n        code: 'payload-size-limit-exceeded',\n        message: 'The provided message payload exceeds the FCM size limits. See the error documentation ' +\n            'for more details.',\n    };\n    MessagingClientErrorCode.INVALID_OPTIONS = {\n        code: 'invalid-options',\n        message: 'Invalid message options provided.',\n    };\n    MessagingClientErrorCode.INVALID_REGISTRATION_TOKEN = {\n        code: 'invalid-registration-token',\n        message: 'Invalid registration token provided. Make sure it matches the registration token ' +\n            'the client app receives from registering with FCM.',\n    };\n    MessagingClientErrorCode.REGISTRATION_TOKEN_NOT_REGISTERED = {\n        code: 'registration-token-not-registered',\n        message: 'The provided registration token is not registered. A previously valid registration ' +\n            'token can be unregistered for a variety of reasons. See the error documentation for more ' +\n            'details. Remove this registration token and stop using it to send messages.',\n    };\n    MessagingClientErrorCode.MISMATCHED_CREDENTIAL = {\n        code: 'mismatched-credential',\n        message: 'The credential used to authenticate this SDK does not have permission to send ' +\n            'messages to the device corresponding to the provided registration token. Make sure the ' +\n            'credential and registration token both belong to the same Firebase project.',\n    };\n    MessagingClientErrorCode.INVALID_PACKAGE_NAME = {\n        code: 'invalid-package-name',\n        message: 'The message was addressed to a registration token whose package name does not match ' +\n            'the provided \"restrictedPackageName\" option.',\n    };\n    MessagingClientErrorCode.DEVICE_MESSAGE_RATE_EXCEEDED = {\n        code: 'device-message-rate-exceeded',\n        message: 'The rate of messages to a particular device is too high. Reduce the number of ' +\n            'messages sent to this device and do not immediately retry sending to this device.',\n    };\n    MessagingClientErrorCode.TOPICS_MESSAGE_RATE_EXCEEDED = {\n        code: 'topics-message-rate-exceeded',\n        message: 'The rate of messages to subscribers to a particular topic is too high. Reduce the ' +\n            'number of messages sent for this topic, and do not immediately retry sending to this topic.',\n    };\n    MessagingClientErrorCode.MESSAGE_RATE_EXCEEDED = {\n        code: 'message-rate-exceeded',\n        message: 'Sending limit exceeded for the message target.',\n    };\n    MessagingClientErrorCode.THIRD_PARTY_AUTH_ERROR = {\n        code: 'third-party-auth-error',\n        message: 'A message targeted to an iOS device could not be sent because the required APNs ' +\n            'SSL certificate was not uploaded or has expired. Check the validity of your development ' +\n            'and production certificates.',\n    };\n    MessagingClientErrorCode.TOO_MANY_TOPICS = {\n        code: 'too-many-topics',\n        message: 'The maximum number of topics the provided registration token can be subscribed to ' +\n            'has been exceeded.',\n    };\n    MessagingClientErrorCode.AUTHENTICATION_ERROR = {\n        code: 'authentication-error',\n        message: 'An error occurred when trying to authenticate to the FCM servers. Make sure the ' +\n            'credential used to authenticate this SDK has the proper permissions. See ' +\n            'https://firebase.google.com/docs/admin/setup for setup instructions.',\n    };\n    MessagingClientErrorCode.SERVER_UNAVAILABLE = {\n        code: 'server-unavailable',\n        message: 'The FCM server could not process the request in time. See the error documentation ' +\n            'for more details.',\n    };\n    MessagingClientErrorCode.INTERNAL_ERROR = {\n        code: 'internal-error',\n        message: 'An internal error has occurred. Please retry the request.',\n    };\n    MessagingClientErrorCode.UNKNOWN_ERROR = {\n        code: 'unknown-error',\n        message: 'An unknown server error was returned.',\n    };\n    return MessagingClientErrorCode;\n}());\nexports.MessagingClientErrorCode = MessagingClientErrorCode;\nvar InstanceIdClientErrorCode = /** @class */ (function () {\n    function InstanceIdClientErrorCode() {\n    }\n    InstanceIdClientErrorCode.INVALID_ARGUMENT = {\n        code: 'invalid-argument',\n        message: 'Invalid argument provided.',\n    };\n    InstanceIdClientErrorCode.INVALID_PROJECT_ID = {\n        code: 'invalid-project-id',\n        message: 'Invalid project ID provided.',\n    };\n    InstanceIdClientErrorCode.INVALID_INSTANCE_ID = {\n        code: 'invalid-instance-id',\n        message: 'Invalid instance ID provided.',\n    };\n    InstanceIdClientErrorCode.API_ERROR = {\n        code: 'api-error',\n        message: 'Instance ID API call failed.',\n    };\n    return InstanceIdClientErrorCode;\n}());\nexports.InstanceIdClientErrorCode = InstanceIdClientErrorCode;\n/** @const {ServerToClientCode} Auth server to client enum error codes. */\nvar AUTH_SERVER_TO_CLIENT_CODE = {\n    // Feature being configured or used requires a billing account.\n    BILLING_NOT_ENABLED: 'BILLING_NOT_ENABLED',\n    // Claims payload is too large.\n    CLAIMS_TOO_LARGE: 'CLAIMS_TOO_LARGE',\n    // Configuration being added already exists.\n    CONFIGURATION_EXISTS: 'CONFIGURATION_EXISTS',\n    // Configuration not found.\n    CONFIGURATION_NOT_FOUND: 'CONFIGURATION_NOT_FOUND',\n    // Provided credential has insufficient permissions.\n    INSUFFICIENT_PERMISSION: 'INSUFFICIENT_PERMISSION',\n    // Provided configuration has invalid fields.\n    INVALID_CONFIG: 'INVALID_CONFIG',\n    // Provided configuration identifier is invalid.\n    INVALID_CONFIG_ID: 'INVALID_PROVIDER_ID',\n    // ActionCodeSettings missing continue URL.\n    INVALID_CONTINUE_URI: 'INVALID_CONTINUE_URI',\n    // Dynamic link domain in provided ActionCodeSettings is not authorized.\n    INVALID_DYNAMIC_LINK_DOMAIN: 'INVALID_DYNAMIC_LINK_DOMAIN',\n    // uploadAccount provides an email that already exists.\n    DUPLICATE_EMAIL: 'EMAIL_ALREADY_EXISTS',\n    // uploadAccount provides a localId that already exists.\n    DUPLICATE_LOCAL_ID: 'UID_ALREADY_EXISTS',\n    // Request specified a multi-factor enrollment ID that already exists.\n    DUPLICATE_MFA_ENROLLMENT_ID: 'SECOND_FACTOR_UID_ALREADY_EXISTS',\n    // setAccountInfo email already exists.\n    EMAIL_EXISTS: 'EMAIL_ALREADY_EXISTS',\n    // Reserved claim name.\n    FORBIDDEN_CLAIM: 'FORBIDDEN_CLAIM',\n    // Invalid claims provided.\n    INVALID_CLAIMS: 'INVALID_CLAIMS',\n    // Invalid session cookie duration.\n    INVALID_DURATION: 'INVALID_SESSION_COOKIE_DURATION',\n    // Invalid email provided.\n    INVALID_EMAIL: 'INVALID_EMAIL',\n    // Invalid tenant display name. This can be thrown on CreateTenant and UpdateTenant.\n    INVALID_DISPLAY_NAME: 'INVALID_DISPLAY_NAME',\n    // Invalid ID token provided.\n    INVALID_ID_TOKEN: 'INVALID_ID_TOKEN',\n    // Invalid tenant/parent resource name.\n    INVALID_NAME: 'INVALID_NAME',\n    // OIDC configuration has an invalid OAuth client ID.\n    INVALID_OAUTH_CLIENT_ID: 'INVALID_OAUTH_CLIENT_ID',\n    // Invalid page token.\n    INVALID_PAGE_SELECTION: 'INVALID_PAGE_TOKEN',\n    // Invalid phone number.\n    INVALID_PHONE_NUMBER: 'INVALID_PHONE_NUMBER',\n    // Invalid agent project. Either agent project doesn't exist or didn't enable multi-tenancy.\n    INVALID_PROJECT_ID: 'INVALID_PROJECT_ID',\n    // Invalid provider ID.\n    INVALID_PROVIDER_ID: 'INVALID_PROVIDER_ID',\n    // Invalid service account.\n    INVALID_SERVICE_ACCOUNT: 'INVALID_SERVICE_ACCOUNT',\n    // Invalid tenant type.\n    INVALID_TENANT_TYPE: 'INVALID_TENANT_TYPE',\n    // Missing Android package name.\n    MISSING_ANDROID_PACKAGE_NAME: 'MISSING_ANDROID_PACKAGE_NAME',\n    // Missing configuration.\n    MISSING_CONFIG: 'MISSING_CONFIG',\n    // Missing configuration identifier.\n    MISSING_CONFIG_ID: 'MISSING_PROVIDER_ID',\n    // Missing tenant display name: This can be thrown on CreateTenant and UpdateTenant.\n    MISSING_DISPLAY_NAME: 'MISSING_DISPLAY_NAME',\n    // Email is required for the specified action. For example a multi-factor user requires\n    // a verified email.\n    MISSING_EMAIL: 'MISSING_EMAIL',\n    // Missing iOS bundle ID.\n    MISSING_IOS_BUNDLE_ID: 'MISSING_IOS_BUNDLE_ID',\n    // Missing OIDC issuer.\n    MISSING_ISSUER: 'MISSING_ISSUER',\n    // No localId provided (deleteAccount missing localId).\n    MISSING_LOCAL_ID: 'MISSING_UID',\n    // OIDC configuration is missing an OAuth client ID.\n    MISSING_OAUTH_CLIENT_ID: 'MISSING_OAUTH_CLIENT_ID',\n    // Missing provider ID.\n    MISSING_PROVIDER_ID: 'MISSING_PROVIDER_ID',\n    // Missing SAML RP config.\n    MISSING_SAML_RELYING_PARTY_CONFIG: 'MISSING_SAML_RELYING_PARTY_CONFIG',\n    // Empty user list in uploadAccount.\n    MISSING_USER_ACCOUNT: 'MISSING_UID',\n    // Password auth disabled in console.\n    OPERATION_NOT_ALLOWED: 'OPERATION_NOT_ALLOWED',\n    // Provided credential has insufficient permissions.\n    PERMISSION_DENIED: 'INSUFFICIENT_PERMISSION',\n    // Phone number already exists.\n    PHONE_NUMBER_EXISTS: 'PHONE_NUMBER_ALREADY_EXISTS',\n    // Project not found.\n    PROJECT_NOT_FOUND: 'PROJECT_NOT_FOUND',\n    // In multi-tenancy context: project creation quota exceeded.\n    QUOTA_EXCEEDED: 'QUOTA_EXCEEDED',\n    // Currently only 5 second factors can be set on the same user.\n    SECOND_FACTOR_LIMIT_EXCEEDED: 'SECOND_FACTOR_LIMIT_EXCEEDED',\n    // Tenant not found.\n    TENANT_NOT_FOUND: 'TENANT_NOT_FOUND',\n    // Tenant ID mismatch.\n    TENANT_ID_MISMATCH: 'MISMATCHING_TENANT_ID',\n    // Token expired error.\n    TOKEN_EXPIRED: 'ID_TOKEN_EXPIRED',\n    // Continue URL provided in ActionCodeSettings has a domain that is not whitelisted.\n    UNAUTHORIZED_DOMAIN: 'UNAUTHORIZED_DOMAIN',\n    // A multi-factor user requires a supported first factor.\n    UNSUPPORTED_FIRST_FACTOR: 'UNSUPPORTED_FIRST_FACTOR',\n    // The request specified an unsupported type of second factor.\n    UNSUPPORTED_SECOND_FACTOR: 'UNSUPPORTED_SECOND_FACTOR',\n    // Operation is not supported in a multi-tenant context.\n    UNSUPPORTED_TENANT_OPERATION: 'UNSUPPORTED_TENANT_OPERATION',\n    // A verified email is required for the specified action. For example a multi-factor user\n    // requires a verified email.\n    UNVERIFIED_EMAIL: 'UNVERIFIED_EMAIL',\n    // User on which action is to be performed is not found.\n    USER_NOT_FOUND: 'USER_NOT_FOUND',\n    // Password provided is too weak.\n    WEAK_PASSWORD: 'INVALID_PASSWORD',\n};\n/** @const {ServerToClientCode} Messaging server to client enum error codes. */\nvar MESSAGING_SERVER_TO_CLIENT_CODE = {\n    /* GENERIC ERRORS */\n    // Generic invalid message parameter provided.\n    InvalidParameters: 'INVALID_ARGUMENT',\n    // Mismatched sender ID.\n    MismatchSenderId: 'MISMATCHED_CREDENTIAL',\n    // FCM server unavailable.\n    Unavailable: 'SERVER_UNAVAILABLE',\n    // FCM server internal error.\n    InternalServerError: 'INTERNAL_ERROR',\n    /* SEND ERRORS */\n    // Invalid registration token format.\n    InvalidRegistration: 'INVALID_REGISTRATION_TOKEN',\n    // Registration token is not registered.\n    NotRegistered: 'REGISTRATION_TOKEN_NOT_REGISTERED',\n    // Registration token does not match restricted package name.\n    InvalidPackageName: 'INVALID_PACKAGE_NAME',\n    // Message payload size limit exceeded.\n    MessageTooBig: 'PAYLOAD_SIZE_LIMIT_EXCEEDED',\n    // Invalid key in the data message payload.\n    InvalidDataKey: 'INVALID_DATA_PAYLOAD_KEY',\n    // Invalid time to live option.\n    InvalidTtl: 'INVALID_OPTIONS',\n    // Device message rate exceeded.\n    DeviceMessageRateExceeded: 'DEVICE_MESSAGE_RATE_EXCEEDED',\n    // Topics message rate exceeded.\n    TopicsMessageRateExceeded: 'TOPICS_MESSAGE_RATE_EXCEEDED',\n    // Invalid APNs credentials.\n    InvalidApnsCredential: 'THIRD_PARTY_AUTH_ERROR',\n    /* FCM v1 canonical error codes */\n    NOT_FOUND: 'REGISTRATION_TOKEN_NOT_REGISTERED',\n    PERMISSION_DENIED: 'MISMATCHED_CREDENTIAL',\n    RESOURCE_EXHAUSTED: 'MESSAGE_RATE_EXCEEDED',\n    UNAUTHENTICATED: 'THIRD_PARTY_AUTH_ERROR',\n    /* FCM v1 new error codes */\n    APNS_AUTH_ERROR: 'THIRD_PARTY_AUTH_ERROR',\n    INTERNAL: 'INTERNAL_ERROR',\n    INVALID_ARGUMENT: 'INVALID_ARGUMENT',\n    QUOTA_EXCEEDED: 'MESSAGE_RATE_EXCEEDED',\n    SENDER_ID_MISMATCH: 'MISMATCHED_CREDENTIAL',\n    THIRD_PARTY_AUTH_ERROR: 'THIRD_PARTY_AUTH_ERROR',\n    UNAVAILABLE: 'SERVER_UNAVAILABLE',\n    UNREGISTERED: 'REGISTRATION_TOKEN_NOT_REGISTERED',\n    UNSPECIFIED_ERROR: 'UNKNOWN_ERROR',\n};\n/** @const {ServerToClientCode} Topic management (IID) server to client enum error codes. */\nvar TOPIC_MGT_SERVER_TO_CLIENT_CODE = {\n    /* TOPIC SUBSCRIPTION MANAGEMENT ERRORS */\n    NOT_FOUND: 'REGISTRATION_TOKEN_NOT_REGISTERED',\n    INVALID_ARGUMENT: 'INVALID_REGISTRATION_TOKEN',\n    TOO_MANY_TOPICS: 'TOO_MANY_TOPICS',\n    RESOURCE_EXHAUSTED: 'TOO_MANY_TOPICS',\n    PERMISSION_DENIED: 'AUTHENTICATION_ERROR',\n    DEADLINE_EXCEEDED: 'SERVER_UNAVAILABLE',\n    INTERNAL: 'INTERNAL_ERROR',\n    UNKNOWN: 'UNKNOWN_ERROR',\n};\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/utils/error.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/utils/index.js":
/*!************************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/utils/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\n/*!\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar credential_1 = __webpack_require__(/*! ../auth/credential */ \"./src/node_modules/firebase-admin/lib/auth/credential.js\");\nvar validator = __webpack_require__(/*! ./validator */ \"./src/node_modules/firebase-admin/lib/utils/validator.js\");\n/**\n * Renames properties on an object given a mapping from old to new property names.\n *\n * For example, this can be used to map underscore_cased properties to camelCase.\n *\n * @param {object} obj The object whose properties to rename.\n * @param {object} keyMap The mapping from old to new property names.\n */\nfunction renameProperties(obj, keyMap) {\n    Object.keys(keyMap).forEach(function (oldKey) {\n        if (oldKey in obj) {\n            var newKey = keyMap[oldKey];\n            // The old key's value takes precedence over the new key's value.\n            obj[newKey] = obj[oldKey];\n            delete obj[oldKey];\n        }\n    });\n}\nexports.renameProperties = renameProperties;\n/**\n * Defines a new read-only property directly on an object and returns the object.\n *\n * @param {object} obj The object on which to define the property.\n * @param {string} prop The name of the property to be defined or modified.\n * @param {any} value The value associated with the property.\n */\nfunction addReadonlyGetter(obj, prop, value) {\n    Object.defineProperty(obj, prop, {\n        value: value,\n        // Make this property read-only.\n        writable: false,\n        // Include this property during enumeration of obj's properties.\n        enumerable: true,\n    });\n}\nexports.addReadonlyGetter = addReadonlyGetter;\n/**\n * Returns the Google Cloud project ID associated with a Firebase app, if it's explicitly\n * specified in either the Firebase app options, credentials or the local environment.\n * Otherwise returns null.\n *\n * @param {FirebaseApp} app A Firebase app to get the project ID from.\n *\n * @return {string} A project ID string or null.\n */\nfunction getExplicitProjectId(app) {\n    var options = app.options;\n    if (validator.isNonEmptyString(options.projectId)) {\n        return options.projectId;\n    }\n    var credential = app.options.credential;\n    if (credential instanceof credential_1.ServiceAccountCredential) {\n        return credential.projectId;\n    }\n    var projectId = process.env.GOOGLE_CLOUD_PROJECT || process.env.GCLOUD_PROJECT;\n    if (validator.isNonEmptyString(projectId)) {\n        return projectId;\n    }\n    return null;\n}\nexports.getExplicitProjectId = getExplicitProjectId;\n/**\n * Determines the Google Cloud project ID associated with a Firebase app. This method\n * first checks if a project ID is explicitly specified in either the Firebase app options,\n * credentials or the local environment in that order. If no explicit project ID is\n * configured, but the SDK has been initialized with ComputeEngineCredentials, this\n * method attempts to discover the project ID from the local metadata service.\n *\n * @param {FirebaseApp} app A Firebase app to get the project ID from.\n *\n * @return {Promise<string | null>} A project ID string or null.\n */\nfunction findProjectId(app) {\n    var projectId = getExplicitProjectId(app);\n    if (projectId) {\n        return Promise.resolve(projectId);\n    }\n    var credential = app.options.credential;\n    if (credential instanceof credential_1.ComputeEngineCredential) {\n        return credential.getProjectId();\n    }\n    return Promise.resolve(null);\n}\nexports.findProjectId = findProjectId;\n/**\n * Encodes data using web-safe-base64.\n *\n * @param {Buffer} data The raw data byte input.\n * @return {string} The base64-encoded result.\n */\nfunction toWebSafeBase64(data) {\n    return data.toString('base64').replace(/\\//g, '_').replace(/\\+/g, '-');\n}\nexports.toWebSafeBase64 = toWebSafeBase64;\n/**\n * Formats a string of form 'project/{projectId}/{api}' and replaces\n * with corresponding arguments {projectId: '1234', api: 'resource'}\n * and returns output: 'project/1234/resource'.\n *\n * @param {string} str The original string where the param need to be\n *     replaced.\n * @param {object=} params The optional parameters to replace in the\n *     string.\n * @return {string} The resulting formatted string.\n */\nfunction formatString(str, params) {\n    var formatted = str;\n    Object.keys(params || {}).forEach(function (key) {\n        formatted = formatted.replace(new RegExp('{' + key + '}', 'g'), params[key]);\n    });\n    return formatted;\n}\nexports.formatString = formatString;\n/**\n * Generates the update mask for the provided object.\n * Note this will ignore the last key with value undefined.\n *\n * @param {[key: string]: any} obj The object to generate the update mask for.\n * @return {Array<string>} The computed update mask list.\n */\nfunction generateUpdateMask(obj) {\n    var updateMask = [];\n    if (!validator.isNonNullObject(obj)) {\n        return updateMask;\n    }\n    var _loop_1 = function (key) {\n        if (Object.prototype.hasOwnProperty.call(obj, key) && typeof obj[key] !== 'undefined') {\n            var maskList = generateUpdateMask(obj[key]);\n            if (maskList.length > 0) {\n                maskList.forEach(function (mask) {\n                    updateMask.push(key + \".\" + mask);\n                });\n            }\n            else {\n                updateMask.push(key);\n            }\n        }\n    };\n    for (var key in obj) {\n        _loop_1(key);\n    }\n    return updateMask;\n}\nexports.generateUpdateMask = generateUpdateMask;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/utils/index.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/lib/utils/validator.js":
/*!****************************************************************!*\
  !*** ./src/node_modules/firebase-admin/lib/utils/validator.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*! firebase-admin v8.13.0 */\n\n/*!\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar url = __webpack_require__(/*! url */ \"url\");\n/**\n * Validates that a value is a byte buffer.\n *\n * @param {any} value The value to validate.\n * @return {boolean} Whether the value is byte buffer or not.\n */\nfunction isBuffer(value) {\n    return value instanceof Buffer;\n}\nexports.isBuffer = isBuffer;\n/**\n * Validates that a value is an array.\n *\n * @param {any} value The value to validate.\n * @return {boolean} Whether the value is an array or not.\n */\nfunction isArray(value) {\n    return Array.isArray(value);\n}\nexports.isArray = isArray;\n/**\n * Validates that a value is a non-empty array.\n *\n * @param {any} value The value to validate.\n * @return {boolean} Whether the value is a non-empty array or not.\n */\nfunction isNonEmptyArray(value) {\n    return isArray(value) && value.length !== 0;\n}\nexports.isNonEmptyArray = isNonEmptyArray;\n/**\n * Validates that a value is a boolean.\n *\n * @param {any} value The value to validate.\n * @return {boolean} Whether the value is a boolean or not.\n */\nfunction isBoolean(value) {\n    return typeof value === 'boolean';\n}\nexports.isBoolean = isBoolean;\n/**\n * Validates that a value is a number.\n *\n * @param {any} value The value to validate.\n * @return {boolean} Whether the value is a number or not.\n */\nfunction isNumber(value) {\n    return typeof value === 'number' && !isNaN(value);\n}\nexports.isNumber = isNumber;\n/**\n * Validates that a value is a string.\n *\n * @param {any} value The value to validate.\n * @return {boolean} Whether the value is a string or not.\n */\nfunction isString(value) {\n    return typeof value === 'string';\n}\nexports.isString = isString;\n/**\n * Validates that a value is a base64 string.\n *\n * @param {any} value The value to validate.\n * @return {boolean} Whether the value is a base64 string or not.\n */\nfunction isBase64String(value) {\n    if (!isString(value)) {\n        return false;\n    }\n    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(value);\n}\nexports.isBase64String = isBase64String;\n/**\n * Validates that a value is a non-empty string.\n *\n * @param {any} value The value to validate.\n * @return {boolean} Whether the value is a non-empty string or not.\n */\nfunction isNonEmptyString(value) {\n    return isString(value) && value !== '';\n}\nexports.isNonEmptyString = isNonEmptyString;\n/**\n * Validates that a value is a nullable object.\n *\n * @param {any} value The value to validate.\n * @return {boolean} Whether the value is an object or not.\n */\nfunction isObject(value) {\n    return typeof value === 'object' && !isArray(value);\n}\nexports.isObject = isObject;\n/**\n * Validates that a value is a non-null object.\n *\n * @param {any} value The value to validate.\n * @return {boolean} Whether the value is a non-null object or not.\n */\nfunction isNonNullObject(value) {\n    return isObject(value) && value !== null;\n}\nexports.isNonNullObject = isNonNullObject;\n/**\n * Validates that a string is a valid Firebase Auth uid.\n *\n * @param {any} uid The string to validate.\n * @return {boolean} Whether the string is a valid Firebase Auth uid.\n */\nfunction isUid(uid) {\n    return typeof uid === 'string' && uid.length > 0 && uid.length <= 128;\n}\nexports.isUid = isUid;\n/**\n * Validates that a string is a valid Firebase Auth password.\n *\n * @param {any} password The password string to validate.\n * @return {boolean} Whether the string is a valid Firebase Auth password.\n */\nfunction isPassword(password) {\n    // A password must be a string of at least 6 characters.\n    return typeof password === 'string' && password.length >= 6;\n}\nexports.isPassword = isPassword;\n/**\n * Validates that a string is a valid email.\n *\n * @param {any} email The string to validate.\n * @return {boolean} Whether the string is valid email or not.\n */\nfunction isEmail(email) {\n    if (typeof email !== 'string') {\n        return false;\n    }\n    // There must at least one character before the @ symbol and another after.\n    var re = /^[^@]+@[^@]+$/;\n    return re.test(email);\n}\nexports.isEmail = isEmail;\n/**\n * Validates that a string is a valid phone number.\n *\n * @param {any} phoneNumber The string to validate.\n * @return {boolean} Whether the string is a valid phone number or not.\n */\nfunction isPhoneNumber(phoneNumber) {\n    if (typeof phoneNumber !== 'string') {\n        return false;\n    }\n    // Phone number validation is very lax here. Backend will enforce E.164\n    // spec compliance and will normalize accordingly.\n    // The phone number string must be non-empty and starts with a plus sign.\n    var re1 = /^\\+/;\n    // The phone number string must contain at least one alphanumeric character.\n    var re2 = /[\\da-zA-Z]+/;\n    return re1.test(phoneNumber) && re2.test(phoneNumber);\n}\nexports.isPhoneNumber = isPhoneNumber;\n/**\n * Validates that a string is a valid ISO date string.\n *\n * @param dateString The string to validate.\n * @return Whether the string is a valid ISO date string.\n */\nfunction isISODateString(dateString) {\n    try {\n        return isNonEmptyString(dateString) &&\n            (new Date(dateString).toISOString() === dateString);\n    }\n    catch (e) {\n        return false;\n    }\n}\nexports.isISODateString = isISODateString;\n/**\n * Validates that a string is a valid UTC date string.\n *\n * @param dateString The string to validate.\n * @return Whether the string is a valid UTC date string.\n */\nfunction isUTCDateString(dateString) {\n    try {\n        return isNonEmptyString(dateString) &&\n            (new Date(dateString).toUTCString() === dateString);\n    }\n    catch (e) {\n        return false;\n    }\n}\nexports.isUTCDateString = isUTCDateString;\n/**\n * Validates that a string is a valid web URL.\n *\n * @param {any} urlStr The string to validate.\n * @return {boolean} Whether the string is valid web URL or not.\n */\nfunction isURL(urlStr) {\n    if (typeof urlStr !== 'string') {\n        return false;\n    }\n    // Lookup illegal characters.\n    var re = /[^a-z0-9:/?#[\\]@!$&'()*+,;=.\\-_~%]/i;\n    if (re.test(urlStr)) {\n        return false;\n    }\n    try {\n        var uri = url.parse(urlStr);\n        var scheme = uri.protocol;\n        var slashes = uri.slashes;\n        var hostname = uri.hostname;\n        var pathname = uri.pathname;\n        if ((scheme !== 'http:' && scheme !== 'https:') || !slashes) {\n            return false;\n        }\n        // Validate hostname: Can contain letters, numbers, underscore and dashes separated by a dot.\n        // Each zone must not start with a hyphen or underscore.\n        if (!hostname || !/^[a-zA-Z0-9]+[\\w-]*([.]?[a-zA-Z0-9]+[\\w-]*)*$/.test(hostname)) {\n            return false;\n        }\n        // Allow for pathnames: (/chars+)*/?\n        // Where chars can be a combination of: a-z A-Z 0-9 - _ . ~ ! $ & ' ( ) * + , ; = : @ %\n        var pathnameRe = /^(\\/[\\w\\-.~!$'()*+,;=:@%]+)*\\/?$/;\n        // Validate pathname.\n        if (pathname &&\n            pathname !== '/' &&\n            !pathnameRe.test(pathname)) {\n            return false;\n        }\n        // Allow any query string and hash as long as no invalid character is used.\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n}\nexports.isURL = isURL;\n/**\n * Validates that the provided topic is a valid FCM topic name.\n *\n * @param {any} topic The topic to validate.\n * @return {boolean} Whether the provided topic is a valid FCM topic name.\n */\nfunction isTopic(topic) {\n    if (typeof topic !== 'string') {\n        return false;\n    }\n    var VALID_TOPIC_REGEX = /^(\\/topics\\/)?(private\\/)?[a-zA-Z0-9-_.~%]+$/;\n    return VALID_TOPIC_REGEX.test(topic);\n}\nexports.isTopic = isTopic;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/lib/utils/validator.js?");

/***/ }),

/***/ "./src/node_modules/firebase-admin/package.json":
/*!******************************************************!*\
  !*** ./src/node_modules/firebase-admin/package.json ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"name\":\"firebase-admin\",\"version\":\"8.13.0\",\"description\":\"Firebase admin SDK for Node.js\",\"author\":\"Firebase <firebase-support@google.com> (https://firebase.google.com/)\",\"license\":\"Apache-2.0\",\"homepage\":\"https://firebase.google.com/\",\"engines\":{\"node\":\"^8.13.0 || >=10.10.0\"},\"scripts\":{\"build\":\"gulp build\",\"build:tests\":\"gulp compile_test\",\"prepare\":\"npm run build\",\"lint\":\"run-p lint:src lint:test\",\"test\":\"run-s lint test:unit\",\"integration\":\"run-s build test:integration\",\"test:unit\":\"mocha test/unit/*.spec.ts --require ts-node/register\",\"test:integration\":\"mocha test/integration/*.ts --slow 5000 --timeout 20000 --require ts-node/register\",\"test:coverage\":\"nyc npm run test:unit\",\"lint:src\":\"eslint src/ --ext .ts\",\"lint:test\":\"eslint test/ --ext .ts\",\"apidocs\":\"node docgen/generate-docs.js --api node\"},\"nyc\":{\"extension\":[\".ts\"],\"include\":[\"src\"],\"exclude\":[\"**/*.d.ts\"],\"all\":true},\"keywords\":[\"admin\",\"database\",\"Firebase\",\"realtime\",\"authentication\"],\"repository\":{\"type\":\"git\",\"url\":\"https://github.com/firebase/firebase-admin-node\"},\"main\":\"lib/index.js\",\"files\":[\"lib/\",\"LICENSE\",\"README.md\",\"package.json\"],\"types\":\"./lib/index.d.ts\",\"dependencies\":{\"@firebase/database\":\"^0.6.0\",\"@types/node\":\"^8.10.59\",\"dicer\":\"^0.3.0\",\"jsonwebtoken\":\"^8.5.1\",\"node-forge\":\"^0.7.6\"},\"optionalDependencies\":{\"@google-cloud/firestore\":\"^3.0.0\",\"@google-cloud/storage\":\"^4.1.2\"},\"devDependencies\":{\"@firebase/app\":\"^0.6.1\",\"@firebase/auth\":\"^0.13.3\",\"@firebase/auth-types\":\"^0.9.3\",\"@types/bcrypt\":\"^2.0.0\",\"@types/chai\":\"^3.4.34\",\"@types/chai-as-promised\":\"0.0.29\",\"@types/firebase-token-generator\":\"^2.0.28\",\"@types/jsonwebtoken\":\"^7.2.8\",\"@types/lodash\":\"^4.14.104\",\"@types/minimist\":\"^1.2.0\",\"@types/mocha\":\"^2.2.48\",\"@types/nock\":\"^9.1.0\",\"@types/request\":\"^2.47.0\",\"@types/request-promise\":\"^4.1.41\",\"@types/scrypt\":\"^6.0.0\",\"@types/sinon\":\"^4.1.3\",\"@types/sinon-chai\":\"^2.7.27\",\"@typescript-eslint/eslint-plugin\":\"^2.20.0\",\"@typescript-eslint/parser\":\"^2.20.0\",\"bcrypt\":\"^3.0.0\",\"chai\":\"^3.5.0\",\"chai-as-promised\":\"^6.0.0\",\"chalk\":\"^1.1.3\",\"child-process-promise\":\"^2.2.1\",\"del\":\"^2.2.1\",\"eslint\":\"^6.8.0\",\"firebase-token-generator\":\"^2.0.0\",\"gulp\":\"^4.0.2\",\"gulp-header\":\"^1.8.8\",\"gulp-replace\":\"^0.5.4\",\"gulp-typescript\":\"^5.0.1\",\"http-message-parser\":\"^0.0.34\",\"jsdom\":\"^15.0.0\",\"lodash\":\"^4.17.15\",\"minimist\":\"^1.2.0\",\"mocha\":\"^5.2.0\",\"mz\":\"^2.7.0\",\"nock\":\"^9.6.0\",\"npm-run-all\":\"^4.1.5\",\"nyc\":\"^14.1.0\",\"request\":\"^2.75.0\",\"request-promise\":\"^4.1.1\",\"run-sequence\":\"^1.1.5\",\"scrypt\":\"^6.0.3\",\"sinon\":\"^4.5.0\",\"sinon-chai\":\"^2.14.0\",\"ts-node\":\"^3.3.0\",\"typedoc\":\"^0.15.0\",\"typescript\":\"^3.7.3\",\"yargs\":\"^13.2.2\"}}');\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-admin/package.json?");

/***/ }),

/***/ "./src/node_modules/firebase-functions/lib/apps.js":
/*!*********************************************************!*\
  !*** ./src/node_modules/firebase-functions/lib/apps.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// The MIT License (MIT)\n//\n// Copyright (c) 2017 Firebase\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.apps = void 0;\nconst firebase = __webpack_require__(/*! firebase-admin */ \"./src/node_modules/firebase-admin/lib/index.js\");\nconst _ = __webpack_require__(/*! lodash */ \"lodash\");\nconst config_1 = __webpack_require__(/*! ./config */ \"./src/node_modules/firebase-functions/lib/config.js\");\nfunction apps() {\n    if (typeof apps.singleton === 'undefined') {\n        apps.init();\n    }\n    return apps.singleton;\n}\nexports.apps = apps;\n(function (apps) {\n    /** @hidden */\n    apps.garbageCollectionInterval = 2 * 60 * 1000;\n    /** @hidden */\n    function delay(delay) {\n        return new Promise((resolve) => {\n            setTimeout(resolve, delay);\n        });\n    }\n    apps.delay = delay;\n    apps.init = () => (apps.singleton = new Apps());\n    class Apps {\n        constructor() {\n            this._refCounter = {};\n        }\n        _appAlive(appName) {\n            try {\n                const app = firebase.app(appName);\n                return !_.get(app, 'isDeleted_');\n            }\n            catch (e) {\n                return false;\n            }\n        }\n        _destroyApp(appName) {\n            if (!this._appAlive(appName)) {\n                return;\n            }\n            firebase\n                .app(appName)\n                .delete()\n                .catch(_.noop);\n        }\n        retain() {\n            const increment = (n) => {\n                return (n || 0) + 1;\n            };\n            // Increment counter for admin because function might use event.data.ref\n            _.update(this._refCounter, '__admin__', increment);\n        }\n        release() {\n            const decrement = (n) => {\n                return n - 1;\n            };\n            return delay(apps.garbageCollectionInterval).then(() => {\n                _.update(this._refCounter, '__admin__', decrement);\n                _.forEach(this._refCounter, (count, key) => {\n                    if (count <= 0) {\n                        this._destroyApp(key);\n                    }\n                });\n            });\n        }\n        get admin() {\n            if (this._emulatedAdminApp) {\n                return this._emulatedAdminApp;\n            }\n            if (this._appAlive('__admin__')) {\n                return firebase.app('__admin__');\n            }\n            return firebase.initializeApp(this.firebaseArgs, '__admin__');\n        }\n        /**\n         * This function allows the Firebase Emulator Suite to override the FirebaseApp instance\n         * used by the Firebase Functions SDK. Developers should never call this function for\n         * other purposes.\n         */\n        setEmulatedAdminApp(app) {\n            this._emulatedAdminApp = app;\n        }\n        get firebaseArgs() {\n            return _.assign({}, config_1.firebaseConfig(), {\n                credential: firebase.credential.applicationDefault(),\n            });\n        }\n    }\n    apps.Apps = Apps;\n})(apps = exports.apps || (exports.apps = {}));\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-functions/lib/apps.js?");

/***/ }),

/***/ "./src/node_modules/firebase-functions/lib/cloud-functions.js":
/*!********************************************************************!*\
  !*** ./src/node_modules/firebase-functions/lib/cloud-functions.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// The MIT License (MIT)\n//\n// Copyright (c) 2017 Firebase\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.optionsToTrigger = exports.makeCloudFunction = exports.Change = void 0;\nconst _ = __webpack_require__(/*! lodash */ \"lodash\");\nconst function_configuration_1 = __webpack_require__(/*! ./function-configuration */ \"./src/node_modules/firebase-functions/lib/function-configuration.js\");\nconst logger_1 = __webpack_require__(/*! ./logger */ \"./src/node_modules/firebase-functions/lib/logger.js\");\n/** @hidden */\nconst WILDCARD_REGEX = new RegExp('{[^/{}]*}', 'g');\n/**\n * The Functions interface for events that change state, such as\n * Realtime Database or Cloud Firestore `onWrite` and `onUpdate`.\n *\n * For more information about the format used to construct `Change` objects, see\n * [`cloud-functions.ChangeJson`](/docs/reference/functions/cloud_functions_.changejson).\n *\n */\nclass Change {\n    constructor(before, after) {\n        this.before = before;\n        this.after = after;\n    }\n}\nexports.Change = Change;\n(function (Change) {\n    /** @hidden */\n    function reinterpretCast(x) {\n        return x;\n    }\n    /**\n     * @hidden\n     * Factory method for creating a Change from a `before` object and an `after`\n     * object.\n     */\n    function fromObjects(before, after) {\n        return new Change(before, after);\n    }\n    Change.fromObjects = fromObjects;\n    /**\n     * @hidden\n     * Factory method for creating a Change from a JSON and an optional customizer\n     * function to be applied to both the `before` and the `after` fields.\n     */\n    function fromJSON(json, customizer = reinterpretCast) {\n        let before = { ...json.before };\n        if (json.fieldMask) {\n            before = applyFieldMask(before, json.after, json.fieldMask);\n        }\n        return Change.fromObjects(customizer(before || {}), customizer(json.after || {}));\n    }\n    Change.fromJSON = fromJSON;\n    /** @hidden */\n    function applyFieldMask(sparseBefore, after, fieldMask) {\n        const before = { ...after };\n        const masks = fieldMask.split(',');\n        masks.forEach((mask) => {\n            const val = _.get(sparseBefore, mask);\n            if (typeof val === 'undefined') {\n                _.unset(before, mask);\n            }\n            else {\n                _.set(before, mask, val);\n            }\n        });\n        return before;\n    }\n    Change.applyFieldMask = applyFieldMask;\n})(Change = exports.Change || (exports.Change = {}));\n/** @hidden */\nfunction makeCloudFunction({ after = () => { }, before = () => { }, contextOnlyHandler, dataConstructor = (raw) => raw.data, eventType, handler, labels = {}, legacyEventType, options = {}, provider, service, triggerResource, }) {\n    const cloudFunction = (data, context) => {\n        if (legacyEventType && context.eventType === legacyEventType) {\n            /*\n             * v1beta1 event flow has different format for context, transform them to\n             * new format.\n             */\n            context.eventType = provider + '.' + eventType;\n            context.resource = {\n                service,\n                name: context.resource,\n            };\n        }\n        const event = {\n            data,\n            context,\n        };\n        if (provider === 'google.firebase.database') {\n            context.authType = _detectAuthType(event);\n            if (context.authType !== 'ADMIN') {\n                context.auth = _makeAuth(event, context.authType);\n            }\n            else {\n                delete context.auth;\n            }\n        }\n        if (triggerResource() == null) {\n            Object.defineProperty(context, 'params', {\n                get: () => {\n                    throw new Error('context.params is not available when using the handler namespace.');\n                },\n            });\n        }\n        else {\n            context.params = context.params || _makeParams(context, triggerResource);\n        }\n        before(event);\n        let promise;\n        if (labels && labels['deployment-scheduled']) {\n            // Scheduled function do not have meaningful data, so exclude it\n            promise = contextOnlyHandler(context);\n        }\n        else {\n            const dataOrChange = dataConstructor(event);\n            promise = handler(dataOrChange, context);\n        }\n        if (typeof promise === 'undefined') {\n            logger_1.warn('Function returned undefined, expected Promise or value');\n        }\n        return Promise.resolve(promise)\n            .then((result) => {\n            after(event);\n            return result;\n        })\n            .catch((err) => {\n            after(event);\n            return Promise.reject(err);\n        });\n    };\n    Object.defineProperty(cloudFunction, '__trigger', {\n        get: () => {\n            if (triggerResource() == null) {\n                return {};\n            }\n            const trigger = _.assign(optionsToTrigger(options), {\n                eventTrigger: {\n                    resource: triggerResource(),\n                    eventType: legacyEventType || provider + '.' + eventType,\n                    service,\n                },\n            });\n            if (!_.isEmpty(labels)) {\n                trigger.labels = labels;\n            }\n            return trigger;\n        },\n    });\n    cloudFunction.run = handler || contextOnlyHandler;\n    return cloudFunction;\n}\nexports.makeCloudFunction = makeCloudFunction;\n/** @hidden */\nfunction _makeParams(context, triggerResourceGetter) {\n    if (context.params) {\n        // In unit testing, user may directly provide `context.params`.\n        return context.params;\n    }\n    if (!context.resource) {\n        // In unit testing, `resource` may be unpopulated for a test event.\n        return {};\n    }\n    const triggerResource = triggerResourceGetter();\n    const wildcards = triggerResource.match(WILDCARD_REGEX);\n    const params = {};\n    if (wildcards) {\n        const triggerResourceParts = _.split(triggerResource, '/');\n        const eventResourceParts = _.split(context.resource.name, '/');\n        _.forEach(wildcards, (wildcard) => {\n            const wildcardNoBraces = wildcard.slice(1, -1);\n            const position = _.indexOf(triggerResourceParts, wildcard);\n            params[wildcardNoBraces] = eventResourceParts[position];\n        });\n    }\n    return params;\n}\n/** @hidden */\nfunction _makeAuth(event, authType) {\n    if (authType === 'UNAUTHENTICATED') {\n        return null;\n    }\n    return {\n        uid: _.get(event, 'context.auth.variable.uid'),\n        token: _.get(event, 'context.auth.variable.token'),\n    };\n}\n/** @hidden */\nfunction _detectAuthType(event) {\n    if (_.get(event, 'context.auth.admin')) {\n        return 'ADMIN';\n    }\n    if (_.has(event, 'context.auth.variable')) {\n        return 'USER';\n    }\n    return 'UNAUTHENTICATED';\n}\n/** @hidden */\nfunction optionsToTrigger(options) {\n    const trigger = {};\n    if (options.regions) {\n        trigger.regions = options.regions;\n    }\n    if (options.failurePolicy !== undefined) {\n        switch (options.failurePolicy) {\n            case false:\n                trigger.failurePolicy = undefined;\n                break;\n            case true:\n                trigger.failurePolicy = function_configuration_1.DEFAULT_FAILURE_POLICY;\n                break;\n            default:\n                trigger.failurePolicy = options.failurePolicy;\n        }\n    }\n    if (options.timeoutSeconds) {\n        trigger.timeout = options.timeoutSeconds.toString() + 's';\n    }\n    if (options.memory) {\n        const memoryLookup = {\n            '128MB': 128,\n            '256MB': 256,\n            '512MB': 512,\n            '1GB': 1024,\n            '2GB': 2048,\n            '4GB': 4096,\n            '8GB': 8192,\n        };\n        trigger.availableMemoryMb = _.get(memoryLookup, options.memory);\n    }\n    if (options.schedule) {\n        trigger.schedule = options.schedule;\n    }\n    if (options.minInstances) {\n        trigger.minInstances = options.minInstances;\n    }\n    if (options.maxInstances) {\n        trigger.maxInstances = options.maxInstances;\n    }\n    if (options.ingressSettings) {\n        trigger.ingressSettings = options.ingressSettings;\n    }\n    if (options.vpcConnector) {\n        trigger.vpcConnector = options.vpcConnector;\n    }\n    if (options.vpcConnectorEgressSettings) {\n        trigger.vpcConnectorEgressSettings = options.vpcConnectorEgressSettings;\n    }\n    if (options.serviceAccount) {\n        if (options.serviceAccount === 'default') {\n            // Do nothing, since this is equivalent to not setting serviceAccount.\n        }\n        else if (options.serviceAccount.endsWith('@')) {\n            if (!process.env.GCLOUD_PROJECT) {\n                throw new Error(`Unable to determine email for service account '${options.serviceAccount}' because process.env.GCLOUD_PROJECT is not set.`);\n            }\n            trigger.serviceAccountEmail = `${options.serviceAccount}${process.env.GCLOUD_PROJECT}.iam.gserviceaccount.com`;\n        }\n        else if (options.serviceAccount.includes('@')) {\n            trigger.serviceAccountEmail = options.serviceAccount;\n        }\n        else {\n            throw new Error(`Invalid option for serviceAccount: '${options.serviceAccount}'. Valid options are 'default', a service account email, or '{serviceAccountName}@'`);\n        }\n    }\n    return trigger;\n}\nexports.optionsToTrigger = optionsToTrigger;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-functions/lib/cloud-functions.js?");

/***/ }),

/***/ "./src/node_modules/firebase-functions/lib/config.js":
/*!***********************************************************!*\
  !*** ./src/node_modules/firebase-functions/lib/config.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// The MIT License (MIT)\n//\n// Copyright (c) 2017 Firebase\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.firebaseConfig = exports.config = void 0;\nconst path = __webpack_require__(/*! path */ \"path\");\nfunction config() {\n    if (typeof config.singleton === 'undefined') {\n        init();\n    }\n    return config.singleton;\n}\nexports.config = config;\n/**\n * Store and retrieve project configuration data such as third-party API\n * keys or other settings. You can set configuration values using the\n * Firebase CLI as described in\n * [Environment Configuration](/docs/functions/config-env).\n */\n(function (config) {\n})(config = exports.config || (exports.config = {}));\n/** @hidden */\nfunction firebaseConfig() {\n    const env = process.env.FIREBASE_CONFIG;\n    if (env) {\n        return JSON.parse(env);\n    }\n    // Could have Runtime Config with Firebase in it as an ENV value.\n    try {\n        const config = JSON.parse(process.env.CLOUD_RUNTIME_CONFIG);\n        if (config.firebase) {\n            return config.firebase;\n        }\n    }\n    catch (e) {\n        // Do nothing\n    }\n    // Could have Runtime Config with Firebase in it as an ENV location or default.\n    try {\n        const configPath = process.env.CLOUD_RUNTIME_CONFIG ||\n            path.join(process.env.PWD, '.runtimeconfig.json');\n        const config = __webpack_require__(\"./src/node_modules/firebase-functions/lib sync recursive\")(configPath);\n        if (config.firebase) {\n            return config.firebase;\n        }\n    }\n    catch (e) {\n        // Do nothing\n    }\n    return null;\n}\nexports.firebaseConfig = firebaseConfig;\nfunction init() {\n    try {\n        const parsed = JSON.parse(process.env.CLOUD_RUNTIME_CONFIG);\n        delete parsed.firebase;\n        config.singleton = parsed;\n        return;\n    }\n    catch (e) {\n        // Do nothing\n    }\n    try {\n        const configPath = process.env.CLOUD_RUNTIME_CONFIG ||\n            path.join(process.env.PWD, '.runtimeconfig.json');\n        const parsed = __webpack_require__(\"./src/node_modules/firebase-functions/lib sync recursive\")(configPath);\n        delete parsed.firebase;\n        config.singleton = parsed;\n        return;\n    }\n    catch (e) {\n        // Do nothing\n    }\n    config.singleton = {};\n}\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-functions/lib/config.js?");

/***/ }),

/***/ "./src/node_modules/firebase-functions/lib/encoder.js":
/*!************************************************************!*\
  !*** ./src/node_modules/firebase-functions/lib/encoder.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// The MIT License (MIT)\n//\n// Copyright (c) 2017 Firebase\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.dateToTimestampProto = void 0;\nfunction dateToTimestampProto(timeString) {\n    if (typeof timeString === 'undefined') {\n        return;\n    }\n    const date = new Date(timeString);\n    const seconds = Math.floor(date.getTime() / 1000);\n    let nanos = 0;\n    if (timeString.length > 20) {\n        const nanoString = timeString.substring(20, timeString.length - 1);\n        const trailingZeroes = 9 - nanoString.length;\n        nanos = parseInt(nanoString, 10) * Math.pow(10, trailingZeroes);\n    }\n    return { seconds, nanos };\n}\nexports.dateToTimestampProto = dateToTimestampProto;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-functions/lib/encoder.js?");

/***/ }),

/***/ "./src/node_modules/firebase-functions/lib/function-builder.js":
/*!*********************************************************************!*\
  !*** ./src/node_modules/firebase-functions/lib/function-builder.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// The MIT License (MIT)\n//\n// Copyright (c) 2017 Firebase\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FunctionBuilder = exports.runWith = exports.region = void 0;\nconst _ = __webpack_require__(/*! lodash */ \"lodash\");\nconst function_configuration_1 = __webpack_require__(/*! ./function-configuration */ \"./src/node_modules/firebase-functions/lib/function-configuration.js\");\nconst analytics = __webpack_require__(/*! ./providers/analytics */ \"./src/node_modules/firebase-functions/lib/providers/analytics.js\");\nconst auth = __webpack_require__(/*! ./providers/auth */ \"./src/node_modules/firebase-functions/lib/providers/auth.js\");\nconst database = __webpack_require__(/*! ./providers/database */ \"./src/node_modules/firebase-functions/lib/providers/database.js\");\nconst firestore = __webpack_require__(/*! ./providers/firestore */ \"./src/node_modules/firebase-functions/lib/providers/firestore.js\");\nconst https = __webpack_require__(/*! ./providers/https */ \"./src/node_modules/firebase-functions/lib/providers/https.js\");\nconst pubsub = __webpack_require__(/*! ./providers/pubsub */ \"./src/node_modules/firebase-functions/lib/providers/pubsub.js\");\nconst remoteConfig = __webpack_require__(/*! ./providers/remoteConfig */ \"./src/node_modules/firebase-functions/lib/providers/remoteConfig.js\");\nconst storage = __webpack_require__(/*! ./providers/storage */ \"./src/node_modules/firebase-functions/lib/providers/storage.js\");\nconst testLab = __webpack_require__(/*! ./providers/testLab */ \"./src/node_modules/firebase-functions/lib/providers/testLab.js\");\n/**\n * Assert that the runtime options passed in are valid.\n * @param runtimeOptions object containing memory and timeout information.\n * @throws { Error } Memory and TimeoutSeconds values must be valid.\n */\nfunction assertRuntimeOptionsValid(runtimeOptions) {\n    if (runtimeOptions.memory &&\n        !_.includes(function_configuration_1.VALID_MEMORY_OPTIONS, runtimeOptions.memory)) {\n        throw new Error(`The only valid memory allocation values are: ${function_configuration_1.VALID_MEMORY_OPTIONS.join(', ')}`);\n    }\n    if (runtimeOptions.timeoutSeconds > function_configuration_1.MAX_TIMEOUT_SECONDS ||\n        runtimeOptions.timeoutSeconds < 0) {\n        throw new Error(`TimeoutSeconds must be between 0 and ${function_configuration_1.MAX_TIMEOUT_SECONDS}`);\n    }\n    if (runtimeOptions.ingressSettings &&\n        !_.includes(function_configuration_1.INGRESS_SETTINGS_OPTIONS, runtimeOptions.ingressSettings)) {\n        throw new Error(`The only valid ingressSettings values are: ${function_configuration_1.INGRESS_SETTINGS_OPTIONS.join(',')}`);\n    }\n    if (runtimeOptions.vpcConnectorEgressSettings &&\n        !_.includes(function_configuration_1.VPC_EGRESS_SETTINGS_OPTIONS, runtimeOptions.vpcConnectorEgressSettings)) {\n        throw new Error(`The only valid vpcConnectorEgressSettings values are: ${function_configuration_1.VPC_EGRESS_SETTINGS_OPTIONS.join(',')}`);\n    }\n    if (runtimeOptions.failurePolicy !== undefined) {\n        if (_.isBoolean(runtimeOptions.failurePolicy) === false &&\n            _.isObjectLike(runtimeOptions.failurePolicy) === false) {\n            throw new Error(`failurePolicy must be a boolean or an object.`);\n        }\n        if (typeof runtimeOptions.failurePolicy === 'object') {\n            if (_.isObjectLike(runtimeOptions.failurePolicy.retry) === false ||\n                _.isEmpty(runtimeOptions.failurePolicy.retry) === false) {\n                throw new Error('failurePolicy.retry must be an empty object.');\n            }\n        }\n    }\n    if (runtimeOptions.serviceAccount &&\n        runtimeOptions.serviceAccount !== 'default' &&\n        !_.includes(runtimeOptions.serviceAccount, '@')) {\n        throw new Error(`serviceAccount must be set to 'default', a service account email, or '{serviceAccountName}@'`);\n    }\n    return true;\n}\n/**\n * Assert regions specified are valid.\n * @param regions list of regions.\n * @throws { Error } Regions must be in list of supported regions.\n */\nfunction assertRegionsAreValid(regions) {\n    if (!regions.length) {\n        throw new Error('You must specify at least one region');\n    }\n    return true;\n}\n/**\n * Configure the regions that the function is deployed to.\n * @param regions One of more region strings.\n * @example\n * functions.region('us-east1')\n * @example\n * functions.region('us-east1', 'us-central1')\n */\nfunction region(...regions) {\n    if (assertRegionsAreValid(regions)) {\n        return new FunctionBuilder({ regions });\n    }\n}\nexports.region = region;\n/**\n * Configure runtime options for the function.\n * @param runtimeOptions Object with optional fields:\n * 1. `memory`: amount of memory to allocate to the function, possible values\n *    are: '128MB', '256MB', '512MB', '1GB', '2GB', and '4GB'.\n * 2. `timeoutSeconds`: timeout for the function in seconds, possible values are\n *    0 to 540.\n * 3. `failurePolicy`: failure policy of the function, with boolean `true` being\n *    equivalent to providing an empty retry object.\n * 4. `vpcConnector`: id of a VPC connector in same project and region.\n * 5. `vpcConnectorEgressSettings`: when a vpcConnector is set, control which\n *    egress traffic is sent through the vpcConnector.\n * 6. `serviceAccount`: Specific service account for the function.\n * 7. `ingressSettings`: ingress settings for the function, which control where a HTTPS\n *    function can be called from.\n *\n * Value must not be null.\n */\nfunction runWith(runtimeOptions) {\n    if (assertRuntimeOptionsValid(runtimeOptions)) {\n        return new FunctionBuilder(runtimeOptions);\n    }\n}\nexports.runWith = runWith;\nclass FunctionBuilder {\n    constructor(options) {\n        this.options = options;\n    }\n    /**\n     * Configure the regions that the function is deployed to.\n     * @param regions One or more region strings.\n     * @example\n     * functions.region('us-east1')\n     * @example\n     * functions.region('us-east1', 'us-central1')\n     */\n    region(...regions) {\n        if (assertRegionsAreValid(regions)) {\n            this.options.regions = regions;\n            return this;\n        }\n    }\n    /**\n     * Configure runtime options for the function.\n     * @param runtimeOptions Object with optional fields:\n     * 1. `memory`: amount of memory to allocate to the function, possible values\n     *    are: '128MB', '256MB', '512MB', '1GB', '2GB', and '4GB'.\n     * 2. `timeoutSeconds`: timeout for the function in seconds, possible values are\n     *    0 to 540.\n     * 3. `failurePolicy`: failure policy of the function, with boolean `true` being\n     *    equivalent to providing an empty retry object.\n     * 4. `vpcConnector`: id of a VPC connector in the same project and region\n     * 5. `vpcConnectorEgressSettings`: when a `vpcConnector` is set, control which\n     *    egress traffic is sent through the `vpcConnector`.\n     *\n     * Value must not be null.\n     */\n    runWith(runtimeOptions) {\n        if (assertRuntimeOptionsValid(runtimeOptions)) {\n            this.options = _.assign(this.options, runtimeOptions);\n            return this;\n        }\n    }\n    get https() {\n        if (this.options.failurePolicy !== undefined) {\n            console.warn('RuntimeOptions.failurePolicy is not supported in https functions.');\n        }\n        return {\n            /**\n             * Handle HTTP requests.\n             * @param handler A function that takes a request and response object,\n             * same signature as an Express app.\n             */\n            onRequest: (handler) => https._onRequestWithOptions(handler, this.options),\n            /**\n             * Declares a callable method for clients to call using a Firebase SDK.\n             * @param handler A method that takes a data and context and returns a value.\n             */\n            onCall: (handler) => https._onCallWithOptions(handler, this.options),\n        };\n    }\n    get database() {\n        return {\n            /**\n             * Selects a database instance that will trigger the function. If omitted,\n             * will pick the default database for your project.\n             * @param instance The Realtime Database instance to use.\n             */\n            instance: (instance) => database._instanceWithOptions(instance, this.options),\n            /**\n             * Select Firebase Realtime Database Reference to listen to.\n             *\n             * This method behaves very similarly to the method of the same name in\n             * the client and Admin Firebase SDKs. Any change to the Database that\n             * affects the data at or below the provided `path` will fire an event in\n             * Cloud Functions.\n             *\n             * There are three important differences between listening to a Realtime\n             * Database event in Cloud Functions and using the Realtime Database in\n             * the client and Admin SDKs:\n             * 1. Cloud Functions allows wildcards in the `path` name. Any `path`\n             *    component in curly brackets (`{}`) is a wildcard that matches all\n             *    strings. The value that matched a certain invocation of a Cloud\n             *    Function is returned as part of the `context.params` object. For\n             *    example, `ref(\"messages/{messageId}\")` matches changes at\n             *    `/messages/message1` or `/messages/message2`, resulting in\n             *    `context.params.messageId` being set to `\"message1\"` or\n             *    `\"message2\"`, respectively.\n             * 2. Cloud Functions do not fire an event for data that already existed\n             *    before the Cloud Function was deployed.\n             * 3. Cloud Function events have access to more information, including\n             *    information about the user who triggered the Cloud Function.\n             * @param ref Path of the database to listen to.\n             */\n            ref: (path) => database._refWithOptions(path, this.options),\n        };\n    }\n    get firestore() {\n        return {\n            /**\n             * Select the Firestore document to listen to for events.\n             * @param path Full database path to listen to. This includes the name of\n             * the collection that the document is a part of. For example, if the\n             * collection is named \"users\" and the document is named \"Ada\", then the\n             * path is \"/users/Ada\".\n             */\n            document: (path) => firestore._documentWithOptions(path, this.options),\n            /** @hidden */\n            namespace: (namespace) => firestore._namespaceWithOptions(namespace, this.options),\n            /** @hidden */\n            database: (database) => firestore._databaseWithOptions(database, this.options),\n        };\n    }\n    get analytics() {\n        return {\n            /**\n             * Select analytics events to listen to for events.\n             * @param analyticsEventType Name of the analytics event type.\n             */\n            event: (analyticsEventType) => analytics._eventWithOptions(analyticsEventType, this.options),\n        };\n    }\n    get remoteConfig() {\n        return {\n            /**\n             * Handle all updates (including rollbacks) that affect a Remote Config\n             * project.\n             * @param handler A function that takes the updated Remote Config template\n             * version metadata as an argument.\n             */\n            onUpdate: (handler) => remoteConfig._onUpdateWithOptions(handler, this.options),\n        };\n    }\n    get storage() {\n        return {\n            /**\n             * The optional bucket function allows you to choose which buckets' events\n             * to handle. This step can be bypassed by calling object() directly,\n             * which will use the default Cloud Storage for Firebase bucket.\n             * @param bucket Name of the Google Cloud Storage bucket to listen to.\n             */\n            bucket: (bucket) => storage._bucketWithOptions(this.options, bucket),\n            /**\n             * Handle events related to Cloud Storage objects.\n             */\n            object: () => storage._objectWithOptions(this.options),\n        };\n    }\n    get pubsub() {\n        return {\n            /**\n             * Select Cloud Pub/Sub topic to listen to.\n             * @param topic Name of Pub/Sub topic, must belong to the same project as\n             * the function.\n             */\n            topic: (topic) => pubsub._topicWithOptions(topic, this.options),\n            schedule: (schedule) => pubsub._scheduleWithOptions(schedule, this.options),\n        };\n    }\n    get auth() {\n        return {\n            /**\n             * Handle events related to Firebase authentication users.\n             */\n            user: () => auth._userWithOptions(this.options),\n        };\n    }\n    get testLab() {\n        return {\n            /**\n             * Handle events related to Test Lab test matrices.\n             */\n            testMatrix: () => testLab._testMatrixWithOpts(this.options),\n        };\n    }\n}\nexports.FunctionBuilder = FunctionBuilder;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-functions/lib/function-builder.js?");

/***/ }),

/***/ "./src/node_modules/firebase-functions/lib/function-configuration.js":
/*!***************************************************************************!*\
  !*** ./src/node_modules/firebase-functions/lib/function-configuration.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DEFAULT_FAILURE_POLICY = exports.INGRESS_SETTINGS_OPTIONS = exports.VPC_EGRESS_SETTINGS_OPTIONS = exports.VALID_MEMORY_OPTIONS = exports.MAX_TIMEOUT_SECONDS = exports.MIN_TIMEOUT_SECONDS = exports.SUPPORTED_REGIONS = void 0;\n/**\n * List of all regions supported by Cloud Functions.\n */\nexports.SUPPORTED_REGIONS = [\n    'us-central1',\n    'us-east1',\n    'us-east4',\n    'us-west2',\n    'us-west3',\n    'us-west4',\n    'europe-central2',\n    'europe-west1',\n    'europe-west2',\n    'europe-west3',\n    'europe-west6',\n    'asia-east2',\n    'asia-northeast1',\n    'asia-northeast2',\n    'asia-northeast3',\n    'asia-south1',\n    'asia-southeast2',\n    'northamerica-northeast1',\n    'southamerica-east1',\n    'australia-southeast1',\n];\n/**\n * Cloud Functions min timeout value.\n */\nexports.MIN_TIMEOUT_SECONDS = 0;\n/**\n * Cloud Functions max timeout value.\n */\nexports.MAX_TIMEOUT_SECONDS = 540;\n/**\n * List of available memory options supported by Cloud Functions.\n */\nexports.VALID_MEMORY_OPTIONS = [\n    '128MB',\n    '256MB',\n    '512MB',\n    '1GB',\n    '2GB',\n    '4GB',\n    '8GB',\n];\n/**\n * List of available options for VpcConnectorEgressSettings.\n */\nexports.VPC_EGRESS_SETTINGS_OPTIONS = [\n    'VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED',\n    'PRIVATE_RANGES_ONLY',\n    'ALL_TRAFFIC',\n];\n/**\n * List of available options for IngressSettings.\n */\nexports.INGRESS_SETTINGS_OPTIONS = [\n    'INGRESS_SETTINGS_UNSPECIFIED',\n    'ALLOW_ALL',\n    'ALLOW_INTERNAL_ONLY',\n    'ALLOW_INTERNAL_AND_GCLB',\n];\nexports.DEFAULT_FAILURE_POLICY = {\n    retry: {},\n};\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-functions/lib/function-configuration.js?");

/***/ }),

/***/ "./src/node_modules/firebase-functions/lib/handler-builder.js":
/*!********************************************************************!*\
  !*** ./src/node_modules/firebase-functions/lib/handler-builder.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// The MIT License (MIT)\n//\n// Copyright (c) 2017 Firebase\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.handler = exports.HandlerBuilder = void 0;\nconst apps_1 = __webpack_require__(/*! ./apps */ \"./src/node_modules/firebase-functions/lib/apps.js\");\nconst analytics = __webpack_require__(/*! ./providers/analytics */ \"./src/node_modules/firebase-functions/lib/providers/analytics.js\");\nconst auth = __webpack_require__(/*! ./providers/auth */ \"./src/node_modules/firebase-functions/lib/providers/auth.js\");\nconst database = __webpack_require__(/*! ./providers/database */ \"./src/node_modules/firebase-functions/lib/providers/database.js\");\nconst firestore = __webpack_require__(/*! ./providers/firestore */ \"./src/node_modules/firebase-functions/lib/providers/firestore.js\");\nconst https = __webpack_require__(/*! ./providers/https */ \"./src/node_modules/firebase-functions/lib/providers/https.js\");\nconst pubsub = __webpack_require__(/*! ./providers/pubsub */ \"./src/node_modules/firebase-functions/lib/providers/pubsub.js\");\nconst remoteConfig = __webpack_require__(/*! ./providers/remoteConfig */ \"./src/node_modules/firebase-functions/lib/providers/remoteConfig.js\");\nconst storage = __webpack_require__(/*! ./providers/storage */ \"./src/node_modules/firebase-functions/lib/providers/storage.js\");\nconst testLab = __webpack_require__(/*! ./providers/testLab */ \"./src/node_modules/firebase-functions/lib/providers/testLab.js\");\n/**\n * The `HandlerBuilder` class facilitates the writing of functions by developers\n * building Firebase Extensions as well as developers who want to use the gcloud CLI or\n * Google Cloud Console to deploy their functions.\n *\n * **Do not use `HandlerBuilder` when writing normal functions for deployment via\n * the Firebase CLI.** For normal purposes, use\n * [`FunctionBuilder`](/docs/reference/functions/function_builder_.functionbuilder).\n */\nclass HandlerBuilder {\n    constructor() { }\n    /**\n     * Create a handler for HTTPS events.\n    \n     * `onRequest` handles an HTTPS request and has the same signature as an Express app.\n     *\n     * @example\n     * ```javascript\n     * exports.myFunction = functions.handler.https.onRequest((req, res) => { ... })\n     * ```\n     *\n     * `onCall` declares a callable function for clients to call using a Firebase SDK.\n     *\n     * @example\n     * ```javascript\n     * exports.myFunction = functions.handler.https.onCall((data, context) => { ... })\n     * ```\n     */\n    get https() {\n        return {\n            onRequest: (handler) => {\n                const func = https._onRequestWithOptions(handler, {});\n                func.__trigger = {};\n                return func;\n            },\n            onCall: (handler) => {\n                const func = https._onCallWithOptions(handler, {});\n                func.__trigger = {};\n                return func;\n            },\n        };\n    }\n    /**\n     * Create a handler for Firebase Realtime Database events.\n     *\n     * `ref.onCreate` handles the creation of new data.\n     *\n     * @example\n     * ```javascript\n     * exports.myFunction = functions.handler.database.ref.onCreate((snap, context) => { ... })\n     * ```\n     *\n     * `ref.onUpdate` handles updates to existing data.\n     *\n     * @example\n     * ```javascript\n     * exports.myFunction = functions.handler.database.ref.onUpdate((change, context) => { ... })\n     * ```\n    \n     * `ref.onDelete` handles the deletion of existing data.\n     *\n     * @example\n     * ```javascript\n     * exports.myFunction = functions.handler.database.ref.onDelete((snap, context) => { ... })\n     * ```\n  \n     * `ref.onWrite` handles the creation, update, or deletion of data.\n     *\n     * @example\n     * ```javascript\n     * exports.myFunction = functions.handler.database.ref.onWrite((change, context) => { ... })\n     * ```\n     */\n    get database() {\n        return {\n            /** @hidden */\n            get instance() {\n                return {\n                    get ref() {\n                        return new database.RefBuilder(apps_1.apps(), () => null, {});\n                    },\n                };\n            },\n            get ref() {\n                return new database.RefBuilder(apps_1.apps(), () => null, {});\n            },\n        };\n    }\n    /**\n     * Create a handler for Cloud Firestore events.\n     *\n     * `document.onCreate` handles the creation of new documents.\n     *\n     * @example\n     * ```javascript\n     * exports.myFunction = functions.handler.firestore.document.onCreate((snap, context) => { ... })\n     * ```\n     \n     * `document.onUpdate` handles updates to existing documents.\n     *\n     * @example\n     * ```javascript\n     * exports.myFunction = functions.handler.firestore.document.onUpdate((change, context) => { ... })\n     * ```\n     \n     * `document.onDelete` handles the deletion of existing documents.\n     *\n     * @example\n     * ```javascript\n     * exports.myFunction = functions.handler.firestore.document.onDelete((snap, context) =>\n     * { ... })\n     * ```\n     \n     * `document.onWrite` handles the creation, update, or deletion of documents.\n     *\n     * @example\n     * ```javascript\n     * exports.myFunction = functions.handler.firestore.document.onWrite((change, context) =>\n     * { ... })\n     * ```\n     */\n    get firestore() {\n        return {\n            get document() {\n                return new firestore.DocumentBuilder(() => null, {});\n            },\n            /** @hidden */\n            get namespace() {\n                return new firestore.DocumentBuilder(() => null, {});\n            },\n            /** @hidden */\n            get database() {\n                return new firestore.DocumentBuilder(() => null, {});\n            },\n        };\n    }\n    /**\n     * Create a handler for Firebase Remote Config events.\n  \n     * `remoteConfig.onUpdate` handles events that update a Remote Config template.\n   \n     * @example\n     * ```javascript\n     * exports.myFunction = functions.handler.remoteConfig.onUpdate() => { ... })\n     * ```\n     */\n    get remoteConfig() {\n        return {\n            onUpdate: (handler) => {\n                return new remoteConfig.UpdateBuilder(() => null, {}).onUpdate(handler);\n            },\n        };\n    }\n    /**\n     * Create a handler for Google Analytics events.\n     \n     * `event.onLog` handles the logging of Analytics conversion events.\n   \n     * @example\n     * ```javascript\n     * exports.myFunction = functions.handler.analytics.event.onLog((event) => { ... })\n     * ```\n     */\n    get analytics() {\n        return {\n            get event() {\n                return new analytics.AnalyticsEventBuilder(() => null, {});\n            },\n        };\n    }\n    /**\n     * Create a handler for Cloud Storage for Firebase events.\n     *\n     * `object.onArchive` handles the archiving of Storage objects.\n     *\n     * @example\n     * ```javascript\n     * exports.myFunction = functions.handler.storage.object.onArchive((object) => { ... })\n     * ```\n     \n     * `object.onDelete` handles the deletion of Storage objects.\n     *\n     * @example\n     * ```javascript\n     * exports.myFunction = functions.handler.storage.object.onDelete((object) => { ... })\n     * ```\n     \n     * `object.onFinalize` handles the creation of Storage objects.\n     *\n     * @example\n     * ```javascript\n     * exports.myFunction = functions.handler.storage.object.onFinalize((object) =>\n     * { ... })\n     * ```\n     \n     * `object.onMetadataUpdate` handles changes to the metadata of existing Storage objects.\n     *\n     * @example\n     * ```javascript\n     * exports.myFunction = functions.handler.storage.object.onMetadataUpdate((object) =>\n     * { ... })\n     * ```\n     */\n    get storage() {\n        return {\n            get bucket() {\n                return new storage.BucketBuilder(() => null, {}).object();\n            },\n            get object() {\n                return new storage.ObjectBuilder(() => null, {});\n            },\n        };\n    }\n    /**\n     * Create a handler for Cloud Pub/Sub events.\n     *\n     * `topic.onPublish` handles messages published to a Pub/Sub topic from SDKs, Cloud Console, or gcloud CLI.\n     *\n     * @example\n     * ```javascript\n     * exports.myFunction = functions.handler.pubsub.topic.onPublish((message) => { ... })\n     * ```\n     \n     * `schedule.onPublish` handles messages published to a Pub/Sub topic on a schedule.\n     *\n     * @example\n     * ```javascript\n     * exports.myFunction = functions.handler.pubsub.schedule.onPublish((message) => { ... })\n     * ```\n     */\n    get pubsub() {\n        return {\n            get topic() {\n                return new pubsub.TopicBuilder(() => null, {});\n            },\n            get schedule() {\n                return new pubsub.ScheduleBuilder(() => null, {});\n            },\n        };\n    }\n    /**\n     * Create a handler for Firebase Authentication events.\n     *\n     * `user.onCreate` handles the creation of users.\n     *\n     * @example\n     * ```javascript\n     * exports.myFunction = functions.handler.auth.user.onCreate((user) => { ... })\n     * ```\n     \n     * `user.onDelete` handles the deletion of users.\n     *\n     * @example\n     * ```javascript\n     * exports.myFunction = functions.handler.auth.user.onDelete((user => { ... })\n     * ```\n     \n     */\n    get auth() {\n        return {\n            get user() {\n                return new auth.UserBuilder(() => null, {});\n            },\n        };\n    }\n    /**\n     * Create a handler for Firebase Test Lab events.\n  \n     * `testMatrix.onComplete` handles the completion of a test matrix.\n   \n     * @example\n     * ```javascript\n     * exports.myFunction = functions.handler.testLab.testMatrix.onComplete((testMatrix) => { ... })\n     * ```\n     */\n    get testLab() {\n        return {\n            get testMatrix() {\n                return new testLab.TestMatrixBuilder(() => null, {});\n            },\n        };\n    }\n}\nexports.HandlerBuilder = HandlerBuilder;\nexports.handler = new HandlerBuilder();\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-functions/lib/handler-builder.js?");

/***/ }),

/***/ "./src/node_modules/firebase-functions/lib/index.js":
/*!**********************************************************!*\
  !*** ./src/node_modules/firebase-functions/lib/index.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n// The MIT License (MIT)\n//\n// Copyright (c) 2017 Firebase\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.logger = exports.testLab = exports.storage = exports.remoteConfig = exports.pubsub = exports.https = exports.handler = exports.firestore = exports.database = exports.auth = exports.app = exports.analytics = void 0;\n// Providers:\nconst analytics = __webpack_require__(/*! ./providers/analytics */ \"./src/node_modules/firebase-functions/lib/providers/analytics.js\");\nexports.analytics = analytics;\nconst auth = __webpack_require__(/*! ./providers/auth */ \"./src/node_modules/firebase-functions/lib/providers/auth.js\");\nexports.auth = auth;\nconst database = __webpack_require__(/*! ./providers/database */ \"./src/node_modules/firebase-functions/lib/providers/database.js\");\nexports.database = database;\nconst firestore = __webpack_require__(/*! ./providers/firestore */ \"./src/node_modules/firebase-functions/lib/providers/firestore.js\");\nexports.firestore = firestore;\nconst https = __webpack_require__(/*! ./providers/https */ \"./src/node_modules/firebase-functions/lib/providers/https.js\");\nexports.https = https;\nconst pubsub = __webpack_require__(/*! ./providers/pubsub */ \"./src/node_modules/firebase-functions/lib/providers/pubsub.js\");\nexports.pubsub = pubsub;\nconst remoteConfig = __webpack_require__(/*! ./providers/remoteConfig */ \"./src/node_modules/firebase-functions/lib/providers/remoteConfig.js\");\nexports.remoteConfig = remoteConfig;\nconst storage = __webpack_require__(/*! ./providers/storage */ \"./src/node_modules/firebase-functions/lib/providers/storage.js\");\nexports.storage = storage;\nconst testLab = __webpack_require__(/*! ./providers/testLab */ \"./src/node_modules/firebase-functions/lib/providers/testLab.js\");\nexports.testLab = testLab;\nconst apps = __webpack_require__(/*! ./apps */ \"./src/node_modules/firebase-functions/lib/apps.js\");\nconst handler_builder_1 = __webpack_require__(/*! ./handler-builder */ \"./src/node_modules/firebase-functions/lib/handler-builder.js\");\nObject.defineProperty(exports, \"handler\", ({ enumerable: true, get: function () { return handler_builder_1.handler; } }));\nconst logger = __webpack_require__(/*! ./logger */ \"./src/node_modules/firebase-functions/lib/logger.js\");\nexports.logger = logger;\nconst setup_1 = __webpack_require__(/*! ./setup */ \"./src/node_modules/firebase-functions/lib/setup.js\");\nconst app = apps.apps();\nexports.app = app;\n// Exported root types:\n__exportStar(__webpack_require__(/*! ./cloud-functions */ \"./src/node_modules/firebase-functions/lib/cloud-functions.js\"), exports);\n__exportStar(__webpack_require__(/*! ./config */ \"./src/node_modules/firebase-functions/lib/config.js\"), exports);\n__exportStar(__webpack_require__(/*! ./function-builder */ \"./src/node_modules/firebase-functions/lib/function-builder.js\"), exports);\n__exportStar(__webpack_require__(/*! ./function-configuration */ \"./src/node_modules/firebase-functions/lib/function-configuration.js\"), exports);\nsetup_1.setup();\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-functions/lib/index.js?");

/***/ }),

/***/ "./src/node_modules/firebase-functions/lib/logger.js":
/*!***********************************************************!*\
  !*** ./src/node_modules/firebase-functions/lib/logger.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.error = exports.warn = exports.info = exports.log = exports.debug = exports.write = void 0;\nconst util_1 = __webpack_require__(/*! util */ \"util\");\nconst common_1 = __webpack_require__(/*! ./logger/common */ \"./src/node_modules/firebase-functions/lib/logger/common.js\");\nfunction removeCircular(obj, refs = []) {\n    if (typeof obj !== 'object' || !obj) {\n        return obj;\n    }\n    if (refs.includes(obj)) {\n        return '[Circular]';\n    }\n    else {\n        refs.push(obj);\n    }\n    let returnObj;\n    if (Array.isArray(obj)) {\n        returnObj = new Array(obj.length);\n    }\n    else {\n        returnObj = {};\n    }\n    for (const k in obj) {\n        if (refs.includes(obj[k])) {\n            returnObj[k] = '[Circular]';\n        }\n        else {\n            returnObj[k] = removeCircular(obj[k], refs);\n        }\n    }\n    return returnObj;\n}\n/**\n * Writes a `LogEntry` to `stdout`/`stderr` (depending on severity).\n * @param entry The `LogEntry` including severity, message, and any additional structured metadata.\n */\nfunction write(entry) {\n    if (common_1.SUPPORTS_STRUCTURED_LOGS) {\n        common_1.UNPATCHED_CONSOLE[common_1.CONSOLE_SEVERITY[entry.severity]](JSON.stringify(removeCircular(entry)));\n        return;\n    }\n    let message = entry.message || '';\n    const jsonPayload = {};\n    let jsonKeyCount = 0;\n    for (const k in entry) {\n        if (!['severity', 'message'].includes(k)) {\n            jsonKeyCount++;\n            jsonPayload[k] = entry[k];\n        }\n    }\n    if (jsonKeyCount > 0) {\n        message = `${message} ${JSON.stringify(removeCircular(jsonPayload), null, 2)}`;\n    }\n    common_1.UNPATCHED_CONSOLE[common_1.CONSOLE_SEVERITY[entry.severity]](message);\n}\nexports.write = write;\n/**\n * Writes a `DEBUG` severity log. If the last argument provided is a plain object,\n * it is added to the `jsonPayload` in the Cloud Logging entry.\n * @param args Arguments, concatenated into the log message with space separators.\n */\nfunction debug(...args) {\n    write(entryFromArgs('DEBUG', args));\n}\nexports.debug = debug;\n/**\n * Writes an `INFO` severity log. If the last argument provided is a plain object,\n * it is added to the `jsonPayload` in the Cloud Logging entry.\n * @param args Arguments, concatenated into the log message with space separators.\n */\nfunction log(...args) {\n    write(entryFromArgs('INFO', args));\n}\nexports.log = log;\n/**\n * Writes an `INFO` severity log. If the last argument provided is a plain object,\n * it is added to the `jsonPayload` in the Cloud Logging entry.\n * @param args Arguments, concatenated into the log message with space separators.\n */\nfunction info(...args) {\n    write(entryFromArgs('INFO', args));\n}\nexports.info = info;\n/**\n * Writes a `WARNING` severity log. If the last argument provided is a plain object,\n * it is added to the `jsonPayload` in the Cloud Logging entry.\n * @param args Arguments, concatenated into the log message with space separators.\n */\nfunction warn(...args) {\n    write(entryFromArgs('WARNING', args));\n}\nexports.warn = warn;\n/**\n * Writes an `ERROR` severity log. If the last argument provided is a plain object,\n * it is added to the `jsonPayload` in the Cloud Logging entry.\n * @param args Arguments, concatenated into the log message with space separators.\n */\nfunction error(...args) {\n    write(entryFromArgs('ERROR', args));\n}\nexports.error = error;\n/** @hidden */\nfunction entryFromArgs(severity, args) {\n    let entry = {};\n    const lastArg = args[args.length - 1];\n    if (lastArg && typeof lastArg == 'object' && lastArg.constructor == Object) {\n        entry = args.pop();\n    }\n    return Object.assign({}, entry, {\n        severity,\n        // mimic `console.*` behavior, see https://nodejs.org/api/console.html#console_console_log_data_args\n        message: util_1.format.apply(null, args),\n    });\n}\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-functions/lib/logger.js?");

/***/ }),

/***/ "./src/node_modules/firebase-functions/lib/logger/common.js":
/*!******************************************************************!*\
  !*** ./src/node_modules/firebase-functions/lib/logger/common.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nvar _a, _b, _c;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UNPATCHED_CONSOLE = exports.CONSOLE_SEVERITY = exports.SUPPORTS_STRUCTURED_LOGS = void 0;\n// Determine if structured logs are supported (node >= 10). If something goes wrong,\n// assume no since unstructured is safer.\n/** @hidden */\nexports.SUPPORTS_STRUCTURED_LOGS = parseInt(((_c = (_b = (_a = process.versions) === null || _a === void 0 ? void 0 : _a.node) === null || _b === void 0 ? void 0 : _b.split('.')) === null || _c === void 0 ? void 0 : _c[0]) || '8', 10) >= 10;\n// Map LogSeverity types to their equivalent `console.*` method.\n/** @hidden */\nexports.CONSOLE_SEVERITY = {\n    DEBUG: 'debug',\n    INFO: 'info',\n    NOTICE: 'info',\n    WARNING: 'warn',\n    ERROR: 'error',\n    CRITICAL: 'error',\n    ALERT: 'error',\n    EMERGENCY: 'error',\n};\n// safely preserve unpatched console.* methods in case of compat require\n/** @hidden */\nexports.UNPATCHED_CONSOLE = {\n    debug: console.debug,\n    info: console.info,\n    log: console.log,\n    warn: console.warn,\n    error: console.error,\n};\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-functions/lib/logger/common.js?");

/***/ }),

/***/ "./src/node_modules/firebase-functions/lib/providers/analytics.js":
/*!************************************************************************!*\
  !*** ./src/node_modules/firebase-functions/lib/providers/analytics.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// The MIT License (MIT)\n//\n// Copyright (c) 2017 Firebase\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ExportBundleInfo = exports.UserPropertyValue = exports.UserDimensions = exports.AnalyticsEvent = exports.AnalyticsEventBuilder = exports._eventWithOptions = exports.event = exports.service = exports.provider = void 0;\nconst _ = __webpack_require__(/*! lodash */ \"lodash\");\nconst cloud_functions_1 = __webpack_require__(/*! ../cloud-functions */ \"./src/node_modules/firebase-functions/lib/cloud-functions.js\");\n/** @hidden */\nexports.provider = 'google.analytics';\n/** @hidden */\nexports.service = 'app-measurement.com';\n/**\n * Registers a function to handle analytics events.\n *\n * @param analyticsEventType Name of the analytics event type to which\n *   this Cloud Function is scoped.\n *\n * @return Analytics event builder interface.\n */\nfunction event(analyticsEventType) {\n    return _eventWithOptions(analyticsEventType, {});\n}\nexports.event = event;\n/** @hidden */\nfunction _eventWithOptions(analyticsEventType, options) {\n    return new AnalyticsEventBuilder(() => {\n        if (!process.env.GCLOUD_PROJECT) {\n            throw new Error('process.env.GCLOUD_PROJECT is not set.');\n        }\n        return ('projects/' + process.env.GCLOUD_PROJECT + '/events/' + analyticsEventType);\n    }, options);\n}\nexports._eventWithOptions = _eventWithOptions;\n/**\n * The Firebase Analytics event builder interface.\n *\n * Access via [`functions.analytics.event()`](functions.analytics#.event).\n */\nclass AnalyticsEventBuilder {\n    /** @hidden */\n    constructor(triggerResource, options) {\n        this.triggerResource = triggerResource;\n        this.options = options;\n    }\n    /**\n     * Event handler that fires every time a Firebase Analytics event occurs.\n     *\n     * @param handler Event handler that fires every time a Firebase Analytics event\n     *   occurs.\n     *\n     * @return A function that you can export and deploy.\n     */\n    onLog(handler) {\n        const dataConstructor = (raw) => {\n            return new AnalyticsEvent(raw.data);\n        };\n        return cloud_functions_1.makeCloudFunction({\n            handler,\n            provider: exports.provider,\n            eventType: 'event.log',\n            service: exports.service,\n            legacyEventType: `providers/google.firebase.analytics/eventTypes/event.log`,\n            triggerResource: this.triggerResource,\n            dataConstructor,\n            options: this.options,\n        });\n    }\n}\nexports.AnalyticsEventBuilder = AnalyticsEventBuilder;\n/** Interface representing a Firebase Analytics event that was logged for a specific user. */\nclass AnalyticsEvent {\n    /** @hidden */\n    constructor(wireFormat) {\n        this.params = {}; // In case of absent field, show empty (not absent) map.\n        if (wireFormat.eventDim && wireFormat.eventDim.length > 0) {\n            // If there's an eventDim, there'll always be exactly one.\n            const eventDim = wireFormat.eventDim[0];\n            copyField(eventDim, this, 'name');\n            copyField(eventDim, this, 'params', (p) => _.mapValues(p, unwrapValue));\n            copyFieldTo(eventDim, this, 'valueInUsd', 'valueInUSD');\n            copyFieldTo(eventDim, this, 'date', 'reportingDate');\n            copyTimestampToString(eventDim, this, 'timestampMicros', 'logTime');\n            copyTimestampToString(eventDim, this, 'previousTimestampMicros', 'previousLogTime');\n        }\n        copyFieldTo(wireFormat, this, 'userDim', 'user', (dim) => new UserDimensions(dim));\n    }\n}\nexports.AnalyticsEvent = AnalyticsEvent;\n/**\n * Interface representing the user who triggered the events.\n */\nclass UserDimensions {\n    /** @hidden */\n    constructor(wireFormat) {\n        // These are interfaces or primitives, no transformation needed.\n        copyFields(wireFormat, this, [\n            'userId',\n            'deviceInfo',\n            'geoInfo',\n            'appInfo',\n        ]);\n        // The following fields do need transformations of some sort.\n        copyTimestampToString(wireFormat, this, 'firstOpenTimestampMicros', 'firstOpenTime');\n        this.userProperties = {}; // With no entries in the wire format, present an empty (as opposed to absent) map.\n        copyField(wireFormat, this, 'userProperties', (r) => _.mapValues(r, (p) => new UserPropertyValue(p)));\n        copyField(wireFormat, this, 'bundleInfo', (r) => new ExportBundleInfo(r));\n        // BUG(36000368) Remove when no longer necessary\n        /* tslint:disable:no-string-literal */\n        if (!this.userId && this.userProperties['user_id']) {\n            this.userId = this.userProperties['user_id'].value;\n        }\n        /* tslint:enable:no-string-literal */\n    }\n}\nexports.UserDimensions = UserDimensions;\n/** Predefined or custom properties stored on the client side. */\nclass UserPropertyValue {\n    /** @hidden */\n    constructor(wireFormat) {\n        copyField(wireFormat, this, 'value', unwrapValueAsString);\n        copyTimestampToString(wireFormat, this, 'setTimestampUsec', 'setTime');\n    }\n}\nexports.UserPropertyValue = UserPropertyValue;\n/** Interface representing the bundle these events were uploaded to. */\nclass ExportBundleInfo {\n    /** @hidden */\n    constructor(wireFormat) {\n        copyField(wireFormat, this, 'bundleSequenceId');\n        copyTimestampToMillis(wireFormat, this, 'serverTimestampOffsetMicros', 'serverTimestampOffset');\n    }\n}\nexports.ExportBundleInfo = ExportBundleInfo;\n/** @hidden */\nfunction copyFieldTo(from, to, fromField, toField, transform = _.identity) {\n    if (from[fromField] !== undefined) {\n        to[toField] = transform(from[fromField]);\n    }\n}\n/** @hidden */\nfunction copyField(from, to, field, transform = _.identity) {\n    copyFieldTo(from, to, field, field, transform);\n}\n/** @hidden */\nfunction copyFields(from, to, fields) {\n    for (const field of fields) {\n        copyField(from, to, field);\n    }\n}\n// The incoming payload will have fields like:\n// {\n//   'myInt': {\n//     'intValue': '123'\n//   },\n//   'myDouble': {\n//     'doubleValue': 1.0\n//   },\n//   'myFloat': {\n//     'floatValue': 1.1\n//   },\n//   'myString': {\n//     'stringValue': 'hi!'\n//   }\n// }\n//\n// The following method will remove these four types of 'xValue' fields, flattening them\n// to just their values, as a string:\n// {\n//   'myInt': '123',\n//   'myDouble': '1.0',\n//   'myFloat': '1.1',\n//   'myString': 'hi!'\n// }\n//\n// Note that while 'intValue' will have a quoted payload, 'doubleValue' and 'floatValue' will not. This\n// is due to the encoding library, which renders int64 values as strings to avoid loss of precision. This\n// method always returns a string, similarly to avoid loss of precision, unlike the less-conservative\n// 'unwrapValue' method just below.\n/** @hidden */\nfunction unwrapValueAsString(wrapped) {\n    const key = _.keys(wrapped)[0];\n    return _.toString(wrapped[key]);\n}\n// Ditto as the method above, but returning the values in the idiomatic JavaScript type (string for strings,\n// number for numbers):\n// {\n//   'myInt': 123,\n//   'myDouble': 1.0,\n//   'myFloat': 1.1,\n//   'myString': 'hi!'\n// }\n//\n// The field names in the incoming xValue fields identify the type a value has, which for JavaScript's\n// purposes can be divided into 'number' versus 'string'. This method will render all the numbers as\n// JavaScript's 'number' type, since we prefer using idiomatic types. Note that this may lead to loss\n// in precision for int64 fields, so use with care.\n/** @hidden */\nconst xValueNumberFields = ['intValue', 'floatValue', 'doubleValue'];\n/** @hidden */\nfunction unwrapValue(wrapped) {\n    const key = _.keys(wrapped)[0];\n    const value = unwrapValueAsString(wrapped);\n    return _.includes(xValueNumberFields, key) ? _.toNumber(value) : value;\n}\n// The JSON payload delivers timestamp fields as strings of timestamps denoted in microseconds.\n// The JavaScript convention is to use numbers denoted in milliseconds. This method\n// makes it easy to convert a field of one type into the other.\n/** @hidden */\nfunction copyTimestampToMillis(from, to, fromName, toName) {\n    if (from[fromName] !== undefined) {\n        to[toName] = _.round(from[fromName] / 1000);\n    }\n}\n// The JSON payload delivers timestamp fields as strings of timestamps denoted in microseconds.\n// In our SDK, we'd like to present timestamp as ISO-format strings. This method makes it easy\n// to convert a field of one type into the other.\n/** @hidden */\nfunction copyTimestampToString(from, to, fromName, toName) {\n    if (from[fromName] !== undefined) {\n        to[toName] = new Date(from[fromName] / 1000).toISOString();\n    }\n}\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-functions/lib/providers/analytics.js?");

/***/ }),

/***/ "./src/node_modules/firebase-functions/lib/providers/auth.js":
/*!*******************************************************************!*\
  !*** ./src/node_modules/firebase-functions/lib/providers/auth.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// The MIT License (MIT)\n//\n// Copyright (c) 2017 Firebase\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.userRecordConstructor = exports.UserBuilder = exports.UserRecordMetadata = exports._userWithOptions = exports.user = exports.service = exports.provider = void 0;\nconst _ = __webpack_require__(/*! lodash */ \"lodash\");\nconst cloud_functions_1 = __webpack_require__(/*! ../cloud-functions */ \"./src/node_modules/firebase-functions/lib/cloud-functions.js\");\n/** @hidden */\nexports.provider = 'google.firebase.auth';\n/** @hidden */\nexports.service = 'firebaseauth.googleapis.com';\n/**\n * Handle events related to Firebase authentication users.\n */\nfunction user() {\n    return _userWithOptions({});\n}\nexports.user = user;\n/** @hidden */\nfunction _userWithOptions(options) {\n    return new UserBuilder(() => {\n        if (!process.env.GCLOUD_PROJECT) {\n            throw new Error('process.env.GCLOUD_PROJECT is not set.');\n        }\n        return 'projects/' + process.env.GCLOUD_PROJECT;\n    }, options);\n}\nexports._userWithOptions = _userWithOptions;\nclass UserRecordMetadata {\n    constructor(creationTime, lastSignInTime) {\n        this.creationTime = creationTime;\n        this.lastSignInTime = lastSignInTime;\n    }\n    /** Returns a plain JavaScript object with the properties of UserRecordMetadata. */\n    toJSON() {\n        return {\n            creationTime: this.creationTime,\n            lastSignInTime: this.lastSignInTime,\n        };\n    }\n}\nexports.UserRecordMetadata = UserRecordMetadata;\n/** Builder used to create Cloud Functions for Firebase Auth user lifecycle events. */\nclass UserBuilder {\n    /** @hidden */\n    constructor(triggerResource, options) {\n        this.triggerResource = triggerResource;\n        this.options = options;\n    }\n    static dataConstructor(raw) {\n        return userRecordConstructor(raw.data);\n    }\n    /** Respond to the creation of a Firebase Auth user. */\n    onCreate(handler) {\n        return this.onOperation(handler, 'user.create');\n    }\n    /** Respond to the deletion of a Firebase Auth user. */\n    onDelete(handler) {\n        return this.onOperation(handler, 'user.delete');\n    }\n    onOperation(handler, eventType) {\n        return cloud_functions_1.makeCloudFunction({\n            handler,\n            provider: exports.provider,\n            eventType,\n            service: exports.service,\n            triggerResource: this.triggerResource,\n            dataConstructor: UserBuilder.dataConstructor,\n            legacyEventType: `providers/firebase.auth/eventTypes/${eventType}`,\n            options: this.options,\n        });\n    }\n}\nexports.UserBuilder = UserBuilder;\nfunction userRecordConstructor(wireData) {\n    // Falsey values from the wire format proto get lost when converted to JSON, this adds them back.\n    const falseyValues = {\n        email: null,\n        emailVerified: false,\n        displayName: null,\n        photoURL: null,\n        phoneNumber: null,\n        disabled: false,\n        providerData: [],\n        customClaims: {},\n        passwordSalt: null,\n        passwordHash: null,\n        tokensValidAfterTime: null,\n    };\n    const record = _.assign({}, falseyValues, wireData);\n    const meta = _.get(record, 'metadata');\n    if (meta) {\n        _.set(record, 'metadata', new UserRecordMetadata(meta.createdAt || meta.creationTime, meta.lastSignedInAt || meta.lastSignInTime));\n    }\n    else {\n        _.set(record, 'metadata', new UserRecordMetadata(null, null));\n    }\n    _.forEach(record.providerData, (entry) => {\n        _.set(entry, 'toJSON', () => {\n            return entry;\n        });\n    });\n    _.set(record, 'toJSON', () => {\n        const json = _.pick(record, [\n            'uid',\n            'email',\n            'emailVerified',\n            'displayName',\n            'photoURL',\n            'phoneNumber',\n            'disabled',\n            'passwordHash',\n            'passwordSalt',\n            'tokensValidAfterTime',\n        ]);\n        json.metadata = _.get(record, 'metadata').toJSON();\n        json.customClaims = _.cloneDeep(record.customClaims);\n        json.providerData = _.map(record.providerData, (entry) => entry.toJSON());\n        return json;\n    });\n    return record;\n}\nexports.userRecordConstructor = userRecordConstructor;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-functions/lib/providers/auth.js?");

/***/ }),

/***/ "./src/node_modules/firebase-functions/lib/providers/database.js":
/*!***********************************************************************!*\
  !*** ./src/node_modules/firebase-functions/lib/providers/database.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// The MIT License (MIT)\n//\n// Copyright (c) 2017 Firebase\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DataSnapshot = exports.extractInstanceAndPath = exports.RefBuilder = exports._refWithOptions = exports.InstanceBuilder = exports._instanceWithOptions = exports.ref = exports.instance = exports.service = exports.provider = void 0;\nconst _ = __webpack_require__(/*! lodash */ \"lodash\");\nconst apps_1 = __webpack_require__(/*! ../apps */ \"./src/node_modules/firebase-functions/lib/apps.js\");\nconst cloud_functions_1 = __webpack_require__(/*! ../cloud-functions */ \"./src/node_modules/firebase-functions/lib/cloud-functions.js\");\nconst config_1 = __webpack_require__(/*! ../config */ \"./src/node_modules/firebase-functions/lib/config.js\");\nconst path_1 = __webpack_require__(/*! ../utilities/path */ \"./src/node_modules/firebase-functions/lib/utilities/path.js\");\nconst utils_1 = __webpack_require__(/*! ../utils */ \"./src/node_modules/firebase-functions/lib/utils.js\");\n/** @hidden */\nexports.provider = 'google.firebase.database';\n/** @hidden */\nexports.service = 'firebaseio.com';\nconst databaseURLRegex = new RegExp('^https://([^.]+).');\nconst emulatorDatabaseURLRegex = new RegExp('^http://.*ns=([^&]+)');\n/**\n * Registers a function that triggers on events from a specific\n * Firebase Realtime Database instance.\n *\n * Use this method together with `ref` to specify the instance on which to\n * watch for database events. For example: `firebase.database.instance('my-app-db-2').ref('/foo/bar')`\n *\n * Note that `functions.database.ref` used without `instance` watches the\n * *default* instance for events.\n *\n * @param instance The instance name of the database instance\n *   to watch for write events.\n * @return Firebase Realtime Database instance builder interface.\n */\nfunction instance(instance) {\n    return _instanceWithOptions(instance, {});\n}\nexports.instance = instance;\n/**\n * Registers a function that triggers on Firebase Realtime Database write\n * events.\n *\n * This method behaves very similarly to the method of the same name in the\n * client and Admin Firebase SDKs. Any change to the Database that affects the\n * data at or below the provided `path` will fire an event in Cloud Functions.\n *\n * There are three important differences between listening to a Realtime\n * Database event in Cloud Functions and using the Realtime Database in the\n * client and Admin SDKs:\n * 1. Cloud Functions allows wildcards in the `path` name. Any `path` component\n *    in curly brackets (`{}`) is a wildcard that matches all strings. The value\n *    that matched a certain invocation of a Cloud Function is returned as part\n *    of the [`EventContext.params`](cloud_functions_eventcontext.html#params object. For\n *    example, `ref(\"messages/{messageId}\")` matches changes at\n *    `/messages/message1` or `/messages/message2`, resulting in\n *    `event.params.messageId` being set to `\"message1\"` or `\"message2\"`,\n *    respectively.\n * 2. Cloud Functions do not fire an event for data that already existed before\n *    the Cloud Function was deployed.\n * 3. Cloud Function events have access to more information, including a\n *    snapshot of the previous event data and information about the user who\n *    triggered the Cloud Function.\n *\n * @param path The path within the Database to watch for write events.\n * @return Firebase Realtime Database builder interface.\n */\nfunction ref(path) {\n    return _refWithOptions(path, {});\n}\nexports.ref = ref;\n/** @hidden */\nfunction _instanceWithOptions(instance, options) {\n    return new InstanceBuilder(instance, options);\n}\nexports._instanceWithOptions = _instanceWithOptions;\n/**\n * The Firebase Realtime Database instance builder interface.\n *\n * Access via [`database.instance()`](providers_database_.html#instance).\n */\nclass InstanceBuilder {\n    /** @hidden */\n    constructor(instance, options) {\n        this.instance = instance;\n        this.options = options;\n    }\n    /**\n     * @return Firebase Realtime Database reference builder interface.\n     */\n    ref(path) {\n        const normalized = path_1.normalizePath(path);\n        return new RefBuilder(apps_1.apps(), () => `projects/_/instances/${this.instance}/refs/${normalized}`, this.options);\n    }\n}\nexports.InstanceBuilder = InstanceBuilder;\n/** @hidden */\nfunction _refWithOptions(path, options) {\n    const resourceGetter = () => {\n        const normalized = path_1.normalizePath(path);\n        const databaseURL = config_1.firebaseConfig().databaseURL;\n        if (!databaseURL) {\n            throw new Error('Missing expected firebase config value databaseURL, ' +\n                'config is actually' +\n                JSON.stringify(config_1.firebaseConfig()) +\n                '\\n If you are unit testing, please set process.env.FIREBASE_CONFIG');\n        }\n        let instance;\n        const prodMatch = databaseURL.match(databaseURLRegex);\n        if (prodMatch) {\n            instance = prodMatch[1];\n        }\n        else {\n            const emulatorMatch = databaseURL.match(emulatorDatabaseURLRegex);\n            if (emulatorMatch) {\n                instance = emulatorMatch[1];\n            }\n        }\n        if (!instance) {\n            throw new Error('Invalid value for config firebase.databaseURL: ' + databaseURL);\n        }\n        return `projects/_/instances/${instance}/refs/${normalized}`;\n    };\n    return new RefBuilder(apps_1.apps(), resourceGetter, options);\n}\nexports._refWithOptions = _refWithOptions;\n/**\n * The Firebase Realtime Database reference builder interface.\n *\n * Access via [`functions.database.ref()`](functions.database#.ref).\n */\nclass RefBuilder {\n    /** @hidden */\n    constructor(apps, triggerResource, options) {\n        this.apps = apps;\n        this.triggerResource = triggerResource;\n        this.options = options;\n        this.changeConstructor = (raw) => {\n            const [dbInstance, path] = extractInstanceAndPath(raw.context.resource.name, raw.context.domain);\n            const before = new DataSnapshot(raw.data.data, path, this.apps.admin, dbInstance);\n            const after = new DataSnapshot(utils_1.applyChange(raw.data.data, raw.data.delta), path, this.apps.admin, dbInstance);\n            return {\n                before,\n                after,\n            };\n        };\n    }\n    /**\n     * Event handler that fires every time a Firebase Realtime Database write\n     * of any kind (creation, update, or delete) occurs.\n     *\n     * @param handler Event handler that runs every time a Firebase Realtime Database\n     *   write occurs.\n     * @return A Cloud Function that you can export and deploy.\n     */\n    onWrite(handler) {\n        return this.onOperation(handler, 'ref.write', this.changeConstructor);\n    }\n    /**\n     * Event handler that fires every time data is updated in\n     * Firebase Realtime Database.\n     *\n     * @param handler Event handler which is run every time a Firebase Realtime Database\n     *   write occurs.\n     * @return A Cloud\n     *   Function which you can export and deploy.\n     */\n    onUpdate(handler) {\n        return this.onOperation(handler, 'ref.update', this.changeConstructor);\n    }\n    /**\n     * Event handler that fires every time new data is created in\n     * Firebase Realtime Database.\n     *\n     * @param handler Event handler that runs every time new data is created in\n     *   Firebase Realtime Database.\n     * @return A Cloud Function that you can export and deploy.\n     */\n    onCreate(handler) {\n        const dataConstructor = (raw) => {\n            const [dbInstance, path] = extractInstanceAndPath(raw.context.resource.name, raw.context.domain);\n            return new DataSnapshot(raw.data.delta, path, this.apps.admin, dbInstance);\n        };\n        return this.onOperation(handler, 'ref.create', dataConstructor);\n    }\n    /**\n     * Event handler that fires every time data is deleted from\n     * Firebase Realtime Database.\n     *\n     * @param handler Event handler that runs every time data is deleted from\n     *   Firebase Realtime Database.\n     * @return A Cloud Function that you can export and deploy.\n     */\n    onDelete(handler) {\n        const dataConstructor = (raw) => {\n            const [dbInstance, path] = extractInstanceAndPath(raw.context.resource.name, raw.context.domain);\n            return new DataSnapshot(raw.data.data, path, this.apps.admin, dbInstance);\n        };\n        return this.onOperation(handler, 'ref.delete', dataConstructor);\n    }\n    onOperation(handler, eventType, dataConstructor) {\n        return cloud_functions_1.makeCloudFunction({\n            handler,\n            provider: exports.provider,\n            service: exports.service,\n            eventType,\n            legacyEventType: `providers/${exports.provider}/eventTypes/${eventType}`,\n            triggerResource: this.triggerResource,\n            dataConstructor,\n            before: (event) => this.apps.retain(),\n            after: (event) => this.apps.release(),\n            options: this.options,\n        });\n    }\n}\nexports.RefBuilder = RefBuilder;\n/**\n * Utility function to extract database reference from resource string\n *\n * @param optional database domain override for the original of the source database.\n *    It defaults to `firebaseio.com`.\n *    Multi-region RTDB will be served from different domains.\n *    Since region is not part of the resource name, it is provided through context.\n */\n/** @hidden */\nfunction extractInstanceAndPath(resource, domain = 'firebaseio.com') {\n    const resourceRegex = `projects/([^/]+)/instances/([a-zA-Z0-9\\-^/]+)/refs(/.+)?`;\n    const match = resource.match(new RegExp(resourceRegex));\n    if (!match) {\n        throw new Error(`Unexpected resource string for Firebase Realtime Database event: ${resource}. ` +\n            'Expected string in the format of \"projects/_/instances/{firebaseioSubdomain}/refs/{ref=**}\"');\n    }\n    const [, project, dbInstanceName, path] = match;\n    if (project !== '_') {\n        throw new Error(`Expect project to be '_' in a Firebase Realtime Database event`);\n    }\n    const emuHost = process.env.FIREBASE_DATABASE_EMULATOR_HOST;\n    if (emuHost) {\n        const dbInstance = `http://${emuHost}/?ns=${dbInstanceName}`;\n        return [dbInstance, path];\n    }\n    else {\n        const dbInstance = 'https://' + dbInstanceName + '.' + domain;\n        return [dbInstance, path];\n    }\n}\nexports.extractInstanceAndPath = extractInstanceAndPath;\n/**\n * Interface representing a Firebase Realtime Database data snapshot.\n */\nclass DataSnapshot {\n    constructor(data, path, // path will be undefined for the database root\n    app, instance) {\n        this.app = app;\n        if (app && app.options.databaseURL.startsWith('http:')) {\n            // In this case we're dealing with an emulator\n            this.instance = app.options.databaseURL;\n        }\n        else if (instance) {\n            // SDK always supplies instance, but user's unit tests may not\n            this.instance = instance;\n        }\n        else if (app) {\n            this.instance = app.options.databaseURL;\n        }\n        else if (process.env.GCLOUD_PROJECT) {\n            this.instance =\n                'https://' + process.env.GCLOUD_PROJECT + '.firebaseio.com';\n        }\n        this._path = path;\n        this._data = data;\n    }\n    /**\n     * Returns a [`Reference`](/docs/reference/admin/node/admin.database.Reference)\n     * to the Database location where the triggering write occurred. Has\n     * full read and write access.\n     */\n    get ref() {\n        if (!this.app) {\n            // may be unpopulated in user's unit tests\n            throw new Error('Please supply a Firebase app in the constructor for DataSnapshot' +\n                ' in order to use the .ref method.');\n        }\n        if (!this._ref) {\n            this._ref = this.app.database(this.instance).ref(this._fullPath());\n        }\n        return this._ref;\n    }\n    /**\n     * The key (last part of the path) of the location of this `DataSnapshot`.\n     *\n     * The last token in a Database location is considered its key. For example,\n     * \"ada\" is the key for the `/users/ada/` node. Accessing the key on any\n     * `DataSnapshot` will return the key for the location that generated it.\n     * However, accessing the key on the root URL of a Database will return `null`.\n     */\n    get key() {\n        const last = _.last(path_1.pathParts(this._fullPath()));\n        return !last || last === '' ? null : last;\n    }\n    /**\n     * Extracts a JavaScript value from a `DataSnapshot`.\n     *\n     * Depending on the data in a `DataSnapshot`, the `val()` method may return a\n     * scalar type (string, number, or boolean), an array, or an object. It may also\n     * return `null`, indicating that the `DataSnapshot` is empty (contains no\n     * data).\n     *\n     * @return The DataSnapshot's contents as a JavaScript value (Object,\n     *   Array, string, number, boolean, or `null`).\n     */\n    val() {\n        const parts = path_1.pathParts(this._childPath);\n        const source = this._data;\n        const node = _.cloneDeep(parts.length ? _.get(source, parts, null) : source);\n        return this._checkAndConvertToArray(node);\n    }\n    /**\n     * Exports the entire contents of the `DataSnapshot` as a JavaScript object.\n     *\n     * The `exportVal()` method is similar to `val()`, except priority information\n     * is included (if available), making it suitable for backing up your data.\n     *\n     * @return The contents of the `DataSnapshot` as a JavaScript value\n     *   (Object, Array, string, number, boolean, or `null`).\n     */\n    exportVal() {\n        return this.val();\n    }\n    /**\n     * Gets the priority value of the data in this `DataSnapshot`.\n     *\n     * As an alternative to using priority, applications can order collections by\n     * ordinary properties. See [Sorting and filtering\n     * data](/docs/database/web/lists-of-data#sorting_and_filtering_data).\n     *\n     * @return The priority value of the data.\n     */\n    getPriority() {\n        return 0;\n    }\n    /**\n     * Returns `true` if this `DataSnapshot` contains any data. It is slightly more\n     * efficient than using `snapshot.val() !== null`.\n     *\n     * @return `true` if this `DataSnapshot` contains any data; otherwise, `false`.\n     */\n    exists() {\n        return !_.isNull(this.val());\n    }\n    /**\n     * Gets a `DataSnapshot` for the location at the specified relative path.\n     *\n     * The relative path can either be a simple child name (for example, \"ada\") or\n     * a deeper slash-separated path (for example, \"ada/name/first\").\n     *\n     * @param path A relative path from this location to the desired child\n     *   location.\n     * @return The specified child location.\n     */\n    child(childPath) {\n        if (!childPath) {\n            return this;\n        }\n        return this._dup(childPath);\n    }\n    /**\n     * Enumerates the `DataSnapshot`s of the children items.\n     *\n     * Because of the way JavaScript objects work, the ordering of data in the\n     * JavaScript object returned by `val()` is not guaranteed to match the ordering\n     * on the server nor the ordering of `child_added` events. That is where\n     * `forEach()` comes in handy. It guarantees the children of a `DataSnapshot`\n     * will be iterated in their query order.\n     *\n     * If no explicit `orderBy*()` method is used, results are returned\n     * ordered by key (unless priorities are used, in which case, results are\n     * returned by priority).\n     *\n     * @param action A function that will be called for each child `DataSnapshot`.\n     *   The callback can return `true` to cancel further enumeration.\n     *\n     * @return `true` if enumeration was canceled due to your callback\n     *   returning `true`.\n     */\n    forEach(action) {\n        const val = this.val();\n        if (_.isPlainObject(val)) {\n            return _.some(val, (value, key) => action(this.child(key)) === true);\n        }\n        return false;\n    }\n    /**\n     * Returns `true` if the specified child path has (non-`null`) data.\n     *\n     * @param path A relative path to the location of a potential child.\n     * @return `true` if data exists at the specified child path; otherwise,\n     *   `false`.\n     */\n    hasChild(childPath) {\n        return this.child(childPath).exists();\n    }\n    /**\n     * Returns whether or not the `DataSnapshot` has any non-`null` child\n     * properties.\n     *\n     * You can use `hasChildren()` to determine if a `DataSnapshot` has any\n     * children. If it does, you can enumerate them using `forEach()`. If it\n     * doesn't, then either this snapshot contains a primitive value (which can be\n     * retrieved with `val()`) or it is empty (in which case, `val()` will return\n     * `null`).\n     *\n     * @return `true` if this snapshot has any children; else `false`.\n     */\n    hasChildren() {\n        const val = this.val();\n        return _.isPlainObject(val) && _.keys(val).length > 0;\n    }\n    /**\n     * Returns the number of child properties of this `DataSnapshot`.\n     *\n     * @return Number of child properties of this `DataSnapshot`.\n     */\n    numChildren() {\n        const val = this.val();\n        return _.isPlainObject(val) ? Object.keys(val).length : 0;\n    }\n    /**\n     * Returns a JSON-serializable representation of this object.\n     *\n     * @return A JSON-serializable representation of this object.\n     */\n    toJSON() {\n        return this.val();\n    }\n    /** Recursive function to check if keys are numeric & convert node object to array if they are\n     *\n     * @hidden\n     */\n    _checkAndConvertToArray(node) {\n        if (node === null || typeof node === 'undefined') {\n            return null;\n        }\n        if (typeof node !== 'object') {\n            return node;\n        }\n        const obj = {};\n        let numKeys = 0;\n        let maxKey = 0;\n        let allIntegerKeys = true;\n        for (const key in node) {\n            if (!node.hasOwnProperty(key)) {\n                continue;\n            }\n            const childNode = node[key];\n            obj[key] = this._checkAndConvertToArray(childNode);\n            numKeys++;\n            const integerRegExp = /^(0|[1-9]\\d*)$/;\n            if (allIntegerKeys && integerRegExp.test(key)) {\n                maxKey = Math.max(maxKey, Number(key));\n            }\n            else {\n                allIntegerKeys = false;\n            }\n        }\n        if (allIntegerKeys && maxKey < 2 * numKeys) {\n            // convert to array.\n            const array = [];\n            _.forOwn(obj, (val, key) => {\n                array[key] = val;\n            });\n            return array;\n        }\n        return obj;\n    }\n    /** @hidden */\n    _dup(childPath) {\n        const dup = new DataSnapshot(this._data, undefined, this.app, this.instance);\n        [dup._path, dup._childPath] = [this._path, this._childPath];\n        if (childPath) {\n            dup._childPath = path_1.joinPath(dup._childPath, childPath);\n        }\n        return dup;\n    }\n    /** @hidden */\n    _fullPath() {\n        const out = (this._path || '') + '/' + (this._childPath || '');\n        return out;\n    }\n}\nexports.DataSnapshot = DataSnapshot;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-functions/lib/providers/database.js?");

/***/ }),

/***/ "./src/node_modules/firebase-functions/lib/providers/firestore.js":
/*!************************************************************************!*\
  !*** ./src/node_modules/firebase-functions/lib/providers/firestore.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// The MIT License (MIT)\n//\n// Copyright (c) 2017 Firebase\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DocumentBuilder = exports.beforeSnapshotConstructor = exports.snapshotConstructor = exports.NamespaceBuilder = exports.DatabaseBuilder = exports._documentWithOptions = exports._namespaceWithOptions = exports._databaseWithOptions = exports.database = exports.namespace = exports.document = exports.defaultDatabase = exports.service = exports.provider = void 0;\nconst firebase = __webpack_require__(/*! firebase-admin */ \"./src/node_modules/firebase-admin/lib/index.js\");\nconst _ = __webpack_require__(/*! lodash */ \"lodash\");\nconst path_1 = __webpack_require__(/*! path */ \"path\");\nconst apps_1 = __webpack_require__(/*! ../apps */ \"./src/node_modules/firebase-functions/lib/apps.js\");\nconst cloud_functions_1 = __webpack_require__(/*! ../cloud-functions */ \"./src/node_modules/firebase-functions/lib/cloud-functions.js\");\nconst encoder_1 = __webpack_require__(/*! ../encoder */ \"./src/node_modules/firebase-functions/lib/encoder.js\");\n/** @hidden */\nexports.provider = 'google.firestore';\n/** @hidden */\nexports.service = 'firestore.googleapis.com';\n/** @hidden */\nexports.defaultDatabase = '(default)';\nlet firestoreInstance;\n/**\n * Select the Firestore document to listen to for events.\n * @param path Full database path to listen to. This includes the name of\n * the collection that the document is a part of. For example, if the\n * collection is named \"users\" and the document is named \"Ada\", then the\n * path is \"/users/Ada\".\n */\nfunction document(path) {\n    return _documentWithOptions(path, {});\n}\nexports.document = document;\n/** @hidden */\n// Multiple namespaces are not yet supported by Firestore.\nfunction namespace(namespace) {\n    return _namespaceWithOptions(namespace, {});\n}\nexports.namespace = namespace;\n/** @hidden */\n// Multiple databases are not yet supported by Firestore.\nfunction database(database) {\n    return _databaseWithOptions(database, {});\n}\nexports.database = database;\n/** @hidden */\nfunction _databaseWithOptions(database = exports.defaultDatabase, options) {\n    return new DatabaseBuilder(database, options);\n}\nexports._databaseWithOptions = _databaseWithOptions;\n/** @hidden */\nfunction _namespaceWithOptions(namespace, options) {\n    return _databaseWithOptions(exports.defaultDatabase, options).namespace(namespace);\n}\nexports._namespaceWithOptions = _namespaceWithOptions;\n/** @hidden */\nfunction _documentWithOptions(path, options) {\n    return _databaseWithOptions(exports.defaultDatabase, options).document(path);\n}\nexports._documentWithOptions = _documentWithOptions;\nclass DatabaseBuilder {\n    /** @hidden */\n    constructor(database, options) {\n        this.database = database;\n        this.options = options;\n    }\n    namespace(namespace) {\n        return new NamespaceBuilder(this.database, this.options, namespace);\n    }\n    document(path) {\n        return new NamespaceBuilder(this.database, this.options).document(path);\n    }\n}\nexports.DatabaseBuilder = DatabaseBuilder;\nclass NamespaceBuilder {\n    /** @hidden */\n    constructor(database, options, namespace) {\n        this.database = database;\n        this.options = options;\n        this.namespace = namespace;\n    }\n    document(path) {\n        return new DocumentBuilder(() => {\n            if (!process.env.GCLOUD_PROJECT) {\n                throw new Error('process.env.GCLOUD_PROJECT is not set.');\n            }\n            const database = path_1.posix.join('projects', process.env.GCLOUD_PROJECT, 'databases', this.database);\n            return path_1.posix.join(database, this.namespace ? `documents@${this.namespace}` : 'documents', path);\n        }, this.options);\n    }\n}\nexports.NamespaceBuilder = NamespaceBuilder;\nfunction _getValueProto(data, resource, valueFieldName) {\n    if (_.isEmpty(_.get(data, valueFieldName))) {\n        // Firestore#snapshot_ takes resource string instead of proto for a non-existent snapshot\n        return resource;\n    }\n    const proto = {\n        fields: _.get(data, [valueFieldName, 'fields'], {}),\n        createTime: encoder_1.dateToTimestampProto(_.get(data, [valueFieldName, 'createTime'])),\n        updateTime: encoder_1.dateToTimestampProto(_.get(data, [valueFieldName, 'updateTime'])),\n        name: _.get(data, [valueFieldName, 'name'], resource),\n    };\n    return proto;\n}\n/** @hidden */\nfunction snapshotConstructor(event) {\n    if (!firestoreInstance) {\n        firestoreInstance = firebase.firestore(apps_1.apps().admin);\n    }\n    const valueProto = _getValueProto(event.data, event.context.resource.name, 'value');\n    const readTime = encoder_1.dateToTimestampProto(_.get(event, 'data.value.readTime'));\n    return firestoreInstance.snapshot_(valueProto, readTime, 'json');\n}\nexports.snapshotConstructor = snapshotConstructor;\n/** @hidden */\n// TODO remove this function when wire format changes to new format\nfunction beforeSnapshotConstructor(event) {\n    if (!firestoreInstance) {\n        firestoreInstance = firebase.firestore(apps_1.apps().admin);\n    }\n    const oldValueProto = _getValueProto(event.data, event.context.resource.name, 'oldValue');\n    const oldReadTime = encoder_1.dateToTimestampProto(_.get(event, 'data.oldValue.readTime'));\n    return firestoreInstance.snapshot_(oldValueProto, oldReadTime, 'json');\n}\nexports.beforeSnapshotConstructor = beforeSnapshotConstructor;\nfunction changeConstructor(raw) {\n    return cloud_functions_1.Change.fromObjects(beforeSnapshotConstructor(raw), snapshotConstructor(raw));\n}\nclass DocumentBuilder {\n    /** @hidden */\n    constructor(triggerResource, options) {\n        this.triggerResource = triggerResource;\n        this.options = options;\n        // TODO what validation do we want to do here?\n    }\n    /** Respond to all document writes (creates, updates, or deletes). */\n    onWrite(handler) {\n        return this.onOperation(handler, 'document.write', changeConstructor);\n    }\n    /** Respond only to document updates. */\n    onUpdate(handler) {\n        return this.onOperation(handler, 'document.update', changeConstructor);\n    }\n    /** Respond only to document creations. */\n    onCreate(handler) {\n        return this.onOperation(handler, 'document.create', snapshotConstructor);\n    }\n    /** Respond only to document deletions. */\n    onDelete(handler) {\n        return this.onOperation(handler, 'document.delete', beforeSnapshotConstructor);\n    }\n    onOperation(handler, eventType, dataConstructor) {\n        return cloud_functions_1.makeCloudFunction({\n            handler,\n            provider: exports.provider,\n            eventType,\n            service: exports.service,\n            triggerResource: this.triggerResource,\n            legacyEventType: `providers/cloud.firestore/eventTypes/${eventType}`,\n            dataConstructor,\n            options: this.options,\n        });\n    }\n}\nexports.DocumentBuilder = DocumentBuilder;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-functions/lib/providers/firestore.js?");

/***/ }),

/***/ "./src/node_modules/firebase-functions/lib/providers/https.js":
/*!********************************************************************!*\
  !*** ./src/node_modules/firebase-functions/lib/providers/https.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// The MIT License (MIT)\n//\n// Copyright (c) 2017 Firebase\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports._onCallWithOptions = exports.decode = exports.encode = exports.HttpsError = exports._onRequestWithOptions = exports.onCall = exports.onRequest = void 0;\nconst cors = __webpack_require__(/*! cors */ \"cors\");\nconst _ = __webpack_require__(/*! lodash */ \"lodash\");\nconst apps_1 = __webpack_require__(/*! ../apps */ \"./src/node_modules/firebase-functions/lib/apps.js\");\nconst cloud_functions_1 = __webpack_require__(/*! ../cloud-functions */ \"./src/node_modules/firebase-functions/lib/cloud-functions.js\");\nconst logger_1 = __webpack_require__(/*! ../logger */ \"./src/node_modules/firebase-functions/lib/logger.js\");\n/**\n * Handle HTTP requests.\n * @param handler A function that takes a request and response object,\n * same signature as an Express app.\n */\nfunction onRequest(handler) {\n    return _onRequestWithOptions(handler, {});\n}\nexports.onRequest = onRequest;\n/**\n * Declares a callable method for clients to call using a Firebase SDK.\n * @param handler A method that takes a data and context and returns a value.\n */\nfunction onCall(handler) {\n    return _onCallWithOptions(handler, {});\n}\nexports.onCall = onCall;\n/** @hidden */\nfunction _onRequestWithOptions(handler, options) {\n    // lets us add __trigger without altering handler:\n    const cloudFunction = (req, res) => {\n        return handler(req, res);\n    };\n    cloudFunction.__trigger = _.assign(cloud_functions_1.optionsToTrigger(options), {\n        httpsTrigger: {},\n    });\n    // TODO parse the options\n    return cloudFunction;\n}\nexports._onRequestWithOptions = _onRequestWithOptions;\n/**\n * Standard error codes and HTTP statuses for different ways a request can fail,\n * as defined by:\n * https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto\n *\n * This map is used primarily to convert from a client error code string to\n * to the HTTP format error code string and status, and make sure it's in the\n * supported set.\n */\nconst errorCodeMap = {\n    ok: { canonicalName: 'OK', status: 200 },\n    cancelled: { canonicalName: 'CANCELLED', status: 499 },\n    unknown: { canonicalName: 'UNKNOWN', status: 500 },\n    'invalid-argument': { canonicalName: 'INVALID_ARGUMENT', status: 400 },\n    'deadline-exceeded': { canonicalName: 'DEADLINE_EXCEEDED', status: 504 },\n    'not-found': { canonicalName: 'NOT_FOUND', status: 404 },\n    'already-exists': { canonicalName: 'ALREADY_EXISTS', status: 409 },\n    'permission-denied': { canonicalName: 'PERMISSION_DENIED', status: 403 },\n    unauthenticated: { canonicalName: 'UNAUTHENTICATED', status: 401 },\n    'resource-exhausted': { canonicalName: 'RESOURCE_EXHAUSTED', status: 429 },\n    'failed-precondition': { canonicalName: 'FAILED_PRECONDITION', status: 400 },\n    aborted: { canonicalName: 'ABORTED', status: 409 },\n    'out-of-range': { canonicalName: 'OUT_OF_RANGE', status: 400 },\n    unimplemented: { canonicalName: 'UNIMPLEMENTED', status: 501 },\n    internal: { canonicalName: 'INTERNAL', status: 500 },\n    unavailable: { canonicalName: 'UNAVAILABLE', status: 503 },\n    'data-loss': { canonicalName: 'DATA_LOSS', status: 500 },\n};\n/**\n * An explicit error that can be thrown from a handler to send an error to the\n * client that called the function.\n */\nclass HttpsError extends Error {\n    constructor(code, message, details) {\n        super(message);\n        // A sanity check for non-TypeScript consumers.\n        if (code in errorCodeMap === false) {\n            throw new Error(`Unknown error code: ${code}.`);\n        }\n        this.code = code;\n        this.details = details;\n        this.httpErrorCode = errorCodeMap[code];\n    }\n    /** @hidden */\n    toJSON() {\n        const { details, httpErrorCode: { canonicalName: status }, message, } = this;\n        return {\n            ...(details === undefined ? {} : { details }),\n            message,\n            status,\n        };\n    }\n}\nexports.HttpsError = HttpsError;\n/** @hidden */\n// Returns true if req is a properly formatted callable request.\nfunction isValidRequest(req) {\n    // The body must not be empty.\n    if (!req.body) {\n        logger_1.warn('Request is missing body.');\n        return false;\n    }\n    // Make sure it's a POST.\n    if (req.method !== 'POST') {\n        logger_1.warn('Request has invalid method.', req.method);\n        return false;\n    }\n    // Check that the Content-Type is JSON.\n    let contentType = (req.header('Content-Type') || '').toLowerCase();\n    // If it has a charset, just ignore it for now.\n    const semiColon = contentType.indexOf(';');\n    if (semiColon >= 0) {\n        contentType = contentType.substr(0, semiColon).trim();\n    }\n    if (contentType !== 'application/json') {\n        logger_1.warn('Request has incorrect Content-Type.', contentType);\n        return false;\n    }\n    // The body must have data.\n    if (_.isUndefined(req.body.data)) {\n        logger_1.warn('Request body is missing data.', req.body);\n        return false;\n    }\n    // TODO(klimt): Allow only whitelisted http headers.\n    // Verify that the body does not have any extra fields.\n    const extras = _.omit(req.body, 'data');\n    if (!_.isEmpty(extras)) {\n        logger_1.warn('Request body has extra fields.', extras);\n        return false;\n    }\n    return true;\n}\n/** @hidden */\nconst LONG_TYPE = 'type.googleapis.com/google.protobuf.Int64Value';\n/** @hidden */\nconst UNSIGNED_LONG_TYPE = 'type.googleapis.com/google.protobuf.UInt64Value';\n/**\n * Encodes arbitrary data in our special format for JSON.\n * This is exposed only for testing.\n */\n/** @hidden */\nfunction encode(data) {\n    if (_.isNull(data) || _.isUndefined(data)) {\n        return null;\n    }\n    // Oddly, _.isFinite(new Number(x)) always returns false, so unwrap Numbers.\n    if (data instanceof Number) {\n        data = data.valueOf();\n    }\n    if (_.isFinite(data)) {\n        // Any number in JS is safe to put directly in JSON and parse as a double\n        // without any loss of precision.\n        return data;\n    }\n    if (_.isBoolean(data)) {\n        return data;\n    }\n    if (_.isString(data)) {\n        return data;\n    }\n    if (_.isArray(data)) {\n        return _.map(data, encode);\n    }\n    if (_.isObject(data)) {\n        // It's not safe to use _.forEach, because the object might be 'array-like'\n        // if it has a key called 'length'. Note that this intentionally overrides\n        // any toJSON method that an object may have.\n        return _.mapValues(data, encode);\n    }\n    // If we got this far, the data is not encodable.\n    logger_1.error('Data cannot be encoded in JSON.', data);\n    throw new Error('Data cannot be encoded in JSON: ' + data);\n}\nexports.encode = encode;\n/**\n * Decodes our special format for JSON into native types.\n * This is exposed only for testing.\n */\n/** @hidden */\nfunction decode(data) {\n    if (data === null) {\n        return data;\n    }\n    if (data['@type']) {\n        switch (data['@type']) {\n            case LONG_TYPE:\n            // Fall through and handle this the same as unsigned.\n            case UNSIGNED_LONG_TYPE: {\n                // Technically, this could work return a valid number for malformed\n                // data if there was a number followed by garbage. But it's just not\n                // worth all the extra code to detect that case.\n                const value = parseFloat(data.value);\n                if (_.isNaN(value)) {\n                    logger_1.error('Data cannot be decoded from JSON.', data);\n                    throw new Error('Data cannot be decoded from JSON: ' + data);\n                }\n                return value;\n            }\n            default: {\n                logger_1.error('Data cannot be decoded from JSON.', data);\n                throw new Error('Data cannot be decoded from JSON: ' + data);\n            }\n        }\n    }\n    if (_.isArray(data)) {\n        return _.map(data, decode);\n    }\n    if (_.isObject(data)) {\n        // It's not safe to use _.forEach, because the object might be 'array-like'\n        // if it has a key called 'length'.\n        return _.mapValues(data, decode);\n    }\n    // Anything else is safe to return.\n    return data;\n}\nexports.decode = decode;\n/**\n * Check and verify tokens included in the requests. Once verified, tokens\n * are injected into the callable context.\n *\n * @param {Request} req - Request sent to the Callable function.\n * @param {CallableContext} ctx - Context to be sent to callable function handler.\n * @return {CallableTokenStatus} Status of the token verifications.\n */\n/** @hidden */\nasync function checkTokens(req, ctx) {\n    const verifications = {\n        app: 'MISSING',\n        auth: 'MISSING',\n    };\n    const appCheck = req.header('X-Firebase-AppCheck');\n    if (appCheck) {\n        verifications.app = 'INVALID';\n        try {\n            if (!apps_1.apps().admin.appCheck) {\n                throw new Error('Cannot validate AppCheck token. Please update Firebase Admin SDK to >= v9.8.0');\n            }\n            const appCheckToken = await apps_1.apps()\n                .admin.appCheck()\n                .verifyToken(appCheck);\n            ctx.app = {\n                appId: appCheckToken.appId,\n                token: appCheckToken.token,\n            };\n            verifications.app = 'VALID';\n        }\n        catch (err) {\n            logger_1.warn('Failed to validate AppCheck token.', err);\n        }\n    }\n    const authorization = req.header('Authorization');\n    if (authorization) {\n        verifications.auth = 'INVALID';\n        const match = authorization.match(/^Bearer (.*)$/);\n        if (match) {\n            const idToken = match[1];\n            try {\n                const authToken = await apps_1.apps()\n                    .admin.auth()\n                    .verifyIdToken(idToken);\n                verifications.auth = 'VALID';\n                ctx.auth = {\n                    uid: authToken.uid,\n                    token: authToken,\n                };\n            }\n            catch (err) {\n                logger_1.warn('Failed to validate auth token.', err);\n            }\n        }\n    }\n    const logPayload = {\n        verifications,\n        'logging.googleapis.com/labels': {\n            'firebase-log-type': 'callable-request-verification',\n        },\n    };\n    const errs = [];\n    if (verifications.app === 'INVALID') {\n        errs.push('AppCheck token was rejected.');\n    }\n    if (verifications.auth === 'INVALID') {\n        errs.push('Auth token was rejected.');\n    }\n    if (errs.length == 0) {\n        logger_1.info('Callable request verification passed', logPayload);\n    }\n    else {\n        logger_1.warn(`Callable request verification failed: ${errs.join(' ')}`, logPayload);\n    }\n    return verifications;\n}\n/** @hidden */\nconst corsHandler = cors({ origin: true, methods: 'POST' });\n/** @hidden */\nfunction _onCallWithOptions(handler, options) {\n    const func = async (req, res) => {\n        try {\n            if (!isValidRequest(req)) {\n                logger_1.error('Invalid request, unable to process.');\n                throw new HttpsError('invalid-argument', 'Bad Request');\n            }\n            const context = { rawRequest: req };\n            const tokenStatus = await checkTokens(req, context);\n            if (tokenStatus.app === 'INVALID' || tokenStatus.auth === 'INVALID') {\n                throw new HttpsError('unauthenticated', 'Unauthenticated');\n            }\n            const instanceId = req.header('Firebase-Instance-ID-Token');\n            if (instanceId) {\n                // Validating the token requires an http request, so we don't do it.\n                // If the user wants to use it for something, it will be validated then.\n                // Currently, the only real use case for this token is for sending\n                // pushes with FCM. In that case, the FCM APIs will validate the token.\n                context.instanceIdToken = req.header('Firebase-Instance-ID-Token');\n            }\n            const data = decode(req.body.data);\n            let result = await handler(data, context);\n            // Encode the result as JSON to preserve types like Dates.\n            result = encode(result);\n            // If there was some result, encode it in the body.\n            const responseBody = { result };\n            res.status(200).send(responseBody);\n        }\n        catch (err) {\n            if (!(err instanceof HttpsError)) {\n                // This doesn't count as an 'explicit' error.\n                logger_1.error('Unhandled error', err);\n                err = new HttpsError('internal', 'INTERNAL');\n            }\n            const { status } = err.httpErrorCode;\n            const body = { error: err.toJSON() };\n            res.status(status).send(body);\n        }\n    };\n    // Wrap the function with a cors handler.\n    const corsFunc = (req, res) => {\n        return corsHandler(req, res, () => func(req, res));\n    };\n    corsFunc.__trigger = _.assign(cloud_functions_1.optionsToTrigger(options), {\n        httpsTrigger: {},\n        labels: { 'deployment-callable': 'true' },\n    });\n    corsFunc.run = handler;\n    return corsFunc;\n}\nexports._onCallWithOptions = _onCallWithOptions;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-functions/lib/providers/https.js?");

/***/ }),

/***/ "./src/node_modules/firebase-functions/lib/providers/pubsub.js":
/*!*********************************************************************!*\
  !*** ./src/node_modules/firebase-functions/lib/providers/pubsub.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// The MIT License (MIT)\n//\n// Copyright (c) 2017 Firebase\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Message = exports.ScheduleBuilder = exports._scheduleWithOptions = exports.schedule = exports.TopicBuilder = exports._topicWithOptions = exports.topic = exports.service = exports.provider = void 0;\nconst cloud_functions_1 = __webpack_require__(/*! ../cloud-functions */ \"./src/node_modules/firebase-functions/lib/cloud-functions.js\");\n/** @hidden */\nexports.provider = 'google.pubsub';\n/** @hidden */\nexports.service = 'pubsub.googleapis.com';\n/**\n * Registers a Cloud Function triggered when a Google Cloud Pub/Sub message\n * is sent to a specified topic.\n *\n * @param topic The Pub/Sub topic to watch for message events.\n * @return Pub/Sub topic builder interface.\n */\nfunction topic(topic) {\n    return _topicWithOptions(topic, {});\n}\nexports.topic = topic;\n/** @hidden */\nfunction _topicWithOptions(topic, options) {\n    if (topic.indexOf('/') !== -1) {\n        throw new Error('Topic name may not have a /');\n    }\n    return new TopicBuilder(() => {\n        if (!process.env.GCLOUD_PROJECT) {\n            throw new Error('process.env.GCLOUD_PROJECT is not set.');\n        }\n        return `projects/${process.env.GCLOUD_PROJECT}/topics/${topic}`;\n    }, options);\n}\nexports._topicWithOptions = _topicWithOptions;\n/**\n * The Google Cloud Pub/Sub topic builder.\n *\n * Access via [`functions.pubsub.topic()`](providers_pubsub_.html#topic).\n */\nclass TopicBuilder {\n    /** @hidden */\n    constructor(triggerResource, options) {\n        this.triggerResource = triggerResource;\n        this.options = options;\n    }\n    /**\n     * Event handler that fires every time a Cloud Pub/Sub message is\n     * published.\n     *\n     * @param handler Event handler that runs every time a Cloud Pub/Sub message\n     *   is published.\n     * @return A Cloud Function that you can export and deploy.\n     */\n    onPublish(handler) {\n        return cloud_functions_1.makeCloudFunction({\n            handler,\n            provider: exports.provider,\n            service: exports.service,\n            triggerResource: this.triggerResource,\n            eventType: 'topic.publish',\n            dataConstructor: (raw) => new Message(raw.data),\n            options: this.options,\n        });\n    }\n}\nexports.TopicBuilder = TopicBuilder;\n/**\n * Registers a Cloud Function to run at specified times.\n *\n * @param schedule The schedule, in Unix Crontab or AppEngine syntax.\n * @return ScheduleBuilder interface.\n */\nfunction schedule(schedule) {\n    return _scheduleWithOptions(schedule, {});\n}\nexports.schedule = schedule;\n/** @hidden */\nfunction _scheduleWithOptions(schedule, options) {\n    const triggerResource = () => {\n        if (!process.env.GCLOUD_PROJECT) {\n            throw new Error('process.env.GCLOUD_PROJECT is not set.');\n        }\n        // The CLI will append the correct topic name based on region and function name\n        return `projects/${process.env.GCLOUD_PROJECT}/topics`;\n    };\n    return new ScheduleBuilder(triggerResource, {\n        ...options,\n        schedule: { schedule },\n    });\n}\nexports._scheduleWithOptions = _scheduleWithOptions;\n/**\n * The builder for scheduled functions, which are powered by\n * Google Pub/Sub and Cloud Scheduler. Describes the Cloud Scheduler\n * job that is deployed to trigger a scheduled function at the provided\n * frequency. For more information, see\n * [Schedule functions](/docs/functions/schedule-functions).\n *\n * Access via [`functions.pubsub.schedule()`](providers_pubsub_.html#schedule).\n */\nclass ScheduleBuilder {\n    /** @hidden */\n    constructor(triggerResource, options) {\n        this.triggerResource = triggerResource;\n        this.options = options;\n    }\n    retryConfig(config) {\n        this.options.schedule.retryConfig = config;\n        return this;\n    }\n    timeZone(timeZone) {\n        this.options.schedule.timeZone = timeZone;\n        return this;\n    }\n    /**\n     * Event handler for scheduled functions. Triggered whenever the associated\n     * scheduler job sends a Pub/Sub message.\n     *\n     * @param handler Handler that fires whenever the associated\n     *   scheduler job sends a Pub/Sub message.\n     * @return A Cloud Function that you can export and deploy.\n     */\n    onRun(handler) {\n        const cloudFunction = cloud_functions_1.makeCloudFunction({\n            contextOnlyHandler: handler,\n            provider: exports.provider,\n            service: exports.service,\n            triggerResource: this.triggerResource,\n            eventType: 'topic.publish',\n            options: this.options,\n            labels: { 'deployment-scheduled': 'true' },\n        });\n        return cloudFunction;\n    }\n}\nexports.ScheduleBuilder = ScheduleBuilder;\n/**\n * Interface representing a Google Cloud Pub/Sub message.\n *\n * @param data Payload of a Pub/Sub message.\n */\nclass Message {\n    constructor(data) {\n        [this.data, this.attributes, this._json] = [\n            data.data,\n            data.attributes || {},\n            data.json,\n        ];\n    }\n    /**\n     * The JSON data payload of this message object, if any.\n     */\n    get json() {\n        if (typeof this._json === 'undefined') {\n            this._json = JSON.parse(new Buffer(this.data, 'base64').toString('utf8'));\n        }\n        return this._json;\n    }\n    /**\n     * Returns a JSON-serializable representation of this object.\n     *\n     * @return A JSON-serializable representation of this object.\n     */\n    toJSON() {\n        return {\n            data: this.data,\n            attributes: this.attributes,\n        };\n    }\n}\nexports.Message = Message;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-functions/lib/providers/pubsub.js?");

/***/ }),

/***/ "./src/node_modules/firebase-functions/lib/providers/remoteConfig.js":
/*!***************************************************************************!*\
  !*** ./src/node_modules/firebase-functions/lib/providers/remoteConfig.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// The MIT License (MIT)\n//\n// Copyright (c) 2018 Firebase\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UpdateBuilder = exports._onUpdateWithOptions = exports.onUpdate = exports.service = exports.provider = void 0;\nconst cloud_functions_1 = __webpack_require__(/*! ../cloud-functions */ \"./src/node_modules/firebase-functions/lib/cloud-functions.js\");\n/** @hidden */\nexports.provider = 'google.firebase.remoteconfig';\n/** @hidden */\nexports.service = 'firebaseremoteconfig.googleapis.com';\n/**\n * Registers a function that triggers on Firebase Remote Config template\n * update events.\n *\n * @param handler A function that takes the updated Remote Config\n *   template version metadata as an argument.\n *\n * @return A Cloud Function that you can export and deploy.\n */\nfunction onUpdate(handler) {\n    return _onUpdateWithOptions(handler, {});\n}\nexports.onUpdate = onUpdate;\n/** @hidden */\nfunction _onUpdateWithOptions(handler, options) {\n    const triggerResource = () => {\n        if (!process.env.GCLOUD_PROJECT) {\n            throw new Error('process.env.GCLOUD_PROJECT is not set.');\n        }\n        return `projects/${process.env.GCLOUD_PROJECT}`;\n    };\n    return new UpdateBuilder(triggerResource, options).onUpdate(handler);\n}\nexports._onUpdateWithOptions = _onUpdateWithOptions;\n/** Builder used to create Cloud Functions for Remote Config. */\nclass UpdateBuilder {\n    /** @hidden */\n    constructor(triggerResource, options) {\n        this.triggerResource = triggerResource;\n        this.options = options;\n    }\n    /**\n     * Handle all updates (including rollbacks) that affect a Remote Config\n     * project.\n     * @param handler A function that takes the updated Remote Config template\n     * version metadata as an argument.\n     */\n    onUpdate(handler) {\n        return cloud_functions_1.makeCloudFunction({\n            handler,\n            provider: exports.provider,\n            service: exports.service,\n            triggerResource: this.triggerResource,\n            eventType: 'update',\n            options: this.options,\n        });\n    }\n}\nexports.UpdateBuilder = UpdateBuilder;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-functions/lib/providers/remoteConfig.js?");

/***/ }),

/***/ "./src/node_modules/firebase-functions/lib/providers/storage.js":
/*!**********************************************************************!*\
  !*** ./src/node_modules/firebase-functions/lib/providers/storage.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// The MIT License (MIT)\n//\n// Copyright (c) 2017 Firebase\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ObjectBuilder = exports.BucketBuilder = exports._objectWithOptions = exports._bucketWithOptions = exports.object = exports.bucket = exports.service = exports.provider = void 0;\nconst cloud_functions_1 = __webpack_require__(/*! ../cloud-functions */ \"./src/node_modules/firebase-functions/lib/cloud-functions.js\");\nconst config_1 = __webpack_require__(/*! ../config */ \"./src/node_modules/firebase-functions/lib/config.js\");\n/** @hidden */\nexports.provider = 'google.storage';\n/** @hidden */\nexports.service = 'storage.googleapis.com';\n/**\n * Registers a Cloud Function scoped to a specific storage bucket.\n *\n * @param bucket Name of the bucket to which this Cloud Function is\n *   scoped.\n *\n * @return Storage bucket builder interface.\n */\nfunction bucket(bucket) {\n    return _bucketWithOptions({}, bucket);\n}\nexports.bucket = bucket;\n/**\n * Registers a Cloud Function scoped to the default storage bucket for the\n * project.\n *\n * @return Storage object builder interface.\n */\nfunction object() {\n    return _objectWithOptions({});\n}\nexports.object = object;\n/** @hidden */\nfunction _bucketWithOptions(options, bucket) {\n    const resourceGetter = () => {\n        bucket = bucket || config_1.firebaseConfig().storageBucket;\n        if (!bucket) {\n            throw new Error('Missing bucket name. If you are unit testing, please provide a bucket name' +\n                ' through `functions.storage.bucket(bucketName)`, or set process.env.FIREBASE_CONFIG.');\n        }\n        if (!/^[a-z\\d][a-z\\d\\\\._-]{1,230}[a-z\\d]$/.test(bucket)) {\n            throw new Error(`Invalid bucket name ${bucket}`);\n        }\n        return `projects/_/buckets/${bucket}`;\n    };\n    return new BucketBuilder(resourceGetter, options);\n}\nexports._bucketWithOptions = _bucketWithOptions;\n/** @hidden */\nfunction _objectWithOptions(options) {\n    return _bucketWithOptions(options).object();\n}\nexports._objectWithOptions = _objectWithOptions;\n/**\n * The Google Cloud Storage bucket builder interface.\n *\n * Access via [`functions.storage.bucket()`](providers_storage_.html#bucket).\n */\nclass BucketBuilder {\n    /** @hidden */\n    constructor(triggerResource, options) {\n        this.triggerResource = triggerResource;\n        this.options = options;\n    }\n    /**\n     * Event handler which fires every time a Google Cloud Storage change occurs.\n     *\n     * @return Storage object builder interface scoped to the specified storage\n     *   bucket.\n     */\n    object() {\n        return new ObjectBuilder(this.triggerResource, this.options);\n    }\n}\nexports.BucketBuilder = BucketBuilder;\n/**\n * The Google Cloud Storage object builder interface.\n *\n * Access via [`functions.storage.object()`](providers_storage_.html#object).\n */\nclass ObjectBuilder {\n    /** @hidden */\n    constructor(triggerResource, options) {\n        this.triggerResource = triggerResource;\n        this.options = options;\n    }\n    /** @hidden */\n    onChange(handler) {\n        throw new Error('\"onChange\" is now deprecated, please use \"onArchive\", \"onDelete\", ' +\n            '\"onFinalize\", or \"onMetadataUpdate\".');\n    }\n    /**\n     * Event handler sent only when a bucket has enabled object versioning.\n     * This event indicates that the live version of an object has become an\n     * archived version, either because it was archived or because it was\n     * overwritten by the upload of an object of the same name.\n     *\n     * @param handler Event handler which is run every time a Google Cloud Storage\n     *   archival occurs.\n     *\n     * @return A Cloud Function which you can export and deploy.\n     */\n    onArchive(handler) {\n        return this.onOperation(handler, 'object.archive');\n    }\n    /**\n     * Event handler which fires every time a Google Cloud Storage deletion occurs.\n     *\n     * Sent when an object has been permanently deleted. This includes objects\n     * that are overwritten or are deleted as part of the bucket's lifecycle\n     * configuration. For buckets with object versioning enabled, this is not\n     * sent when an object is archived, even if archival occurs\n     * via the `storage.objects.delete` method.\n     *\n     * @param handler Event handler which is run every time a Google Cloud Storage\n     *   deletion occurs.\n     *\n     * @return A Cloud Function which you can export and deploy.\n     */\n    onDelete(handler) {\n        return this.onOperation(handler, 'object.delete');\n    }\n    /**\n     * Event handler which fires every time a Google Cloud Storage object\n     * creation occurs.\n     *\n     * Sent when a new object (or a new generation of an existing object)\n     * is successfully created in the bucket. This includes copying or rewriting\n     * an existing object. A failed upload does not trigger this event.\n     *\n     * @param handler Event handler which is run every time a Google Cloud Storage\n     *   object creation occurs.\n     *\n     * @return A Cloud Function which you can export and deploy.\n     */\n    onFinalize(handler) {\n        return this.onOperation(handler, 'object.finalize');\n    }\n    /**\n     * Event handler which fires every time the metadata of an existing object\n     * changes.\n     *\n     * @param handler Event handler which is run every time a Google Cloud Storage\n     *   metadata update occurs.\n     *\n     * @return A Cloud Function which you can export and deploy.\n     */\n    onMetadataUpdate(handler) {\n        return this.onOperation(handler, 'object.metadataUpdate');\n    }\n    /** @hidden */\n    onOperation(handler, eventType) {\n        return cloud_functions_1.makeCloudFunction({\n            handler,\n            provider: exports.provider,\n            service: exports.service,\n            eventType,\n            triggerResource: this.triggerResource,\n            options: this.options,\n        });\n    }\n}\nexports.ObjectBuilder = ObjectBuilder;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-functions/lib/providers/storage.js?");

/***/ }),

/***/ "./src/node_modules/firebase-functions/lib/providers/testLab.js":
/*!**********************************************************************!*\
  !*** ./src/node_modules/firebase-functions/lib/providers/testLab.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// The MIT License (MIT)\n//\n// Copyright (c) 2019 Firebase\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ResultStorage = exports.ClientInfo = exports.TestMatrix = exports.TestMatrixBuilder = exports._testMatrixWithOpts = exports.testMatrix = exports.TEST_MATRIX_COMPLETE_EVENT_TYPE = exports.SERVICE = exports.PROVIDER = void 0;\nconst _ = __webpack_require__(/*! lodash */ \"lodash\");\nconst cloud_functions_1 = __webpack_require__(/*! ../cloud-functions */ \"./src/node_modules/firebase-functions/lib/cloud-functions.js\");\n/** @internal */\nexports.PROVIDER = 'google.testing';\n/** @internal */\nexports.SERVICE = 'testing.googleapis.com';\n/** @internal */\nexports.TEST_MATRIX_COMPLETE_EVENT_TYPE = 'testMatrix.complete';\n/** Handle events related to Test Lab test matrices. */\nfunction testMatrix() {\n    return _testMatrixWithOpts({});\n}\nexports.testMatrix = testMatrix;\n/** @internal */\nfunction _testMatrixWithOpts(opts) {\n    return new TestMatrixBuilder(() => {\n        if (!process.env.GCLOUD_PROJECT) {\n            throw new Error('process.env.GCLOUD_PROJECT is not set.');\n        }\n        return 'projects/' + process.env.GCLOUD_PROJECT + '/testMatrices/{matrix}';\n    }, opts);\n}\nexports._testMatrixWithOpts = _testMatrixWithOpts;\n/** Builder used to create Cloud Functions for Test Lab test matrices events. */\nclass TestMatrixBuilder {\n    /** @internal */\n    constructor(triggerResource, options) {\n        this.triggerResource = triggerResource;\n        this.options = options;\n    }\n    /** Handle a TestMatrix that reached a final test state. */\n    onComplete(handler) {\n        const dataConstructor = (raw) => {\n            return new TestMatrix(raw.data);\n        };\n        return cloud_functions_1.makeCloudFunction({\n            provider: exports.PROVIDER,\n            eventType: exports.TEST_MATRIX_COMPLETE_EVENT_TYPE,\n            triggerResource: this.triggerResource,\n            service: exports.SERVICE,\n            dataConstructor,\n            handler,\n            options: this.options,\n        });\n    }\n}\nexports.TestMatrixBuilder = TestMatrixBuilder;\n/** TestMatrix captures details about a test run. */\nclass TestMatrix {\n    /** @internal */\n    constructor(data) {\n        this.testMatrixId = data.testMatrixId;\n        this.createTime = data.timestamp;\n        this.state = data.state;\n        this.outcomeSummary = data.outcomeSummary;\n        this.invalidMatrixDetails = data.invalidMatrixDetails;\n        this.resultStorage = new ResultStorage(data.resultStorage);\n        this.clientInfo = new ClientInfo(data.clientInfo);\n    }\n}\nexports.TestMatrix = TestMatrix;\n/** Information about the client which invoked the test. */\nclass ClientInfo {\n    /** @internal */\n    constructor(data) {\n        this.name = _.get(data, 'name', '');\n        this.details = {};\n        _.forEach(_.get(data, 'clientInfoDetails'), (detail) => {\n            this.details[detail.key] = detail.value || '';\n        });\n    }\n}\nexports.ClientInfo = ClientInfo;\n/** Locations where the test results are stored. */\nclass ResultStorage {\n    /** @internal */\n    constructor(data) {\n        this.gcsPath = _.get(data, 'googleCloudStorage.gcsPath');\n        this.toolResultsHistoryId = _.get(data, 'toolResultsHistory.historyId');\n        this.toolResultsExecutionId = _.get(data, 'toolResultsExecution.executionId');\n        this.resultsUrl = _.get(data, 'resultsUrl');\n    }\n}\nexports.ResultStorage = ResultStorage;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-functions/lib/providers/testLab.js?");

/***/ }),

/***/ "./src/node_modules/firebase-functions/lib/setup.js":
/*!**********************************************************!*\
  !*** ./src/node_modules/firebase-functions/lib/setup.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// The MIT License (MIT)\n//\n// Copyright (c) 2017 Firebase\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setup = void 0;\n/** @hidden */\nconst config_1 = __webpack_require__(/*! ./config */ \"./src/node_modules/firebase-functions/lib/config.js\");\nconst logger_1 = __webpack_require__(/*! ./logger */ \"./src/node_modules/firebase-functions/lib/logger.js\");\n// Set up for config and vars\nfunction setup() {\n    // TEMPORARY WORKAROUND (BUG 63586213):\n    // Until the Cloud Functions builder can publish FIREBASE_CONFIG, automatically provide it on import based on what\n    // we can deduce.\n    if (!process.env.FIREBASE_CONFIG) {\n        const cfg = config_1.firebaseConfig();\n        if (cfg) {\n            process.env.FIREBASE_CONFIG = JSON.stringify(cfg);\n        }\n    }\n    // WORKAROUND (BUG 134416569): GCLOUD_PROJECT missing in Node 10\n    if (!process.env.GCLOUD_PROJECT && process.env.FIREBASE_CONFIG) {\n        process.env.GCLOUD_PROJECT = JSON.parse(process.env.FIREBASE_CONFIG).projectId;\n    }\n    // If FIREBASE_CONFIG is still not found, try using GCLOUD_PROJECT to estimate\n    if (!process.env.FIREBASE_CONFIG) {\n        if (process.env.GCLOUD_PROJECT) {\n            logger_1.warn('Warning, estimating Firebase Config based on GCLOUD_PROJECT. Initializing firebase-admin may fail');\n            process.env.FIREBASE_CONFIG = JSON.stringify({\n                databaseURL: process.env.DATABASE_URL ||\n                    `https://${process.env.GCLOUD_PROJECT}.firebaseio.com`,\n                storageBucket: process.env.STORAGE_BUCKET_URL ||\n                    `${process.env.GCLOUD_PROJECT}.appspot.com`,\n                projectId: process.env.GCLOUD_PROJECT,\n            });\n        }\n        else {\n            logger_1.warn('Warning, FIREBASE_CONFIG and GCLOUD_PROJECT environment variables are missing. Initializing firebase-admin will fail');\n        }\n    }\n}\nexports.setup = setup;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-functions/lib/setup.js?");

/***/ }),

/***/ "./src/node_modules/firebase-functions/lib/utilities/path.js":
/*!*******************************************************************!*\
  !*** ./src/node_modules/firebase-functions/lib/utilities/path.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.joinPath = exports.pathParts = exports.normalizePath = void 0;\n/** @hidden\n * Removes leading and trailing slashes from a path.\n *\n * @param path A path to normalize, in POSIX format.\n */\nfunction normalizePath(path) {\n    if (!path) {\n        return '';\n    }\n    return path.replace(/^\\//, '').replace(/\\/$/, '');\n}\nexports.normalizePath = normalizePath;\n/**\n * Normalizes a given path and splits it into an array of segments.\n *\n * @param path A path to split, in POSIX format.\n */\nfunction pathParts(path) {\n    if (!path || path === '' || path === '/') {\n        return [];\n    }\n    return normalizePath(path).split('/');\n}\nexports.pathParts = pathParts;\n/**\n * Normalizes given paths and joins these together using a POSIX separator.\n *\n * @param base A first path segment, in POSIX format.\n * @param child A second path segment, in POSIX format.\n */\nfunction joinPath(base, child) {\n    return pathParts(base)\n        .concat(pathParts(child))\n        .join('/');\n}\nexports.joinPath = joinPath;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-functions/lib/utilities/path.js?");

/***/ }),

/***/ "./src/node_modules/firebase-functions/lib/utils.js":
/*!**********************************************************!*\
  !*** ./src/node_modules/firebase-functions/lib/utils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// The MIT License (MIT)\n//\n// Copyright (c) 2017 Firebase\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.pruneNulls = exports.applyChange = void 0;\n/** @hidden */\nconst _ = __webpack_require__(/*! lodash */ \"lodash\");\nfunction applyChange(src, dest) {\n    // if not mergeable, don't merge\n    if (!_.isPlainObject(dest) || !_.isPlainObject(src)) {\n        return dest;\n    }\n    return pruneNulls(_.merge({}, src, dest));\n}\nexports.applyChange = applyChange;\nfunction pruneNulls(obj) {\n    for (const key in obj) {\n        if (obj[key] === null) {\n            delete obj[key];\n        }\n        else if (_.isPlainObject(obj[key])) {\n            pruneNulls(obj[key]);\n        }\n    }\n    return obj;\n}\nexports.pruneNulls = pruneNulls;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-functions/lib/utils.js?");

/***/ }),

/***/ "./src/node_modules/firebase-functions/lib sync recursive":
/*!*******************************************************!*\
  !*** ./src/node_modules/firebase-functions/lib/ sync ***!
  \*******************************************************/
/***/ ((module) => {

eval("function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = \"./src/node_modules/firebase-functions/lib sync recursive\";\nmodule.exports = webpackEmptyContext;\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/firebase-functions/lib/_sync?");

/***/ }),

/***/ "./src/node_modules/foreach/index.js":
/*!*******************************************!*\
  !*** ./src/node_modules/foreach/index.js ***!
  \*******************************************/
/***/ ((module) => {

eval("\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toString = Object.prototype.toString;\n\nmodule.exports = function forEach (obj, fn, ctx) {\n    if (toString.call(fn) !== '[object Function]') {\n        throw new TypeError('iterator must be a function');\n    }\n    var l = obj.length;\n    if (l === +l) {\n        for (var i = 0; i < l; i++) {\n            fn.call(ctx, obj[i], i, obj);\n        }\n    } else {\n        for (var k in obj) {\n            if (hasOwn.call(obj, k)) {\n                fn.call(ctx, obj[k], k, obj);\n            }\n        }\n    }\n};\n\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/foreach/index.js?");

/***/ }),

/***/ "./src/node_modules/functional-red-black-tree/rbtree.js":
/*!**************************************************************!*\
  !*** ./src/node_modules/functional-red-black-tree/rbtree.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = createRBTree\n\nvar RED   = 0\nvar BLACK = 1\n\nfunction RBNode(color, key, value, left, right, count) {\n  this._color = color\n  this.key = key\n  this.value = value\n  this.left = left\n  this.right = right\n  this._count = count\n}\n\nfunction cloneNode(node) {\n  return new RBNode(node._color, node.key, node.value, node.left, node.right, node._count)\n}\n\nfunction repaint(color, node) {\n  return new RBNode(color, node.key, node.value, node.left, node.right, node._count)\n}\n\nfunction recount(node) {\n  node._count = 1 + (node.left ? node.left._count : 0) + (node.right ? node.right._count : 0)\n}\n\nfunction RedBlackTree(compare, root) {\n  this._compare = compare\n  this.root = root\n}\n\nvar proto = RedBlackTree.prototype\n\nObject.defineProperty(proto, \"keys\", {\n  get: function() {\n    var result = []\n    this.forEach(function(k,v) {\n      result.push(k)\n    })\n    return result\n  }\n})\n\nObject.defineProperty(proto, \"values\", {\n  get: function() {\n    var result = []\n    this.forEach(function(k,v) {\n      result.push(v)\n    })\n    return result\n  }\n})\n\n//Returns the number of nodes in the tree\nObject.defineProperty(proto, \"length\", {\n  get: function() {\n    if(this.root) {\n      return this.root._count\n    }\n    return 0\n  }\n})\n\n//Insert a new item into the tree\nproto.insert = function(key, value) {\n  var cmp = this._compare\n  //Find point to insert new node at\n  var n = this.root\n  var n_stack = []\n  var d_stack = []\n  while(n) {\n    var d = cmp(key, n.key)\n    n_stack.push(n)\n    d_stack.push(d)\n    if(d <= 0) {\n      n = n.left\n    } else {\n      n = n.right\n    }\n  }\n  //Rebuild path to leaf node\n  n_stack.push(new RBNode(RED, key, value, null, null, 1))\n  for(var s=n_stack.length-2; s>=0; --s) {\n    var n = n_stack[s]\n    if(d_stack[s] <= 0) {\n      n_stack[s] = new RBNode(n._color, n.key, n.value, n_stack[s+1], n.right, n._count+1)\n    } else {\n      n_stack[s] = new RBNode(n._color, n.key, n.value, n.left, n_stack[s+1], n._count+1)\n    }\n  }\n  //Rebalance tree using rotations\n  //console.log(\"start insert\", key, d_stack)\n  for(var s=n_stack.length-1; s>1; --s) {\n    var p = n_stack[s-1]\n    var n = n_stack[s]\n    if(p._color === BLACK || n._color === BLACK) {\n      break\n    }\n    var pp = n_stack[s-2]\n    if(pp.left === p) {\n      if(p.left === n) {\n        var y = pp.right\n        if(y && y._color === RED) {\n          //console.log(\"LLr\")\n          p._color = BLACK\n          pp.right = repaint(BLACK, y)\n          pp._color = RED\n          s -= 1\n        } else {\n          //console.log(\"LLb\")\n          pp._color = RED\n          pp.left = p.right\n          p._color = BLACK\n          p.right = pp\n          n_stack[s-2] = p\n          n_stack[s-1] = n\n          recount(pp)\n          recount(p)\n          if(s >= 3) {\n            var ppp = n_stack[s-3]\n            if(ppp.left === pp) {\n              ppp.left = p\n            } else {\n              ppp.right = p\n            }\n          }\n          break\n        }\n      } else {\n        var y = pp.right\n        if(y && y._color === RED) {\n          //console.log(\"LRr\")\n          p._color = BLACK\n          pp.right = repaint(BLACK, y)\n          pp._color = RED\n          s -= 1\n        } else {\n          //console.log(\"LRb\")\n          p.right = n.left\n          pp._color = RED\n          pp.left = n.right\n          n._color = BLACK\n          n.left = p\n          n.right = pp\n          n_stack[s-2] = n\n          n_stack[s-1] = p\n          recount(pp)\n          recount(p)\n          recount(n)\n          if(s >= 3) {\n            var ppp = n_stack[s-3]\n            if(ppp.left === pp) {\n              ppp.left = n\n            } else {\n              ppp.right = n\n            }\n          }\n          break\n        }\n      }\n    } else {\n      if(p.right === n) {\n        var y = pp.left\n        if(y && y._color === RED) {\n          //console.log(\"RRr\", y.key)\n          p._color = BLACK\n          pp.left = repaint(BLACK, y)\n          pp._color = RED\n          s -= 1\n        } else {\n          //console.log(\"RRb\")\n          pp._color = RED\n          pp.right = p.left\n          p._color = BLACK\n          p.left = pp\n          n_stack[s-2] = p\n          n_stack[s-1] = n\n          recount(pp)\n          recount(p)\n          if(s >= 3) {\n            var ppp = n_stack[s-3]\n            if(ppp.right === pp) {\n              ppp.right = p\n            } else {\n              ppp.left = p\n            }\n          }\n          break\n        }\n      } else {\n        var y = pp.left\n        if(y && y._color === RED) {\n          //console.log(\"RLr\")\n          p._color = BLACK\n          pp.left = repaint(BLACK, y)\n          pp._color = RED\n          s -= 1\n        } else {\n          //console.log(\"RLb\")\n          p.left = n.right\n          pp._color = RED\n          pp.right = n.left\n          n._color = BLACK\n          n.right = p\n          n.left = pp\n          n_stack[s-2] = n\n          n_stack[s-1] = p\n          recount(pp)\n          recount(p)\n          recount(n)\n          if(s >= 3) {\n            var ppp = n_stack[s-3]\n            if(ppp.right === pp) {\n              ppp.right = n\n            } else {\n              ppp.left = n\n            }\n          }\n          break\n        }\n      }\n    }\n  }\n  //Return new tree\n  n_stack[0]._color = BLACK\n  return new RedBlackTree(cmp, n_stack[0])\n}\n\n\n//Visit all nodes inorder\nfunction doVisitFull(visit, node) {\n  if(node.left) {\n    var v = doVisitFull(visit, node.left)\n    if(v) { return v }\n  }\n  var v = visit(node.key, node.value)\n  if(v) { return v }\n  if(node.right) {\n    return doVisitFull(visit, node.right)\n  }\n}\n\n//Visit half nodes in order\nfunction doVisitHalf(lo, compare, visit, node) {\n  var l = compare(lo, node.key)\n  if(l <= 0) {\n    if(node.left) {\n      var v = doVisitHalf(lo, compare, visit, node.left)\n      if(v) { return v }\n    }\n    var v = visit(node.key, node.value)\n    if(v) { return v }\n  }\n  if(node.right) {\n    return doVisitHalf(lo, compare, visit, node.right)\n  }\n}\n\n//Visit all nodes within a range\nfunction doVisit(lo, hi, compare, visit, node) {\n  var l = compare(lo, node.key)\n  var h = compare(hi, node.key)\n  var v\n  if(l <= 0) {\n    if(node.left) {\n      v = doVisit(lo, hi, compare, visit, node.left)\n      if(v) { return v }\n    }\n    if(h > 0) {\n      v = visit(node.key, node.value)\n      if(v) { return v }\n    }\n  }\n  if(h > 0 && node.right) {\n    return doVisit(lo, hi, compare, visit, node.right)\n  }\n}\n\n\nproto.forEach = function rbTreeForEach(visit, lo, hi) {\n  if(!this.root) {\n    return\n  }\n  switch(arguments.length) {\n    case 1:\n      return doVisitFull(visit, this.root)\n    break\n\n    case 2:\n      return doVisitHalf(lo, this._compare, visit, this.root)\n    break\n\n    case 3:\n      if(this._compare(lo, hi) >= 0) {\n        return\n      }\n      return doVisit(lo, hi, this._compare, visit, this.root)\n    break\n  }\n}\n\n//First item in list\nObject.defineProperty(proto, \"begin\", {\n  get: function() {\n    var stack = []\n    var n = this.root\n    while(n) {\n      stack.push(n)\n      n = n.left\n    }\n    return new RedBlackTreeIterator(this, stack)\n  }\n})\n\n//Last item in list\nObject.defineProperty(proto, \"end\", {\n  get: function() {\n    var stack = []\n    var n = this.root\n    while(n) {\n      stack.push(n)\n      n = n.right\n    }\n    return new RedBlackTreeIterator(this, stack)\n  }\n})\n\n//Find the ith item in the tree\nproto.at = function(idx) {\n  if(idx < 0) {\n    return new RedBlackTreeIterator(this, [])\n  }\n  var n = this.root\n  var stack = []\n  while(true) {\n    stack.push(n)\n    if(n.left) {\n      if(idx < n.left._count) {\n        n = n.left\n        continue\n      }\n      idx -= n.left._count\n    }\n    if(!idx) {\n      return new RedBlackTreeIterator(this, stack)\n    }\n    idx -= 1\n    if(n.right) {\n      if(idx >= n.right._count) {\n        break\n      }\n      n = n.right\n    } else {\n      break\n    }\n  }\n  return new RedBlackTreeIterator(this, [])\n}\n\nproto.ge = function(key) {\n  var cmp = this._compare\n  var n = this.root\n  var stack = []\n  var last_ptr = 0\n  while(n) {\n    var d = cmp(key, n.key)\n    stack.push(n)\n    if(d <= 0) {\n      last_ptr = stack.length\n    }\n    if(d <= 0) {\n      n = n.left\n    } else {\n      n = n.right\n    }\n  }\n  stack.length = last_ptr\n  return new RedBlackTreeIterator(this, stack)\n}\n\nproto.gt = function(key) {\n  var cmp = this._compare\n  var n = this.root\n  var stack = []\n  var last_ptr = 0\n  while(n) {\n    var d = cmp(key, n.key)\n    stack.push(n)\n    if(d < 0) {\n      last_ptr = stack.length\n    }\n    if(d < 0) {\n      n = n.left\n    } else {\n      n = n.right\n    }\n  }\n  stack.length = last_ptr\n  return new RedBlackTreeIterator(this, stack)\n}\n\nproto.lt = function(key) {\n  var cmp = this._compare\n  var n = this.root\n  var stack = []\n  var last_ptr = 0\n  while(n) {\n    var d = cmp(key, n.key)\n    stack.push(n)\n    if(d > 0) {\n      last_ptr = stack.length\n    }\n    if(d <= 0) {\n      n = n.left\n    } else {\n      n = n.right\n    }\n  }\n  stack.length = last_ptr\n  return new RedBlackTreeIterator(this, stack)\n}\n\nproto.le = function(key) {\n  var cmp = this._compare\n  var n = this.root\n  var stack = []\n  var last_ptr = 0\n  while(n) {\n    var d = cmp(key, n.key)\n    stack.push(n)\n    if(d >= 0) {\n      last_ptr = stack.length\n    }\n    if(d < 0) {\n      n = n.left\n    } else {\n      n = n.right\n    }\n  }\n  stack.length = last_ptr\n  return new RedBlackTreeIterator(this, stack)\n}\n\n//Finds the item with key if it exists\nproto.find = function(key) {\n  var cmp = this._compare\n  var n = this.root\n  var stack = []\n  while(n) {\n    var d = cmp(key, n.key)\n    stack.push(n)\n    if(d === 0) {\n      return new RedBlackTreeIterator(this, stack)\n    }\n    if(d <= 0) {\n      n = n.left\n    } else {\n      n = n.right\n    }\n  }\n  return new RedBlackTreeIterator(this, [])\n}\n\n//Removes item with key from tree\nproto.remove = function(key) {\n  var iter = this.find(key)\n  if(iter) {\n    return iter.remove()\n  }\n  return this\n}\n\n//Returns the item at `key`\nproto.get = function(key) {\n  var cmp = this._compare\n  var n = this.root\n  while(n) {\n    var d = cmp(key, n.key)\n    if(d === 0) {\n      return n.value\n    }\n    if(d <= 0) {\n      n = n.left\n    } else {\n      n = n.right\n    }\n  }\n  return\n}\n\n//Iterator for red black tree\nfunction RedBlackTreeIterator(tree, stack) {\n  this.tree = tree\n  this._stack = stack\n}\n\nvar iproto = RedBlackTreeIterator.prototype\n\n//Test if iterator is valid\nObject.defineProperty(iproto, \"valid\", {\n  get: function() {\n    return this._stack.length > 0\n  }\n})\n\n//Node of the iterator\nObject.defineProperty(iproto, \"node\", {\n  get: function() {\n    if(this._stack.length > 0) {\n      return this._stack[this._stack.length-1]\n    }\n    return null\n  },\n  enumerable: true\n})\n\n//Makes a copy of an iterator\niproto.clone = function() {\n  return new RedBlackTreeIterator(this.tree, this._stack.slice())\n}\n\n//Swaps two nodes\nfunction swapNode(n, v) {\n  n.key = v.key\n  n.value = v.value\n  n.left = v.left\n  n.right = v.right\n  n._color = v._color\n  n._count = v._count\n}\n\n//Fix up a double black node in a tree\nfunction fixDoubleBlack(stack) {\n  var n, p, s, z\n  for(var i=stack.length-1; i>=0; --i) {\n    n = stack[i]\n    if(i === 0) {\n      n._color = BLACK\n      return\n    }\n    //console.log(\"visit node:\", n.key, i, stack[i].key, stack[i-1].key)\n    p = stack[i-1]\n    if(p.left === n) {\n      //console.log(\"left child\")\n      s = p.right\n      if(s.right && s.right._color === RED) {\n        //console.log(\"case 1: right sibling child red\")\n        s = p.right = cloneNode(s)\n        z = s.right = cloneNode(s.right)\n        p.right = s.left\n        s.left = p\n        s.right = z\n        s._color = p._color\n        n._color = BLACK\n        p._color = BLACK\n        z._color = BLACK\n        recount(p)\n        recount(s)\n        if(i > 1) {\n          var pp = stack[i-2]\n          if(pp.left === p) {\n            pp.left = s\n          } else {\n            pp.right = s\n          }\n        }\n        stack[i-1] = s\n        return\n      } else if(s.left && s.left._color === RED) {\n        //console.log(\"case 1: left sibling child red\")\n        s = p.right = cloneNode(s)\n        z = s.left = cloneNode(s.left)\n        p.right = z.left\n        s.left = z.right\n        z.left = p\n        z.right = s\n        z._color = p._color\n        p._color = BLACK\n        s._color = BLACK\n        n._color = BLACK\n        recount(p)\n        recount(s)\n        recount(z)\n        if(i > 1) {\n          var pp = stack[i-2]\n          if(pp.left === p) {\n            pp.left = z\n          } else {\n            pp.right = z\n          }\n        }\n        stack[i-1] = z\n        return\n      }\n      if(s._color === BLACK) {\n        if(p._color === RED) {\n          //console.log(\"case 2: black sibling, red parent\", p.right.value)\n          p._color = BLACK\n          p.right = repaint(RED, s)\n          return\n        } else {\n          //console.log(\"case 2: black sibling, black parent\", p.right.value)\n          p.right = repaint(RED, s)\n          continue  \n        }\n      } else {\n        //console.log(\"case 3: red sibling\")\n        s = cloneNode(s)\n        p.right = s.left\n        s.left = p\n        s._color = p._color\n        p._color = RED\n        recount(p)\n        recount(s)\n        if(i > 1) {\n          var pp = stack[i-2]\n          if(pp.left === p) {\n            pp.left = s\n          } else {\n            pp.right = s\n          }\n        }\n        stack[i-1] = s\n        stack[i] = p\n        if(i+1 < stack.length) {\n          stack[i+1] = n\n        } else {\n          stack.push(n)\n        }\n        i = i+2\n      }\n    } else {\n      //console.log(\"right child\")\n      s = p.left\n      if(s.left && s.left._color === RED) {\n        //console.log(\"case 1: left sibling child red\", p.value, p._color)\n        s = p.left = cloneNode(s)\n        z = s.left = cloneNode(s.left)\n        p.left = s.right\n        s.right = p\n        s.left = z\n        s._color = p._color\n        n._color = BLACK\n        p._color = BLACK\n        z._color = BLACK\n        recount(p)\n        recount(s)\n        if(i > 1) {\n          var pp = stack[i-2]\n          if(pp.right === p) {\n            pp.right = s\n          } else {\n            pp.left = s\n          }\n        }\n        stack[i-1] = s\n        return\n      } else if(s.right && s.right._color === RED) {\n        //console.log(\"case 1: right sibling child red\")\n        s = p.left = cloneNode(s)\n        z = s.right = cloneNode(s.right)\n        p.left = z.right\n        s.right = z.left\n        z.right = p\n        z.left = s\n        z._color = p._color\n        p._color = BLACK\n        s._color = BLACK\n        n._color = BLACK\n        recount(p)\n        recount(s)\n        recount(z)\n        if(i > 1) {\n          var pp = stack[i-2]\n          if(pp.right === p) {\n            pp.right = z\n          } else {\n            pp.left = z\n          }\n        }\n        stack[i-1] = z\n        return\n      }\n      if(s._color === BLACK) {\n        if(p._color === RED) {\n          //console.log(\"case 2: black sibling, red parent\")\n          p._color = BLACK\n          p.left = repaint(RED, s)\n          return\n        } else {\n          //console.log(\"case 2: black sibling, black parent\")\n          p.left = repaint(RED, s)\n          continue  \n        }\n      } else {\n        //console.log(\"case 3: red sibling\")\n        s = cloneNode(s)\n        p.left = s.right\n        s.right = p\n        s._color = p._color\n        p._color = RED\n        recount(p)\n        recount(s)\n        if(i > 1) {\n          var pp = stack[i-2]\n          if(pp.right === p) {\n            pp.right = s\n          } else {\n            pp.left = s\n          }\n        }\n        stack[i-1] = s\n        stack[i] = p\n        if(i+1 < stack.length) {\n          stack[i+1] = n\n        } else {\n          stack.push(n)\n        }\n        i = i+2\n      }\n    }\n  }\n}\n\n//Removes item at iterator from tree\niproto.remove = function() {\n  var stack = this._stack\n  if(stack.length === 0) {\n    return this.tree\n  }\n  //First copy path to node\n  var cstack = new Array(stack.length)\n  var n = stack[stack.length-1]\n  cstack[cstack.length-1] = new RBNode(n._color, n.key, n.value, n.left, n.right, n._count)\n  for(var i=stack.length-2; i>=0; --i) {\n    var n = stack[i]\n    if(n.left === stack[i+1]) {\n      cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i+1], n.right, n._count)\n    } else {\n      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i+1], n._count)\n    }\n  }\n\n  //Get node\n  n = cstack[cstack.length-1]\n  //console.log(\"start remove: \", n.value)\n\n  //If not leaf, then swap with previous node\n  if(n.left && n.right) {\n    //console.log(\"moving to leaf\")\n\n    //First walk to previous leaf\n    var split = cstack.length\n    n = n.left\n    while(n.right) {\n      cstack.push(n)\n      n = n.right\n    }\n    //Copy path to leaf\n    var v = cstack[split-1]\n    cstack.push(new RBNode(n._color, v.key, v.value, n.left, n.right, n._count))\n    cstack[split-1].key = n.key\n    cstack[split-1].value = n.value\n\n    //Fix up stack\n    for(var i=cstack.length-2; i>=split; --i) {\n      n = cstack[i]\n      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i+1], n._count)\n    }\n    cstack[split-1].left = cstack[split]\n  }\n  //console.log(\"stack=\", cstack.map(function(v) { return v.value }))\n\n  //Remove leaf node\n  n = cstack[cstack.length-1]\n  if(n._color === RED) {\n    //Easy case: removing red leaf\n    //console.log(\"RED leaf\")\n    var p = cstack[cstack.length-2]\n    if(p.left === n) {\n      p.left = null\n    } else if(p.right === n) {\n      p.right = null\n    }\n    cstack.pop()\n    for(var i=0; i<cstack.length; ++i) {\n      cstack[i]._count--\n    }\n    return new RedBlackTree(this.tree._compare, cstack[0])\n  } else {\n    if(n.left || n.right) {\n      //Second easy case:  Single child black parent\n      //console.log(\"BLACK single child\")\n      if(n.left) {\n        swapNode(n, n.left)\n      } else if(n.right) {\n        swapNode(n, n.right)\n      }\n      //Child must be red, so repaint it black to balance color\n      n._color = BLACK\n      for(var i=0; i<cstack.length-1; ++i) {\n        cstack[i]._count--\n      }\n      return new RedBlackTree(this.tree._compare, cstack[0])\n    } else if(cstack.length === 1) {\n      //Third easy case: root\n      //console.log(\"ROOT\")\n      return new RedBlackTree(this.tree._compare, null)\n    } else {\n      //Hard case: Repaint n, and then do some nasty stuff\n      //console.log(\"BLACK leaf no children\")\n      for(var i=0; i<cstack.length; ++i) {\n        cstack[i]._count--\n      }\n      var parent = cstack[cstack.length-2]\n      fixDoubleBlack(cstack)\n      //Fix up links\n      if(parent.left === n) {\n        parent.left = null\n      } else {\n        parent.right = null\n      }\n    }\n  }\n  return new RedBlackTree(this.tree._compare, cstack[0])\n}\n\n//Returns key\nObject.defineProperty(iproto, \"key\", {\n  get: function() {\n    if(this._stack.length > 0) {\n      return this._stack[this._stack.length-1].key\n    }\n    return\n  },\n  enumerable: true\n})\n\n//Returns value\nObject.defineProperty(iproto, \"value\", {\n  get: function() {\n    if(this._stack.length > 0) {\n      return this._stack[this._stack.length-1].value\n    }\n    return\n  },\n  enumerable: true\n})\n\n\n//Returns the position of this iterator in the sorted list\nObject.defineProperty(iproto, \"index\", {\n  get: function() {\n    var idx = 0\n    var stack = this._stack\n    if(stack.length === 0) {\n      var r = this.tree.root\n      if(r) {\n        return r._count\n      }\n      return 0\n    } else if(stack[stack.length-1].left) {\n      idx = stack[stack.length-1].left._count\n    }\n    for(var s=stack.length-2; s>=0; --s) {\n      if(stack[s+1] === stack[s].right) {\n        ++idx\n        if(stack[s].left) {\n          idx += stack[s].left._count\n        }\n      }\n    }\n    return idx\n  },\n  enumerable: true\n})\n\n//Advances iterator to next element in list\niproto.next = function() {\n  var stack = this._stack\n  if(stack.length === 0) {\n    return\n  }\n  var n = stack[stack.length-1]\n  if(n.right) {\n    n = n.right\n    while(n) {\n      stack.push(n)\n      n = n.left\n    }\n  } else {\n    stack.pop()\n    while(stack.length > 0 && stack[stack.length-1].right === n) {\n      n = stack[stack.length-1]\n      stack.pop()\n    }\n  }\n}\n\n//Checks if iterator is at end of tree\nObject.defineProperty(iproto, \"hasNext\", {\n  get: function() {\n    var stack = this._stack\n    if(stack.length === 0) {\n      return false\n    }\n    if(stack[stack.length-1].right) {\n      return true\n    }\n    for(var s=stack.length-1; s>0; --s) {\n      if(stack[s-1].left === stack[s]) {\n        return true\n      }\n    }\n    return false\n  }\n})\n\n//Update value\niproto.update = function(value) {\n  var stack = this._stack\n  if(stack.length === 0) {\n    throw new Error(\"Can't update empty node!\")\n  }\n  var cstack = new Array(stack.length)\n  var n = stack[stack.length-1]\n  cstack[cstack.length-1] = new RBNode(n._color, n.key, value, n.left, n.right, n._count)\n  for(var i=stack.length-2; i>=0; --i) {\n    n = stack[i]\n    if(n.left === stack[i+1]) {\n      cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i+1], n.right, n._count)\n    } else {\n      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i+1], n._count)\n    }\n  }\n  return new RedBlackTree(this.tree._compare, cstack[0])\n}\n\n//Moves iterator backward one element\niproto.prev = function() {\n  var stack = this._stack\n  if(stack.length === 0) {\n    return\n  }\n  var n = stack[stack.length-1]\n  if(n.left) {\n    n = n.left\n    while(n) {\n      stack.push(n)\n      n = n.right\n    }\n  } else {\n    stack.pop()\n    while(stack.length > 0 && stack[stack.length-1].left === n) {\n      n = stack[stack.length-1]\n      stack.pop()\n    }\n  }\n}\n\n//Checks if iterator is at start of tree\nObject.defineProperty(iproto, \"hasPrev\", {\n  get: function() {\n    var stack = this._stack\n    if(stack.length === 0) {\n      return false\n    }\n    if(stack[stack.length-1].left) {\n      return true\n    }\n    for(var s=stack.length-1; s>0; --s) {\n      if(stack[s-1].right === stack[s]) {\n        return true\n      }\n    }\n    return false\n  }\n})\n\n//Default comparison function\nfunction defaultCompare(a, b) {\n  if(a < b) {\n    return -1\n  }\n  if(a > b) {\n    return 1\n  }\n  return 0\n}\n\n//Build a tree\nfunction createRBTree(compare) {\n  return new RedBlackTree(compare || defaultCompare, null)\n}\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/functional-red-black-tree/rbtree.js?");

/***/ }),

/***/ "./src/node_modules/gcs-resumable-upload/build/src/index.js":
/*!******************************************************************!*\
  !*** ./src/node_modules/gcs-resumable-upload/build/src/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst abort_controller_1 = __webpack_require__(/*! abort-controller */ \"abort-controller\");\nconst ConfigStore = __webpack_require__(/*! configstore */ \"configstore\");\nconst crypto_1 = __webpack_require__(/*! crypto */ \"crypto\");\nconst google_auth_library_1 = __webpack_require__(/*! google-auth-library */ \"google-auth-library\");\nconst Pumpify = __webpack_require__(/*! pumpify */ \"pumpify\");\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst streamEvents = __webpack_require__(/*! stream-events */ \"./src/node_modules/stream-events/index.js\");\nconst TERMINATED_UPLOAD_STATUS_CODE = 410;\nconst RESUMABLE_INCOMPLETE_STATUS_CODE = 308;\nconst RETRY_LIMIT = 5;\nclass Upload extends Pumpify {\n    constructor(cfg) {\n        super();\n        this.numBytesWritten = 0;\n        this.numRetries = 0;\n        streamEvents(this);\n        cfg = cfg || {};\n        if (!cfg.bucket || !cfg.file) {\n            throw new Error('A bucket and file name are required');\n        }\n        cfg.authConfig = cfg.authConfig || {};\n        cfg.authConfig.scopes = [\n            'https://www.googleapis.com/auth/devstorage.full_control',\n        ];\n        this.authClient = cfg.authClient || new google_auth_library_1.GoogleAuth(cfg.authConfig);\n        this.apiEndpoint = cfg.apiEndpoint || 'storage.googleapis.com';\n        this.bucket = cfg.bucket;\n        const cacheKeyElements = [cfg.bucket, cfg.file];\n        if (typeof cfg.generation === 'number') {\n            cacheKeyElements.push(`${cfg.generation}`);\n        }\n        this.cacheKey = cacheKeyElements.join('/');\n        this.file = cfg.file;\n        this.generation = cfg.generation;\n        this.kmsKeyName = cfg.kmsKeyName;\n        this.metadata = cfg.metadata || {};\n        this.offset = cfg.offset;\n        this.origin = cfg.origin;\n        this.params = cfg.params || {};\n        this.userProject = cfg.userProject;\n        if (cfg.key) {\n            /**\n             * NOTE: This is `as string` because there appears to be some weird kind\n             * of TypeScript bug as 2.8. Tracking the issue here:\n             * https://github.com/Microsoft/TypeScript/issues/23155\n             */\n            const base64Key = Buffer.from(cfg.key).toString('base64');\n            this.encryption = {\n                key: base64Key,\n                hash: crypto_1.createHash('sha256')\n                    .update(cfg.key)\n                    .digest('base64'),\n            };\n        }\n        this.predefinedAcl = cfg.predefinedAcl;\n        if (cfg.private)\n            this.predefinedAcl = 'private';\n        if (cfg.public)\n            this.predefinedAcl = 'publicRead';\n        const configPath = cfg.configPath;\n        this.configStore = new ConfigStore('gcs-resumable-upload', null, {\n            configPath,\n        });\n        this.uriProvidedManually = !!cfg.uri;\n        this.uri = cfg.uri || this.get('uri');\n        this.numBytesWritten = 0;\n        this.numRetries = 0;\n        const contentLength = cfg.metadata\n            ? Number(cfg.metadata.contentLength)\n            : NaN;\n        this.contentLength = isNaN(contentLength) ? '*' : contentLength;\n        this.once('writing', () => {\n            if (this.uri) {\n                this.continueUploading();\n            }\n            else {\n                this.createURI(err => {\n                    if (err) {\n                        return this.destroy(err);\n                    }\n                    this.startUploading();\n                });\n            }\n        });\n    }\n    get baseURI() {\n        return `https://${this.apiEndpoint}/upload/storage/v1/b`;\n    }\n    createURI(callback) {\n        if (!callback) {\n            return this.createURIAsync();\n        }\n        this.createURIAsync().then(r => callback(null, r), callback);\n    }\n    async createURIAsync() {\n        const metadata = this.metadata;\n        const reqOpts = {\n            method: 'POST',\n            url: [this.baseURI, this.bucket, 'o'].join('/'),\n            params: Object.assign({\n                name: this.file,\n                uploadType: 'resumable',\n            }, this.params),\n            data: metadata,\n            headers: {},\n        };\n        if (metadata.contentLength) {\n            reqOpts.headers['X-Upload-Content-Length'] = metadata.contentLength.toString();\n        }\n        if (metadata.contentType) {\n            reqOpts.headers['X-Upload-Content-Type'] = metadata.contentType;\n        }\n        if (typeof this.generation !== 'undefined') {\n            reqOpts.params.ifGenerationMatch = this.generation;\n        }\n        if (this.kmsKeyName) {\n            reqOpts.params.kmsKeyName = this.kmsKeyName;\n        }\n        if (this.predefinedAcl) {\n            reqOpts.params.predefinedAcl = this.predefinedAcl;\n        }\n        if (this.origin) {\n            reqOpts.headers.Origin = this.origin;\n        }\n        const resp = await this.makeRequest(reqOpts);\n        const uri = resp.headers.location;\n        this.uri = uri;\n        this.set({ uri });\n        this.offset = 0;\n        return uri;\n    }\n    async continueUploading() {\n        if (typeof this.offset === 'number') {\n            this.startUploading();\n            return;\n        }\n        await this.getAndSetOffset();\n        this.startUploading();\n    }\n    async startUploading() {\n        // The buffer stream allows us to keep chunks in memory\n        // until we are sure we can successfully resume the upload.\n        const bufferStream = this.bufferStream || new stream_1.PassThrough();\n        this.bufferStream = bufferStream;\n        // The offset stream allows us to analyze each incoming\n        // chunk to analyze it against what the upstream API already\n        // has stored for this upload.\n        const offsetStream = (this.offsetStream = new stream_1.Transform({\n            transform: this.onChunk.bind(this),\n        }));\n        // The delay stream gives us a chance to catch the response\n        // from the API request before we signal to the user that\n        // the upload was successful.\n        const delayStream = new stream_1.PassThrough();\n        // The request library (authClient.request()) requires the\n        // stream to be sent within the request options.\n        const requestStreamEmbeddedStream = new stream_1.PassThrough();\n        delayStream.on('prefinish', () => {\n            // Pause the stream from finishing so we can process the\n            // response from the API.\n            this.cork();\n        });\n        // Process the API response to look for errors that came in\n        // the response body.\n        this.on('response', (resp) => {\n            if (resp.data.error) {\n                this.destroy(resp.data.error);\n                return;\n            }\n            if (resp.status < 200 || resp.status > 299) {\n                this.destroy(new Error('Upload failed'));\n                return;\n            }\n            if (resp && resp.data) {\n                resp.data.size = Number(resp.data.size);\n            }\n            this.emit('metadata', resp.data);\n            this.deleteConfig();\n            // Allow the stream to continue naturally so the user's\n            // \"finish\" event fires.\n            this.uncork();\n        });\n        this.setPipeline(bufferStream, offsetStream, delayStream);\n        this.pipe(requestStreamEmbeddedStream);\n        this.once('restart', () => {\n            // The upload is being re-attempted. Disconnect the request\n            // stream, so it won't receive more data.\n            this.unpipe(requestStreamEmbeddedStream);\n        });\n        const reqOpts = {\n            method: 'PUT',\n            url: this.uri,\n            headers: {\n                'Content-Range': 'bytes ' + this.offset + '-*/' + this.contentLength,\n            },\n            body: requestStreamEmbeddedStream,\n        };\n        try {\n            await this.makeRequestStream(reqOpts);\n        }\n        catch (e) {\n            this.destroy(e);\n        }\n    }\n    onChunk(chunk, enc, next) {\n        const offset = this.offset;\n        const numBytesWritten = this.numBytesWritten;\n        this.emit('progress', {\n            bytesWritten: this.numBytesWritten,\n            contentLength: this.contentLength,\n        });\n        // check if this is the same content uploaded previously. this caches a\n        // slice of the first chunk, then compares it with the first byte of\n        // incoming data\n        if (numBytesWritten === 0) {\n            let cachedFirstChunk = this.get('firstChunk');\n            const firstChunk = chunk.slice(0, 16).valueOf();\n            if (!cachedFirstChunk) {\n                // This is a new upload. Cache the first chunk.\n                this.set({ uri: this.uri, firstChunk });\n            }\n            else {\n                // this continues an upload in progress. check if the bytes are the same\n                cachedFirstChunk = Buffer.from(cachedFirstChunk);\n                const nextChunk = Buffer.from(firstChunk);\n                if (Buffer.compare(cachedFirstChunk, nextChunk) !== 0) {\n                    // this data is not the same. start a new upload\n                    this.bufferStream.unshift(chunk);\n                    this.bufferStream.unpipe(this.offsetStream);\n                    this.restart();\n                    return;\n                }\n            }\n        }\n        let length = chunk.length;\n        if (typeof chunk === 'string')\n            length = Buffer.byteLength(chunk, enc);\n        if (numBytesWritten < offset)\n            chunk = chunk.slice(offset - numBytesWritten);\n        this.numBytesWritten += length;\n        // only push data from the byte after the one we left off on\n        next(undefined, this.numBytesWritten > offset ? chunk : undefined);\n    }\n    async getAndSetOffset() {\n        const opts = {\n            method: 'PUT',\n            url: this.uri,\n            headers: { 'Content-Length': 0, 'Content-Range': 'bytes */*' },\n        };\n        try {\n            const resp = await this.makeRequest(opts);\n            if (resp.status === RESUMABLE_INCOMPLETE_STATUS_CODE) {\n                if (resp.headers.range) {\n                    const range = resp.headers.range;\n                    this.offset = Number(range.split('-')[1]) + 1;\n                    return;\n                }\n            }\n            this.offset = 0;\n        }\n        catch (err) {\n            const resp = err.response;\n            // we don't return a 404 to the user if they provided the resumable\n            // URI. if we're just using the configstore file to tell us that this\n            // file exists, and it turns out that it doesn't (the 404), that's\n            // probably stale config data.\n            if (resp && resp.status === 404 && !this.uriProvidedManually) {\n                this.restart();\n                return;\n            }\n            // this resumable upload is unrecoverable (bad data or service error).\n            //  -\n            //  https://github.com/stephenplusplus/gcs-resumable-upload/issues/15\n            //  -\n            //  https://github.com/stephenplusplus/gcs-resumable-upload/pull/16#discussion_r80363774\n            if (resp && resp.status === TERMINATED_UPLOAD_STATUS_CODE) {\n                this.restart();\n                return;\n            }\n            this.destroy(err);\n        }\n    }\n    async makeRequest(reqOpts) {\n        if (this.encryption) {\n            reqOpts.headers = reqOpts.headers || {};\n            reqOpts.headers['x-goog-encryption-algorithm'] = 'AES256';\n            reqOpts.headers['x-goog-encryption-key'] = this.encryption.key.toString();\n            reqOpts.headers['x-goog-encryption-key-sha256'] = this.encryption.hash.toString();\n        }\n        if (this.userProject) {\n            reqOpts.params = reqOpts.params || {};\n            reqOpts.params.userProject = this.userProject;\n        }\n        // Let gaxios know we will handle a 308 error code ourselves.\n        reqOpts.validateStatus = (status) => {\n            return ((status >= 200 && status < 300) ||\n                status === RESUMABLE_INCOMPLETE_STATUS_CODE);\n        };\n        const res = await this.authClient.request(reqOpts);\n        if (res.data && res.data.error) {\n            throw res.data.error;\n        }\n        return res;\n    }\n    async makeRequestStream(reqOpts) {\n        const controller = new abort_controller_1.default();\n        this.once('error', () => controller.abort());\n        if (this.userProject) {\n            reqOpts.params = reqOpts.params || {};\n            reqOpts.params.userProject = this.userProject;\n        }\n        reqOpts.signal = controller.signal;\n        reqOpts.validateStatus = () => true;\n        const res = await this.authClient.request(reqOpts);\n        this.onResponse(res);\n        return res;\n    }\n    restart() {\n        this.emit('restart');\n        this.numBytesWritten = 0;\n        this.deleteConfig();\n        this.createURI(err => {\n            if (err) {\n                return this.destroy(err);\n            }\n            this.startUploading();\n        });\n    }\n    get(prop) {\n        const store = this.configStore.get(this.cacheKey);\n        return store && store[prop];\n    }\n    // tslint:disable-next-line no-any\n    set(props) {\n        this.configStore.set(this.cacheKey, props);\n    }\n    deleteConfig() {\n        this.configStore.delete(this.cacheKey);\n    }\n    /**\n     * @return {bool} is the request good?\n     */\n    onResponse(resp) {\n        if (resp.status === 404) {\n            if (this.numRetries < RETRY_LIMIT) {\n                this.numRetries++;\n                this.startUploading();\n            }\n            else {\n                this.destroy(new Error('Retry limit exceeded - ' + resp.data));\n            }\n            return false;\n        }\n        if (resp.status > 499 && resp.status < 600) {\n            if (this.numRetries < RETRY_LIMIT) {\n                const randomMs = Math.round(Math.random() * 1000);\n                const waitTime = Math.pow(2, this.numRetries) * 1000 + randomMs;\n                this.numRetries++;\n                setTimeout(this.continueUploading.bind(this), waitTime);\n            }\n            else {\n                this.destroy(new Error('Retry limit exceeded - ' + resp.data));\n            }\n            return false;\n        }\n        this.emit('response', resp);\n        return true;\n    }\n}\nexports.Upload = Upload;\nfunction upload(cfg) {\n    return new Upload(cfg);\n}\nexports.upload = upload;\nfunction createURI(cfg, callback) {\n    const up = new Upload(cfg);\n    if (!callback) {\n        return up.createURI();\n    }\n    up.createURI().then(r => callback(null, r), callback);\n}\nexports.createURI = createURI;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/gcs-resumable-upload/build/src/index.js?");

/***/ }),

/***/ "./src/node_modules/hash-stream-validation/crc32c.js":
/*!***********************************************************!*\
  !*** ./src/node_modules/hash-stream-validation/crc32c.js ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";
eval("// Original author:\n// https://github.com/ashi009/node-fast-crc32c/blob/5e7f9d63cfdb3de9b6c34577466de3dfd732c25d/impls/js_crc32c.js\n\n\n\nvar kCRCTable = new Int32Array([\n  0x00000000, 0xf26b8303, 0xe13b70f7, 0x1350f3f4,\n  0xc79a971f, 0x35f1141c, 0x26a1e7e8, 0xd4ca64eb,\n  0x8ad958cf, 0x78b2dbcc, 0x6be22838, 0x9989ab3b,\n  0x4d43cfd0, 0xbf284cd3, 0xac78bf27, 0x5e133c24,\n  0x105ec76f, 0xe235446c, 0xf165b798, 0x030e349b,\n  0xd7c45070, 0x25afd373, 0x36ff2087, 0xc494a384,\n  0x9a879fa0, 0x68ec1ca3, 0x7bbcef57, 0x89d76c54,\n  0x5d1d08bf, 0xaf768bbc, 0xbc267848, 0x4e4dfb4b,\n  0x20bd8ede, 0xd2d60ddd, 0xc186fe29, 0x33ed7d2a,\n  0xe72719c1, 0x154c9ac2, 0x061c6936, 0xf477ea35,\n  0xaa64d611, 0x580f5512, 0x4b5fa6e6, 0xb93425e5,\n  0x6dfe410e, 0x9f95c20d, 0x8cc531f9, 0x7eaeb2fa,\n  0x30e349b1, 0xc288cab2, 0xd1d83946, 0x23b3ba45,\n  0xf779deae, 0x05125dad, 0x1642ae59, 0xe4292d5a,\n  0xba3a117e, 0x4851927d, 0x5b016189, 0xa96ae28a,\n  0x7da08661, 0x8fcb0562, 0x9c9bf696, 0x6ef07595,\n  0x417b1dbc, 0xb3109ebf, 0xa0406d4b, 0x522bee48,\n  0x86e18aa3, 0x748a09a0, 0x67dafa54, 0x95b17957,\n  0xcba24573, 0x39c9c670, 0x2a993584, 0xd8f2b687,\n  0x0c38d26c, 0xfe53516f, 0xed03a29b, 0x1f682198,\n  0x5125dad3, 0xa34e59d0, 0xb01eaa24, 0x42752927,\n  0x96bf4dcc, 0x64d4cecf, 0x77843d3b, 0x85efbe38,\n  0xdbfc821c, 0x2997011f, 0x3ac7f2eb, 0xc8ac71e8,\n  0x1c661503, 0xee0d9600, 0xfd5d65f4, 0x0f36e6f7,\n  0x61c69362, 0x93ad1061, 0x80fde395, 0x72966096,\n  0xa65c047d, 0x5437877e, 0x4767748a, 0xb50cf789,\n  0xeb1fcbad, 0x197448ae, 0x0a24bb5a, 0xf84f3859,\n  0x2c855cb2, 0xdeeedfb1, 0xcdbe2c45, 0x3fd5af46,\n  0x7198540d, 0x83f3d70e, 0x90a324fa, 0x62c8a7f9,\n  0xb602c312, 0x44694011, 0x5739b3e5, 0xa55230e6,\n  0xfb410cc2, 0x092a8fc1, 0x1a7a7c35, 0xe811ff36,\n  0x3cdb9bdd, 0xceb018de, 0xdde0eb2a, 0x2f8b6829,\n  0x82f63b78, 0x709db87b, 0x63cd4b8f, 0x91a6c88c,\n  0x456cac67, 0xb7072f64, 0xa457dc90, 0x563c5f93,\n  0x082f63b7, 0xfa44e0b4, 0xe9141340, 0x1b7f9043,\n  0xcfb5f4a8, 0x3dde77ab, 0x2e8e845f, 0xdce5075c,\n  0x92a8fc17, 0x60c37f14, 0x73938ce0, 0x81f80fe3,\n  0x55326b08, 0xa759e80b, 0xb4091bff, 0x466298fc,\n  0x1871a4d8, 0xea1a27db, 0xf94ad42f, 0x0b21572c,\n  0xdfeb33c7, 0x2d80b0c4, 0x3ed04330, 0xccbbc033,\n  0xa24bb5a6, 0x502036a5, 0x4370c551, 0xb11b4652,\n  0x65d122b9, 0x97baa1ba, 0x84ea524e, 0x7681d14d,\n  0x2892ed69, 0xdaf96e6a, 0xc9a99d9e, 0x3bc21e9d,\n  0xef087a76, 0x1d63f975, 0x0e330a81, 0xfc588982,\n  0xb21572c9, 0x407ef1ca, 0x532e023e, 0xa145813d,\n  0x758fe5d6, 0x87e466d5, 0x94b49521, 0x66df1622,\n  0x38cc2a06, 0xcaa7a905, 0xd9f75af1, 0x2b9cd9f2,\n  0xff56bd19, 0x0d3d3e1a, 0x1e6dcdee, 0xec064eed,\n  0xc38d26c4, 0x31e6a5c7, 0x22b65633, 0xd0ddd530,\n  0x0417b1db, 0xf67c32d8, 0xe52cc12c, 0x1747422f,\n  0x49547e0b, 0xbb3ffd08, 0xa86f0efc, 0x5a048dff,\n  0x8ecee914, 0x7ca56a17, 0x6ff599e3, 0x9d9e1ae0,\n  0xd3d3e1ab, 0x21b862a8, 0x32e8915c, 0xc083125f,\n  0x144976b4, 0xe622f5b7, 0xf5720643, 0x07198540,\n  0x590ab964, 0xab613a67, 0xb831c993, 0x4a5a4a90,\n  0x9e902e7b, 0x6cfbad78, 0x7fab5e8c, 0x8dc0dd8f,\n  0xe330a81a, 0x115b2b19, 0x020bd8ed, 0xf0605bee,\n  0x24aa3f05, 0xd6c1bc06, 0xc5914ff2, 0x37faccf1,\n  0x69e9f0d5, 0x9b8273d6, 0x88d28022, 0x7ab90321,\n  0xae7367ca, 0x5c18e4c9, 0x4f48173d, 0xbd23943e,\n  0xf36e6f75, 0x0105ec76, 0x12551f82, 0xe03e9c81,\n  0x34f4f86a, 0xc69f7b69, 0xd5cf889d, 0x27a40b9e,\n  0x79b737ba, 0x8bdcb4b9, 0x988c474d, 0x6ae7c44e,\n  0xbe2da0a5, 0x4c4623a6, 0x5f16d052, 0xad7d5351\n])\n\nmodule.exports = {\n  calculate: function (buf, initial) {\n    if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n\n    var crc = (initial | 0) ^ -1\n    for (var i = 0; i < buf.length; i++)\n      crc = kCRCTable[(crc ^ buf[i]) & 0xff] ^ (crc >>> 8)\n\n    return (crc ^ -1) >>> 0\n  }\n}\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/hash-stream-validation/crc32c.js?");

/***/ }),

/***/ "./src/node_modules/hash-stream-validation/index.js":
/*!**********************************************************!*\
  !*** ./src/node_modules/hash-stream-validation/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar crc\ntry {\n  crc = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fast-crc32c'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))\n} catch (e) {\n  crc = __webpack_require__(/*! ./crc32c.js */ \"./src/node_modules/hash-stream-validation/crc32c.js\")\n}\n\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\")\nvar { PassThrough } = __webpack_require__(/*! stream */ \"stream\")\n\nmodule.exports = function (cfg) {\n  cfg = cfg || {}\n\n  var crc32c = cfg.crc32c !== false\n  var md5 = cfg.md5 !== false\n\n  var hashes = {}\n  if (md5) hashes.md5 = crypto.createHash('md5')\n\n  var onData = function (chunk, enc, done) {\n    if (crc32c) hashes.crc32c = crc.calculate(chunk, hashes.crc32c || 0)\n    if (md5) hashes.md5.update(chunk)\n\n    done(null, chunk)\n  }\n\n  var onFlush = function (done) {\n    if (crc32c) hashes.crc32c = Buffer.from([hashes.crc32c]).toString('base64')\n    if (md5) hashes.md5 = hashes.md5.digest('base64')\n\n    done()\n  }\n\n  var validationStream = new PassThrough({\n    transform: onData,\n    flush: onFlush\n  })\n\n  validationStream.test = function (algo, sum) {\n    return hashes[algo] === sum\n  }\n\n  return validationStream\n}\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/hash-stream-validation/index.js?");

/***/ }),

/***/ "./src/node_modules/htmlparser2/lib/FeedHandler.js":
/*!*********************************************************!*\
  !*** ./src/node_modules/htmlparser2/lib/FeedHandler.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseFeed = exports.FeedHandler = void 0;\nvar domhandler_1 = __importDefault(__webpack_require__(/*! domhandler */ \"./src/node_modules/domhandler/lib/index.js\"));\nvar DomUtils = __importStar(__webpack_require__(/*! domutils */ \"./src/node_modules/domutils/lib/index.js\"));\nvar Parser_1 = __webpack_require__(/*! ./Parser */ \"./src/node_modules/htmlparser2/lib/Parser.js\");\nvar FeedItemMediaMedium;\n(function (FeedItemMediaMedium) {\n    FeedItemMediaMedium[FeedItemMediaMedium[\"image\"] = 0] = \"image\";\n    FeedItemMediaMedium[FeedItemMediaMedium[\"audio\"] = 1] = \"audio\";\n    FeedItemMediaMedium[FeedItemMediaMedium[\"video\"] = 2] = \"video\";\n    FeedItemMediaMedium[FeedItemMediaMedium[\"document\"] = 3] = \"document\";\n    FeedItemMediaMedium[FeedItemMediaMedium[\"executable\"] = 4] = \"executable\";\n})(FeedItemMediaMedium || (FeedItemMediaMedium = {}));\nvar FeedItemMediaExpression;\n(function (FeedItemMediaExpression) {\n    FeedItemMediaExpression[FeedItemMediaExpression[\"sample\"] = 0] = \"sample\";\n    FeedItemMediaExpression[FeedItemMediaExpression[\"full\"] = 1] = \"full\";\n    FeedItemMediaExpression[FeedItemMediaExpression[\"nonstop\"] = 2] = \"nonstop\";\n})(FeedItemMediaExpression || (FeedItemMediaExpression = {}));\n// TODO: Consume data as it is coming in\nvar FeedHandler = /** @class */ (function (_super) {\n    __extends(FeedHandler, _super);\n    /**\n     *\n     * @param callback\n     * @param options\n     */\n    function FeedHandler(callback, options) {\n        var _this = this;\n        if (typeof callback === \"object\") {\n            callback = undefined;\n            options = callback;\n        }\n        _this = _super.call(this, callback, options) || this;\n        return _this;\n    }\n    FeedHandler.prototype.onend = function () {\n        var _a, _b;\n        var feedRoot = getOneElement(isValidFeed, this.dom);\n        if (!feedRoot) {\n            this.handleCallback(new Error(\"couldn't find root of feed\"));\n            return;\n        }\n        var feed = {};\n        if (feedRoot.name === \"feed\") {\n            var childs = feedRoot.children;\n            feed.type = \"atom\";\n            addConditionally(feed, \"id\", \"id\", childs);\n            addConditionally(feed, \"title\", \"title\", childs);\n            var href = getAttribute(\"href\", getOneElement(\"link\", childs));\n            if (href) {\n                feed.link = href;\n            }\n            addConditionally(feed, \"description\", \"subtitle\", childs);\n            var updated = fetch(\"updated\", childs);\n            if (updated) {\n                feed.updated = new Date(updated);\n            }\n            addConditionally(feed, \"author\", \"email\", childs, true);\n            feed.items = getElements(\"entry\", childs).map(function (item) {\n                var entry = {};\n                var children = item.children;\n                addConditionally(entry, \"id\", \"id\", children);\n                addConditionally(entry, \"title\", \"title\", children);\n                var href = getAttribute(\"href\", getOneElement(\"link\", children));\n                if (href) {\n                    entry.link = href;\n                }\n                var description = fetch(\"summary\", children) || fetch(\"content\", children);\n                if (description) {\n                    entry.description = description;\n                }\n                var pubDate = fetch(\"updated\", children);\n                if (pubDate) {\n                    entry.pubDate = new Date(pubDate);\n                }\n                entry.media = getMediaElements(children);\n                return entry;\n            });\n        }\n        else {\n            var childs = (_b = (_a = getOneElement(\"channel\", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];\n            feed.type = feedRoot.name.substr(0, 3);\n            feed.id = \"\";\n            addConditionally(feed, \"title\", \"title\", childs);\n            addConditionally(feed, \"link\", \"link\", childs);\n            addConditionally(feed, \"description\", \"description\", childs);\n            var updated = fetch(\"lastBuildDate\", childs);\n            if (updated) {\n                feed.updated = new Date(updated);\n            }\n            addConditionally(feed, \"author\", \"managingEditor\", childs, true);\n            feed.items = getElements(\"item\", feedRoot.children).map(function (item) {\n                var entry = {};\n                var children = item.children;\n                addConditionally(entry, \"id\", \"guid\", children);\n                addConditionally(entry, \"title\", \"title\", children);\n                addConditionally(entry, \"link\", \"link\", children);\n                addConditionally(entry, \"description\", \"description\", children);\n                var pubDate = fetch(\"pubDate\", children);\n                if (pubDate)\n                    entry.pubDate = new Date(pubDate);\n                entry.media = getMediaElements(children);\n                return entry;\n            });\n        }\n        this.feed = feed;\n        this.handleCallback(null);\n    };\n    return FeedHandler;\n}(domhandler_1.default));\nexports.FeedHandler = FeedHandler;\nfunction getMediaElements(where) {\n    return getElements(\"media:content\", where).map(function (elem) {\n        var media = {\n            medium: elem.attribs.medium,\n            isDefault: !!elem.attribs.isDefault,\n        };\n        if (elem.attribs.url) {\n            media.url = elem.attribs.url;\n        }\n        if (elem.attribs.fileSize) {\n            media.fileSize = parseInt(elem.attribs.fileSize, 10);\n        }\n        if (elem.attribs.type) {\n            media.type = elem.attribs.type;\n        }\n        if (elem.attribs.expression) {\n            media.expression = elem.attribs\n                .expression;\n        }\n        if (elem.attribs.bitrate) {\n            media.bitrate = parseInt(elem.attribs.bitrate, 10);\n        }\n        if (elem.attribs.framerate) {\n            media.framerate = parseInt(elem.attribs.framerate, 10);\n        }\n        if (elem.attribs.samplingrate) {\n            media.samplingrate = parseInt(elem.attribs.samplingrate, 10);\n        }\n        if (elem.attribs.channels) {\n            media.channels = parseInt(elem.attribs.channels, 10);\n        }\n        if (elem.attribs.duration) {\n            media.duration = parseInt(elem.attribs.duration, 10);\n        }\n        if (elem.attribs.height) {\n            media.height = parseInt(elem.attribs.height, 10);\n        }\n        if (elem.attribs.width) {\n            media.width = parseInt(elem.attribs.width, 10);\n        }\n        if (elem.attribs.lang) {\n            media.lang = elem.attribs.lang;\n        }\n        return media;\n    });\n}\nfunction getElements(tagName, where) {\n    return DomUtils.getElementsByTagName(tagName, where, true);\n}\nfunction getOneElement(tagName, node) {\n    return DomUtils.getElementsByTagName(tagName, node, true, 1)[0];\n}\nfunction fetch(tagName, where, recurse) {\n    if (recurse === void 0) { recurse = false; }\n    return DomUtils.getText(DomUtils.getElementsByTagName(tagName, where, recurse, 1)).trim();\n}\nfunction getAttribute(name, elem) {\n    if (!elem) {\n        return null;\n    }\n    var attribs = elem.attribs;\n    return attribs[name];\n}\nfunction addConditionally(obj, prop, what, where, recurse) {\n    if (recurse === void 0) { recurse = false; }\n    var tmp = fetch(what, where, recurse);\n    if (tmp)\n        obj[prop] = tmp;\n}\nfunction isValidFeed(value) {\n    return value === \"rss\" || value === \"feed\" || value === \"rdf:RDF\";\n}\n/**\n * Parse a feed.\n *\n * @param feed The feed that should be parsed, as a string.\n * @param options Optionally, options for parsing. When using this option, you should set `xmlMode` to `true`.\n */\nfunction parseFeed(feed, options) {\n    if (options === void 0) { options = { xmlMode: true }; }\n    var handler = new FeedHandler(options);\n    new Parser_1.Parser(handler, options).end(feed);\n    return handler.feed;\n}\nexports.parseFeed = parseFeed;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/htmlparser2/lib/FeedHandler.js?");

/***/ }),

/***/ "./src/node_modules/htmlparser2/lib/Parser.js":
/*!****************************************************!*\
  !*** ./src/node_modules/htmlparser2/lib/Parser.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Parser = void 0;\nvar Tokenizer_1 = __importDefault(__webpack_require__(/*! ./Tokenizer */ \"./src/node_modules/htmlparser2/lib/Tokenizer.js\"));\nvar formTags = new Set([\n    \"input\",\n    \"option\",\n    \"optgroup\",\n    \"select\",\n    \"button\",\n    \"datalist\",\n    \"textarea\",\n]);\nvar pTag = new Set([\"p\"]);\nvar openImpliesClose = {\n    tr: new Set([\"tr\", \"th\", \"td\"]),\n    th: new Set([\"th\"]),\n    td: new Set([\"thead\", \"th\", \"td\"]),\n    body: new Set([\"head\", \"link\", \"script\"]),\n    li: new Set([\"li\"]),\n    p: pTag,\n    h1: pTag,\n    h2: pTag,\n    h3: pTag,\n    h4: pTag,\n    h5: pTag,\n    h6: pTag,\n    select: formTags,\n    input: formTags,\n    output: formTags,\n    button: formTags,\n    datalist: formTags,\n    textarea: formTags,\n    option: new Set([\"option\"]),\n    optgroup: new Set([\"optgroup\", \"option\"]),\n    dd: new Set([\"dt\", \"dd\"]),\n    dt: new Set([\"dt\", \"dd\"]),\n    address: pTag,\n    article: pTag,\n    aside: pTag,\n    blockquote: pTag,\n    details: pTag,\n    div: pTag,\n    dl: pTag,\n    fieldset: pTag,\n    figcaption: pTag,\n    figure: pTag,\n    footer: pTag,\n    form: pTag,\n    header: pTag,\n    hr: pTag,\n    main: pTag,\n    nav: pTag,\n    ol: pTag,\n    pre: pTag,\n    section: pTag,\n    table: pTag,\n    ul: pTag,\n    rt: new Set([\"rt\", \"rp\"]),\n    rp: new Set([\"rt\", \"rp\"]),\n    tbody: new Set([\"thead\", \"tbody\"]),\n    tfoot: new Set([\"thead\", \"tbody\"]),\n};\nvar voidElements = new Set([\n    \"area\",\n    \"base\",\n    \"basefont\",\n    \"br\",\n    \"col\",\n    \"command\",\n    \"embed\",\n    \"frame\",\n    \"hr\",\n    \"img\",\n    \"input\",\n    \"isindex\",\n    \"keygen\",\n    \"link\",\n    \"meta\",\n    \"param\",\n    \"source\",\n    \"track\",\n    \"wbr\",\n]);\nvar foreignContextElements = new Set([\"math\", \"svg\"]);\nvar htmlIntegrationElements = new Set([\n    \"mi\",\n    \"mo\",\n    \"mn\",\n    \"ms\",\n    \"mtext\",\n    \"annotation-xml\",\n    \"foreignObject\",\n    \"desc\",\n    \"title\",\n]);\nvar reNameEnd = /\\s|\\//;\nvar Parser = /** @class */ (function () {\n    function Parser(cbs, options) {\n        if (options === void 0) { options = {}; }\n        var _a, _b, _c, _d, _e;\n        /** The start index of the last event. */\n        this.startIndex = 0;\n        /** The end index of the last event. */\n        this.endIndex = null;\n        this.tagname = \"\";\n        this.attribname = \"\";\n        this.attribvalue = \"\";\n        this.attribs = null;\n        this.stack = [];\n        this.foreignContext = [];\n        this.options = options;\n        this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};\n        this.lowerCaseTagNames = (_a = options.lowerCaseTags) !== null && _a !== void 0 ? _a : !options.xmlMode;\n        this.lowerCaseAttributeNames =\n            (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options.xmlMode;\n        this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer_1.default)(this.options, this);\n        (_e = (_d = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d, this);\n    }\n    Parser.prototype.updatePosition = function (initialOffset) {\n        if (this.endIndex === null) {\n            if (this.tokenizer.sectionStart <= initialOffset) {\n                this.startIndex = 0;\n            }\n            else {\n                this.startIndex = this.tokenizer.sectionStart - initialOffset;\n            }\n        }\n        else {\n            this.startIndex = this.endIndex + 1;\n        }\n        this.endIndex = this.tokenizer.getAbsoluteIndex();\n    };\n    // Tokenizer event handlers\n    Parser.prototype.ontext = function (data) {\n        var _a, _b;\n        this.updatePosition(1);\n        this.endIndex--;\n        (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, data);\n    };\n    Parser.prototype.onopentagname = function (name) {\n        var _a, _b;\n        if (this.lowerCaseTagNames) {\n            name = name.toLowerCase();\n        }\n        this.tagname = name;\n        if (!this.options.xmlMode &&\n            Object.prototype.hasOwnProperty.call(openImpliesClose, name)) {\n            var el = void 0;\n            while (this.stack.length > 0 &&\n                openImpliesClose[name].has((el = this.stack[this.stack.length - 1]))) {\n                this.onclosetag(el);\n            }\n        }\n        if (this.options.xmlMode || !voidElements.has(name)) {\n            this.stack.push(name);\n            if (foreignContextElements.has(name)) {\n                this.foreignContext.push(true);\n            }\n            else if (htmlIntegrationElements.has(name)) {\n                this.foreignContext.push(false);\n            }\n        }\n        (_b = (_a = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a, name);\n        if (this.cbs.onopentag)\n            this.attribs = {};\n    };\n    Parser.prototype.onopentagend = function () {\n        var _a, _b;\n        this.updatePosition(1);\n        if (this.attribs) {\n            (_b = (_a = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a, this.tagname, this.attribs);\n            this.attribs = null;\n        }\n        if (!this.options.xmlMode &&\n            this.cbs.onclosetag &&\n            voidElements.has(this.tagname)) {\n            this.cbs.onclosetag(this.tagname);\n        }\n        this.tagname = \"\";\n    };\n    Parser.prototype.onclosetag = function (name) {\n        this.updatePosition(1);\n        if (this.lowerCaseTagNames) {\n            name = name.toLowerCase();\n        }\n        if (foreignContextElements.has(name) ||\n            htmlIntegrationElements.has(name)) {\n            this.foreignContext.pop();\n        }\n        if (this.stack.length &&\n            (this.options.xmlMode || !voidElements.has(name))) {\n            var pos = this.stack.lastIndexOf(name);\n            if (pos !== -1) {\n                if (this.cbs.onclosetag) {\n                    pos = this.stack.length - pos;\n                    while (pos--) {\n                        // We know the stack has sufficient elements.\n                        this.cbs.onclosetag(this.stack.pop());\n                    }\n                }\n                else\n                    this.stack.length = pos;\n            }\n            else if (name === \"p\" && !this.options.xmlMode) {\n                this.onopentagname(name);\n                this.closeCurrentTag();\n            }\n        }\n        else if (!this.options.xmlMode && (name === \"br\" || name === \"p\")) {\n            this.onopentagname(name);\n            this.closeCurrentTag();\n        }\n    };\n    Parser.prototype.onselfclosingtag = function () {\n        if (this.options.xmlMode ||\n            this.options.recognizeSelfClosing ||\n            this.foreignContext[this.foreignContext.length - 1]) {\n            this.closeCurrentTag();\n        }\n        else {\n            this.onopentagend();\n        }\n    };\n    Parser.prototype.closeCurrentTag = function () {\n        var _a, _b;\n        var name = this.tagname;\n        this.onopentagend();\n        /*\n         * Self-closing tags will be on the top of the stack\n         * (cheaper check than in onclosetag)\n         */\n        if (this.stack[this.stack.length - 1] === name) {\n            (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, name);\n            this.stack.pop();\n        }\n    };\n    Parser.prototype.onattribname = function (name) {\n        if (this.lowerCaseAttributeNames) {\n            name = name.toLowerCase();\n        }\n        this.attribname = name;\n    };\n    Parser.prototype.onattribdata = function (value) {\n        this.attribvalue += value;\n    };\n    Parser.prototype.onattribend = function (quote) {\n        var _a, _b;\n        (_b = (_a = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a, this.attribname, this.attribvalue, quote);\n        if (this.attribs &&\n            !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {\n            this.attribs[this.attribname] = this.attribvalue;\n        }\n        this.attribname = \"\";\n        this.attribvalue = \"\";\n    };\n    Parser.prototype.getInstructionName = function (value) {\n        var idx = value.search(reNameEnd);\n        var name = idx < 0 ? value : value.substr(0, idx);\n        if (this.lowerCaseTagNames) {\n            name = name.toLowerCase();\n        }\n        return name;\n    };\n    Parser.prototype.ondeclaration = function (value) {\n        if (this.cbs.onprocessinginstruction) {\n            var name_1 = this.getInstructionName(value);\n            this.cbs.onprocessinginstruction(\"!\" + name_1, \"!\" + value);\n        }\n    };\n    Parser.prototype.onprocessinginstruction = function (value) {\n        if (this.cbs.onprocessinginstruction) {\n            var name_2 = this.getInstructionName(value);\n            this.cbs.onprocessinginstruction(\"?\" + name_2, \"?\" + value);\n        }\n    };\n    Parser.prototype.oncomment = function (value) {\n        var _a, _b, _c, _d;\n        this.updatePosition(4);\n        (_b = (_a = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a, value);\n        (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);\n    };\n    Parser.prototype.oncdata = function (value) {\n        var _a, _b, _c, _d, _e, _f;\n        this.updatePosition(1);\n        if (this.options.xmlMode || this.options.recognizeCDATA) {\n            (_b = (_a = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a);\n            (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);\n            (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);\n        }\n        else {\n            this.oncomment(\"[CDATA[\" + value + \"]]\");\n        }\n    };\n    Parser.prototype.onerror = function (err) {\n        var _a, _b;\n        (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, err);\n    };\n    Parser.prototype.onend = function () {\n        var _a, _b;\n        if (this.cbs.onclosetag) {\n            for (var i = this.stack.length; i > 0; this.cbs.onclosetag(this.stack[--i]))\n                ;\n        }\n        (_b = (_a = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a);\n    };\n    /**\n     * Resets the parser to a blank state, ready to parse a new HTML document\n     */\n    Parser.prototype.reset = function () {\n        var _a, _b, _c, _d;\n        (_b = (_a = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a);\n        this.tokenizer.reset();\n        this.tagname = \"\";\n        this.attribname = \"\";\n        this.attribs = null;\n        this.stack = [];\n        (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);\n    };\n    /**\n     * Resets the parser, then parses a complete document and\n     * pushes it to the handler.\n     *\n     * @param data Document to parse.\n     */\n    Parser.prototype.parseComplete = function (data) {\n        this.reset();\n        this.end(data);\n    };\n    /**\n     * Parses a chunk of data and calls the corresponding callbacks.\n     *\n     * @param chunk Chunk to parse.\n     */\n    Parser.prototype.write = function (chunk) {\n        this.tokenizer.write(chunk);\n    };\n    /**\n     * Parses the end of the buffer and clears the stack, calls onend.\n     *\n     * @param chunk Optional final chunk to parse.\n     */\n    Parser.prototype.end = function (chunk) {\n        this.tokenizer.end(chunk);\n    };\n    /**\n     * Pauses parsing. The parser won't emit events until `resume` is called.\n     */\n    Parser.prototype.pause = function () {\n        this.tokenizer.pause();\n    };\n    /**\n     * Resumes parsing after `pause` was called.\n     */\n    Parser.prototype.resume = function () {\n        this.tokenizer.resume();\n    };\n    /**\n     * Alias of `write`, for backwards compatibility.\n     *\n     * @param chunk Chunk to parse.\n     * @deprecated\n     */\n    Parser.prototype.parseChunk = function (chunk) {\n        this.write(chunk);\n    };\n    /**\n     * Alias of `end`, for backwards compatibility.\n     *\n     * @param chunk Optional final chunk to parse.\n     * @deprecated\n     */\n    Parser.prototype.done = function (chunk) {\n        this.end(chunk);\n    };\n    return Parser;\n}());\nexports.Parser = Parser;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/htmlparser2/lib/Parser.js?");

/***/ }),

/***/ "./src/node_modules/htmlparser2/lib/Tokenizer.js":
/*!*******************************************************!*\
  !*** ./src/node_modules/htmlparser2/lib/Tokenizer.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar decode_codepoint_1 = __importDefault(__webpack_require__(/*! entities/lib/decode_codepoint */ \"./src/node_modules/entities/lib/decode_codepoint.js\"));\nvar entities_json_1 = __importDefault(__webpack_require__(/*! entities/lib/maps/entities.json */ \"./src/node_modules/entities/lib/maps/entities.json\"));\nvar legacy_json_1 = __importDefault(__webpack_require__(/*! entities/lib/maps/legacy.json */ \"./src/node_modules/entities/lib/maps/legacy.json\"));\nvar xml_json_1 = __importDefault(__webpack_require__(/*! entities/lib/maps/xml.json */ \"./src/node_modules/entities/lib/maps/xml.json\"));\nfunction whitespace(c) {\n    return c === \" \" || c === \"\\n\" || c === \"\\t\" || c === \"\\f\" || c === \"\\r\";\n}\nfunction isASCIIAlpha(c) {\n    return (c >= \"a\" && c <= \"z\") || (c >= \"A\" && c <= \"Z\");\n}\nfunction ifElseState(upper, SUCCESS, FAILURE) {\n    var lower = upper.toLowerCase();\n    if (upper === lower) {\n        return function (t, c) {\n            if (c === lower) {\n                t._state = SUCCESS;\n            }\n            else {\n                t._state = FAILURE;\n                t._index--;\n            }\n        };\n    }\n    return function (t, c) {\n        if (c === lower || c === upper) {\n            t._state = SUCCESS;\n        }\n        else {\n            t._state = FAILURE;\n            t._index--;\n        }\n    };\n}\nfunction consumeSpecialNameChar(upper, NEXT_STATE) {\n    var lower = upper.toLowerCase();\n    return function (t, c) {\n        if (c === lower || c === upper) {\n            t._state = NEXT_STATE;\n        }\n        else {\n            t._state = 3 /* InTagName */;\n            t._index--; // Consume the token again\n        }\n    };\n}\nvar stateBeforeCdata1 = ifElseState(\"C\", 24 /* BeforeCdata2 */, 16 /* InDeclaration */);\nvar stateBeforeCdata2 = ifElseState(\"D\", 25 /* BeforeCdata3 */, 16 /* InDeclaration */);\nvar stateBeforeCdata3 = ifElseState(\"A\", 26 /* BeforeCdata4 */, 16 /* InDeclaration */);\nvar stateBeforeCdata4 = ifElseState(\"T\", 27 /* BeforeCdata5 */, 16 /* InDeclaration */);\nvar stateBeforeCdata5 = ifElseState(\"A\", 28 /* BeforeCdata6 */, 16 /* InDeclaration */);\nvar stateBeforeScript1 = consumeSpecialNameChar(\"R\", 35 /* BeforeScript2 */);\nvar stateBeforeScript2 = consumeSpecialNameChar(\"I\", 36 /* BeforeScript3 */);\nvar stateBeforeScript3 = consumeSpecialNameChar(\"P\", 37 /* BeforeScript4 */);\nvar stateBeforeScript4 = consumeSpecialNameChar(\"T\", 38 /* BeforeScript5 */);\nvar stateAfterScript1 = ifElseState(\"R\", 40 /* AfterScript2 */, 1 /* Text */);\nvar stateAfterScript2 = ifElseState(\"I\", 41 /* AfterScript3 */, 1 /* Text */);\nvar stateAfterScript3 = ifElseState(\"P\", 42 /* AfterScript4 */, 1 /* Text */);\nvar stateAfterScript4 = ifElseState(\"T\", 43 /* AfterScript5 */, 1 /* Text */);\nvar stateBeforeStyle1 = consumeSpecialNameChar(\"Y\", 45 /* BeforeStyle2 */);\nvar stateBeforeStyle2 = consumeSpecialNameChar(\"L\", 46 /* BeforeStyle3 */);\nvar stateBeforeStyle3 = consumeSpecialNameChar(\"E\", 47 /* BeforeStyle4 */);\nvar stateAfterStyle1 = ifElseState(\"Y\", 49 /* AfterStyle2 */, 1 /* Text */);\nvar stateAfterStyle2 = ifElseState(\"L\", 50 /* AfterStyle3 */, 1 /* Text */);\nvar stateAfterStyle3 = ifElseState(\"E\", 51 /* AfterStyle4 */, 1 /* Text */);\nvar stateBeforeSpecialT = consumeSpecialNameChar(\"I\", 54 /* BeforeTitle1 */);\nvar stateBeforeTitle1 = consumeSpecialNameChar(\"T\", 55 /* BeforeTitle2 */);\nvar stateBeforeTitle2 = consumeSpecialNameChar(\"L\", 56 /* BeforeTitle3 */);\nvar stateBeforeTitle3 = consumeSpecialNameChar(\"E\", 57 /* BeforeTitle4 */);\nvar stateAfterSpecialTEnd = ifElseState(\"I\", 58 /* AfterTitle1 */, 1 /* Text */);\nvar stateAfterTitle1 = ifElseState(\"T\", 59 /* AfterTitle2 */, 1 /* Text */);\nvar stateAfterTitle2 = ifElseState(\"L\", 60 /* AfterTitle3 */, 1 /* Text */);\nvar stateAfterTitle3 = ifElseState(\"E\", 61 /* AfterTitle4 */, 1 /* Text */);\nvar stateBeforeEntity = ifElseState(\"#\", 63 /* BeforeNumericEntity */, 64 /* InNamedEntity */);\nvar stateBeforeNumericEntity = ifElseState(\"X\", 66 /* InHexEntity */, 65 /* InNumericEntity */);\nvar Tokenizer = /** @class */ (function () {\n    function Tokenizer(options, cbs) {\n        var _a;\n        /** The current state the tokenizer is in. */\n        this._state = 1 /* Text */;\n        /** The read buffer. */\n        this.buffer = \"\";\n        /** The beginning of the section that is currently being read. */\n        this.sectionStart = 0;\n        /** The index within the buffer that we are currently looking at. */\n        this._index = 0;\n        /**\n         * Data that has already been processed will be removed from the buffer occasionally.\n         * `_bufferOffset` keeps track of how many characters have been removed, to make sure position information is accurate.\n         */\n        this.bufferOffset = 0;\n        /** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */\n        this.baseState = 1 /* Text */;\n        /** For special parsing behavior inside of script and style tags. */\n        this.special = 1 /* None */;\n        /** Indicates whether the tokenizer has been paused. */\n        this.running = true;\n        /** Indicates whether the tokenizer has finished running / `.end` has been called. */\n        this.ended = false;\n        this.cbs = cbs;\n        this.xmlMode = !!(options === null || options === void 0 ? void 0 : options.xmlMode);\n        this.decodeEntities = (_a = options === null || options === void 0 ? void 0 : options.decodeEntities) !== null && _a !== void 0 ? _a : true;\n    }\n    Tokenizer.prototype.reset = function () {\n        this._state = 1 /* Text */;\n        this.buffer = \"\";\n        this.sectionStart = 0;\n        this._index = 0;\n        this.bufferOffset = 0;\n        this.baseState = 1 /* Text */;\n        this.special = 1 /* None */;\n        this.running = true;\n        this.ended = false;\n    };\n    Tokenizer.prototype.write = function (chunk) {\n        if (this.ended)\n            this.cbs.onerror(Error(\".write() after done!\"));\n        this.buffer += chunk;\n        this.parse();\n    };\n    Tokenizer.prototype.end = function (chunk) {\n        if (this.ended)\n            this.cbs.onerror(Error(\".end() after done!\"));\n        if (chunk)\n            this.write(chunk);\n        this.ended = true;\n        if (this.running)\n            this.finish();\n    };\n    Tokenizer.prototype.pause = function () {\n        this.running = false;\n    };\n    Tokenizer.prototype.resume = function () {\n        this.running = true;\n        if (this._index < this.buffer.length) {\n            this.parse();\n        }\n        if (this.ended) {\n            this.finish();\n        }\n    };\n    /**\n     * The current index within all of the written data.\n     */\n    Tokenizer.prototype.getAbsoluteIndex = function () {\n        return this.bufferOffset + this._index;\n    };\n    Tokenizer.prototype.stateText = function (c) {\n        if (c === \"<\") {\n            if (this._index > this.sectionStart) {\n                this.cbs.ontext(this.getSection());\n            }\n            this._state = 2 /* BeforeTagName */;\n            this.sectionStart = this._index;\n        }\n        else if (this.decodeEntities &&\n            c === \"&\" &&\n            (this.special === 1 /* None */ || this.special === 4 /* Title */)) {\n            if (this._index > this.sectionStart) {\n                this.cbs.ontext(this.getSection());\n            }\n            this.baseState = 1 /* Text */;\n            this._state = 62 /* BeforeEntity */;\n            this.sectionStart = this._index;\n        }\n    };\n    /**\n     * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.\n     *\n     * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).\n     * We allow anything that wouldn't end the tag.\n     */\n    Tokenizer.prototype.isTagStartChar = function (c) {\n        return (isASCIIAlpha(c) ||\n            (this.xmlMode && !whitespace(c) && c !== \"/\" && c !== \">\"));\n    };\n    Tokenizer.prototype.stateBeforeTagName = function (c) {\n        if (c === \"/\") {\n            this._state = 5 /* BeforeClosingTagName */;\n        }\n        else if (c === \"<\") {\n            this.cbs.ontext(this.getSection());\n            this.sectionStart = this._index;\n        }\n        else if (c === \">\" ||\n            this.special !== 1 /* None */ ||\n            whitespace(c)) {\n            this._state = 1 /* Text */;\n        }\n        else if (c === \"!\") {\n            this._state = 15 /* BeforeDeclaration */;\n            this.sectionStart = this._index + 1;\n        }\n        else if (c === \"?\") {\n            this._state = 17 /* InProcessingInstruction */;\n            this.sectionStart = this._index + 1;\n        }\n        else if (!this.isTagStartChar(c)) {\n            this._state = 1 /* Text */;\n        }\n        else {\n            this._state =\n                !this.xmlMode && (c === \"s\" || c === \"S\")\n                    ? 32 /* BeforeSpecialS */\n                    : !this.xmlMode && (c === \"t\" || c === \"T\")\n                        ? 52 /* BeforeSpecialT */\n                        : 3 /* InTagName */;\n            this.sectionStart = this._index;\n        }\n    };\n    Tokenizer.prototype.stateInTagName = function (c) {\n        if (c === \"/\" || c === \">\" || whitespace(c)) {\n            this.emitToken(\"onopentagname\");\n            this._state = 8 /* BeforeAttributeName */;\n            this._index--;\n        }\n    };\n    Tokenizer.prototype.stateBeforeClosingTagName = function (c) {\n        if (whitespace(c)) {\n            // Ignore\n        }\n        else if (c === \">\") {\n            this._state = 1 /* Text */;\n        }\n        else if (this.special !== 1 /* None */) {\n            if (this.special !== 4 /* Title */ && (c === \"s\" || c === \"S\")) {\n                this._state = 33 /* BeforeSpecialSEnd */;\n            }\n            else if (this.special === 4 /* Title */ &&\n                (c === \"t\" || c === \"T\")) {\n                this._state = 53 /* BeforeSpecialTEnd */;\n            }\n            else {\n                this._state = 1 /* Text */;\n                this._index--;\n            }\n        }\n        else if (!this.isTagStartChar(c)) {\n            this._state = 20 /* InSpecialComment */;\n            this.sectionStart = this._index;\n        }\n        else {\n            this._state = 6 /* InClosingTagName */;\n            this.sectionStart = this._index;\n        }\n    };\n    Tokenizer.prototype.stateInClosingTagName = function (c) {\n        if (c === \">\" || whitespace(c)) {\n            this.emitToken(\"onclosetag\");\n            this._state = 7 /* AfterClosingTagName */;\n            this._index--;\n        }\n    };\n    Tokenizer.prototype.stateAfterClosingTagName = function (c) {\n        // Skip everything until \">\"\n        if (c === \">\") {\n            this._state = 1 /* Text */;\n            this.sectionStart = this._index + 1;\n        }\n    };\n    Tokenizer.prototype.stateBeforeAttributeName = function (c) {\n        if (c === \">\") {\n            this.cbs.onopentagend();\n            this._state = 1 /* Text */;\n            this.sectionStart = this._index + 1;\n        }\n        else if (c === \"/\") {\n            this._state = 4 /* InSelfClosingTag */;\n        }\n        else if (!whitespace(c)) {\n            this._state = 9 /* InAttributeName */;\n            this.sectionStart = this._index;\n        }\n    };\n    Tokenizer.prototype.stateInSelfClosingTag = function (c) {\n        if (c === \">\") {\n            this.cbs.onselfclosingtag();\n            this._state = 1 /* Text */;\n            this.sectionStart = this._index + 1;\n            this.special = 1 /* None */; // Reset special state, in case of self-closing special tags\n        }\n        else if (!whitespace(c)) {\n            this._state = 8 /* BeforeAttributeName */;\n            this._index--;\n        }\n    };\n    Tokenizer.prototype.stateInAttributeName = function (c) {\n        if (c === \"=\" || c === \"/\" || c === \">\" || whitespace(c)) {\n            this.cbs.onattribname(this.getSection());\n            this.sectionStart = -1;\n            this._state = 10 /* AfterAttributeName */;\n            this._index--;\n        }\n    };\n    Tokenizer.prototype.stateAfterAttributeName = function (c) {\n        if (c === \"=\") {\n            this._state = 11 /* BeforeAttributeValue */;\n        }\n        else if (c === \"/\" || c === \">\") {\n            this.cbs.onattribend(undefined);\n            this._state = 8 /* BeforeAttributeName */;\n            this._index--;\n        }\n        else if (!whitespace(c)) {\n            this.cbs.onattribend(undefined);\n            this._state = 9 /* InAttributeName */;\n            this.sectionStart = this._index;\n        }\n    };\n    Tokenizer.prototype.stateBeforeAttributeValue = function (c) {\n        if (c === '\"') {\n            this._state = 12 /* InAttributeValueDq */;\n            this.sectionStart = this._index + 1;\n        }\n        else if (c === \"'\") {\n            this._state = 13 /* InAttributeValueSq */;\n            this.sectionStart = this._index + 1;\n        }\n        else if (!whitespace(c)) {\n            this._state = 14 /* InAttributeValueNq */;\n            this.sectionStart = this._index;\n            this._index--; // Reconsume token\n        }\n    };\n    Tokenizer.prototype.handleInAttributeValue = function (c, quote) {\n        if (c === quote) {\n            this.emitToken(\"onattribdata\");\n            this.cbs.onattribend(quote);\n            this._state = 8 /* BeforeAttributeName */;\n        }\n        else if (this.decodeEntities && c === \"&\") {\n            this.emitToken(\"onattribdata\");\n            this.baseState = this._state;\n            this._state = 62 /* BeforeEntity */;\n            this.sectionStart = this._index;\n        }\n    };\n    Tokenizer.prototype.stateInAttributeValueDoubleQuotes = function (c) {\n        this.handleInAttributeValue(c, '\"');\n    };\n    Tokenizer.prototype.stateInAttributeValueSingleQuotes = function (c) {\n        this.handleInAttributeValue(c, \"'\");\n    };\n    Tokenizer.prototype.stateInAttributeValueNoQuotes = function (c) {\n        if (whitespace(c) || c === \">\") {\n            this.emitToken(\"onattribdata\");\n            this.cbs.onattribend(null);\n            this._state = 8 /* BeforeAttributeName */;\n            this._index--;\n        }\n        else if (this.decodeEntities && c === \"&\") {\n            this.emitToken(\"onattribdata\");\n            this.baseState = this._state;\n            this._state = 62 /* BeforeEntity */;\n            this.sectionStart = this._index;\n        }\n    };\n    Tokenizer.prototype.stateBeforeDeclaration = function (c) {\n        this._state =\n            c === \"[\"\n                ? 23 /* BeforeCdata1 */\n                : c === \"-\"\n                    ? 18 /* BeforeComment */\n                    : 16 /* InDeclaration */;\n    };\n    Tokenizer.prototype.stateInDeclaration = function (c) {\n        if (c === \">\") {\n            this.cbs.ondeclaration(this.getSection());\n            this._state = 1 /* Text */;\n            this.sectionStart = this._index + 1;\n        }\n    };\n    Tokenizer.prototype.stateInProcessingInstruction = function (c) {\n        if (c === \">\") {\n            this.cbs.onprocessinginstruction(this.getSection());\n            this._state = 1 /* Text */;\n            this.sectionStart = this._index + 1;\n        }\n    };\n    Tokenizer.prototype.stateBeforeComment = function (c) {\n        if (c === \"-\") {\n            this._state = 19 /* InComment */;\n            this.sectionStart = this._index + 1;\n        }\n        else {\n            this._state = 16 /* InDeclaration */;\n        }\n    };\n    Tokenizer.prototype.stateInComment = function (c) {\n        if (c === \"-\")\n            this._state = 21 /* AfterComment1 */;\n    };\n    Tokenizer.prototype.stateInSpecialComment = function (c) {\n        if (c === \">\") {\n            this.cbs.oncomment(this.buffer.substring(this.sectionStart, this._index));\n            this._state = 1 /* Text */;\n            this.sectionStart = this._index + 1;\n        }\n    };\n    Tokenizer.prototype.stateAfterComment1 = function (c) {\n        if (c === \"-\") {\n            this._state = 22 /* AfterComment2 */;\n        }\n        else {\n            this._state = 19 /* InComment */;\n        }\n    };\n    Tokenizer.prototype.stateAfterComment2 = function (c) {\n        if (c === \">\") {\n            // Remove 2 trailing chars\n            this.cbs.oncomment(this.buffer.substring(this.sectionStart, this._index - 2));\n            this._state = 1 /* Text */;\n            this.sectionStart = this._index + 1;\n        }\n        else if (c !== \"-\") {\n            this._state = 19 /* InComment */;\n        }\n        // Else: stay in AFTER_COMMENT_2 (`--->`)\n    };\n    Tokenizer.prototype.stateBeforeCdata6 = function (c) {\n        if (c === \"[\") {\n            this._state = 29 /* InCdata */;\n            this.sectionStart = this._index + 1;\n        }\n        else {\n            this._state = 16 /* InDeclaration */;\n            this._index--;\n        }\n    };\n    Tokenizer.prototype.stateInCdata = function (c) {\n        if (c === \"]\")\n            this._state = 30 /* AfterCdata1 */;\n    };\n    Tokenizer.prototype.stateAfterCdata1 = function (c) {\n        if (c === \"]\")\n            this._state = 31 /* AfterCdata2 */;\n        else\n            this._state = 29 /* InCdata */;\n    };\n    Tokenizer.prototype.stateAfterCdata2 = function (c) {\n        if (c === \">\") {\n            // Remove 2 trailing chars\n            this.cbs.oncdata(this.buffer.substring(this.sectionStart, this._index - 2));\n            this._state = 1 /* Text */;\n            this.sectionStart = this._index + 1;\n        }\n        else if (c !== \"]\") {\n            this._state = 29 /* InCdata */;\n        }\n        // Else: stay in AFTER_CDATA_2 (`]]]>`)\n    };\n    Tokenizer.prototype.stateBeforeSpecialS = function (c) {\n        if (c === \"c\" || c === \"C\") {\n            this._state = 34 /* BeforeScript1 */;\n        }\n        else if (c === \"t\" || c === \"T\") {\n            this._state = 44 /* BeforeStyle1 */;\n        }\n        else {\n            this._state = 3 /* InTagName */;\n            this._index--; // Consume the token again\n        }\n    };\n    Tokenizer.prototype.stateBeforeSpecialSEnd = function (c) {\n        if (this.special === 2 /* Script */ && (c === \"c\" || c === \"C\")) {\n            this._state = 39 /* AfterScript1 */;\n        }\n        else if (this.special === 3 /* Style */ && (c === \"t\" || c === \"T\")) {\n            this._state = 48 /* AfterStyle1 */;\n        }\n        else\n            this._state = 1 /* Text */;\n    };\n    Tokenizer.prototype.stateBeforeSpecialLast = function (c, special) {\n        if (c === \"/\" || c === \">\" || whitespace(c)) {\n            this.special = special;\n        }\n        this._state = 3 /* InTagName */;\n        this._index--; // Consume the token again\n    };\n    Tokenizer.prototype.stateAfterSpecialLast = function (c, sectionStartOffset) {\n        if (c === \">\" || whitespace(c)) {\n            this.special = 1 /* None */;\n            this._state = 6 /* InClosingTagName */;\n            this.sectionStart = this._index - sectionStartOffset;\n            this._index--; // Reconsume the token\n        }\n        else\n            this._state = 1 /* Text */;\n    };\n    // For entities terminated with a semicolon\n    Tokenizer.prototype.parseFixedEntity = function (map) {\n        if (map === void 0) { map = this.xmlMode ? xml_json_1.default : entities_json_1.default; }\n        // Offset = 1\n        if (this.sectionStart + 1 < this._index) {\n            var entity = this.buffer.substring(this.sectionStart + 1, this._index);\n            if (Object.prototype.hasOwnProperty.call(map, entity)) {\n                this.emitPartial(map[entity]);\n                this.sectionStart = this._index + 1;\n            }\n        }\n    };\n    // Parses legacy entities (without trailing semicolon)\n    Tokenizer.prototype.parseLegacyEntity = function () {\n        var start = this.sectionStart + 1;\n        // The max length of legacy entities is 6\n        var limit = Math.min(this._index - start, 6);\n        while (limit >= 2) {\n            // The min length of legacy entities is 2\n            var entity = this.buffer.substr(start, limit);\n            if (Object.prototype.hasOwnProperty.call(legacy_json_1.default, entity)) {\n                this.emitPartial(legacy_json_1.default[entity]);\n                this.sectionStart += limit + 1;\n                return;\n            }\n            limit--;\n        }\n    };\n    Tokenizer.prototype.stateInNamedEntity = function (c) {\n        if (c === \";\") {\n            this.parseFixedEntity();\n            // Retry as legacy entity if entity wasn't parsed\n            if (this.baseState === 1 /* Text */ &&\n                this.sectionStart + 1 < this._index &&\n                !this.xmlMode) {\n                this.parseLegacyEntity();\n            }\n            this._state = this.baseState;\n        }\n        else if ((c < \"0\" || c > \"9\") && !isASCIIAlpha(c)) {\n            if (this.xmlMode || this.sectionStart + 1 === this._index) {\n                // Ignore\n            }\n            else if (this.baseState !== 1 /* Text */) {\n                if (c !== \"=\") {\n                    // Parse as legacy entity, without allowing additional characters.\n                    this.parseFixedEntity(legacy_json_1.default);\n                }\n            }\n            else {\n                this.parseLegacyEntity();\n            }\n            this._state = this.baseState;\n            this._index--;\n        }\n    };\n    Tokenizer.prototype.decodeNumericEntity = function (offset, base, strict) {\n        var sectionStart = this.sectionStart + offset;\n        if (sectionStart !== this._index) {\n            // Parse entity\n            var entity = this.buffer.substring(sectionStart, this._index);\n            var parsed = parseInt(entity, base);\n            this.emitPartial(decode_codepoint_1.default(parsed));\n            this.sectionStart = strict ? this._index + 1 : this._index;\n        }\n        this._state = this.baseState;\n    };\n    Tokenizer.prototype.stateInNumericEntity = function (c) {\n        if (c === \";\") {\n            this.decodeNumericEntity(2, 10, true);\n        }\n        else if (c < \"0\" || c > \"9\") {\n            if (!this.xmlMode) {\n                this.decodeNumericEntity(2, 10, false);\n            }\n            else {\n                this._state = this.baseState;\n            }\n            this._index--;\n        }\n    };\n    Tokenizer.prototype.stateInHexEntity = function (c) {\n        if (c === \";\") {\n            this.decodeNumericEntity(3, 16, true);\n        }\n        else if ((c < \"a\" || c > \"f\") &&\n            (c < \"A\" || c > \"F\") &&\n            (c < \"0\" || c > \"9\")) {\n            if (!this.xmlMode) {\n                this.decodeNumericEntity(3, 16, false);\n            }\n            else {\n                this._state = this.baseState;\n            }\n            this._index--;\n        }\n    };\n    Tokenizer.prototype.cleanup = function () {\n        if (this.sectionStart < 0) {\n            this.buffer = \"\";\n            this.bufferOffset += this._index;\n            this._index = 0;\n        }\n        else if (this.running) {\n            if (this._state === 1 /* Text */) {\n                if (this.sectionStart !== this._index) {\n                    this.cbs.ontext(this.buffer.substr(this.sectionStart));\n                }\n                this.buffer = \"\";\n                this.bufferOffset += this._index;\n                this._index = 0;\n            }\n            else if (this.sectionStart === this._index) {\n                // The section just started\n                this.buffer = \"\";\n                this.bufferOffset += this._index;\n                this._index = 0;\n            }\n            else {\n                // Remove everything unnecessary\n                this.buffer = this.buffer.substr(this.sectionStart);\n                this._index -= this.sectionStart;\n                this.bufferOffset += this.sectionStart;\n            }\n            this.sectionStart = 0;\n        }\n    };\n    /**\n     * Iterates through the buffer, calling the function corresponding to the current state.\n     *\n     * States that are more likely to be hit are higher up, as a performance improvement.\n     */\n    Tokenizer.prototype.parse = function () {\n        while (this._index < this.buffer.length && this.running) {\n            var c = this.buffer.charAt(this._index);\n            if (this._state === 1 /* Text */) {\n                this.stateText(c);\n            }\n            else if (this._state === 12 /* InAttributeValueDq */) {\n                this.stateInAttributeValueDoubleQuotes(c);\n            }\n            else if (this._state === 9 /* InAttributeName */) {\n                this.stateInAttributeName(c);\n            }\n            else if (this._state === 19 /* InComment */) {\n                this.stateInComment(c);\n            }\n            else if (this._state === 20 /* InSpecialComment */) {\n                this.stateInSpecialComment(c);\n            }\n            else if (this._state === 8 /* BeforeAttributeName */) {\n                this.stateBeforeAttributeName(c);\n            }\n            else if (this._state === 3 /* InTagName */) {\n                this.stateInTagName(c);\n            }\n            else if (this._state === 6 /* InClosingTagName */) {\n                this.stateInClosingTagName(c);\n            }\n            else if (this._state === 2 /* BeforeTagName */) {\n                this.stateBeforeTagName(c);\n            }\n            else if (this._state === 10 /* AfterAttributeName */) {\n                this.stateAfterAttributeName(c);\n            }\n            else if (this._state === 13 /* InAttributeValueSq */) {\n                this.stateInAttributeValueSingleQuotes(c);\n            }\n            else if (this._state === 11 /* BeforeAttributeValue */) {\n                this.stateBeforeAttributeValue(c);\n            }\n            else if (this._state === 5 /* BeforeClosingTagName */) {\n                this.stateBeforeClosingTagName(c);\n            }\n            else if (this._state === 7 /* AfterClosingTagName */) {\n                this.stateAfterClosingTagName(c);\n            }\n            else if (this._state === 32 /* BeforeSpecialS */) {\n                this.stateBeforeSpecialS(c);\n            }\n            else if (this._state === 21 /* AfterComment1 */) {\n                this.stateAfterComment1(c);\n            }\n            else if (this._state === 14 /* InAttributeValueNq */) {\n                this.stateInAttributeValueNoQuotes(c);\n            }\n            else if (this._state === 4 /* InSelfClosingTag */) {\n                this.stateInSelfClosingTag(c);\n            }\n            else if (this._state === 16 /* InDeclaration */) {\n                this.stateInDeclaration(c);\n            }\n            else if (this._state === 15 /* BeforeDeclaration */) {\n                this.stateBeforeDeclaration(c);\n            }\n            else if (this._state === 22 /* AfterComment2 */) {\n                this.stateAfterComment2(c);\n            }\n            else if (this._state === 18 /* BeforeComment */) {\n                this.stateBeforeComment(c);\n            }\n            else if (this._state === 33 /* BeforeSpecialSEnd */) {\n                this.stateBeforeSpecialSEnd(c);\n            }\n            else if (this._state === 53 /* BeforeSpecialTEnd */) {\n                stateAfterSpecialTEnd(this, c);\n            }\n            else if (this._state === 39 /* AfterScript1 */) {\n                stateAfterScript1(this, c);\n            }\n            else if (this._state === 40 /* AfterScript2 */) {\n                stateAfterScript2(this, c);\n            }\n            else if (this._state === 41 /* AfterScript3 */) {\n                stateAfterScript3(this, c);\n            }\n            else if (this._state === 34 /* BeforeScript1 */) {\n                stateBeforeScript1(this, c);\n            }\n            else if (this._state === 35 /* BeforeScript2 */) {\n                stateBeforeScript2(this, c);\n            }\n            else if (this._state === 36 /* BeforeScript3 */) {\n                stateBeforeScript3(this, c);\n            }\n            else if (this._state === 37 /* BeforeScript4 */) {\n                stateBeforeScript4(this, c);\n            }\n            else if (this._state === 38 /* BeforeScript5 */) {\n                this.stateBeforeSpecialLast(c, 2 /* Script */);\n            }\n            else if (this._state === 42 /* AfterScript4 */) {\n                stateAfterScript4(this, c);\n            }\n            else if (this._state === 43 /* AfterScript5 */) {\n                this.stateAfterSpecialLast(c, 6);\n            }\n            else if (this._state === 44 /* BeforeStyle1 */) {\n                stateBeforeStyle1(this, c);\n            }\n            else if (this._state === 29 /* InCdata */) {\n                this.stateInCdata(c);\n            }\n            else if (this._state === 45 /* BeforeStyle2 */) {\n                stateBeforeStyle2(this, c);\n            }\n            else if (this._state === 46 /* BeforeStyle3 */) {\n                stateBeforeStyle3(this, c);\n            }\n            else if (this._state === 47 /* BeforeStyle4 */) {\n                this.stateBeforeSpecialLast(c, 3 /* Style */);\n            }\n            else if (this._state === 48 /* AfterStyle1 */) {\n                stateAfterStyle1(this, c);\n            }\n            else if (this._state === 49 /* AfterStyle2 */) {\n                stateAfterStyle2(this, c);\n            }\n            else if (this._state === 50 /* AfterStyle3 */) {\n                stateAfterStyle3(this, c);\n            }\n            else if (this._state === 51 /* AfterStyle4 */) {\n                this.stateAfterSpecialLast(c, 5);\n            }\n            else if (this._state === 52 /* BeforeSpecialT */) {\n                stateBeforeSpecialT(this, c);\n            }\n            else if (this._state === 54 /* BeforeTitle1 */) {\n                stateBeforeTitle1(this, c);\n            }\n            else if (this._state === 55 /* BeforeTitle2 */) {\n                stateBeforeTitle2(this, c);\n            }\n            else if (this._state === 56 /* BeforeTitle3 */) {\n                stateBeforeTitle3(this, c);\n            }\n            else if (this._state === 57 /* BeforeTitle4 */) {\n                this.stateBeforeSpecialLast(c, 4 /* Title */);\n            }\n            else if (this._state === 58 /* AfterTitle1 */) {\n                stateAfterTitle1(this, c);\n            }\n            else if (this._state === 59 /* AfterTitle2 */) {\n                stateAfterTitle2(this, c);\n            }\n            else if (this._state === 60 /* AfterTitle3 */) {\n                stateAfterTitle3(this, c);\n            }\n            else if (this._state === 61 /* AfterTitle4 */) {\n                this.stateAfterSpecialLast(c, 5);\n            }\n            else if (this._state === 17 /* InProcessingInstruction */) {\n                this.stateInProcessingInstruction(c);\n            }\n            else if (this._state === 64 /* InNamedEntity */) {\n                this.stateInNamedEntity(c);\n            }\n            else if (this._state === 23 /* BeforeCdata1 */) {\n                stateBeforeCdata1(this, c);\n            }\n            else if (this._state === 62 /* BeforeEntity */) {\n                stateBeforeEntity(this, c);\n            }\n            else if (this._state === 24 /* BeforeCdata2 */) {\n                stateBeforeCdata2(this, c);\n            }\n            else if (this._state === 25 /* BeforeCdata3 */) {\n                stateBeforeCdata3(this, c);\n            }\n            else if (this._state === 30 /* AfterCdata1 */) {\n                this.stateAfterCdata1(c);\n            }\n            else if (this._state === 31 /* AfterCdata2 */) {\n                this.stateAfterCdata2(c);\n            }\n            else if (this._state === 26 /* BeforeCdata4 */) {\n                stateBeforeCdata4(this, c);\n            }\n            else if (this._state === 27 /* BeforeCdata5 */) {\n                stateBeforeCdata5(this, c);\n            }\n            else if (this._state === 28 /* BeforeCdata6 */) {\n                this.stateBeforeCdata6(c);\n            }\n            else if (this._state === 66 /* InHexEntity */) {\n                this.stateInHexEntity(c);\n            }\n            else if (this._state === 65 /* InNumericEntity */) {\n                this.stateInNumericEntity(c);\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            }\n            else if (this._state === 63 /* BeforeNumericEntity */) {\n                stateBeforeNumericEntity(this, c);\n            }\n            else {\n                this.cbs.onerror(Error(\"unknown _state\"), this._state);\n            }\n            this._index++;\n        }\n        this.cleanup();\n    };\n    Tokenizer.prototype.finish = function () {\n        // If there is remaining data, emit it in a reasonable way\n        if (this.sectionStart < this._index) {\n            this.handleTrailingData();\n        }\n        this.cbs.onend();\n    };\n    Tokenizer.prototype.handleTrailingData = function () {\n        var data = this.buffer.substr(this.sectionStart);\n        if (this._state === 29 /* InCdata */ ||\n            this._state === 30 /* AfterCdata1 */ ||\n            this._state === 31 /* AfterCdata2 */) {\n            this.cbs.oncdata(data);\n        }\n        else if (this._state === 19 /* InComment */ ||\n            this._state === 21 /* AfterComment1 */ ||\n            this._state === 22 /* AfterComment2 */) {\n            this.cbs.oncomment(data);\n        }\n        else if (this._state === 64 /* InNamedEntity */ && !this.xmlMode) {\n            this.parseLegacyEntity();\n            if (this.sectionStart < this._index) {\n                this._state = this.baseState;\n                this.handleTrailingData();\n            }\n        }\n        else if (this._state === 65 /* InNumericEntity */ && !this.xmlMode) {\n            this.decodeNumericEntity(2, 10, false);\n            if (this.sectionStart < this._index) {\n                this._state = this.baseState;\n                this.handleTrailingData();\n            }\n        }\n        else if (this._state === 66 /* InHexEntity */ && !this.xmlMode) {\n            this.decodeNumericEntity(3, 16, false);\n            if (this.sectionStart < this._index) {\n                this._state = this.baseState;\n                this.handleTrailingData();\n            }\n        }\n        else if (this._state !== 3 /* InTagName */ &&\n            this._state !== 8 /* BeforeAttributeName */ &&\n            this._state !== 11 /* BeforeAttributeValue */ &&\n            this._state !== 10 /* AfterAttributeName */ &&\n            this._state !== 9 /* InAttributeName */ &&\n            this._state !== 13 /* InAttributeValueSq */ &&\n            this._state !== 12 /* InAttributeValueDq */ &&\n            this._state !== 14 /* InAttributeValueNq */ &&\n            this._state !== 6 /* InClosingTagName */) {\n            this.cbs.ontext(data);\n        }\n        /*\n         * Else, ignore remaining data\n         * TODO add a way to remove current tag\n         */\n    };\n    Tokenizer.prototype.getSection = function () {\n        return this.buffer.substring(this.sectionStart, this._index);\n    };\n    Tokenizer.prototype.emitToken = function (name) {\n        this.cbs[name](this.getSection());\n        this.sectionStart = -1;\n    };\n    Tokenizer.prototype.emitPartial = function (value) {\n        if (this.baseState !== 1 /* Text */) {\n            this.cbs.onattribdata(value); // TODO implement the new event\n        }\n        else {\n            this.cbs.ontext(value);\n        }\n    };\n    return Tokenizer;\n}());\nexports.default = Tokenizer;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/htmlparser2/lib/Tokenizer.js?");

/***/ }),

/***/ "./src/node_modules/htmlparser2/lib/index.js":
/*!***************************************************!*\
  !*** ./src/node_modules/htmlparser2/lib/index.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RssHandler = exports.DefaultHandler = exports.DomUtils = exports.ElementType = exports.Tokenizer = exports.createDomStream = exports.parseDOM = exports.parseDocument = exports.DomHandler = exports.Parser = void 0;\nvar Parser_1 = __webpack_require__(/*! ./Parser */ \"./src/node_modules/htmlparser2/lib/Parser.js\");\nObject.defineProperty(exports, \"Parser\", ({ enumerable: true, get: function () { return Parser_1.Parser; } }));\nvar domhandler_1 = __webpack_require__(/*! domhandler */ \"./src/node_modules/domhandler/lib/index.js\");\nObject.defineProperty(exports, \"DomHandler\", ({ enumerable: true, get: function () { return domhandler_1.DomHandler; } }));\nObject.defineProperty(exports, \"DefaultHandler\", ({ enumerable: true, get: function () { return domhandler_1.DomHandler; } }));\n// Helper methods\n/**\n * Parses the data, returns the resulting document.\n *\n * @param data The data that should be parsed.\n * @param options Optional options for the parser and DOM builder.\n */\nfunction parseDocument(data, options) {\n    var handler = new domhandler_1.DomHandler(undefined, options);\n    new Parser_1.Parser(handler, options).end(data);\n    return handler.root;\n}\nexports.parseDocument = parseDocument;\n/**\n * Parses data, returns an array of the root nodes.\n *\n * Note that the root nodes still have a `Document` node as their parent.\n * Use `parseDocument` to get the `Document` node instead.\n *\n * @param data The data that should be parsed.\n * @param options Optional options for the parser and DOM builder.\n * @deprecated Use `parseDocument` instead.\n */\nfunction parseDOM(data, options) {\n    return parseDocument(data, options).children;\n}\nexports.parseDOM = parseDOM;\n/**\n * Creates a parser instance, with an attached DOM handler.\n *\n * @param cb A callback that will be called once parsing has been completed.\n * @param options Optional options for the parser and DOM builder.\n * @param elementCb An optional callback that will be called every time a tag has been completed inside of the DOM.\n */\nfunction createDomStream(cb, options, elementCb) {\n    var handler = new domhandler_1.DomHandler(cb, options, elementCb);\n    return new Parser_1.Parser(handler, options);\n}\nexports.createDomStream = createDomStream;\nvar Tokenizer_1 = __webpack_require__(/*! ./Tokenizer */ \"./src/node_modules/htmlparser2/lib/Tokenizer.js\");\nObject.defineProperty(exports, \"Tokenizer\", ({ enumerable: true, get: function () { return __importDefault(Tokenizer_1).default; } }));\nvar ElementType = __importStar(__webpack_require__(/*! domelementtype */ \"./src/node_modules/domelementtype/lib/index.js\"));\nexports.ElementType = ElementType;\n/*\n * All of the following exports exist for backwards-compatibility.\n * They should probably be removed eventually.\n */\n__exportStar(__webpack_require__(/*! ./FeedHandler */ \"./src/node_modules/htmlparser2/lib/FeedHandler.js\"), exports);\nexports.DomUtils = __importStar(__webpack_require__(/*! domutils */ \"./src/node_modules/domutils/lib/index.js\"));\nvar FeedHandler_1 = __webpack_require__(/*! ./FeedHandler */ \"./src/node_modules/htmlparser2/lib/FeedHandler.js\");\nObject.defineProperty(exports, \"RssHandler\", ({ enumerable: true, get: function () { return FeedHandler_1.FeedHandler; } }));\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/htmlparser2/lib/index.js?");

/***/ }),

/***/ "./src/node_modules/is-arguments/index.js":
/*!************************************************!*\
  !*** ./src/node_modules/is-arguments/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\nvar callBound = __webpack_require__(/*! call-bind/callBound */ \"call-bind/callBound\");\n\nvar $toString = callBound('Object.prototype.toString');\n\nvar isStandardArguments = function isArguments(value) {\n\tif (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {\n\t\treturn false;\n\t}\n\treturn $toString(value) === '[object Arguments]';\n};\n\nvar isLegacyArguments = function isArguments(value) {\n\tif (isStandardArguments(value)) {\n\t\treturn true;\n\t}\n\treturn value !== null &&\n\t\ttypeof value === 'object' &&\n\t\ttypeof value.length === 'number' &&\n\t\tvalue.length >= 0 &&\n\t\t$toString(value) !== '[object Array]' &&\n\t\t$toString(value.callee) === '[object Function]';\n};\n\nvar supportsStandardArguments = (function () {\n\treturn isStandardArguments(arguments);\n}());\n\nisStandardArguments.isLegacyArguments = isLegacyArguments; // for tests\n\nmodule.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/is-arguments/index.js?");

/***/ }),

/***/ "./src/node_modules/is-bigint/index.js":
/*!*********************************************!*\
  !*** ./src/node_modules/is-bigint/index.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
eval("\n\nif (typeof BigInt === 'function') {\n\tvar bigIntValueOf = BigInt.prototype.valueOf;\n\tvar tryBigInt = function tryBigIntObject(value) {\n\t\ttry {\n\t\t\tbigIntValueOf.call(value);\n\t\t\treturn true;\n\t\t} catch (e) {\n\t\t}\n\t\treturn false;\n\t};\n\n\tmodule.exports = function isBigInt(value) {\n\t\tif (\n\t\t\tvalue === null\n\t\t\t|| typeof value === 'undefined'\n\t\t\t|| typeof value === 'boolean'\n\t\t\t|| typeof value === 'string'\n\t\t\t|| typeof value === 'number'\n\t\t\t|| typeof value === 'symbol'\n\t\t\t|| typeof value === 'function'\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\t\tif (typeof value === 'bigint') {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn tryBigInt(value);\n\t};\n} else {\n\tmodule.exports = function isBigInt(value) {\n\t\treturn  false && 0;\n\t};\n}\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/is-bigint/index.js?");

/***/ }),

/***/ "./src/node_modules/is-boolean-object/index.js":
/*!*****************************************************!*\
  !*** ./src/node_modules/is-boolean-object/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar callBound = __webpack_require__(/*! call-bind/callBound */ \"call-bind/callBound\");\nvar $boolToStr = callBound('Boolean.prototype.toString');\nvar $toString = callBound('Object.prototype.toString');\n\nvar tryBooleanObject = function booleanBrandCheck(value) {\n\ttry {\n\t\t$boolToStr(value);\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\nvar boolClass = '[object Boolean]';\nvar hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag;\n\nmodule.exports = function isBoolean(value) {\n\tif (typeof value === 'boolean') {\n\t\treturn true;\n\t}\n\tif (value === null || typeof value !== 'object') {\n\t\treturn false;\n\t}\n\treturn hasToStringTag && Symbol.toStringTag in value ? tryBooleanObject(value) : $toString(value) === boolClass;\n};\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/is-boolean-object/index.js?");

/***/ }),

/***/ "./src/node_modules/is-date-object/index.js":
/*!**************************************************!*\
  !*** ./src/node_modules/is-date-object/index.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar getDay = Date.prototype.getDay;\nvar tryDateObject = function tryDateGetDayCall(value) {\n\ttry {\n\t\tgetDay.call(value);\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\n\nvar toStr = Object.prototype.toString;\nvar dateClass = '[object Date]';\nvar hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag;\n\nmodule.exports = function isDateObject(value) {\n\tif (typeof value !== 'object' || value === null) {\n\t\treturn false;\n\t}\n\treturn hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;\n};\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/is-date-object/index.js?");

/***/ }),

/***/ "./src/node_modules/is-map/index.js":
/*!******************************************!*\
  !*** ./src/node_modules/is-map/index.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar $Map = typeof Map === 'function' && Map.prototype ? Map : null;\nvar $Set = typeof Set === 'function' && Set.prototype ? Set : null;\n\nvar exported;\n\nif (!$Map) {\n\t// eslint-disable-next-line no-unused-vars\n\texported = function isMap(x) {\n\t\t// `Map` is not present in this environment.\n\t\treturn false;\n\t};\n}\n\nvar $mapHas = $Map ? Map.prototype.has : null;\nvar $setHas = $Set ? Set.prototype.has : null;\nif (!exported && !$mapHas) {\n\t// eslint-disable-next-line no-unused-vars\n\texported = function isMap(x) {\n\t\t// `Map` does not have a `has` method\n\t\treturn false;\n\t};\n}\n\nmodule.exports = exported || function isMap(x) {\n\tif (!x || typeof x !== 'object') {\n\t\treturn false;\n\t}\n\ttry {\n\t\t$mapHas.call(x);\n\t\tif ($setHas) {\n\t\t\ttry {\n\t\t\t\t$setHas.call(x);\n\t\t\t} catch (e) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn x instanceof $Map; // core-js workaround, pre-v2.5.0\n\t} catch (e) {}\n\treturn false;\n};\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/is-map/index.js?");

/***/ }),

/***/ "./src/node_modules/is-number-object/index.js":
/*!****************************************************!*\
  !*** ./src/node_modules/is-number-object/index.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar numToStr = Number.prototype.toString;\nvar tryNumberObject = function tryNumberObject(value) {\n\ttry {\n\t\tnumToStr.call(value);\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\nvar toStr = Object.prototype.toString;\nvar numClass = '[object Number]';\nvar hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag;\n\nmodule.exports = function isNumberObject(value) {\n\tif (typeof value === 'number') {\n\t\treturn true;\n\t}\n\tif (typeof value !== 'object') {\n\t\treturn false;\n\t}\n\treturn hasToStringTag ? tryNumberObject(value) : toStr.call(value) === numClass;\n};\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/is-number-object/index.js?");

/***/ }),

/***/ "./src/node_modules/is-regex/index.js":
/*!********************************************!*\
  !*** ./src/node_modules/is-regex/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar callBound = __webpack_require__(/*! call-bind/callBound */ \"call-bind/callBound\");\nvar hasSymbols = __webpack_require__(/*! has-symbols/shams */ \"has-symbols/shams\")();\nvar hasToStringTag = hasSymbols && !!Symbol.toStringTag;\nvar has;\nvar $exec;\nvar isRegexMarker;\nvar badStringifier;\n\nif (hasToStringTag) {\n\thas = callBound('Object.prototype.hasOwnProperty');\n\t$exec = callBound('RegExp.prototype.exec');\n\tisRegexMarker = {};\n\n\tvar throwRegexMarker = function () {\n\t\tthrow isRegexMarker;\n\t};\n\tbadStringifier = {\n\t\ttoString: throwRegexMarker,\n\t\tvalueOf: throwRegexMarker\n\t};\n\n\tif (typeof Symbol.toPrimitive === 'symbol') {\n\t\tbadStringifier[Symbol.toPrimitive] = throwRegexMarker;\n\t}\n}\n\nvar $toString = callBound('Object.prototype.toString');\nvar gOPD = Object.getOwnPropertyDescriptor;\nvar regexClass = '[object RegExp]';\n\nmodule.exports = hasToStringTag\n\t// eslint-disable-next-line consistent-return\n\t? function isRegex(value) {\n\t\tif (!value || typeof value !== 'object') {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar descriptor = gOPD(value, 'lastIndex');\n\t\tvar hasLastIndexDataProperty = descriptor && has(descriptor, 'value');\n\t\tif (!hasLastIndexDataProperty) {\n\t\t\treturn false;\n\t\t}\n\n\t\ttry {\n\t\t\t$exec(value, badStringifier);\n\t\t} catch (e) {\n\t\t\treturn e === isRegexMarker;\n\t\t}\n\t}\n\t: function isRegex(value) {\n\t\t// In older browsers, typeof regex incorrectly returns 'function'\n\t\tif (!value || (typeof value !== 'object' && typeof value !== 'function')) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn $toString(value) === regexClass;\n\t};\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/is-regex/index.js?");

/***/ }),

/***/ "./src/node_modules/is-set/index.js":
/*!******************************************!*\
  !*** ./src/node_modules/is-set/index.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar $Map = typeof Map === 'function' && Map.prototype ? Map : null;\nvar $Set = typeof Set === 'function' && Set.prototype ? Set : null;\n\nvar exported;\n\nif (!$Set) {\n\t// eslint-disable-next-line no-unused-vars\n\texported = function isSet(x) {\n\t\t// `Set` is not present in this environment.\n\t\treturn false;\n\t};\n}\n\nvar $mapHas = $Map ? Map.prototype.has : null;\nvar $setHas = $Set ? Set.prototype.has : null;\nif (!exported && !$setHas) {\n\t// eslint-disable-next-line no-unused-vars\n\texported = function isSet(x) {\n\t\t// `Set` does not have a `has` method\n\t\treturn false;\n\t};\n}\n\nmodule.exports = exported || function isSet(x) {\n\tif (!x || typeof x !== 'object') {\n\t\treturn false;\n\t}\n\ttry {\n\t\t$setHas.call(x);\n\t\tif ($mapHas) {\n\t\t\ttry {\n\t\t\t\t$mapHas.call(x);\n\t\t\t} catch (e) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn x instanceof $Set; // core-js workaround, pre-v2.5.0\n\t} catch (e) {}\n\treturn false;\n};\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/is-set/index.js?");

/***/ }),

/***/ "./src/node_modules/is-string/index.js":
/*!*********************************************!*\
  !*** ./src/node_modules/is-string/index.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar strValue = String.prototype.valueOf;\nvar tryStringObject = function tryStringObject(value) {\n\ttry {\n\t\tstrValue.call(value);\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\nvar toStr = Object.prototype.toString;\nvar strClass = '[object String]';\nvar hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag;\n\nmodule.exports = function isString(value) {\n\tif (typeof value === 'string') {\n\t\treturn true;\n\t}\n\tif (typeof value !== 'object') {\n\t\treturn false;\n\t}\n\treturn hasToStringTag ? tryStringObject(value) : toStr.call(value) === strClass;\n};\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/is-string/index.js?");

/***/ }),

/***/ "./src/node_modules/is-symbol/index.js":
/*!*********************************************!*\
  !*** ./src/node_modules/is-symbol/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar toStr = Object.prototype.toString;\nvar hasSymbols = __webpack_require__(/*! has-symbols */ \"has-symbols\")();\n\nif (hasSymbols) {\n\tvar symToStr = Symbol.prototype.toString;\n\tvar symStringRegex = /^Symbol\\(.*\\)$/;\n\tvar isSymbolObject = function isRealSymbolObject(value) {\n\t\tif (typeof value.valueOf() !== 'symbol') {\n\t\t\treturn false;\n\t\t}\n\t\treturn symStringRegex.test(symToStr.call(value));\n\t};\n\n\tmodule.exports = function isSymbol(value) {\n\t\tif (typeof value === 'symbol') {\n\t\t\treturn true;\n\t\t}\n\t\tif (toStr.call(value) !== '[object Symbol]') {\n\t\t\treturn false;\n\t\t}\n\t\ttry {\n\t\t\treturn isSymbolObject(value);\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t};\n} else {\n\n\tmodule.exports = function isSymbol(value) {\n\t\t// this environment does not support Symbols.\n\t\treturn  false && 0;\n\t};\n}\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/is-symbol/index.js?");

/***/ }),

/***/ "./src/node_modules/is-typed-array/index.js":
/*!**************************************************!*\
  !*** ./src/node_modules/is-typed-array/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar forEach = __webpack_require__(/*! foreach */ \"./src/node_modules/foreach/index.js\");\nvar availableTypedArrays = __webpack_require__(/*! available-typed-arrays */ \"./src/node_modules/available-typed-arrays/index.js\");\nvar callBound = __webpack_require__(/*! call-bind/callBound */ \"call-bind/callBound\");\n\nvar $toString = callBound('Object.prototype.toString');\nvar hasSymbols = __webpack_require__(/*! has-symbols */ \"has-symbols\")();\nvar hasToStringTag = hasSymbols && typeof Symbol.toStringTag === 'symbol';\n\nvar typedArrays = availableTypedArrays();\n\nvar $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {\n\tfor (var i = 0; i < array.length; i += 1) {\n\t\tif (array[i] === value) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n};\nvar $slice = callBound('String.prototype.slice');\nvar toStrTags = {};\nvar gOPD = __webpack_require__(/*! es-abstract/helpers/getOwnPropertyDescriptor */ \"./src/node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js\");\nvar getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');\nif (hasToStringTag && gOPD && getPrototypeOf) {\n\tforEach(typedArrays, function (typedArray) {\n\t\tvar arr = new global[typedArray]();\n\t\tif (!(Symbol.toStringTag in arr)) {\n\t\t\tthrow new EvalError('this engine has support for Symbol.toStringTag, but ' + typedArray + ' does not have the property! Please report this.');\n\t\t}\n\t\tvar proto = getPrototypeOf(arr);\n\t\tvar descriptor = gOPD(proto, Symbol.toStringTag);\n\t\tif (!descriptor) {\n\t\t\tvar superProto = getPrototypeOf(proto);\n\t\t\tdescriptor = gOPD(superProto, Symbol.toStringTag);\n\t\t}\n\t\ttoStrTags[typedArray] = descriptor.get;\n\t});\n}\n\nvar tryTypedArrays = function tryAllTypedArrays(value) {\n\tvar anyTrue = false;\n\tforEach(toStrTags, function (getter, typedArray) {\n\t\tif (!anyTrue) {\n\t\t\ttry {\n\t\t\t\tanyTrue = getter.call(value) === typedArray;\n\t\t\t} catch (e) { /**/ }\n\t\t}\n\t});\n\treturn anyTrue;\n};\n\nmodule.exports = function isTypedArray(value) {\n\tif (!value || typeof value !== 'object') { return false; }\n\tif (!hasToStringTag) {\n\t\tvar tag = $slice($toString(value), 8, -1);\n\t\treturn $indexOf(typedArrays, tag) > -1;\n\t}\n\tif (!gOPD) { return false; }\n\treturn tryTypedArrays(value);\n};\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/is-typed-array/index.js?");

/***/ }),

/***/ "./src/node_modules/is-weakmap/index.js":
/*!**********************************************!*\
  !*** ./src/node_modules/is-weakmap/index.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar $WeakMap = typeof WeakMap === 'function' && WeakMap.prototype ? WeakMap : null;\nvar $WeakSet = typeof WeakSet === 'function' && WeakSet.prototype ? WeakSet : null;\n\nvar exported;\n\nif (!$WeakMap) {\n\t// eslint-disable-next-line no-unused-vars\n\texported = function isWeakMap(x) {\n\t\t// `WeakMap` is not present in this environment.\n\t\treturn false;\n\t};\n}\n\nvar $mapHas = $WeakMap ? $WeakMap.prototype.has : null;\nvar $setHas = $WeakSet ? $WeakSet.prototype.has : null;\nif (!exported && !$mapHas) {\n\t// eslint-disable-next-line no-unused-vars\n\texported = function isWeakMap(x) {\n\t\t// `WeakMap` does not have a `has` method\n\t\treturn false;\n\t};\n}\n\nmodule.exports = exported || function isWeakMap(x) {\n\tif (!x || typeof x !== 'object') {\n\t\treturn false;\n\t}\n\ttry {\n\t\t$mapHas.call(x, $mapHas);\n\t\tif ($setHas) {\n\t\t\ttry {\n\t\t\t\t$setHas.call(x, $setHas);\n\t\t\t} catch (e) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn x instanceof $WeakMap; // core-js workaround, pre-v3\n\t} catch (e) {}\n\treturn false;\n};\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/is-weakmap/index.js?");

/***/ }),

/***/ "./src/node_modules/is-weakset/index.js":
/*!**********************************************!*\
  !*** ./src/node_modules/is-weakset/index.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar $WeakMap = typeof WeakMap === 'function' && WeakMap.prototype ? WeakMap : null;\nvar $WeakSet = typeof WeakSet === 'function' && WeakSet.prototype ? WeakSet : null;\n\nvar exported;\n\nif (!$WeakMap) {\n\t// eslint-disable-next-line no-unused-vars\n\texported = function isWeakSet(x) {\n\t\t// `WeakSet` is not present in this environment.\n\t\treturn false;\n\t};\n}\n\nvar $mapHas = $WeakMap ? $WeakMap.prototype.has : null;\nvar $setHas = $WeakSet ? $WeakSet.prototype.has : null;\nif (!exported && !$setHas) {\n\t// eslint-disable-next-line no-unused-vars\n\tmodule.exports = function isWeakSet(x) {\n\t\t// `WeakSet` does not have a `has` method\n\t\treturn false;\n\t};\n}\n\nmodule.exports = exported || function isWeakSet(x) {\n\tif (!x || typeof x !== 'object') {\n\t\treturn false;\n\t}\n\ttry {\n\t\t$setHas.call(x, $setHas);\n\t\tif ($mapHas) {\n\t\t\ttry {\n\t\t\t\t$mapHas.call(x, $mapHas);\n\t\t\t} catch (e) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn x instanceof $WeakSet; // core-js workaround, pre-v3\n\t} catch (e) {}\n\treturn false;\n};\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/is-weakset/index.js?");

/***/ }),

/***/ "./src/node_modules/nth-check/lib/compile.js":
/*!***************************************************!*\
  !*** ./src/node_modules/nth-check/lib/compile.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.compile = void 0;\nvar boolbase_1 = __webpack_require__(/*! boolbase */ \"./src/node_modules/boolbase/index.js\");\n/**\n * Returns a function that checks if an elements index matches the given rule\n * highly optimized to return the fastest solution.\n *\n * @param parsed A tuple [a, b], as returned by `parse`.\n * @returns A highly optimized function that returns whether an index matches the nth-check.\n * @example\n * const check = nthCheck.compile([2, 3]);\n *\n * check(0); // `false`\n * check(1); // `false`\n * check(2); // `true`\n * check(3); // `false`\n * check(4); // `true`\n * check(5); // `false`\n * check(6); // `true`\n */\nfunction compile(parsed) {\n    var a = parsed[0];\n    // Subtract 1 from `b`, to convert from one- to zero-indexed.\n    var b = parsed[1] - 1;\n    /*\n     * When `b <= 0`, `a * n` won't be lead to any matches for `a < 0`.\n     * Besides, the specification states that no elements are\n     * matched when `a` and `b` are 0.\n     *\n     * `b < 0` here as we subtracted 1 from `b` above.\n     */\n    if (b < 0 && a <= 0)\n        return boolbase_1.falseFunc;\n    // When `a` is in the range -1..1, it matches any element (so only `b` is checked).\n    if (a === -1)\n        return function (index) { return index <= b; };\n    if (a === 0)\n        return function (index) { return index === b; };\n    // When `b <= 0` and `a === 1`, they match any element.\n    if (a === 1)\n        return b < 0 ? boolbase_1.trueFunc : function (index) { return index >= b; };\n    /*\n     * Otherwise, modulo can be used to check if there is a match.\n     *\n     * Modulo doesn't care about the sign, so let's use `a`s absolute value.\n     */\n    var absA = Math.abs(a);\n    // Get `b mod a`, + a if this is negative.\n    var bMod = ((b % absA) + absA) % absA;\n    return a > 1\n        ? function (index) { return index >= b && index % absA === bMod; }\n        : function (index) { return index <= b && index % absA === bMod; };\n}\nexports.compile = compile;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/nth-check/lib/compile.js?");

/***/ }),

/***/ "./src/node_modules/nth-check/lib/index.js":
/*!*************************************************!*\
  !*** ./src/node_modules/nth-check/lib/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.compile = exports.parse = void 0;\nvar parse_1 = __webpack_require__(/*! ./parse */ \"./src/node_modules/nth-check/lib/parse.js\");\nObject.defineProperty(exports, \"parse\", ({ enumerable: true, get: function () { return parse_1.parse; } }));\nvar compile_1 = __webpack_require__(/*! ./compile */ \"./src/node_modules/nth-check/lib/compile.js\");\nObject.defineProperty(exports, \"compile\", ({ enumerable: true, get: function () { return compile_1.compile; } }));\n/**\n * Parses and compiles a formula to a highly optimized function.\n * Combination of `parse` and `compile`.\n *\n * If the formula doesn't match any elements,\n * it returns [`boolbase`](https://github.com/fb55/boolbase)'s `falseFunc`.\n * Otherwise, a function accepting an _index_ is returned, which returns\n * whether or not the passed _index_ matches the formula.\n *\n * Note: The nth-rule starts counting at `1`, the returned function at `0`.\n *\n * @param formula The formula to compile.\n * @example\n * const check = nthCheck(\"2n+3\");\n *\n * check(0); // `false`\n * check(1); // `false`\n * check(2); // `true`\n * check(3); // `false`\n * check(4); // `true`\n * check(5); // `false`\n * check(6); // `true`\n */\nfunction nthCheck(formula) {\n    return compile_1.compile(parse_1.parse(formula));\n}\nexports.default = nthCheck;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/nth-check/lib/index.js?");

/***/ }),

/***/ "./src/node_modules/nth-check/lib/parse.js":
/*!*************************************************!*\
  !*** ./src/node_modules/nth-check/lib/parse.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// Following http://www.w3.org/TR/css3-selectors/#nth-child-pseudo\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parse = void 0;\n// [ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]?\nvar RE_NTH_ELEMENT = /^([+-]?\\d*n)?\\s*(?:([+-]?)\\s*(\\d+))?$/;\n/**\n * Parses an expression.\n *\n * @throws An `Error` if parsing fails.\n * @returns An array containing the integer step size and the integer offset of the nth rule.\n * @example nthCheck.parse(\"2n+3\"); // returns [2, 3]\n */\nfunction parse(formula) {\n    formula = formula.trim().toLowerCase();\n    if (formula === \"even\") {\n        return [2, 0];\n    }\n    else if (formula === \"odd\") {\n        return [2, 1];\n    }\n    var parsed = formula.match(RE_NTH_ELEMENT);\n    if (!parsed) {\n        throw new Error(\"n-th rule couldn't be parsed ('\" + formula + \"')\");\n    }\n    var a;\n    if (parsed[1]) {\n        a = parseInt(parsed[1], 10);\n        if (isNaN(a)) {\n            a = parsed[1].startsWith(\"-\") ? -1 : 1;\n        }\n    }\n    else\n        a = 0;\n    var b = (parsed[2] === \"-\" ? -1 : 1) *\n        (parsed[3] ? parseInt(parsed[3], 10) : 0);\n    return [a, b];\n}\nexports.parse = parse;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/nth-check/lib/parse.js?");

/***/ }),

/***/ "./src/node_modules/object-is/implementation.js":
/*!******************************************************!*\
  !*** ./src/node_modules/object-is/implementation.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar numberIsNaN = function (value) {\n\treturn value !== value;\n};\n\nmodule.exports = function is(a, b) {\n\tif (a === 0 && b === 0) {\n\t\treturn 1 / a === 1 / b;\n\t}\n\tif (a === b) {\n\t\treturn true;\n\t}\n\tif (numberIsNaN(a) && numberIsNaN(b)) {\n\t\treturn true;\n\t}\n\treturn false;\n};\n\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/object-is/implementation.js?");

/***/ }),

/***/ "./src/node_modules/object-is/index.js":
/*!*********************************************!*\
  !*** ./src/node_modules/object-is/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar define = __webpack_require__(/*! define-properties */ \"define-properties\");\nvar callBind = __webpack_require__(/*! call-bind */ \"call-bind\");\n\nvar implementation = __webpack_require__(/*! ./implementation */ \"./src/node_modules/object-is/implementation.js\");\nvar getPolyfill = __webpack_require__(/*! ./polyfill */ \"./src/node_modules/object-is/polyfill.js\");\nvar shim = __webpack_require__(/*! ./shim */ \"./src/node_modules/object-is/shim.js\");\n\nvar polyfill = callBind(getPolyfill(), Object);\n\ndefine(polyfill, {\n\tgetPolyfill: getPolyfill,\n\timplementation: implementation,\n\tshim: shim\n});\n\nmodule.exports = polyfill;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/object-is/index.js?");

/***/ }),

/***/ "./src/node_modules/object-is/polyfill.js":
/*!************************************************!*\
  !*** ./src/node_modules/object-is/polyfill.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar implementation = __webpack_require__(/*! ./implementation */ \"./src/node_modules/object-is/implementation.js\");\n\nmodule.exports = function getPolyfill() {\n\treturn typeof Object.is === 'function' ? Object.is : implementation;\n};\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/object-is/polyfill.js?");

/***/ }),

/***/ "./src/node_modules/object-is/shim.js":
/*!********************************************!*\
  !*** ./src/node_modules/object-is/shim.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar getPolyfill = __webpack_require__(/*! ./polyfill */ \"./src/node_modules/object-is/polyfill.js\");\nvar define = __webpack_require__(/*! define-properties */ \"define-properties\");\n\nmodule.exports = function shimObjectIs() {\n\tvar polyfill = getPolyfill();\n\tdefine(Object, { is: polyfill }, {\n\t\tis: function testObjectIs() {\n\t\t\treturn Object.is !== polyfill;\n\t\t}\n\t});\n\treturn polyfill;\n};\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/object-is/shim.js?");

/***/ }),

/***/ "./src/node_modules/parse5-htmlparser2-tree-adapter/lib/index.js":
/*!***********************************************************************!*\
  !*** ./src/node_modules/parse5-htmlparser2-tree-adapter/lib/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst doctype = __webpack_require__(/*! parse5/lib/common/doctype */ \"./src/node_modules/parse5/lib/common/doctype.js\");\nconst { DOCUMENT_MODE } = __webpack_require__(/*! parse5/lib/common/html */ \"./src/node_modules/parse5/lib/common/html.js\");\n\n//Conversion tables for DOM Level1 structure emulation\nconst nodeTypes = {\n    element: 1,\n    text: 3,\n    cdata: 4,\n    comment: 8\n};\n\nconst nodePropertyShorthands = {\n    tagName: 'name',\n    childNodes: 'children',\n    parentNode: 'parent',\n    previousSibling: 'prev',\n    nextSibling: 'next',\n    nodeValue: 'data'\n};\n\n//Node\nclass Node {\n    constructor(props) {\n        for (const key of Object.keys(props)) {\n            this[key] = props[key];\n        }\n    }\n\n    get firstChild() {\n        const children = this.children;\n\n        return (children && children[0]) || null;\n    }\n\n    get lastChild() {\n        const children = this.children;\n\n        return (children && children[children.length - 1]) || null;\n    }\n\n    get nodeType() {\n        return nodeTypes[this.type] || nodeTypes.element;\n    }\n}\n\nObject.keys(nodePropertyShorthands).forEach(key => {\n    const shorthand = nodePropertyShorthands[key];\n\n    Object.defineProperty(Node.prototype, key, {\n        get: function() {\n            return this[shorthand] || null;\n        },\n        set: function(val) {\n            this[shorthand] = val;\n            return val;\n        }\n    });\n});\n\n//Node construction\nexports.createDocument = function() {\n    return new Node({\n        type: 'root',\n        name: 'root',\n        parent: null,\n        prev: null,\n        next: null,\n        children: [],\n        'x-mode': DOCUMENT_MODE.NO_QUIRKS\n    });\n};\n\nexports.createDocumentFragment = function() {\n    return new Node({\n        type: 'root',\n        name: 'root',\n        parent: null,\n        prev: null,\n        next: null,\n        children: []\n    });\n};\n\nexports.createElement = function(tagName, namespaceURI, attrs) {\n    const attribs = Object.create(null);\n    const attribsNamespace = Object.create(null);\n    const attribsPrefix = Object.create(null);\n\n    for (let i = 0; i < attrs.length; i++) {\n        const attrName = attrs[i].name;\n\n        attribs[attrName] = attrs[i].value;\n        attribsNamespace[attrName] = attrs[i].namespace;\n        attribsPrefix[attrName] = attrs[i].prefix;\n    }\n\n    return new Node({\n        type: tagName === 'script' || tagName === 'style' ? tagName : 'tag',\n        name: tagName,\n        namespace: namespaceURI,\n        attribs: attribs,\n        'x-attribsNamespace': attribsNamespace,\n        'x-attribsPrefix': attribsPrefix,\n        children: [],\n        parent: null,\n        prev: null,\n        next: null\n    });\n};\n\nexports.createCommentNode = function(data) {\n    return new Node({\n        type: 'comment',\n        data: data,\n        parent: null,\n        prev: null,\n        next: null\n    });\n};\n\nconst createTextNode = function(value) {\n    return new Node({\n        type: 'text',\n        data: value,\n        parent: null,\n        prev: null,\n        next: null\n    });\n};\n\n//Tree mutation\nconst appendChild = (exports.appendChild = function(parentNode, newNode) {\n    const prev = parentNode.children[parentNode.children.length - 1];\n\n    if (prev) {\n        prev.next = newNode;\n        newNode.prev = prev;\n    }\n\n    parentNode.children.push(newNode);\n    newNode.parent = parentNode;\n});\n\nconst insertBefore = (exports.insertBefore = function(parentNode, newNode, referenceNode) {\n    const insertionIdx = parentNode.children.indexOf(referenceNode);\n    const prev = referenceNode.prev;\n\n    if (prev) {\n        prev.next = newNode;\n        newNode.prev = prev;\n    }\n\n    referenceNode.prev = newNode;\n    newNode.next = referenceNode;\n\n    parentNode.children.splice(insertionIdx, 0, newNode);\n    newNode.parent = parentNode;\n});\n\nexports.setTemplateContent = function(templateElement, contentElement) {\n    appendChild(templateElement, contentElement);\n};\n\nexports.getTemplateContent = function(templateElement) {\n    return templateElement.children[0];\n};\n\nexports.setDocumentType = function(document, name, publicId, systemId) {\n    const data = doctype.serializeContent(name, publicId, systemId);\n    let doctypeNode = null;\n\n    for (let i = 0; i < document.children.length; i++) {\n        if (document.children[i].type === 'directive' && document.children[i].name === '!doctype') {\n            doctypeNode = document.children[i];\n            break;\n        }\n    }\n\n    if (doctypeNode) {\n        doctypeNode.data = data;\n        doctypeNode['x-name'] = name;\n        doctypeNode['x-publicId'] = publicId;\n        doctypeNode['x-systemId'] = systemId;\n    } else {\n        appendChild(\n            document,\n            new Node({\n                type: 'directive',\n                name: '!doctype',\n                data: data,\n                'x-name': name,\n                'x-publicId': publicId,\n                'x-systemId': systemId\n            })\n        );\n    }\n};\n\nexports.setDocumentMode = function(document, mode) {\n    document['x-mode'] = mode;\n};\n\nexports.getDocumentMode = function(document) {\n    return document['x-mode'];\n};\n\nexports.detachNode = function(node) {\n    if (node.parent) {\n        const idx = node.parent.children.indexOf(node);\n        const prev = node.prev;\n        const next = node.next;\n\n        node.prev = null;\n        node.next = null;\n\n        if (prev) {\n            prev.next = next;\n        }\n\n        if (next) {\n            next.prev = prev;\n        }\n\n        node.parent.children.splice(idx, 1);\n        node.parent = null;\n    }\n};\n\nexports.insertText = function(parentNode, text) {\n    const lastChild = parentNode.children[parentNode.children.length - 1];\n\n    if (lastChild && lastChild.type === 'text') {\n        lastChild.data += text;\n    } else {\n        appendChild(parentNode, createTextNode(text));\n    }\n};\n\nexports.insertTextBefore = function(parentNode, text, referenceNode) {\n    const prevNode = parentNode.children[parentNode.children.indexOf(referenceNode) - 1];\n\n    if (prevNode && prevNode.type === 'text') {\n        prevNode.data += text;\n    } else {\n        insertBefore(parentNode, createTextNode(text), referenceNode);\n    }\n};\n\nexports.adoptAttributes = function(recipient, attrs) {\n    for (let i = 0; i < attrs.length; i++) {\n        const attrName = attrs[i].name;\n\n        if (typeof recipient.attribs[attrName] === 'undefined') {\n            recipient.attribs[attrName] = attrs[i].value;\n            recipient['x-attribsNamespace'][attrName] = attrs[i].namespace;\n            recipient['x-attribsPrefix'][attrName] = attrs[i].prefix;\n        }\n    }\n};\n\n//Tree traversing\nexports.getFirstChild = function(node) {\n    return node.children[0];\n};\n\nexports.getChildNodes = function(node) {\n    return node.children;\n};\n\nexports.getParentNode = function(node) {\n    return node.parent;\n};\n\nexports.getAttrList = function(element) {\n    const attrList = [];\n\n    for (const name in element.attribs) {\n        attrList.push({\n            name: name,\n            value: element.attribs[name],\n            namespace: element['x-attribsNamespace'][name],\n            prefix: element['x-attribsPrefix'][name]\n        });\n    }\n\n    return attrList;\n};\n\n//Node data\nexports.getTagName = function(element) {\n    return element.name;\n};\n\nexports.getNamespaceURI = function(element) {\n    return element.namespace;\n};\n\nexports.getTextNodeContent = function(textNode) {\n    return textNode.data;\n};\n\nexports.getCommentNodeContent = function(commentNode) {\n    return commentNode.data;\n};\n\nexports.getDocumentTypeNodeName = function(doctypeNode) {\n    return doctypeNode['x-name'];\n};\n\nexports.getDocumentTypeNodePublicId = function(doctypeNode) {\n    return doctypeNode['x-publicId'];\n};\n\nexports.getDocumentTypeNodeSystemId = function(doctypeNode) {\n    return doctypeNode['x-systemId'];\n};\n\n//Node types\nexports.isTextNode = function(node) {\n    return node.type === 'text';\n};\n\nexports.isCommentNode = function(node) {\n    return node.type === 'comment';\n};\n\nexports.isDocumentTypeNode = function(node) {\n    return node.type === 'directive' && node.name === '!doctype';\n};\n\nexports.isElementNode = function(node) {\n    return !!node.attribs;\n};\n\n// Source code location\nexports.setNodeSourceCodeLocation = function(node, location) {\n    node.sourceCodeLocation = location;\n};\n\nexports.getNodeSourceCodeLocation = function(node) {\n    return node.sourceCodeLocation;\n};\n\nexports.updateNodeSourceCodeLocation = function(node, endLocation) {\n    node.sourceCodeLocation = Object.assign(node.sourceCodeLocation, endLocation);\n};\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/parse5-htmlparser2-tree-adapter/lib/index.js?");

/***/ }),

/***/ "./src/node_modules/parse5/lib/common/doctype.js":
/*!*******************************************************!*\
  !*** ./src/node_modules/parse5/lib/common/doctype.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { DOCUMENT_MODE } = __webpack_require__(/*! ./html */ \"./src/node_modules/parse5/lib/common/html.js\");\n\n//Const\nconst VALID_DOCTYPE_NAME = 'html';\nconst VALID_SYSTEM_ID = 'about:legacy-compat';\nconst QUIRKS_MODE_SYSTEM_ID = 'http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd';\n\nconst QUIRKS_MODE_PUBLIC_ID_PREFIXES = [\n    '+//silmaril//dtd html pro v0r11 19970101//',\n    '-//as//dtd html 3.0 aswedit + extensions//',\n    '-//advasoft ltd//dtd html 3.0 aswedit + extensions//',\n    '-//ietf//dtd html 2.0 level 1//',\n    '-//ietf//dtd html 2.0 level 2//',\n    '-//ietf//dtd html 2.0 strict level 1//',\n    '-//ietf//dtd html 2.0 strict level 2//',\n    '-//ietf//dtd html 2.0 strict//',\n    '-//ietf//dtd html 2.0//',\n    '-//ietf//dtd html 2.1e//',\n    '-//ietf//dtd html 3.0//',\n    '-//ietf//dtd html 3.2 final//',\n    '-//ietf//dtd html 3.2//',\n    '-//ietf//dtd html 3//',\n    '-//ietf//dtd html level 0//',\n    '-//ietf//dtd html level 1//',\n    '-//ietf//dtd html level 2//',\n    '-//ietf//dtd html level 3//',\n    '-//ietf//dtd html strict level 0//',\n    '-//ietf//dtd html strict level 1//',\n    '-//ietf//dtd html strict level 2//',\n    '-//ietf//dtd html strict level 3//',\n    '-//ietf//dtd html strict//',\n    '-//ietf//dtd html//',\n    '-//metrius//dtd metrius presentational//',\n    '-//microsoft//dtd internet explorer 2.0 html strict//',\n    '-//microsoft//dtd internet explorer 2.0 html//',\n    '-//microsoft//dtd internet explorer 2.0 tables//',\n    '-//microsoft//dtd internet explorer 3.0 html strict//',\n    '-//microsoft//dtd internet explorer 3.0 html//',\n    '-//microsoft//dtd internet explorer 3.0 tables//',\n    '-//netscape comm. corp.//dtd html//',\n    '-//netscape comm. corp.//dtd strict html//',\n    \"-//o'reilly and associates//dtd html 2.0//\",\n    \"-//o'reilly and associates//dtd html extended 1.0//\",\n    \"-//o'reilly and associates//dtd html extended relaxed 1.0//\",\n    '-//sq//dtd html 2.0 hotmetal + extensions//',\n    '-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//',\n    '-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//',\n    '-//spyglass//dtd html 2.0 extended//',\n    '-//sun microsystems corp.//dtd hotjava html//',\n    '-//sun microsystems corp.//dtd hotjava strict html//',\n    '-//w3c//dtd html 3 1995-03-24//',\n    '-//w3c//dtd html 3.2 draft//',\n    '-//w3c//dtd html 3.2 final//',\n    '-//w3c//dtd html 3.2//',\n    '-//w3c//dtd html 3.2s draft//',\n    '-//w3c//dtd html 4.0 frameset//',\n    '-//w3c//dtd html 4.0 transitional//',\n    '-//w3c//dtd html experimental 19960712//',\n    '-//w3c//dtd html experimental 970421//',\n    '-//w3c//dtd w3 html//',\n    '-//w3o//dtd w3 html 3.0//',\n    '-//webtechs//dtd mozilla html 2.0//',\n    '-//webtechs//dtd mozilla html//'\n];\n\nconst QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES = QUIRKS_MODE_PUBLIC_ID_PREFIXES.concat([\n    '-//w3c//dtd html 4.01 frameset//',\n    '-//w3c//dtd html 4.01 transitional//'\n]);\n\nconst QUIRKS_MODE_PUBLIC_IDS = ['-//w3o//dtd w3 html strict 3.0//en//', '-/w3c/dtd html 4.0 transitional/en', 'html'];\nconst LIMITED_QUIRKS_PUBLIC_ID_PREFIXES = ['-//w3c//dtd xhtml 1.0 frameset//', '-//w3c//dtd xhtml 1.0 transitional//'];\n\nconst LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES = LIMITED_QUIRKS_PUBLIC_ID_PREFIXES.concat([\n    '-//w3c//dtd html 4.01 frameset//',\n    '-//w3c//dtd html 4.01 transitional//'\n]);\n\n//Utils\nfunction enquoteDoctypeId(id) {\n    const quote = id.indexOf('\"') !== -1 ? \"'\" : '\"';\n\n    return quote + id + quote;\n}\n\nfunction hasPrefix(publicId, prefixes) {\n    for (let i = 0; i < prefixes.length; i++) {\n        if (publicId.indexOf(prefixes[i]) === 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n//API\nexports.isConforming = function(token) {\n    return (\n        token.name === VALID_DOCTYPE_NAME &&\n        token.publicId === null &&\n        (token.systemId === null || token.systemId === VALID_SYSTEM_ID)\n    );\n};\n\nexports.getDocumentMode = function(token) {\n    if (token.name !== VALID_DOCTYPE_NAME) {\n        return DOCUMENT_MODE.QUIRKS;\n    }\n\n    const systemId = token.systemId;\n\n    if (systemId && systemId.toLowerCase() === QUIRKS_MODE_SYSTEM_ID) {\n        return DOCUMENT_MODE.QUIRKS;\n    }\n\n    let publicId = token.publicId;\n\n    if (publicId !== null) {\n        publicId = publicId.toLowerCase();\n\n        if (QUIRKS_MODE_PUBLIC_IDS.indexOf(publicId) > -1) {\n            return DOCUMENT_MODE.QUIRKS;\n        }\n\n        let prefixes = systemId === null ? QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES : QUIRKS_MODE_PUBLIC_ID_PREFIXES;\n\n        if (hasPrefix(publicId, prefixes)) {\n            return DOCUMENT_MODE.QUIRKS;\n        }\n\n        prefixes =\n            systemId === null ? LIMITED_QUIRKS_PUBLIC_ID_PREFIXES : LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES;\n\n        if (hasPrefix(publicId, prefixes)) {\n            return DOCUMENT_MODE.LIMITED_QUIRKS;\n        }\n    }\n\n    return DOCUMENT_MODE.NO_QUIRKS;\n};\n\nexports.serializeContent = function(name, publicId, systemId) {\n    let str = '!DOCTYPE ';\n\n    if (name) {\n        str += name;\n    }\n\n    if (publicId) {\n        str += ' PUBLIC ' + enquoteDoctypeId(publicId);\n    } else if (systemId) {\n        str += ' SYSTEM';\n    }\n\n    if (systemId !== null) {\n        str += ' ' + enquoteDoctypeId(systemId);\n    }\n\n    return str;\n};\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/parse5/lib/common/doctype.js?");

/***/ }),

/***/ "./src/node_modules/parse5/lib/common/error-codes.js":
/*!***********************************************************!*\
  !*** ./src/node_modules/parse5/lib/common/error-codes.js ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = {\n    controlCharacterInInputStream: 'control-character-in-input-stream',\n    noncharacterInInputStream: 'noncharacter-in-input-stream',\n    surrogateInInputStream: 'surrogate-in-input-stream',\n    nonVoidHtmlElementStartTagWithTrailingSolidus: 'non-void-html-element-start-tag-with-trailing-solidus',\n    endTagWithAttributes: 'end-tag-with-attributes',\n    endTagWithTrailingSolidus: 'end-tag-with-trailing-solidus',\n    unexpectedSolidusInTag: 'unexpected-solidus-in-tag',\n    unexpectedNullCharacter: 'unexpected-null-character',\n    unexpectedQuestionMarkInsteadOfTagName: 'unexpected-question-mark-instead-of-tag-name',\n    invalidFirstCharacterOfTagName: 'invalid-first-character-of-tag-name',\n    unexpectedEqualsSignBeforeAttributeName: 'unexpected-equals-sign-before-attribute-name',\n    missingEndTagName: 'missing-end-tag-name',\n    unexpectedCharacterInAttributeName: 'unexpected-character-in-attribute-name',\n    unknownNamedCharacterReference: 'unknown-named-character-reference',\n    missingSemicolonAfterCharacterReference: 'missing-semicolon-after-character-reference',\n    unexpectedCharacterAfterDoctypeSystemIdentifier: 'unexpected-character-after-doctype-system-identifier',\n    unexpectedCharacterInUnquotedAttributeValue: 'unexpected-character-in-unquoted-attribute-value',\n    eofBeforeTagName: 'eof-before-tag-name',\n    eofInTag: 'eof-in-tag',\n    missingAttributeValue: 'missing-attribute-value',\n    missingWhitespaceBetweenAttributes: 'missing-whitespace-between-attributes',\n    missingWhitespaceAfterDoctypePublicKeyword: 'missing-whitespace-after-doctype-public-keyword',\n    missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers:\n        'missing-whitespace-between-doctype-public-and-system-identifiers',\n    missingWhitespaceAfterDoctypeSystemKeyword: 'missing-whitespace-after-doctype-system-keyword',\n    missingQuoteBeforeDoctypePublicIdentifier: 'missing-quote-before-doctype-public-identifier',\n    missingQuoteBeforeDoctypeSystemIdentifier: 'missing-quote-before-doctype-system-identifier',\n    missingDoctypePublicIdentifier: 'missing-doctype-public-identifier',\n    missingDoctypeSystemIdentifier: 'missing-doctype-system-identifier',\n    abruptDoctypePublicIdentifier: 'abrupt-doctype-public-identifier',\n    abruptDoctypeSystemIdentifier: 'abrupt-doctype-system-identifier',\n    cdataInHtmlContent: 'cdata-in-html-content',\n    incorrectlyOpenedComment: 'incorrectly-opened-comment',\n    eofInScriptHtmlCommentLikeText: 'eof-in-script-html-comment-like-text',\n    eofInDoctype: 'eof-in-doctype',\n    nestedComment: 'nested-comment',\n    abruptClosingOfEmptyComment: 'abrupt-closing-of-empty-comment',\n    eofInComment: 'eof-in-comment',\n    incorrectlyClosedComment: 'incorrectly-closed-comment',\n    eofInCdata: 'eof-in-cdata',\n    absenceOfDigitsInNumericCharacterReference: 'absence-of-digits-in-numeric-character-reference',\n    nullCharacterReference: 'null-character-reference',\n    surrogateCharacterReference: 'surrogate-character-reference',\n    characterReferenceOutsideUnicodeRange: 'character-reference-outside-unicode-range',\n    controlCharacterReference: 'control-character-reference',\n    noncharacterCharacterReference: 'noncharacter-character-reference',\n    missingWhitespaceBeforeDoctypeName: 'missing-whitespace-before-doctype-name',\n    missingDoctypeName: 'missing-doctype-name',\n    invalidCharacterSequenceAfterDoctypeName: 'invalid-character-sequence-after-doctype-name',\n    duplicateAttribute: 'duplicate-attribute',\n    nonConformingDoctype: 'non-conforming-doctype',\n    missingDoctype: 'missing-doctype',\n    misplacedDoctype: 'misplaced-doctype',\n    endTagWithoutMatchingOpenElement: 'end-tag-without-matching-open-element',\n    closingOfElementWithOpenChildElements: 'closing-of-element-with-open-child-elements',\n    disallowedContentInNoscriptInHead: 'disallowed-content-in-noscript-in-head',\n    openElementsLeftAfterEof: 'open-elements-left-after-eof',\n    abandonedHeadElementChild: 'abandoned-head-element-child',\n    misplacedStartTagForHeadElement: 'misplaced-start-tag-for-head-element',\n    nestedNoscriptInHead: 'nested-noscript-in-head',\n    eofInElementThatCanContainOnlyText: 'eof-in-element-that-can-contain-only-text'\n};\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/parse5/lib/common/error-codes.js?");

/***/ }),

/***/ "./src/node_modules/parse5/lib/common/foreign-content.js":
/*!***************************************************************!*\
  !*** ./src/node_modules/parse5/lib/common/foreign-content.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Tokenizer = __webpack_require__(/*! ../tokenizer */ \"./src/node_modules/parse5/lib/tokenizer/index.js\");\nconst HTML = __webpack_require__(/*! ./html */ \"./src/node_modules/parse5/lib/common/html.js\");\n\n//Aliases\nconst $ = HTML.TAG_NAMES;\nconst NS = HTML.NAMESPACES;\nconst ATTRS = HTML.ATTRS;\n\n//MIME types\nconst MIME_TYPES = {\n    TEXT_HTML: 'text/html',\n    APPLICATION_XML: 'application/xhtml+xml'\n};\n\n//Attributes\nconst DEFINITION_URL_ATTR = 'definitionurl';\nconst ADJUSTED_DEFINITION_URL_ATTR = 'definitionURL';\nconst SVG_ATTRS_ADJUSTMENT_MAP = {\n    attributename: 'attributeName',\n    attributetype: 'attributeType',\n    basefrequency: 'baseFrequency',\n    baseprofile: 'baseProfile',\n    calcmode: 'calcMode',\n    clippathunits: 'clipPathUnits',\n    diffuseconstant: 'diffuseConstant',\n    edgemode: 'edgeMode',\n    filterunits: 'filterUnits',\n    glyphref: 'glyphRef',\n    gradienttransform: 'gradientTransform',\n    gradientunits: 'gradientUnits',\n    kernelmatrix: 'kernelMatrix',\n    kernelunitlength: 'kernelUnitLength',\n    keypoints: 'keyPoints',\n    keysplines: 'keySplines',\n    keytimes: 'keyTimes',\n    lengthadjust: 'lengthAdjust',\n    limitingconeangle: 'limitingConeAngle',\n    markerheight: 'markerHeight',\n    markerunits: 'markerUnits',\n    markerwidth: 'markerWidth',\n    maskcontentunits: 'maskContentUnits',\n    maskunits: 'maskUnits',\n    numoctaves: 'numOctaves',\n    pathlength: 'pathLength',\n    patterncontentunits: 'patternContentUnits',\n    patterntransform: 'patternTransform',\n    patternunits: 'patternUnits',\n    pointsatx: 'pointsAtX',\n    pointsaty: 'pointsAtY',\n    pointsatz: 'pointsAtZ',\n    preservealpha: 'preserveAlpha',\n    preserveaspectratio: 'preserveAspectRatio',\n    primitiveunits: 'primitiveUnits',\n    refx: 'refX',\n    refy: 'refY',\n    repeatcount: 'repeatCount',\n    repeatdur: 'repeatDur',\n    requiredextensions: 'requiredExtensions',\n    requiredfeatures: 'requiredFeatures',\n    specularconstant: 'specularConstant',\n    specularexponent: 'specularExponent',\n    spreadmethod: 'spreadMethod',\n    startoffset: 'startOffset',\n    stddeviation: 'stdDeviation',\n    stitchtiles: 'stitchTiles',\n    surfacescale: 'surfaceScale',\n    systemlanguage: 'systemLanguage',\n    tablevalues: 'tableValues',\n    targetx: 'targetX',\n    targety: 'targetY',\n    textlength: 'textLength',\n    viewbox: 'viewBox',\n    viewtarget: 'viewTarget',\n    xchannelselector: 'xChannelSelector',\n    ychannelselector: 'yChannelSelector',\n    zoomandpan: 'zoomAndPan'\n};\n\nconst XML_ATTRS_ADJUSTMENT_MAP = {\n    'xlink:actuate': { prefix: 'xlink', name: 'actuate', namespace: NS.XLINK },\n    'xlink:arcrole': { prefix: 'xlink', name: 'arcrole', namespace: NS.XLINK },\n    'xlink:href': { prefix: 'xlink', name: 'href', namespace: NS.XLINK },\n    'xlink:role': { prefix: 'xlink', name: 'role', namespace: NS.XLINK },\n    'xlink:show': { prefix: 'xlink', name: 'show', namespace: NS.XLINK },\n    'xlink:title': { prefix: 'xlink', name: 'title', namespace: NS.XLINK },\n    'xlink:type': { prefix: 'xlink', name: 'type', namespace: NS.XLINK },\n    'xml:base': { prefix: 'xml', name: 'base', namespace: NS.XML },\n    'xml:lang': { prefix: 'xml', name: 'lang', namespace: NS.XML },\n    'xml:space': { prefix: 'xml', name: 'space', namespace: NS.XML },\n    xmlns: { prefix: '', name: 'xmlns', namespace: NS.XMLNS },\n    'xmlns:xlink': { prefix: 'xmlns', name: 'xlink', namespace: NS.XMLNS }\n};\n\n//SVG tag names adjustment map\nconst SVG_TAG_NAMES_ADJUSTMENT_MAP = (exports.SVG_TAG_NAMES_ADJUSTMENT_MAP = {\n    altglyph: 'altGlyph',\n    altglyphdef: 'altGlyphDef',\n    altglyphitem: 'altGlyphItem',\n    animatecolor: 'animateColor',\n    animatemotion: 'animateMotion',\n    animatetransform: 'animateTransform',\n    clippath: 'clipPath',\n    feblend: 'feBlend',\n    fecolormatrix: 'feColorMatrix',\n    fecomponenttransfer: 'feComponentTransfer',\n    fecomposite: 'feComposite',\n    feconvolvematrix: 'feConvolveMatrix',\n    fediffuselighting: 'feDiffuseLighting',\n    fedisplacementmap: 'feDisplacementMap',\n    fedistantlight: 'feDistantLight',\n    feflood: 'feFlood',\n    fefunca: 'feFuncA',\n    fefuncb: 'feFuncB',\n    fefuncg: 'feFuncG',\n    fefuncr: 'feFuncR',\n    fegaussianblur: 'feGaussianBlur',\n    feimage: 'feImage',\n    femerge: 'feMerge',\n    femergenode: 'feMergeNode',\n    femorphology: 'feMorphology',\n    feoffset: 'feOffset',\n    fepointlight: 'fePointLight',\n    fespecularlighting: 'feSpecularLighting',\n    fespotlight: 'feSpotLight',\n    fetile: 'feTile',\n    feturbulence: 'feTurbulence',\n    foreignobject: 'foreignObject',\n    glyphref: 'glyphRef',\n    lineargradient: 'linearGradient',\n    radialgradient: 'radialGradient',\n    textpath: 'textPath'\n});\n\n//Tags that causes exit from foreign content\nconst EXITS_FOREIGN_CONTENT = {\n    [$.B]: true,\n    [$.BIG]: true,\n    [$.BLOCKQUOTE]: true,\n    [$.BODY]: true,\n    [$.BR]: true,\n    [$.CENTER]: true,\n    [$.CODE]: true,\n    [$.DD]: true,\n    [$.DIV]: true,\n    [$.DL]: true,\n    [$.DT]: true,\n    [$.EM]: true,\n    [$.EMBED]: true,\n    [$.H1]: true,\n    [$.H2]: true,\n    [$.H3]: true,\n    [$.H4]: true,\n    [$.H5]: true,\n    [$.H6]: true,\n    [$.HEAD]: true,\n    [$.HR]: true,\n    [$.I]: true,\n    [$.IMG]: true,\n    [$.LI]: true,\n    [$.LISTING]: true,\n    [$.MENU]: true,\n    [$.META]: true,\n    [$.NOBR]: true,\n    [$.OL]: true,\n    [$.P]: true,\n    [$.PRE]: true,\n    [$.RUBY]: true,\n    [$.S]: true,\n    [$.SMALL]: true,\n    [$.SPAN]: true,\n    [$.STRONG]: true,\n    [$.STRIKE]: true,\n    [$.SUB]: true,\n    [$.SUP]: true,\n    [$.TABLE]: true,\n    [$.TT]: true,\n    [$.U]: true,\n    [$.UL]: true,\n    [$.VAR]: true\n};\n\n//Check exit from foreign content\nexports.causesExit = function(startTagToken) {\n    const tn = startTagToken.tagName;\n    const isFontWithAttrs =\n        tn === $.FONT &&\n        (Tokenizer.getTokenAttr(startTagToken, ATTRS.COLOR) !== null ||\n            Tokenizer.getTokenAttr(startTagToken, ATTRS.SIZE) !== null ||\n            Tokenizer.getTokenAttr(startTagToken, ATTRS.FACE) !== null);\n\n    return isFontWithAttrs ? true : EXITS_FOREIGN_CONTENT[tn];\n};\n\n//Token adjustments\nexports.adjustTokenMathMLAttrs = function(token) {\n    for (let i = 0; i < token.attrs.length; i++) {\n        if (token.attrs[i].name === DEFINITION_URL_ATTR) {\n            token.attrs[i].name = ADJUSTED_DEFINITION_URL_ATTR;\n            break;\n        }\n    }\n};\n\nexports.adjustTokenSVGAttrs = function(token) {\n    for (let i = 0; i < token.attrs.length; i++) {\n        const adjustedAttrName = SVG_ATTRS_ADJUSTMENT_MAP[token.attrs[i].name];\n\n        if (adjustedAttrName) {\n            token.attrs[i].name = adjustedAttrName;\n        }\n    }\n};\n\nexports.adjustTokenXMLAttrs = function(token) {\n    for (let i = 0; i < token.attrs.length; i++) {\n        const adjustedAttrEntry = XML_ATTRS_ADJUSTMENT_MAP[token.attrs[i].name];\n\n        if (adjustedAttrEntry) {\n            token.attrs[i].prefix = adjustedAttrEntry.prefix;\n            token.attrs[i].name = adjustedAttrEntry.name;\n            token.attrs[i].namespace = adjustedAttrEntry.namespace;\n        }\n    }\n};\n\nexports.adjustTokenSVGTagName = function(token) {\n    const adjustedTagName = SVG_TAG_NAMES_ADJUSTMENT_MAP[token.tagName];\n\n    if (adjustedTagName) {\n        token.tagName = adjustedTagName;\n    }\n};\n\n//Integration points\nfunction isMathMLTextIntegrationPoint(tn, ns) {\n    return ns === NS.MATHML && (tn === $.MI || tn === $.MO || tn === $.MN || tn === $.MS || tn === $.MTEXT);\n}\n\nfunction isHtmlIntegrationPoint(tn, ns, attrs) {\n    if (ns === NS.MATHML && tn === $.ANNOTATION_XML) {\n        for (let i = 0; i < attrs.length; i++) {\n            if (attrs[i].name === ATTRS.ENCODING) {\n                const value = attrs[i].value.toLowerCase();\n\n                return value === MIME_TYPES.TEXT_HTML || value === MIME_TYPES.APPLICATION_XML;\n            }\n        }\n    }\n\n    return ns === NS.SVG && (tn === $.FOREIGN_OBJECT || tn === $.DESC || tn === $.TITLE);\n}\n\nexports.isIntegrationPoint = function(tn, ns, attrs, foreignNS) {\n    if ((!foreignNS || foreignNS === NS.HTML) && isHtmlIntegrationPoint(tn, ns, attrs)) {\n        return true;\n    }\n\n    if ((!foreignNS || foreignNS === NS.MATHML) && isMathMLTextIntegrationPoint(tn, ns)) {\n        return true;\n    }\n\n    return false;\n};\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/parse5/lib/common/foreign-content.js?");

/***/ }),

/***/ "./src/node_modules/parse5/lib/common/html.js":
/*!****************************************************!*\
  !*** ./src/node_modules/parse5/lib/common/html.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nconst NS = (exports.NAMESPACES = {\n    HTML: 'http://www.w3.org/1999/xhtml',\n    MATHML: 'http://www.w3.org/1998/Math/MathML',\n    SVG: 'http://www.w3.org/2000/svg',\n    XLINK: 'http://www.w3.org/1999/xlink',\n    XML: 'http://www.w3.org/XML/1998/namespace',\n    XMLNS: 'http://www.w3.org/2000/xmlns/'\n});\n\nexports.ATTRS = {\n    TYPE: 'type',\n    ACTION: 'action',\n    ENCODING: 'encoding',\n    PROMPT: 'prompt',\n    NAME: 'name',\n    COLOR: 'color',\n    FACE: 'face',\n    SIZE: 'size'\n};\n\nexports.DOCUMENT_MODE = {\n    NO_QUIRKS: 'no-quirks',\n    QUIRKS: 'quirks',\n    LIMITED_QUIRKS: 'limited-quirks'\n};\n\nconst $ = (exports.TAG_NAMES = {\n    A: 'a',\n    ADDRESS: 'address',\n    ANNOTATION_XML: 'annotation-xml',\n    APPLET: 'applet',\n    AREA: 'area',\n    ARTICLE: 'article',\n    ASIDE: 'aside',\n\n    B: 'b',\n    BASE: 'base',\n    BASEFONT: 'basefont',\n    BGSOUND: 'bgsound',\n    BIG: 'big',\n    BLOCKQUOTE: 'blockquote',\n    BODY: 'body',\n    BR: 'br',\n    BUTTON: 'button',\n\n    CAPTION: 'caption',\n    CENTER: 'center',\n    CODE: 'code',\n    COL: 'col',\n    COLGROUP: 'colgroup',\n\n    DD: 'dd',\n    DESC: 'desc',\n    DETAILS: 'details',\n    DIALOG: 'dialog',\n    DIR: 'dir',\n    DIV: 'div',\n    DL: 'dl',\n    DT: 'dt',\n\n    EM: 'em',\n    EMBED: 'embed',\n\n    FIELDSET: 'fieldset',\n    FIGCAPTION: 'figcaption',\n    FIGURE: 'figure',\n    FONT: 'font',\n    FOOTER: 'footer',\n    FOREIGN_OBJECT: 'foreignObject',\n    FORM: 'form',\n    FRAME: 'frame',\n    FRAMESET: 'frameset',\n\n    H1: 'h1',\n    H2: 'h2',\n    H3: 'h3',\n    H4: 'h4',\n    H5: 'h5',\n    H6: 'h6',\n    HEAD: 'head',\n    HEADER: 'header',\n    HGROUP: 'hgroup',\n    HR: 'hr',\n    HTML: 'html',\n\n    I: 'i',\n    IMG: 'img',\n    IMAGE: 'image',\n    INPUT: 'input',\n    IFRAME: 'iframe',\n\n    KEYGEN: 'keygen',\n\n    LABEL: 'label',\n    LI: 'li',\n    LINK: 'link',\n    LISTING: 'listing',\n\n    MAIN: 'main',\n    MALIGNMARK: 'malignmark',\n    MARQUEE: 'marquee',\n    MATH: 'math',\n    MENU: 'menu',\n    META: 'meta',\n    MGLYPH: 'mglyph',\n    MI: 'mi',\n    MO: 'mo',\n    MN: 'mn',\n    MS: 'ms',\n    MTEXT: 'mtext',\n\n    NAV: 'nav',\n    NOBR: 'nobr',\n    NOFRAMES: 'noframes',\n    NOEMBED: 'noembed',\n    NOSCRIPT: 'noscript',\n\n    OBJECT: 'object',\n    OL: 'ol',\n    OPTGROUP: 'optgroup',\n    OPTION: 'option',\n\n    P: 'p',\n    PARAM: 'param',\n    PLAINTEXT: 'plaintext',\n    PRE: 'pre',\n\n    RB: 'rb',\n    RP: 'rp',\n    RT: 'rt',\n    RTC: 'rtc',\n    RUBY: 'ruby',\n\n    S: 's',\n    SCRIPT: 'script',\n    SECTION: 'section',\n    SELECT: 'select',\n    SOURCE: 'source',\n    SMALL: 'small',\n    SPAN: 'span',\n    STRIKE: 'strike',\n    STRONG: 'strong',\n    STYLE: 'style',\n    SUB: 'sub',\n    SUMMARY: 'summary',\n    SUP: 'sup',\n\n    TABLE: 'table',\n    TBODY: 'tbody',\n    TEMPLATE: 'template',\n    TEXTAREA: 'textarea',\n    TFOOT: 'tfoot',\n    TD: 'td',\n    TH: 'th',\n    THEAD: 'thead',\n    TITLE: 'title',\n    TR: 'tr',\n    TRACK: 'track',\n    TT: 'tt',\n\n    U: 'u',\n    UL: 'ul',\n\n    SVG: 'svg',\n\n    VAR: 'var',\n\n    WBR: 'wbr',\n\n    XMP: 'xmp'\n});\n\nexports.SPECIAL_ELEMENTS = {\n    [NS.HTML]: {\n        [$.ADDRESS]: true,\n        [$.APPLET]: true,\n        [$.AREA]: true,\n        [$.ARTICLE]: true,\n        [$.ASIDE]: true,\n        [$.BASE]: true,\n        [$.BASEFONT]: true,\n        [$.BGSOUND]: true,\n        [$.BLOCKQUOTE]: true,\n        [$.BODY]: true,\n        [$.BR]: true,\n        [$.BUTTON]: true,\n        [$.CAPTION]: true,\n        [$.CENTER]: true,\n        [$.COL]: true,\n        [$.COLGROUP]: true,\n        [$.DD]: true,\n        [$.DETAILS]: true,\n        [$.DIR]: true,\n        [$.DIV]: true,\n        [$.DL]: true,\n        [$.DT]: true,\n        [$.EMBED]: true,\n        [$.FIELDSET]: true,\n        [$.FIGCAPTION]: true,\n        [$.FIGURE]: true,\n        [$.FOOTER]: true,\n        [$.FORM]: true,\n        [$.FRAME]: true,\n        [$.FRAMESET]: true,\n        [$.H1]: true,\n        [$.H2]: true,\n        [$.H3]: true,\n        [$.H4]: true,\n        [$.H5]: true,\n        [$.H6]: true,\n        [$.HEAD]: true,\n        [$.HEADER]: true,\n        [$.HGROUP]: true,\n        [$.HR]: true,\n        [$.HTML]: true,\n        [$.IFRAME]: true,\n        [$.IMG]: true,\n        [$.INPUT]: true,\n        [$.LI]: true,\n        [$.LINK]: true,\n        [$.LISTING]: true,\n        [$.MAIN]: true,\n        [$.MARQUEE]: true,\n        [$.MENU]: true,\n        [$.META]: true,\n        [$.NAV]: true,\n        [$.NOEMBED]: true,\n        [$.NOFRAMES]: true,\n        [$.NOSCRIPT]: true,\n        [$.OBJECT]: true,\n        [$.OL]: true,\n        [$.P]: true,\n        [$.PARAM]: true,\n        [$.PLAINTEXT]: true,\n        [$.PRE]: true,\n        [$.SCRIPT]: true,\n        [$.SECTION]: true,\n        [$.SELECT]: true,\n        [$.SOURCE]: true,\n        [$.STYLE]: true,\n        [$.SUMMARY]: true,\n        [$.TABLE]: true,\n        [$.TBODY]: true,\n        [$.TD]: true,\n        [$.TEMPLATE]: true,\n        [$.TEXTAREA]: true,\n        [$.TFOOT]: true,\n        [$.TH]: true,\n        [$.THEAD]: true,\n        [$.TITLE]: true,\n        [$.TR]: true,\n        [$.TRACK]: true,\n        [$.UL]: true,\n        [$.WBR]: true,\n        [$.XMP]: true\n    },\n    [NS.MATHML]: {\n        [$.MI]: true,\n        [$.MO]: true,\n        [$.MN]: true,\n        [$.MS]: true,\n        [$.MTEXT]: true,\n        [$.ANNOTATION_XML]: true\n    },\n    [NS.SVG]: {\n        [$.TITLE]: true,\n        [$.FOREIGN_OBJECT]: true,\n        [$.DESC]: true\n    }\n};\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/parse5/lib/common/html.js?");

/***/ }),

/***/ "./src/node_modules/parse5/lib/common/unicode.js":
/*!*******************************************************!*\
  !*** ./src/node_modules/parse5/lib/common/unicode.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nconst UNDEFINED_CODE_POINTS = [\n    0xfffe,\n    0xffff,\n    0x1fffe,\n    0x1ffff,\n    0x2fffe,\n    0x2ffff,\n    0x3fffe,\n    0x3ffff,\n    0x4fffe,\n    0x4ffff,\n    0x5fffe,\n    0x5ffff,\n    0x6fffe,\n    0x6ffff,\n    0x7fffe,\n    0x7ffff,\n    0x8fffe,\n    0x8ffff,\n    0x9fffe,\n    0x9ffff,\n    0xafffe,\n    0xaffff,\n    0xbfffe,\n    0xbffff,\n    0xcfffe,\n    0xcffff,\n    0xdfffe,\n    0xdffff,\n    0xefffe,\n    0xeffff,\n    0xffffe,\n    0xfffff,\n    0x10fffe,\n    0x10ffff\n];\n\nexports.REPLACEMENT_CHARACTER = '\\uFFFD';\n\nexports.CODE_POINTS = {\n    EOF: -1,\n    NULL: 0x00,\n    TABULATION: 0x09,\n    CARRIAGE_RETURN: 0x0d,\n    LINE_FEED: 0x0a,\n    FORM_FEED: 0x0c,\n    SPACE: 0x20,\n    EXCLAMATION_MARK: 0x21,\n    QUOTATION_MARK: 0x22,\n    NUMBER_SIGN: 0x23,\n    AMPERSAND: 0x26,\n    APOSTROPHE: 0x27,\n    HYPHEN_MINUS: 0x2d,\n    SOLIDUS: 0x2f,\n    DIGIT_0: 0x30,\n    DIGIT_9: 0x39,\n    SEMICOLON: 0x3b,\n    LESS_THAN_SIGN: 0x3c,\n    EQUALS_SIGN: 0x3d,\n    GREATER_THAN_SIGN: 0x3e,\n    QUESTION_MARK: 0x3f,\n    LATIN_CAPITAL_A: 0x41,\n    LATIN_CAPITAL_F: 0x46,\n    LATIN_CAPITAL_X: 0x58,\n    LATIN_CAPITAL_Z: 0x5a,\n    RIGHT_SQUARE_BRACKET: 0x5d,\n    GRAVE_ACCENT: 0x60,\n    LATIN_SMALL_A: 0x61,\n    LATIN_SMALL_F: 0x66,\n    LATIN_SMALL_X: 0x78,\n    LATIN_SMALL_Z: 0x7a,\n    REPLACEMENT_CHARACTER: 0xfffd\n};\n\nexports.CODE_POINT_SEQUENCES = {\n    DASH_DASH_STRING: [0x2d, 0x2d], //--\n    DOCTYPE_STRING: [0x44, 0x4f, 0x43, 0x54, 0x59, 0x50, 0x45], //DOCTYPE\n    CDATA_START_STRING: [0x5b, 0x43, 0x44, 0x41, 0x54, 0x41, 0x5b], //[CDATA[\n    SCRIPT_STRING: [0x73, 0x63, 0x72, 0x69, 0x70, 0x74], //script\n    PUBLIC_STRING: [0x50, 0x55, 0x42, 0x4c, 0x49, 0x43], //PUBLIC\n    SYSTEM_STRING: [0x53, 0x59, 0x53, 0x54, 0x45, 0x4d] //SYSTEM\n};\n\n//Surrogates\nexports.isSurrogate = function(cp) {\n    return cp >= 0xd800 && cp <= 0xdfff;\n};\n\nexports.isSurrogatePair = function(cp) {\n    return cp >= 0xdc00 && cp <= 0xdfff;\n};\n\nexports.getSurrogatePairCodePoint = function(cp1, cp2) {\n    return (cp1 - 0xd800) * 0x400 + 0x2400 + cp2;\n};\n\n//NOTE: excluding NULL and ASCII whitespace\nexports.isControlCodePoint = function(cp) {\n    return (\n        (cp !== 0x20 && cp !== 0x0a && cp !== 0x0d && cp !== 0x09 && cp !== 0x0c && cp >= 0x01 && cp <= 0x1f) ||\n        (cp >= 0x7f && cp <= 0x9f)\n    );\n};\n\nexports.isUndefinedCodePoint = function(cp) {\n    return (cp >= 0xfdd0 && cp <= 0xfdef) || UNDEFINED_CODE_POINTS.indexOf(cp) > -1;\n};\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/parse5/lib/common/unicode.js?");

/***/ }),

/***/ "./src/node_modules/parse5/lib/extensions/error-reporting/mixin-base.js":
/*!******************************************************************************!*\
  !*** ./src/node_modules/parse5/lib/extensions/error-reporting/mixin-base.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Mixin = __webpack_require__(/*! ../../utils/mixin */ \"./src/node_modules/parse5/lib/utils/mixin.js\");\n\nclass ErrorReportingMixinBase extends Mixin {\n    constructor(host, opts) {\n        super(host);\n\n        this.posTracker = null;\n        this.onParseError = opts.onParseError;\n    }\n\n    _setErrorLocation(err) {\n        err.startLine = err.endLine = this.posTracker.line;\n        err.startCol = err.endCol = this.posTracker.col;\n        err.startOffset = err.endOffset = this.posTracker.offset;\n    }\n\n    _reportError(code) {\n        const err = {\n            code: code,\n            startLine: -1,\n            startCol: -1,\n            startOffset: -1,\n            endLine: -1,\n            endCol: -1,\n            endOffset: -1\n        };\n\n        this._setErrorLocation(err);\n        this.onParseError(err);\n    }\n\n    _getOverriddenMethods(mxn) {\n        return {\n            _err(code) {\n                mxn._reportError(code);\n            }\n        };\n    }\n}\n\nmodule.exports = ErrorReportingMixinBase;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/parse5/lib/extensions/error-reporting/mixin-base.js?");

/***/ }),

/***/ "./src/node_modules/parse5/lib/extensions/error-reporting/parser-mixin.js":
/*!********************************************************************************!*\
  !*** ./src/node_modules/parse5/lib/extensions/error-reporting/parser-mixin.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst ErrorReportingMixinBase = __webpack_require__(/*! ./mixin-base */ \"./src/node_modules/parse5/lib/extensions/error-reporting/mixin-base.js\");\nconst ErrorReportingTokenizerMixin = __webpack_require__(/*! ./tokenizer-mixin */ \"./src/node_modules/parse5/lib/extensions/error-reporting/tokenizer-mixin.js\");\nconst LocationInfoTokenizerMixin = __webpack_require__(/*! ../location-info/tokenizer-mixin */ \"./src/node_modules/parse5/lib/extensions/location-info/tokenizer-mixin.js\");\nconst Mixin = __webpack_require__(/*! ../../utils/mixin */ \"./src/node_modules/parse5/lib/utils/mixin.js\");\n\nclass ErrorReportingParserMixin extends ErrorReportingMixinBase {\n    constructor(parser, opts) {\n        super(parser, opts);\n\n        this.opts = opts;\n        this.ctLoc = null;\n        this.locBeforeToken = false;\n    }\n\n    _setErrorLocation(err) {\n        if (this.ctLoc) {\n            err.startLine = this.ctLoc.startLine;\n            err.startCol = this.ctLoc.startCol;\n            err.startOffset = this.ctLoc.startOffset;\n\n            err.endLine = this.locBeforeToken ? this.ctLoc.startLine : this.ctLoc.endLine;\n            err.endCol = this.locBeforeToken ? this.ctLoc.startCol : this.ctLoc.endCol;\n            err.endOffset = this.locBeforeToken ? this.ctLoc.startOffset : this.ctLoc.endOffset;\n        }\n    }\n\n    _getOverriddenMethods(mxn, orig) {\n        return {\n            _bootstrap(document, fragmentContext) {\n                orig._bootstrap.call(this, document, fragmentContext);\n\n                Mixin.install(this.tokenizer, ErrorReportingTokenizerMixin, mxn.opts);\n                Mixin.install(this.tokenizer, LocationInfoTokenizerMixin);\n            },\n\n            _processInputToken(token) {\n                mxn.ctLoc = token.location;\n\n                orig._processInputToken.call(this, token);\n            },\n\n            _err(code, options) {\n                mxn.locBeforeToken = options && options.beforeToken;\n                mxn._reportError(code);\n            }\n        };\n    }\n}\n\nmodule.exports = ErrorReportingParserMixin;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/parse5/lib/extensions/error-reporting/parser-mixin.js?");

/***/ }),

/***/ "./src/node_modules/parse5/lib/extensions/error-reporting/preprocessor-mixin.js":
/*!**************************************************************************************!*\
  !*** ./src/node_modules/parse5/lib/extensions/error-reporting/preprocessor-mixin.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst ErrorReportingMixinBase = __webpack_require__(/*! ./mixin-base */ \"./src/node_modules/parse5/lib/extensions/error-reporting/mixin-base.js\");\nconst PositionTrackingPreprocessorMixin = __webpack_require__(/*! ../position-tracking/preprocessor-mixin */ \"./src/node_modules/parse5/lib/extensions/position-tracking/preprocessor-mixin.js\");\nconst Mixin = __webpack_require__(/*! ../../utils/mixin */ \"./src/node_modules/parse5/lib/utils/mixin.js\");\n\nclass ErrorReportingPreprocessorMixin extends ErrorReportingMixinBase {\n    constructor(preprocessor, opts) {\n        super(preprocessor, opts);\n\n        this.posTracker = Mixin.install(preprocessor, PositionTrackingPreprocessorMixin);\n        this.lastErrOffset = -1;\n    }\n\n    _reportError(code) {\n        //NOTE: avoid reporting error twice on advance/retreat\n        if (this.lastErrOffset !== this.posTracker.offset) {\n            this.lastErrOffset = this.posTracker.offset;\n            super._reportError(code);\n        }\n    }\n}\n\nmodule.exports = ErrorReportingPreprocessorMixin;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/parse5/lib/extensions/error-reporting/preprocessor-mixin.js?");

/***/ }),

/***/ "./src/node_modules/parse5/lib/extensions/error-reporting/tokenizer-mixin.js":
/*!***********************************************************************************!*\
  !*** ./src/node_modules/parse5/lib/extensions/error-reporting/tokenizer-mixin.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst ErrorReportingMixinBase = __webpack_require__(/*! ./mixin-base */ \"./src/node_modules/parse5/lib/extensions/error-reporting/mixin-base.js\");\nconst ErrorReportingPreprocessorMixin = __webpack_require__(/*! ./preprocessor-mixin */ \"./src/node_modules/parse5/lib/extensions/error-reporting/preprocessor-mixin.js\");\nconst Mixin = __webpack_require__(/*! ../../utils/mixin */ \"./src/node_modules/parse5/lib/utils/mixin.js\");\n\nclass ErrorReportingTokenizerMixin extends ErrorReportingMixinBase {\n    constructor(tokenizer, opts) {\n        super(tokenizer, opts);\n\n        const preprocessorMixin = Mixin.install(tokenizer.preprocessor, ErrorReportingPreprocessorMixin, opts);\n\n        this.posTracker = preprocessorMixin.posTracker;\n    }\n}\n\nmodule.exports = ErrorReportingTokenizerMixin;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/parse5/lib/extensions/error-reporting/tokenizer-mixin.js?");

/***/ }),

/***/ "./src/node_modules/parse5/lib/extensions/location-info/open-element-stack-mixin.js":
/*!******************************************************************************************!*\
  !*** ./src/node_modules/parse5/lib/extensions/location-info/open-element-stack-mixin.js ***!
  \******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Mixin = __webpack_require__(/*! ../../utils/mixin */ \"./src/node_modules/parse5/lib/utils/mixin.js\");\n\nclass LocationInfoOpenElementStackMixin extends Mixin {\n    constructor(stack, opts) {\n        super(stack);\n\n        this.onItemPop = opts.onItemPop;\n    }\n\n    _getOverriddenMethods(mxn, orig) {\n        return {\n            pop() {\n                mxn.onItemPop(this.current);\n                orig.pop.call(this);\n            },\n\n            popAllUpToHtmlElement() {\n                for (let i = this.stackTop; i > 0; i--) {\n                    mxn.onItemPop(this.items[i]);\n                }\n\n                orig.popAllUpToHtmlElement.call(this);\n            },\n\n            remove(element) {\n                mxn.onItemPop(this.current);\n                orig.remove.call(this, element);\n            }\n        };\n    }\n}\n\nmodule.exports = LocationInfoOpenElementStackMixin;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/parse5/lib/extensions/location-info/open-element-stack-mixin.js?");

/***/ }),

/***/ "./src/node_modules/parse5/lib/extensions/location-info/parser-mixin.js":
/*!******************************************************************************!*\
  !*** ./src/node_modules/parse5/lib/extensions/location-info/parser-mixin.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Mixin = __webpack_require__(/*! ../../utils/mixin */ \"./src/node_modules/parse5/lib/utils/mixin.js\");\nconst Tokenizer = __webpack_require__(/*! ../../tokenizer */ \"./src/node_modules/parse5/lib/tokenizer/index.js\");\nconst LocationInfoTokenizerMixin = __webpack_require__(/*! ./tokenizer-mixin */ \"./src/node_modules/parse5/lib/extensions/location-info/tokenizer-mixin.js\");\nconst LocationInfoOpenElementStackMixin = __webpack_require__(/*! ./open-element-stack-mixin */ \"./src/node_modules/parse5/lib/extensions/location-info/open-element-stack-mixin.js\");\nconst HTML = __webpack_require__(/*! ../../common/html */ \"./src/node_modules/parse5/lib/common/html.js\");\n\n//Aliases\nconst $ = HTML.TAG_NAMES;\n\nclass LocationInfoParserMixin extends Mixin {\n    constructor(parser) {\n        super(parser);\n\n        this.parser = parser;\n        this.treeAdapter = this.parser.treeAdapter;\n        this.posTracker = null;\n        this.lastStartTagToken = null;\n        this.lastFosterParentingLocation = null;\n        this.currentToken = null;\n    }\n\n    _setStartLocation(element) {\n        let loc = null;\n\n        if (this.lastStartTagToken) {\n            loc = Object.assign({}, this.lastStartTagToken.location);\n            loc.startTag = this.lastStartTagToken.location;\n        }\n\n        this.treeAdapter.setNodeSourceCodeLocation(element, loc);\n    }\n\n    _setEndLocation(element, closingToken) {\n        const loc = this.treeAdapter.getNodeSourceCodeLocation(element);\n\n        if (loc) {\n            if (closingToken.location) {\n                const ctLoc = closingToken.location;\n                const tn = this.treeAdapter.getTagName(element);\n\n                // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing\n                // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.\n                const isClosingEndTag = closingToken.type === Tokenizer.END_TAG_TOKEN && tn === closingToken.tagName;\n                const endLoc = {};\n                if (isClosingEndTag) {\n                    endLoc.endTag = Object.assign({}, ctLoc);\n                    endLoc.endLine = ctLoc.endLine;\n                    endLoc.endCol = ctLoc.endCol;\n                    endLoc.endOffset = ctLoc.endOffset;\n                } else {\n                    endLoc.endLine = ctLoc.startLine;\n                    endLoc.endCol = ctLoc.startCol;\n                    endLoc.endOffset = ctLoc.startOffset;\n                }\n\n                this.treeAdapter.updateNodeSourceCodeLocation(element, endLoc);\n            }\n        }\n    }\n\n    _getOverriddenMethods(mxn, orig) {\n        return {\n            _bootstrap(document, fragmentContext) {\n                orig._bootstrap.call(this, document, fragmentContext);\n\n                mxn.lastStartTagToken = null;\n                mxn.lastFosterParentingLocation = null;\n                mxn.currentToken = null;\n\n                const tokenizerMixin = Mixin.install(this.tokenizer, LocationInfoTokenizerMixin);\n\n                mxn.posTracker = tokenizerMixin.posTracker;\n\n                Mixin.install(this.openElements, LocationInfoOpenElementStackMixin, {\n                    onItemPop: function(element) {\n                        mxn._setEndLocation(element, mxn.currentToken);\n                    }\n                });\n            },\n\n            _runParsingLoop(scriptHandler) {\n                orig._runParsingLoop.call(this, scriptHandler);\n\n                // NOTE: generate location info for elements\n                // that remains on open element stack\n                for (let i = this.openElements.stackTop; i >= 0; i--) {\n                    mxn._setEndLocation(this.openElements.items[i], mxn.currentToken);\n                }\n            },\n\n            //Token processing\n            _processTokenInForeignContent(token) {\n                mxn.currentToken = token;\n                orig._processTokenInForeignContent.call(this, token);\n            },\n\n            _processToken(token) {\n                mxn.currentToken = token;\n                orig._processToken.call(this, token);\n\n                //NOTE: <body> and <html> are never popped from the stack, so we need to updated\n                //their end location explicitly.\n                const requireExplicitUpdate =\n                    token.type === Tokenizer.END_TAG_TOKEN &&\n                    (token.tagName === $.HTML || (token.tagName === $.BODY && this.openElements.hasInScope($.BODY)));\n\n                if (requireExplicitUpdate) {\n                    for (let i = this.openElements.stackTop; i >= 0; i--) {\n                        const element = this.openElements.items[i];\n\n                        if (this.treeAdapter.getTagName(element) === token.tagName) {\n                            mxn._setEndLocation(element, token);\n                            break;\n                        }\n                    }\n                }\n            },\n\n            //Doctype\n            _setDocumentType(token) {\n                orig._setDocumentType.call(this, token);\n\n                const documentChildren = this.treeAdapter.getChildNodes(this.document);\n                const cnLength = documentChildren.length;\n\n                for (let i = 0; i < cnLength; i++) {\n                    const node = documentChildren[i];\n\n                    if (this.treeAdapter.isDocumentTypeNode(node)) {\n                        this.treeAdapter.setNodeSourceCodeLocation(node, token.location);\n                        break;\n                    }\n                }\n            },\n\n            //Elements\n            _attachElementToTree(element) {\n                //NOTE: _attachElementToTree is called from _appendElement, _insertElement and _insertTemplate methods.\n                //So we will use token location stored in this methods for the element.\n                mxn._setStartLocation(element);\n                mxn.lastStartTagToken = null;\n                orig._attachElementToTree.call(this, element);\n            },\n\n            _appendElement(token, namespaceURI) {\n                mxn.lastStartTagToken = token;\n                orig._appendElement.call(this, token, namespaceURI);\n            },\n\n            _insertElement(token, namespaceURI) {\n                mxn.lastStartTagToken = token;\n                orig._insertElement.call(this, token, namespaceURI);\n            },\n\n            _insertTemplate(token) {\n                mxn.lastStartTagToken = token;\n                orig._insertTemplate.call(this, token);\n\n                const tmplContent = this.treeAdapter.getTemplateContent(this.openElements.current);\n\n                this.treeAdapter.setNodeSourceCodeLocation(tmplContent, null);\n            },\n\n            _insertFakeRootElement() {\n                orig._insertFakeRootElement.call(this);\n                this.treeAdapter.setNodeSourceCodeLocation(this.openElements.current, null);\n            },\n\n            //Comments\n            _appendCommentNode(token, parent) {\n                orig._appendCommentNode.call(this, token, parent);\n\n                const children = this.treeAdapter.getChildNodes(parent);\n                const commentNode = children[children.length - 1];\n\n                this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);\n            },\n\n            //Text\n            _findFosterParentingLocation() {\n                //NOTE: store last foster parenting location, so we will be able to find inserted text\n                //in case of foster parenting\n                mxn.lastFosterParentingLocation = orig._findFosterParentingLocation.call(this);\n\n                return mxn.lastFosterParentingLocation;\n            },\n\n            _insertCharacters(token) {\n                orig._insertCharacters.call(this, token);\n\n                const hasFosterParent = this._shouldFosterParentOnInsertion();\n\n                const parent =\n                    (hasFosterParent && mxn.lastFosterParentingLocation.parent) ||\n                    this.openElements.currentTmplContent ||\n                    this.openElements.current;\n\n                const siblings = this.treeAdapter.getChildNodes(parent);\n\n                const textNodeIdx =\n                    hasFosterParent && mxn.lastFosterParentingLocation.beforeElement\n                        ? siblings.indexOf(mxn.lastFosterParentingLocation.beforeElement) - 1\n                        : siblings.length - 1;\n\n                const textNode = siblings[textNodeIdx];\n\n                //NOTE: if we have location assigned by another token, then just update end position\n                const tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);\n\n                if (tnLoc) {\n                    const { endLine, endCol, endOffset } = token.location;\n                    this.treeAdapter.updateNodeSourceCodeLocation(textNode, { endLine, endCol, endOffset });\n                } else {\n                    this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);\n                }\n            }\n        };\n    }\n}\n\nmodule.exports = LocationInfoParserMixin;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/parse5/lib/extensions/location-info/parser-mixin.js?");

/***/ }),

/***/ "./src/node_modules/parse5/lib/extensions/location-info/tokenizer-mixin.js":
/*!*********************************************************************************!*\
  !*** ./src/node_modules/parse5/lib/extensions/location-info/tokenizer-mixin.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Mixin = __webpack_require__(/*! ../../utils/mixin */ \"./src/node_modules/parse5/lib/utils/mixin.js\");\nconst Tokenizer = __webpack_require__(/*! ../../tokenizer */ \"./src/node_modules/parse5/lib/tokenizer/index.js\");\nconst PositionTrackingPreprocessorMixin = __webpack_require__(/*! ../position-tracking/preprocessor-mixin */ \"./src/node_modules/parse5/lib/extensions/position-tracking/preprocessor-mixin.js\");\n\nclass LocationInfoTokenizerMixin extends Mixin {\n    constructor(tokenizer) {\n        super(tokenizer);\n\n        this.tokenizer = tokenizer;\n        this.posTracker = Mixin.install(tokenizer.preprocessor, PositionTrackingPreprocessorMixin);\n        this.currentAttrLocation = null;\n        this.ctLoc = null;\n    }\n\n    _getCurrentLocation() {\n        return {\n            startLine: this.posTracker.line,\n            startCol: this.posTracker.col,\n            startOffset: this.posTracker.offset,\n            endLine: -1,\n            endCol: -1,\n            endOffset: -1\n        };\n    }\n\n    _attachCurrentAttrLocationInfo() {\n        this.currentAttrLocation.endLine = this.posTracker.line;\n        this.currentAttrLocation.endCol = this.posTracker.col;\n        this.currentAttrLocation.endOffset = this.posTracker.offset;\n\n        const currentToken = this.tokenizer.currentToken;\n        const currentAttr = this.tokenizer.currentAttr;\n\n        if (!currentToken.location.attrs) {\n            currentToken.location.attrs = Object.create(null);\n        }\n\n        currentToken.location.attrs[currentAttr.name] = this.currentAttrLocation;\n    }\n\n    _getOverriddenMethods(mxn, orig) {\n        const methods = {\n            _createStartTagToken() {\n                orig._createStartTagToken.call(this);\n                this.currentToken.location = mxn.ctLoc;\n            },\n\n            _createEndTagToken() {\n                orig._createEndTagToken.call(this);\n                this.currentToken.location = mxn.ctLoc;\n            },\n\n            _createCommentToken() {\n                orig._createCommentToken.call(this);\n                this.currentToken.location = mxn.ctLoc;\n            },\n\n            _createDoctypeToken(initialName) {\n                orig._createDoctypeToken.call(this, initialName);\n                this.currentToken.location = mxn.ctLoc;\n            },\n\n            _createCharacterToken(type, ch) {\n                orig._createCharacterToken.call(this, type, ch);\n                this.currentCharacterToken.location = mxn.ctLoc;\n            },\n\n            _createEOFToken() {\n                orig._createEOFToken.call(this);\n                this.currentToken.location = mxn._getCurrentLocation();\n            },\n\n            _createAttr(attrNameFirstCh) {\n                orig._createAttr.call(this, attrNameFirstCh);\n                mxn.currentAttrLocation = mxn._getCurrentLocation();\n            },\n\n            _leaveAttrName(toState) {\n                orig._leaveAttrName.call(this, toState);\n                mxn._attachCurrentAttrLocationInfo();\n            },\n\n            _leaveAttrValue(toState) {\n                orig._leaveAttrValue.call(this, toState);\n                mxn._attachCurrentAttrLocationInfo();\n            },\n\n            _emitCurrentToken() {\n                const ctLoc = this.currentToken.location;\n\n                //NOTE: if we have pending character token make it's end location equal to the\n                //current token's start location.\n                if (this.currentCharacterToken) {\n                    this.currentCharacterToken.location.endLine = ctLoc.startLine;\n                    this.currentCharacterToken.location.endCol = ctLoc.startCol;\n                    this.currentCharacterToken.location.endOffset = ctLoc.startOffset;\n                }\n\n                if (this.currentToken.type === Tokenizer.EOF_TOKEN) {\n                    ctLoc.endLine = ctLoc.startLine;\n                    ctLoc.endCol = ctLoc.startCol;\n                    ctLoc.endOffset = ctLoc.startOffset;\n                } else {\n                    ctLoc.endLine = mxn.posTracker.line;\n                    ctLoc.endCol = mxn.posTracker.col + 1;\n                    ctLoc.endOffset = mxn.posTracker.offset + 1;\n                }\n\n                orig._emitCurrentToken.call(this);\n            },\n\n            _emitCurrentCharacterToken() {\n                const ctLoc = this.currentCharacterToken && this.currentCharacterToken.location;\n\n                //NOTE: if we have character token and it's location wasn't set in the _emitCurrentToken(),\n                //then set it's location at the current preprocessor position.\n                //We don't need to increment preprocessor position, since character token\n                //emission is always forced by the start of the next character token here.\n                //So, we already have advanced position.\n                if (ctLoc && ctLoc.endOffset === -1) {\n                    ctLoc.endLine = mxn.posTracker.line;\n                    ctLoc.endCol = mxn.posTracker.col;\n                    ctLoc.endOffset = mxn.posTracker.offset;\n                }\n\n                orig._emitCurrentCharacterToken.call(this);\n            }\n        };\n\n        //NOTE: patch initial states for each mode to obtain token start position\n        Object.keys(Tokenizer.MODE).forEach(modeName => {\n            const state = Tokenizer.MODE[modeName];\n\n            methods[state] = function(cp) {\n                mxn.ctLoc = mxn._getCurrentLocation();\n                orig[state].call(this, cp);\n            };\n        });\n\n        return methods;\n    }\n}\n\nmodule.exports = LocationInfoTokenizerMixin;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/parse5/lib/extensions/location-info/tokenizer-mixin.js?");

/***/ }),

/***/ "./src/node_modules/parse5/lib/extensions/position-tracking/preprocessor-mixin.js":
/*!****************************************************************************************!*\
  !*** ./src/node_modules/parse5/lib/extensions/position-tracking/preprocessor-mixin.js ***!
  \****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Mixin = __webpack_require__(/*! ../../utils/mixin */ \"./src/node_modules/parse5/lib/utils/mixin.js\");\n\nclass PositionTrackingPreprocessorMixin extends Mixin {\n    constructor(preprocessor) {\n        super(preprocessor);\n\n        this.preprocessor = preprocessor;\n        this.isEol = false;\n        this.lineStartPos = 0;\n        this.droppedBufferSize = 0;\n\n        this.offset = 0;\n        this.col = 0;\n        this.line = 1;\n    }\n\n    _getOverriddenMethods(mxn, orig) {\n        return {\n            advance() {\n                const pos = this.pos + 1;\n                const ch = this.html[pos];\n\n                //NOTE: LF should be in the last column of the line\n                if (mxn.isEol) {\n                    mxn.isEol = false;\n                    mxn.line++;\n                    mxn.lineStartPos = pos;\n                }\n\n                if (ch === '\\n' || (ch === '\\r' && this.html[pos + 1] !== '\\n')) {\n                    mxn.isEol = true;\n                }\n\n                mxn.col = pos - mxn.lineStartPos + 1;\n                mxn.offset = mxn.droppedBufferSize + pos;\n\n                return orig.advance.call(this);\n            },\n\n            retreat() {\n                orig.retreat.call(this);\n\n                mxn.isEol = false;\n                mxn.col = this.pos - mxn.lineStartPos + 1;\n            },\n\n            dropParsedChunk() {\n                const prevPos = this.pos;\n\n                orig.dropParsedChunk.call(this);\n\n                const reduction = prevPos - this.pos;\n\n                mxn.lineStartPos -= reduction;\n                mxn.droppedBufferSize += reduction;\n                mxn.offset = mxn.droppedBufferSize + this.pos;\n            }\n        };\n    }\n}\n\nmodule.exports = PositionTrackingPreprocessorMixin;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/parse5/lib/extensions/position-tracking/preprocessor-mixin.js?");

/***/ }),

/***/ "./src/node_modules/parse5/lib/index.js":
/*!**********************************************!*\
  !*** ./src/node_modules/parse5/lib/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Parser = __webpack_require__(/*! ./parser */ \"./src/node_modules/parse5/lib/parser/index.js\");\nconst Serializer = __webpack_require__(/*! ./serializer */ \"./src/node_modules/parse5/lib/serializer/index.js\");\n\n// Shorthands\nexports.parse = function parse(html, options) {\n    const parser = new Parser(options);\n\n    return parser.parse(html);\n};\n\nexports.parseFragment = function parseFragment(fragmentContext, html, options) {\n    if (typeof fragmentContext === 'string') {\n        options = html;\n        html = fragmentContext;\n        fragmentContext = null;\n    }\n\n    const parser = new Parser(options);\n\n    return parser.parseFragment(html, fragmentContext);\n};\n\nexports.serialize = function(node, options) {\n    const serializer = new Serializer(node, options);\n\n    return serializer.serialize();\n};\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/parse5/lib/index.js?");

/***/ }),

/***/ "./src/node_modules/parse5/lib/parser/formatting-element-list.js":
/*!***********************************************************************!*\
  !*** ./src/node_modules/parse5/lib/parser/formatting-element-list.js ***!
  \***********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n//Const\nconst NOAH_ARK_CAPACITY = 3;\n\n//List of formatting elements\nclass FormattingElementList {\n    constructor(treeAdapter) {\n        this.length = 0;\n        this.entries = [];\n        this.treeAdapter = treeAdapter;\n        this.bookmark = null;\n    }\n\n    //Noah Ark's condition\n    //OPTIMIZATION: at first we try to find possible candidates for exclusion using\n    //lightweight heuristics without thorough attributes check.\n    _getNoahArkConditionCandidates(newElement) {\n        const candidates = [];\n\n        if (this.length >= NOAH_ARK_CAPACITY) {\n            const neAttrsLength = this.treeAdapter.getAttrList(newElement).length;\n            const neTagName = this.treeAdapter.getTagName(newElement);\n            const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);\n\n            for (let i = this.length - 1; i >= 0; i--) {\n                const entry = this.entries[i];\n\n                if (entry.type === FormattingElementList.MARKER_ENTRY) {\n                    break;\n                }\n\n                const element = entry.element;\n                const elementAttrs = this.treeAdapter.getAttrList(element);\n\n                const isCandidate =\n                    this.treeAdapter.getTagName(element) === neTagName &&\n                    this.treeAdapter.getNamespaceURI(element) === neNamespaceURI &&\n                    elementAttrs.length === neAttrsLength;\n\n                if (isCandidate) {\n                    candidates.push({ idx: i, attrs: elementAttrs });\n                }\n            }\n        }\n\n        return candidates.length < NOAH_ARK_CAPACITY ? [] : candidates;\n    }\n\n    _ensureNoahArkCondition(newElement) {\n        const candidates = this._getNoahArkConditionCandidates(newElement);\n        let cLength = candidates.length;\n\n        if (cLength) {\n            const neAttrs = this.treeAdapter.getAttrList(newElement);\n            const neAttrsLength = neAttrs.length;\n            const neAttrsMap = Object.create(null);\n\n            //NOTE: build attrs map for the new element so we can perform fast lookups\n            for (let i = 0; i < neAttrsLength; i++) {\n                const neAttr = neAttrs[i];\n\n                neAttrsMap[neAttr.name] = neAttr.value;\n            }\n\n            for (let i = 0; i < neAttrsLength; i++) {\n                for (let j = 0; j < cLength; j++) {\n                    const cAttr = candidates[j].attrs[i];\n\n                    if (neAttrsMap[cAttr.name] !== cAttr.value) {\n                        candidates.splice(j, 1);\n                        cLength--;\n                    }\n\n                    if (candidates.length < NOAH_ARK_CAPACITY) {\n                        return;\n                    }\n                }\n            }\n\n            //NOTE: remove bottommost candidates until Noah's Ark condition will not be met\n            for (let i = cLength - 1; i >= NOAH_ARK_CAPACITY - 1; i--) {\n                this.entries.splice(candidates[i].idx, 1);\n                this.length--;\n            }\n        }\n    }\n\n    //Mutations\n    insertMarker() {\n        this.entries.push({ type: FormattingElementList.MARKER_ENTRY });\n        this.length++;\n    }\n\n    pushElement(element, token) {\n        this._ensureNoahArkCondition(element);\n\n        this.entries.push({\n            type: FormattingElementList.ELEMENT_ENTRY,\n            element: element,\n            token: token\n        });\n\n        this.length++;\n    }\n\n    insertElementAfterBookmark(element, token) {\n        let bookmarkIdx = this.length - 1;\n\n        for (; bookmarkIdx >= 0; bookmarkIdx--) {\n            if (this.entries[bookmarkIdx] === this.bookmark) {\n                break;\n            }\n        }\n\n        this.entries.splice(bookmarkIdx + 1, 0, {\n            type: FormattingElementList.ELEMENT_ENTRY,\n            element: element,\n            token: token\n        });\n\n        this.length++;\n    }\n\n    removeEntry(entry) {\n        for (let i = this.length - 1; i >= 0; i--) {\n            if (this.entries[i] === entry) {\n                this.entries.splice(i, 1);\n                this.length--;\n                break;\n            }\n        }\n    }\n\n    clearToLastMarker() {\n        while (this.length) {\n            const entry = this.entries.pop();\n\n            this.length--;\n\n            if (entry.type === FormattingElementList.MARKER_ENTRY) {\n                break;\n            }\n        }\n    }\n\n    //Search\n    getElementEntryInScopeWithTagName(tagName) {\n        for (let i = this.length - 1; i >= 0; i--) {\n            const entry = this.entries[i];\n\n            if (entry.type === FormattingElementList.MARKER_ENTRY) {\n                return null;\n            }\n\n            if (this.treeAdapter.getTagName(entry.element) === tagName) {\n                return entry;\n            }\n        }\n\n        return null;\n    }\n\n    getElementEntry(element) {\n        for (let i = this.length - 1; i >= 0; i--) {\n            const entry = this.entries[i];\n\n            if (entry.type === FormattingElementList.ELEMENT_ENTRY && entry.element === element) {\n                return entry;\n            }\n        }\n\n        return null;\n    }\n}\n\n//Entry types\nFormattingElementList.MARKER_ENTRY = 'MARKER_ENTRY';\nFormattingElementList.ELEMENT_ENTRY = 'ELEMENT_ENTRY';\n\nmodule.exports = FormattingElementList;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/parse5/lib/parser/formatting-element-list.js?");

/***/ }),

/***/ "./src/node_modules/parse5/lib/parser/index.js":
/*!*****************************************************!*\
  !*** ./src/node_modules/parse5/lib/parser/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Tokenizer = __webpack_require__(/*! ../tokenizer */ \"./src/node_modules/parse5/lib/tokenizer/index.js\");\nconst OpenElementStack = __webpack_require__(/*! ./open-element-stack */ \"./src/node_modules/parse5/lib/parser/open-element-stack.js\");\nconst FormattingElementList = __webpack_require__(/*! ./formatting-element-list */ \"./src/node_modules/parse5/lib/parser/formatting-element-list.js\");\nconst LocationInfoParserMixin = __webpack_require__(/*! ../extensions/location-info/parser-mixin */ \"./src/node_modules/parse5/lib/extensions/location-info/parser-mixin.js\");\nconst ErrorReportingParserMixin = __webpack_require__(/*! ../extensions/error-reporting/parser-mixin */ \"./src/node_modules/parse5/lib/extensions/error-reporting/parser-mixin.js\");\nconst Mixin = __webpack_require__(/*! ../utils/mixin */ \"./src/node_modules/parse5/lib/utils/mixin.js\");\nconst defaultTreeAdapter = __webpack_require__(/*! ../tree-adapters/default */ \"./src/node_modules/parse5/lib/tree-adapters/default.js\");\nconst mergeOptions = __webpack_require__(/*! ../utils/merge-options */ \"./src/node_modules/parse5/lib/utils/merge-options.js\");\nconst doctype = __webpack_require__(/*! ../common/doctype */ \"./src/node_modules/parse5/lib/common/doctype.js\");\nconst foreignContent = __webpack_require__(/*! ../common/foreign-content */ \"./src/node_modules/parse5/lib/common/foreign-content.js\");\nconst ERR = __webpack_require__(/*! ../common/error-codes */ \"./src/node_modules/parse5/lib/common/error-codes.js\");\nconst unicode = __webpack_require__(/*! ../common/unicode */ \"./src/node_modules/parse5/lib/common/unicode.js\");\nconst HTML = __webpack_require__(/*! ../common/html */ \"./src/node_modules/parse5/lib/common/html.js\");\n\n//Aliases\nconst $ = HTML.TAG_NAMES;\nconst NS = HTML.NAMESPACES;\nconst ATTRS = HTML.ATTRS;\n\nconst DEFAULT_OPTIONS = {\n    scriptingEnabled: true,\n    sourceCodeLocationInfo: false,\n    onParseError: null,\n    treeAdapter: defaultTreeAdapter\n};\n\n//Misc constants\nconst HIDDEN_INPUT_TYPE = 'hidden';\n\n//Adoption agency loops iteration count\nconst AA_OUTER_LOOP_ITER = 8;\nconst AA_INNER_LOOP_ITER = 3;\n\n//Insertion modes\nconst INITIAL_MODE = 'INITIAL_MODE';\nconst BEFORE_HTML_MODE = 'BEFORE_HTML_MODE';\nconst BEFORE_HEAD_MODE = 'BEFORE_HEAD_MODE';\nconst IN_HEAD_MODE = 'IN_HEAD_MODE';\nconst IN_HEAD_NO_SCRIPT_MODE = 'IN_HEAD_NO_SCRIPT_MODE';\nconst AFTER_HEAD_MODE = 'AFTER_HEAD_MODE';\nconst IN_BODY_MODE = 'IN_BODY_MODE';\nconst TEXT_MODE = 'TEXT_MODE';\nconst IN_TABLE_MODE = 'IN_TABLE_MODE';\nconst IN_TABLE_TEXT_MODE = 'IN_TABLE_TEXT_MODE';\nconst IN_CAPTION_MODE = 'IN_CAPTION_MODE';\nconst IN_COLUMN_GROUP_MODE = 'IN_COLUMN_GROUP_MODE';\nconst IN_TABLE_BODY_MODE = 'IN_TABLE_BODY_MODE';\nconst IN_ROW_MODE = 'IN_ROW_MODE';\nconst IN_CELL_MODE = 'IN_CELL_MODE';\nconst IN_SELECT_MODE = 'IN_SELECT_MODE';\nconst IN_SELECT_IN_TABLE_MODE = 'IN_SELECT_IN_TABLE_MODE';\nconst IN_TEMPLATE_MODE = 'IN_TEMPLATE_MODE';\nconst AFTER_BODY_MODE = 'AFTER_BODY_MODE';\nconst IN_FRAMESET_MODE = 'IN_FRAMESET_MODE';\nconst AFTER_FRAMESET_MODE = 'AFTER_FRAMESET_MODE';\nconst AFTER_AFTER_BODY_MODE = 'AFTER_AFTER_BODY_MODE';\nconst AFTER_AFTER_FRAMESET_MODE = 'AFTER_AFTER_FRAMESET_MODE';\n\n//Insertion mode reset map\nconst INSERTION_MODE_RESET_MAP = {\n    [$.TR]: IN_ROW_MODE,\n    [$.TBODY]: IN_TABLE_BODY_MODE,\n    [$.THEAD]: IN_TABLE_BODY_MODE,\n    [$.TFOOT]: IN_TABLE_BODY_MODE,\n    [$.CAPTION]: IN_CAPTION_MODE,\n    [$.COLGROUP]: IN_COLUMN_GROUP_MODE,\n    [$.TABLE]: IN_TABLE_MODE,\n    [$.BODY]: IN_BODY_MODE,\n    [$.FRAMESET]: IN_FRAMESET_MODE\n};\n\n//Template insertion mode switch map\nconst TEMPLATE_INSERTION_MODE_SWITCH_MAP = {\n    [$.CAPTION]: IN_TABLE_MODE,\n    [$.COLGROUP]: IN_TABLE_MODE,\n    [$.TBODY]: IN_TABLE_MODE,\n    [$.TFOOT]: IN_TABLE_MODE,\n    [$.THEAD]: IN_TABLE_MODE,\n    [$.COL]: IN_COLUMN_GROUP_MODE,\n    [$.TR]: IN_TABLE_BODY_MODE,\n    [$.TD]: IN_ROW_MODE,\n    [$.TH]: IN_ROW_MODE\n};\n\n//Token handlers map for insertion modes\nconst TOKEN_HANDLERS = {\n    [INITIAL_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: tokenInInitialMode,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInInitialMode,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: ignoreToken,\n        [Tokenizer.COMMENT_TOKEN]: appendComment,\n        [Tokenizer.DOCTYPE_TOKEN]: doctypeInInitialMode,\n        [Tokenizer.START_TAG_TOKEN]: tokenInInitialMode,\n        [Tokenizer.END_TAG_TOKEN]: tokenInInitialMode,\n        [Tokenizer.EOF_TOKEN]: tokenInInitialMode\n    },\n    [BEFORE_HTML_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: tokenBeforeHtml,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenBeforeHtml,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: ignoreToken,\n        [Tokenizer.COMMENT_TOKEN]: appendComment,\n        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n        [Tokenizer.START_TAG_TOKEN]: startTagBeforeHtml,\n        [Tokenizer.END_TAG_TOKEN]: endTagBeforeHtml,\n        [Tokenizer.EOF_TOKEN]: tokenBeforeHtml\n    },\n    [BEFORE_HEAD_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: tokenBeforeHead,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenBeforeHead,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: ignoreToken,\n        [Tokenizer.COMMENT_TOKEN]: appendComment,\n        [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,\n        [Tokenizer.START_TAG_TOKEN]: startTagBeforeHead,\n        [Tokenizer.END_TAG_TOKEN]: endTagBeforeHead,\n        [Tokenizer.EOF_TOKEN]: tokenBeforeHead\n    },\n    [IN_HEAD_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: tokenInHead,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInHead,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,\n        [Tokenizer.COMMENT_TOKEN]: appendComment,\n        [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,\n        [Tokenizer.START_TAG_TOKEN]: startTagInHead,\n        [Tokenizer.END_TAG_TOKEN]: endTagInHead,\n        [Tokenizer.EOF_TOKEN]: tokenInHead\n    },\n    [IN_HEAD_NO_SCRIPT_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: tokenInHeadNoScript,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInHeadNoScript,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,\n        [Tokenizer.COMMENT_TOKEN]: appendComment,\n        [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,\n        [Tokenizer.START_TAG_TOKEN]: startTagInHeadNoScript,\n        [Tokenizer.END_TAG_TOKEN]: endTagInHeadNoScript,\n        [Tokenizer.EOF_TOKEN]: tokenInHeadNoScript\n    },\n    [AFTER_HEAD_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: tokenAfterHead,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenAfterHead,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,\n        [Tokenizer.COMMENT_TOKEN]: appendComment,\n        [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,\n        [Tokenizer.START_TAG_TOKEN]: startTagAfterHead,\n        [Tokenizer.END_TAG_TOKEN]: endTagAfterHead,\n        [Tokenizer.EOF_TOKEN]: tokenAfterHead\n    },\n    [IN_BODY_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: characterInBody,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,\n        [Tokenizer.COMMENT_TOKEN]: appendComment,\n        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n        [Tokenizer.START_TAG_TOKEN]: startTagInBody,\n        [Tokenizer.END_TAG_TOKEN]: endTagInBody,\n        [Tokenizer.EOF_TOKEN]: eofInBody\n    },\n    [TEXT_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: insertCharacters,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: insertCharacters,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,\n        [Tokenizer.COMMENT_TOKEN]: ignoreToken,\n        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n        [Tokenizer.START_TAG_TOKEN]: ignoreToken,\n        [Tokenizer.END_TAG_TOKEN]: endTagInText,\n        [Tokenizer.EOF_TOKEN]: eofInText\n    },\n    [IN_TABLE_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: characterInTable,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: characterInTable,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: characterInTable,\n        [Tokenizer.COMMENT_TOKEN]: appendComment,\n        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n        [Tokenizer.START_TAG_TOKEN]: startTagInTable,\n        [Tokenizer.END_TAG_TOKEN]: endTagInTable,\n        [Tokenizer.EOF_TOKEN]: eofInBody\n    },\n    [IN_TABLE_TEXT_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: characterInTableText,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInTableText,\n        [Tokenizer.COMMENT_TOKEN]: tokenInTableText,\n        [Tokenizer.DOCTYPE_TOKEN]: tokenInTableText,\n        [Tokenizer.START_TAG_TOKEN]: tokenInTableText,\n        [Tokenizer.END_TAG_TOKEN]: tokenInTableText,\n        [Tokenizer.EOF_TOKEN]: tokenInTableText\n    },\n    [IN_CAPTION_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: characterInBody,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,\n        [Tokenizer.COMMENT_TOKEN]: appendComment,\n        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n        [Tokenizer.START_TAG_TOKEN]: startTagInCaption,\n        [Tokenizer.END_TAG_TOKEN]: endTagInCaption,\n        [Tokenizer.EOF_TOKEN]: eofInBody\n    },\n    [IN_COLUMN_GROUP_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: tokenInColumnGroup,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInColumnGroup,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,\n        [Tokenizer.COMMENT_TOKEN]: appendComment,\n        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n        [Tokenizer.START_TAG_TOKEN]: startTagInColumnGroup,\n        [Tokenizer.END_TAG_TOKEN]: endTagInColumnGroup,\n        [Tokenizer.EOF_TOKEN]: eofInBody\n    },\n    [IN_TABLE_BODY_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: characterInTable,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: characterInTable,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: characterInTable,\n        [Tokenizer.COMMENT_TOKEN]: appendComment,\n        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n        [Tokenizer.START_TAG_TOKEN]: startTagInTableBody,\n        [Tokenizer.END_TAG_TOKEN]: endTagInTableBody,\n        [Tokenizer.EOF_TOKEN]: eofInBody\n    },\n    [IN_ROW_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: characterInTable,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: characterInTable,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: characterInTable,\n        [Tokenizer.COMMENT_TOKEN]: appendComment,\n        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n        [Tokenizer.START_TAG_TOKEN]: startTagInRow,\n        [Tokenizer.END_TAG_TOKEN]: endTagInRow,\n        [Tokenizer.EOF_TOKEN]: eofInBody\n    },\n    [IN_CELL_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: characterInBody,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,\n        [Tokenizer.COMMENT_TOKEN]: appendComment,\n        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n        [Tokenizer.START_TAG_TOKEN]: startTagInCell,\n        [Tokenizer.END_TAG_TOKEN]: endTagInCell,\n        [Tokenizer.EOF_TOKEN]: eofInBody\n    },\n    [IN_SELECT_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: insertCharacters,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,\n        [Tokenizer.COMMENT_TOKEN]: appendComment,\n        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n        [Tokenizer.START_TAG_TOKEN]: startTagInSelect,\n        [Tokenizer.END_TAG_TOKEN]: endTagInSelect,\n        [Tokenizer.EOF_TOKEN]: eofInBody\n    },\n    [IN_SELECT_IN_TABLE_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: insertCharacters,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,\n        [Tokenizer.COMMENT_TOKEN]: appendComment,\n        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n        [Tokenizer.START_TAG_TOKEN]: startTagInSelectInTable,\n        [Tokenizer.END_TAG_TOKEN]: endTagInSelectInTable,\n        [Tokenizer.EOF_TOKEN]: eofInBody\n    },\n    [IN_TEMPLATE_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: characterInBody,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,\n        [Tokenizer.COMMENT_TOKEN]: appendComment,\n        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n        [Tokenizer.START_TAG_TOKEN]: startTagInTemplate,\n        [Tokenizer.END_TAG_TOKEN]: endTagInTemplate,\n        [Tokenizer.EOF_TOKEN]: eofInTemplate\n    },\n    [AFTER_BODY_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: tokenAfterBody,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenAfterBody,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,\n        [Tokenizer.COMMENT_TOKEN]: appendCommentToRootHtmlElement,\n        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n        [Tokenizer.START_TAG_TOKEN]: startTagAfterBody,\n        [Tokenizer.END_TAG_TOKEN]: endTagAfterBody,\n        [Tokenizer.EOF_TOKEN]: stopParsing\n    },\n    [IN_FRAMESET_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: ignoreToken,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,\n        [Tokenizer.COMMENT_TOKEN]: appendComment,\n        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n        [Tokenizer.START_TAG_TOKEN]: startTagInFrameset,\n        [Tokenizer.END_TAG_TOKEN]: endTagInFrameset,\n        [Tokenizer.EOF_TOKEN]: stopParsing\n    },\n    [AFTER_FRAMESET_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: ignoreToken,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,\n        [Tokenizer.COMMENT_TOKEN]: appendComment,\n        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n        [Tokenizer.START_TAG_TOKEN]: startTagAfterFrameset,\n        [Tokenizer.END_TAG_TOKEN]: endTagAfterFrameset,\n        [Tokenizer.EOF_TOKEN]: stopParsing\n    },\n    [AFTER_AFTER_BODY_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: tokenAfterAfterBody,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenAfterAfterBody,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,\n        [Tokenizer.COMMENT_TOKEN]: appendCommentToDocument,\n        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n        [Tokenizer.START_TAG_TOKEN]: startTagAfterAfterBody,\n        [Tokenizer.END_TAG_TOKEN]: tokenAfterAfterBody,\n        [Tokenizer.EOF_TOKEN]: stopParsing\n    },\n    [AFTER_AFTER_FRAMESET_MODE]: {\n        [Tokenizer.CHARACTER_TOKEN]: ignoreToken,\n        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,\n        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,\n        [Tokenizer.COMMENT_TOKEN]: appendCommentToDocument,\n        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n        [Tokenizer.START_TAG_TOKEN]: startTagAfterAfterFrameset,\n        [Tokenizer.END_TAG_TOKEN]: ignoreToken,\n        [Tokenizer.EOF_TOKEN]: stopParsing\n    }\n};\n\n//Parser\nclass Parser {\n    constructor(options) {\n        this.options = mergeOptions(DEFAULT_OPTIONS, options);\n\n        this.treeAdapter = this.options.treeAdapter;\n        this.pendingScript = null;\n\n        if (this.options.sourceCodeLocationInfo) {\n            Mixin.install(this, LocationInfoParserMixin);\n        }\n\n        if (this.options.onParseError) {\n            Mixin.install(this, ErrorReportingParserMixin, { onParseError: this.options.onParseError });\n        }\n    }\n\n    // API\n    parse(html) {\n        const document = this.treeAdapter.createDocument();\n\n        this._bootstrap(document, null);\n        this.tokenizer.write(html, true);\n        this._runParsingLoop(null);\n\n        return document;\n    }\n\n    parseFragment(html, fragmentContext) {\n        //NOTE: use <template> element as a fragment context if context element was not provided,\n        //so we will parse in \"forgiving\" manner\n        if (!fragmentContext) {\n            fragmentContext = this.treeAdapter.createElement($.TEMPLATE, NS.HTML, []);\n        }\n\n        //NOTE: create fake element which will be used as 'document' for fragment parsing.\n        //This is important for jsdom there 'document' can't be recreated, therefore\n        //fragment parsing causes messing of the main `document`.\n        const documentMock = this.treeAdapter.createElement('documentmock', NS.HTML, []);\n\n        this._bootstrap(documentMock, fragmentContext);\n\n        if (this.treeAdapter.getTagName(fragmentContext) === $.TEMPLATE) {\n            this._pushTmplInsertionMode(IN_TEMPLATE_MODE);\n        }\n\n        this._initTokenizerForFragmentParsing();\n        this._insertFakeRootElement();\n        this._resetInsertionMode();\n        this._findFormInFragmentContext();\n        this.tokenizer.write(html, true);\n        this._runParsingLoop(null);\n\n        const rootElement = this.treeAdapter.getFirstChild(documentMock);\n        const fragment = this.treeAdapter.createDocumentFragment();\n\n        this._adoptNodes(rootElement, fragment);\n\n        return fragment;\n    }\n\n    //Bootstrap parser\n    _bootstrap(document, fragmentContext) {\n        this.tokenizer = new Tokenizer(this.options);\n\n        this.stopped = false;\n\n        this.insertionMode = INITIAL_MODE;\n        this.originalInsertionMode = '';\n\n        this.document = document;\n        this.fragmentContext = fragmentContext;\n\n        this.headElement = null;\n        this.formElement = null;\n\n        this.openElements = new OpenElementStack(this.document, this.treeAdapter);\n        this.activeFormattingElements = new FormattingElementList(this.treeAdapter);\n\n        this.tmplInsertionModeStack = [];\n        this.tmplInsertionModeStackTop = -1;\n        this.currentTmplInsertionMode = null;\n\n        this.pendingCharacterTokens = [];\n        this.hasNonWhitespacePendingCharacterToken = false;\n\n        this.framesetOk = true;\n        this.skipNextNewLine = false;\n        this.fosterParentingEnabled = false;\n    }\n\n    //Errors\n    _err() {\n        // NOTE: err reporting is noop by default. Enabled by mixin.\n    }\n\n    //Parsing loop\n    _runParsingLoop(scriptHandler) {\n        while (!this.stopped) {\n            this._setupTokenizerCDATAMode();\n\n            const token = this.tokenizer.getNextToken();\n\n            if (token.type === Tokenizer.HIBERNATION_TOKEN) {\n                break;\n            }\n\n            if (this.skipNextNewLine) {\n                this.skipNextNewLine = false;\n\n                if (token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN && token.chars[0] === '\\n') {\n                    if (token.chars.length === 1) {\n                        continue;\n                    }\n\n                    token.chars = token.chars.substr(1);\n                }\n            }\n\n            this._processInputToken(token);\n\n            if (scriptHandler && this.pendingScript) {\n                break;\n            }\n        }\n    }\n\n    runParsingLoopForCurrentChunk(writeCallback, scriptHandler) {\n        this._runParsingLoop(scriptHandler);\n\n        if (scriptHandler && this.pendingScript) {\n            const script = this.pendingScript;\n\n            this.pendingScript = null;\n\n            scriptHandler(script);\n\n            return;\n        }\n\n        if (writeCallback) {\n            writeCallback();\n        }\n    }\n\n    //Text parsing\n    _setupTokenizerCDATAMode() {\n        const current = this._getAdjustedCurrentElement();\n\n        this.tokenizer.allowCDATA =\n            current &&\n            current !== this.document &&\n            this.treeAdapter.getNamespaceURI(current) !== NS.HTML &&\n            !this._isIntegrationPoint(current);\n    }\n\n    _switchToTextParsing(currentToken, nextTokenizerState) {\n        this._insertElement(currentToken, NS.HTML);\n        this.tokenizer.state = nextTokenizerState;\n        this.originalInsertionMode = this.insertionMode;\n        this.insertionMode = TEXT_MODE;\n    }\n\n    switchToPlaintextParsing() {\n        this.insertionMode = TEXT_MODE;\n        this.originalInsertionMode = IN_BODY_MODE;\n        this.tokenizer.state = Tokenizer.MODE.PLAINTEXT;\n    }\n\n    //Fragment parsing\n    _getAdjustedCurrentElement() {\n        return this.openElements.stackTop === 0 && this.fragmentContext\n            ? this.fragmentContext\n            : this.openElements.current;\n    }\n\n    _findFormInFragmentContext() {\n        let node = this.fragmentContext;\n\n        do {\n            if (this.treeAdapter.getTagName(node) === $.FORM) {\n                this.formElement = node;\n                break;\n            }\n\n            node = this.treeAdapter.getParentNode(node);\n        } while (node);\n    }\n\n    _initTokenizerForFragmentParsing() {\n        if (this.treeAdapter.getNamespaceURI(this.fragmentContext) === NS.HTML) {\n            const tn = this.treeAdapter.getTagName(this.fragmentContext);\n\n            if (tn === $.TITLE || tn === $.TEXTAREA) {\n                this.tokenizer.state = Tokenizer.MODE.RCDATA;\n            } else if (\n                tn === $.STYLE ||\n                tn === $.XMP ||\n                tn === $.IFRAME ||\n                tn === $.NOEMBED ||\n                tn === $.NOFRAMES ||\n                tn === $.NOSCRIPT\n            ) {\n                this.tokenizer.state = Tokenizer.MODE.RAWTEXT;\n            } else if (tn === $.SCRIPT) {\n                this.tokenizer.state = Tokenizer.MODE.SCRIPT_DATA;\n            } else if (tn === $.PLAINTEXT) {\n                this.tokenizer.state = Tokenizer.MODE.PLAINTEXT;\n            }\n        }\n    }\n\n    //Tree mutation\n    _setDocumentType(token) {\n        const name = token.name || '';\n        const publicId = token.publicId || '';\n        const systemId = token.systemId || '';\n\n        this.treeAdapter.setDocumentType(this.document, name, publicId, systemId);\n    }\n\n    _attachElementToTree(element) {\n        if (this._shouldFosterParentOnInsertion()) {\n            this._fosterParentElement(element);\n        } else {\n            const parent = this.openElements.currentTmplContent || this.openElements.current;\n\n            this.treeAdapter.appendChild(parent, element);\n        }\n    }\n\n    _appendElement(token, namespaceURI) {\n        const element = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);\n\n        this._attachElementToTree(element);\n    }\n\n    _insertElement(token, namespaceURI) {\n        const element = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);\n\n        this._attachElementToTree(element);\n        this.openElements.push(element);\n    }\n\n    _insertFakeElement(tagName) {\n        const element = this.treeAdapter.createElement(tagName, NS.HTML, []);\n\n        this._attachElementToTree(element);\n        this.openElements.push(element);\n    }\n\n    _insertTemplate(token) {\n        const tmpl = this.treeAdapter.createElement(token.tagName, NS.HTML, token.attrs);\n        const content = this.treeAdapter.createDocumentFragment();\n\n        this.treeAdapter.setTemplateContent(tmpl, content);\n        this._attachElementToTree(tmpl);\n        this.openElements.push(tmpl);\n    }\n\n    _insertFakeRootElement() {\n        const element = this.treeAdapter.createElement($.HTML, NS.HTML, []);\n\n        this.treeAdapter.appendChild(this.openElements.current, element);\n        this.openElements.push(element);\n    }\n\n    _appendCommentNode(token, parent) {\n        const commentNode = this.treeAdapter.createCommentNode(token.data);\n\n        this.treeAdapter.appendChild(parent, commentNode);\n    }\n\n    _insertCharacters(token) {\n        if (this._shouldFosterParentOnInsertion()) {\n            this._fosterParentText(token.chars);\n        } else {\n            const parent = this.openElements.currentTmplContent || this.openElements.current;\n\n            this.treeAdapter.insertText(parent, token.chars);\n        }\n    }\n\n    _adoptNodes(donor, recipient) {\n        for (let child = this.treeAdapter.getFirstChild(donor); child; child = this.treeAdapter.getFirstChild(donor)) {\n            this.treeAdapter.detachNode(child);\n            this.treeAdapter.appendChild(recipient, child);\n        }\n    }\n\n    //Token processing\n    _shouldProcessTokenInForeignContent(token) {\n        const current = this._getAdjustedCurrentElement();\n\n        if (!current || current === this.document) {\n            return false;\n        }\n\n        const ns = this.treeAdapter.getNamespaceURI(current);\n\n        if (ns === NS.HTML) {\n            return false;\n        }\n\n        if (\n            this.treeAdapter.getTagName(current) === $.ANNOTATION_XML &&\n            ns === NS.MATHML &&\n            token.type === Tokenizer.START_TAG_TOKEN &&\n            token.tagName === $.SVG\n        ) {\n            return false;\n        }\n\n        const isCharacterToken =\n            token.type === Tokenizer.CHARACTER_TOKEN ||\n            token.type === Tokenizer.NULL_CHARACTER_TOKEN ||\n            token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN;\n\n        const isMathMLTextStartTag =\n            token.type === Tokenizer.START_TAG_TOKEN && token.tagName !== $.MGLYPH && token.tagName !== $.MALIGNMARK;\n\n        if ((isMathMLTextStartTag || isCharacterToken) && this._isIntegrationPoint(current, NS.MATHML)) {\n            return false;\n        }\n\n        if (\n            (token.type === Tokenizer.START_TAG_TOKEN || isCharacterToken) &&\n            this._isIntegrationPoint(current, NS.HTML)\n        ) {\n            return false;\n        }\n\n        return token.type !== Tokenizer.EOF_TOKEN;\n    }\n\n    _processToken(token) {\n        TOKEN_HANDLERS[this.insertionMode][token.type](this, token);\n    }\n\n    _processTokenInBodyMode(token) {\n        TOKEN_HANDLERS[IN_BODY_MODE][token.type](this, token);\n    }\n\n    _processTokenInForeignContent(token) {\n        if (token.type === Tokenizer.CHARACTER_TOKEN) {\n            characterInForeignContent(this, token);\n        } else if (token.type === Tokenizer.NULL_CHARACTER_TOKEN) {\n            nullCharacterInForeignContent(this, token);\n        } else if (token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN) {\n            insertCharacters(this, token);\n        } else if (token.type === Tokenizer.COMMENT_TOKEN) {\n            appendComment(this, token);\n        } else if (token.type === Tokenizer.START_TAG_TOKEN) {\n            startTagInForeignContent(this, token);\n        } else if (token.type === Tokenizer.END_TAG_TOKEN) {\n            endTagInForeignContent(this, token);\n        }\n    }\n\n    _processInputToken(token) {\n        if (this._shouldProcessTokenInForeignContent(token)) {\n            this._processTokenInForeignContent(token);\n        } else {\n            this._processToken(token);\n        }\n\n        if (token.type === Tokenizer.START_TAG_TOKEN && token.selfClosing && !token.ackSelfClosing) {\n            this._err(ERR.nonVoidHtmlElementStartTagWithTrailingSolidus);\n        }\n    }\n\n    //Integration points\n    _isIntegrationPoint(element, foreignNS) {\n        const tn = this.treeAdapter.getTagName(element);\n        const ns = this.treeAdapter.getNamespaceURI(element);\n        const attrs = this.treeAdapter.getAttrList(element);\n\n        return foreignContent.isIntegrationPoint(tn, ns, attrs, foreignNS);\n    }\n\n    //Active formatting elements reconstruction\n    _reconstructActiveFormattingElements() {\n        const listLength = this.activeFormattingElements.length;\n\n        if (listLength) {\n            let unopenIdx = listLength;\n            let entry = null;\n\n            do {\n                unopenIdx--;\n                entry = this.activeFormattingElements.entries[unopenIdx];\n\n                if (entry.type === FormattingElementList.MARKER_ENTRY || this.openElements.contains(entry.element)) {\n                    unopenIdx++;\n                    break;\n                }\n            } while (unopenIdx > 0);\n\n            for (let i = unopenIdx; i < listLength; i++) {\n                entry = this.activeFormattingElements.entries[i];\n                this._insertElement(entry.token, this.treeAdapter.getNamespaceURI(entry.element));\n                entry.element = this.openElements.current;\n            }\n        }\n    }\n\n    //Close elements\n    _closeTableCell() {\n        this.openElements.generateImpliedEndTags();\n        this.openElements.popUntilTableCellPopped();\n        this.activeFormattingElements.clearToLastMarker();\n        this.insertionMode = IN_ROW_MODE;\n    }\n\n    _closePElement() {\n        this.openElements.generateImpliedEndTagsWithExclusion($.P);\n        this.openElements.popUntilTagNamePopped($.P);\n    }\n\n    //Insertion modes\n    _resetInsertionMode() {\n        for (let i = this.openElements.stackTop, last = false; i >= 0; i--) {\n            let element = this.openElements.items[i];\n\n            if (i === 0) {\n                last = true;\n\n                if (this.fragmentContext) {\n                    element = this.fragmentContext;\n                }\n            }\n\n            const tn = this.treeAdapter.getTagName(element);\n            const newInsertionMode = INSERTION_MODE_RESET_MAP[tn];\n\n            if (newInsertionMode) {\n                this.insertionMode = newInsertionMode;\n                break;\n            } else if (!last && (tn === $.TD || tn === $.TH)) {\n                this.insertionMode = IN_CELL_MODE;\n                break;\n            } else if (!last && tn === $.HEAD) {\n                this.insertionMode = IN_HEAD_MODE;\n                break;\n            } else if (tn === $.SELECT) {\n                this._resetInsertionModeForSelect(i);\n                break;\n            } else if (tn === $.TEMPLATE) {\n                this.insertionMode = this.currentTmplInsertionMode;\n                break;\n            } else if (tn === $.HTML) {\n                this.insertionMode = this.headElement ? AFTER_HEAD_MODE : BEFORE_HEAD_MODE;\n                break;\n            } else if (last) {\n                this.insertionMode = IN_BODY_MODE;\n                break;\n            }\n        }\n    }\n\n    _resetInsertionModeForSelect(selectIdx) {\n        if (selectIdx > 0) {\n            for (let i = selectIdx - 1; i > 0; i--) {\n                const ancestor = this.openElements.items[i];\n                const tn = this.treeAdapter.getTagName(ancestor);\n\n                if (tn === $.TEMPLATE) {\n                    break;\n                } else if (tn === $.TABLE) {\n                    this.insertionMode = IN_SELECT_IN_TABLE_MODE;\n                    return;\n                }\n            }\n        }\n\n        this.insertionMode = IN_SELECT_MODE;\n    }\n\n    _pushTmplInsertionMode(mode) {\n        this.tmplInsertionModeStack.push(mode);\n        this.tmplInsertionModeStackTop++;\n        this.currentTmplInsertionMode = mode;\n    }\n\n    _popTmplInsertionMode() {\n        this.tmplInsertionModeStack.pop();\n        this.tmplInsertionModeStackTop--;\n        this.currentTmplInsertionMode = this.tmplInsertionModeStack[this.tmplInsertionModeStackTop];\n    }\n\n    //Foster parenting\n    _isElementCausesFosterParenting(element) {\n        const tn = this.treeAdapter.getTagName(element);\n\n        return tn === $.TABLE || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD || tn === $.TR;\n    }\n\n    _shouldFosterParentOnInsertion() {\n        return this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.current);\n    }\n\n    _findFosterParentingLocation() {\n        const location = {\n            parent: null,\n            beforeElement: null\n        };\n\n        for (let i = this.openElements.stackTop; i >= 0; i--) {\n            const openElement = this.openElements.items[i];\n            const tn = this.treeAdapter.getTagName(openElement);\n            const ns = this.treeAdapter.getNamespaceURI(openElement);\n\n            if (tn === $.TEMPLATE && ns === NS.HTML) {\n                location.parent = this.treeAdapter.getTemplateContent(openElement);\n                break;\n            } else if (tn === $.TABLE) {\n                location.parent = this.treeAdapter.getParentNode(openElement);\n\n                if (location.parent) {\n                    location.beforeElement = openElement;\n                } else {\n                    location.parent = this.openElements.items[i - 1];\n                }\n\n                break;\n            }\n        }\n\n        if (!location.parent) {\n            location.parent = this.openElements.items[0];\n        }\n\n        return location;\n    }\n\n    _fosterParentElement(element) {\n        const location = this._findFosterParentingLocation();\n\n        if (location.beforeElement) {\n            this.treeAdapter.insertBefore(location.parent, element, location.beforeElement);\n        } else {\n            this.treeAdapter.appendChild(location.parent, element);\n        }\n    }\n\n    _fosterParentText(chars) {\n        const location = this._findFosterParentingLocation();\n\n        if (location.beforeElement) {\n            this.treeAdapter.insertTextBefore(location.parent, chars, location.beforeElement);\n        } else {\n            this.treeAdapter.insertText(location.parent, chars);\n        }\n    }\n\n    //Special elements\n    _isSpecialElement(element) {\n        const tn = this.treeAdapter.getTagName(element);\n        const ns = this.treeAdapter.getNamespaceURI(element);\n\n        return HTML.SPECIAL_ELEMENTS[ns][tn];\n    }\n}\n\nmodule.exports = Parser;\n\n//Adoption agency algorithm\n//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/tree-construction.html#adoptionAgency)\n//------------------------------------------------------------------\n\n//Steps 5-8 of the algorithm\nfunction aaObtainFormattingElementEntry(p, token) {\n    let formattingElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName(token.tagName);\n\n    if (formattingElementEntry) {\n        if (!p.openElements.contains(formattingElementEntry.element)) {\n            p.activeFormattingElements.removeEntry(formattingElementEntry);\n            formattingElementEntry = null;\n        } else if (!p.openElements.hasInScope(token.tagName)) {\n            formattingElementEntry = null;\n        }\n    } else {\n        genericEndTagInBody(p, token);\n    }\n\n    return formattingElementEntry;\n}\n\n//Steps 9 and 10 of the algorithm\nfunction aaObtainFurthestBlock(p, formattingElementEntry) {\n    let furthestBlock = null;\n\n    for (let i = p.openElements.stackTop; i >= 0; i--) {\n        const element = p.openElements.items[i];\n\n        if (element === formattingElementEntry.element) {\n            break;\n        }\n\n        if (p._isSpecialElement(element)) {\n            furthestBlock = element;\n        }\n    }\n\n    if (!furthestBlock) {\n        p.openElements.popUntilElementPopped(formattingElementEntry.element);\n        p.activeFormattingElements.removeEntry(formattingElementEntry);\n    }\n\n    return furthestBlock;\n}\n\n//Step 13 of the algorithm\nfunction aaInnerLoop(p, furthestBlock, formattingElement) {\n    let lastElement = furthestBlock;\n    let nextElement = p.openElements.getCommonAncestor(furthestBlock);\n\n    for (let i = 0, element = nextElement; element !== formattingElement; i++, element = nextElement) {\n        //NOTE: store next element for the next loop iteration (it may be deleted from the stack by step 9.5)\n        nextElement = p.openElements.getCommonAncestor(element);\n\n        const elementEntry = p.activeFormattingElements.getElementEntry(element);\n        const counterOverflow = elementEntry && i >= AA_INNER_LOOP_ITER;\n        const shouldRemoveFromOpenElements = !elementEntry || counterOverflow;\n\n        if (shouldRemoveFromOpenElements) {\n            if (counterOverflow) {\n                p.activeFormattingElements.removeEntry(elementEntry);\n            }\n\n            p.openElements.remove(element);\n        } else {\n            element = aaRecreateElementFromEntry(p, elementEntry);\n\n            if (lastElement === furthestBlock) {\n                p.activeFormattingElements.bookmark = elementEntry;\n            }\n\n            p.treeAdapter.detachNode(lastElement);\n            p.treeAdapter.appendChild(element, lastElement);\n            lastElement = element;\n        }\n    }\n\n    return lastElement;\n}\n\n//Step 13.7 of the algorithm\nfunction aaRecreateElementFromEntry(p, elementEntry) {\n    const ns = p.treeAdapter.getNamespaceURI(elementEntry.element);\n    const newElement = p.treeAdapter.createElement(elementEntry.token.tagName, ns, elementEntry.token.attrs);\n\n    p.openElements.replace(elementEntry.element, newElement);\n    elementEntry.element = newElement;\n\n    return newElement;\n}\n\n//Step 14 of the algorithm\nfunction aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement) {\n    if (p._isElementCausesFosterParenting(commonAncestor)) {\n        p._fosterParentElement(lastElement);\n    } else {\n        const tn = p.treeAdapter.getTagName(commonAncestor);\n        const ns = p.treeAdapter.getNamespaceURI(commonAncestor);\n\n        if (tn === $.TEMPLATE && ns === NS.HTML) {\n            commonAncestor = p.treeAdapter.getTemplateContent(commonAncestor);\n        }\n\n        p.treeAdapter.appendChild(commonAncestor, lastElement);\n    }\n}\n\n//Steps 15-19 of the algorithm\nfunction aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry) {\n    const ns = p.treeAdapter.getNamespaceURI(formattingElementEntry.element);\n    const token = formattingElementEntry.token;\n    const newElement = p.treeAdapter.createElement(token.tagName, ns, token.attrs);\n\n    p._adoptNodes(furthestBlock, newElement);\n    p.treeAdapter.appendChild(furthestBlock, newElement);\n\n    p.activeFormattingElements.insertElementAfterBookmark(newElement, formattingElementEntry.token);\n    p.activeFormattingElements.removeEntry(formattingElementEntry);\n\n    p.openElements.remove(formattingElementEntry.element);\n    p.openElements.insertAfter(furthestBlock, newElement);\n}\n\n//Algorithm entry point\nfunction callAdoptionAgency(p, token) {\n    let formattingElementEntry;\n\n    for (let i = 0; i < AA_OUTER_LOOP_ITER; i++) {\n        formattingElementEntry = aaObtainFormattingElementEntry(p, token, formattingElementEntry);\n\n        if (!formattingElementEntry) {\n            break;\n        }\n\n        const furthestBlock = aaObtainFurthestBlock(p, formattingElementEntry);\n\n        if (!furthestBlock) {\n            break;\n        }\n\n        p.activeFormattingElements.bookmark = formattingElementEntry;\n\n        const lastElement = aaInnerLoop(p, furthestBlock, formattingElementEntry.element);\n        const commonAncestor = p.openElements.getCommonAncestor(formattingElementEntry.element);\n\n        p.treeAdapter.detachNode(lastElement);\n        aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement);\n        aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry);\n    }\n}\n\n//Generic token handlers\n//------------------------------------------------------------------\nfunction ignoreToken() {\n    //NOTE: do nothing =)\n}\n\nfunction misplacedDoctype(p) {\n    p._err(ERR.misplacedDoctype);\n}\n\nfunction appendComment(p, token) {\n    p._appendCommentNode(token, p.openElements.currentTmplContent || p.openElements.current);\n}\n\nfunction appendCommentToRootHtmlElement(p, token) {\n    p._appendCommentNode(token, p.openElements.items[0]);\n}\n\nfunction appendCommentToDocument(p, token) {\n    p._appendCommentNode(token, p.document);\n}\n\nfunction insertCharacters(p, token) {\n    p._insertCharacters(token);\n}\n\nfunction stopParsing(p) {\n    p.stopped = true;\n}\n\n// The \"initial\" insertion mode\n//------------------------------------------------------------------\nfunction doctypeInInitialMode(p, token) {\n    p._setDocumentType(token);\n\n    const mode = token.forceQuirks ? HTML.DOCUMENT_MODE.QUIRKS : doctype.getDocumentMode(token);\n\n    if (!doctype.isConforming(token)) {\n        p._err(ERR.nonConformingDoctype);\n    }\n\n    p.treeAdapter.setDocumentMode(p.document, mode);\n\n    p.insertionMode = BEFORE_HTML_MODE;\n}\n\nfunction tokenInInitialMode(p, token) {\n    p._err(ERR.missingDoctype, { beforeToken: true });\n    p.treeAdapter.setDocumentMode(p.document, HTML.DOCUMENT_MODE.QUIRKS);\n    p.insertionMode = BEFORE_HTML_MODE;\n    p._processToken(token);\n}\n\n// The \"before html\" insertion mode\n//------------------------------------------------------------------\nfunction startTagBeforeHtml(p, token) {\n    if (token.tagName === $.HTML) {\n        p._insertElement(token, NS.HTML);\n        p.insertionMode = BEFORE_HEAD_MODE;\n    } else {\n        tokenBeforeHtml(p, token);\n    }\n}\n\nfunction endTagBeforeHtml(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.HTML || tn === $.HEAD || tn === $.BODY || tn === $.BR) {\n        tokenBeforeHtml(p, token);\n    }\n}\n\nfunction tokenBeforeHtml(p, token) {\n    p._insertFakeRootElement();\n    p.insertionMode = BEFORE_HEAD_MODE;\n    p._processToken(token);\n}\n\n// The \"before head\" insertion mode\n//------------------------------------------------------------------\nfunction startTagBeforeHead(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.HTML) {\n        startTagInBody(p, token);\n    } else if (tn === $.HEAD) {\n        p._insertElement(token, NS.HTML);\n        p.headElement = p.openElements.current;\n        p.insertionMode = IN_HEAD_MODE;\n    } else {\n        tokenBeforeHead(p, token);\n    }\n}\n\nfunction endTagBeforeHead(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.HEAD || tn === $.BODY || tn === $.HTML || tn === $.BR) {\n        tokenBeforeHead(p, token);\n    } else {\n        p._err(ERR.endTagWithoutMatchingOpenElement);\n    }\n}\n\nfunction tokenBeforeHead(p, token) {\n    p._insertFakeElement($.HEAD);\n    p.headElement = p.openElements.current;\n    p.insertionMode = IN_HEAD_MODE;\n    p._processToken(token);\n}\n\n// The \"in head\" insertion mode\n//------------------------------------------------------------------\nfunction startTagInHead(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.HTML) {\n        startTagInBody(p, token);\n    } else if (tn === $.BASE || tn === $.BASEFONT || tn === $.BGSOUND || tn === $.LINK || tn === $.META) {\n        p._appendElement(token, NS.HTML);\n        token.ackSelfClosing = true;\n    } else if (tn === $.TITLE) {\n        p._switchToTextParsing(token, Tokenizer.MODE.RCDATA);\n    } else if (tn === $.NOSCRIPT) {\n        if (p.options.scriptingEnabled) {\n            p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);\n        } else {\n            p._insertElement(token, NS.HTML);\n            p.insertionMode = IN_HEAD_NO_SCRIPT_MODE;\n        }\n    } else if (tn === $.NOFRAMES || tn === $.STYLE) {\n        p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);\n    } else if (tn === $.SCRIPT) {\n        p._switchToTextParsing(token, Tokenizer.MODE.SCRIPT_DATA);\n    } else if (tn === $.TEMPLATE) {\n        p._insertTemplate(token, NS.HTML);\n        p.activeFormattingElements.insertMarker();\n        p.framesetOk = false;\n        p.insertionMode = IN_TEMPLATE_MODE;\n        p._pushTmplInsertionMode(IN_TEMPLATE_MODE);\n    } else if (tn === $.HEAD) {\n        p._err(ERR.misplacedStartTagForHeadElement);\n    } else {\n        tokenInHead(p, token);\n    }\n}\n\nfunction endTagInHead(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.HEAD) {\n        p.openElements.pop();\n        p.insertionMode = AFTER_HEAD_MODE;\n    } else if (tn === $.BODY || tn === $.BR || tn === $.HTML) {\n        tokenInHead(p, token);\n    } else if (tn === $.TEMPLATE) {\n        if (p.openElements.tmplCount > 0) {\n            p.openElements.generateImpliedEndTagsThoroughly();\n\n            if (p.openElements.currentTagName !== $.TEMPLATE) {\n                p._err(ERR.closingOfElementWithOpenChildElements);\n            }\n\n            p.openElements.popUntilTagNamePopped($.TEMPLATE);\n            p.activeFormattingElements.clearToLastMarker();\n            p._popTmplInsertionMode();\n            p._resetInsertionMode();\n        } else {\n            p._err(ERR.endTagWithoutMatchingOpenElement);\n        }\n    } else {\n        p._err(ERR.endTagWithoutMatchingOpenElement);\n    }\n}\n\nfunction tokenInHead(p, token) {\n    p.openElements.pop();\n    p.insertionMode = AFTER_HEAD_MODE;\n    p._processToken(token);\n}\n\n// The \"in head no script\" insertion mode\n//------------------------------------------------------------------\nfunction startTagInHeadNoScript(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.HTML) {\n        startTagInBody(p, token);\n    } else if (\n        tn === $.BASEFONT ||\n        tn === $.BGSOUND ||\n        tn === $.HEAD ||\n        tn === $.LINK ||\n        tn === $.META ||\n        tn === $.NOFRAMES ||\n        tn === $.STYLE\n    ) {\n        startTagInHead(p, token);\n    } else if (tn === $.NOSCRIPT) {\n        p._err(ERR.nestedNoscriptInHead);\n    } else {\n        tokenInHeadNoScript(p, token);\n    }\n}\n\nfunction endTagInHeadNoScript(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.NOSCRIPT) {\n        p.openElements.pop();\n        p.insertionMode = IN_HEAD_MODE;\n    } else if (tn === $.BR) {\n        tokenInHeadNoScript(p, token);\n    } else {\n        p._err(ERR.endTagWithoutMatchingOpenElement);\n    }\n}\n\nfunction tokenInHeadNoScript(p, token) {\n    const errCode =\n        token.type === Tokenizer.EOF_TOKEN ? ERR.openElementsLeftAfterEof : ERR.disallowedContentInNoscriptInHead;\n\n    p._err(errCode);\n    p.openElements.pop();\n    p.insertionMode = IN_HEAD_MODE;\n    p._processToken(token);\n}\n\n// The \"after head\" insertion mode\n//------------------------------------------------------------------\nfunction startTagAfterHead(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.HTML) {\n        startTagInBody(p, token);\n    } else if (tn === $.BODY) {\n        p._insertElement(token, NS.HTML);\n        p.framesetOk = false;\n        p.insertionMode = IN_BODY_MODE;\n    } else if (tn === $.FRAMESET) {\n        p._insertElement(token, NS.HTML);\n        p.insertionMode = IN_FRAMESET_MODE;\n    } else if (\n        tn === $.BASE ||\n        tn === $.BASEFONT ||\n        tn === $.BGSOUND ||\n        tn === $.LINK ||\n        tn === $.META ||\n        tn === $.NOFRAMES ||\n        tn === $.SCRIPT ||\n        tn === $.STYLE ||\n        tn === $.TEMPLATE ||\n        tn === $.TITLE\n    ) {\n        p._err(ERR.abandonedHeadElementChild);\n        p.openElements.push(p.headElement);\n        startTagInHead(p, token);\n        p.openElements.remove(p.headElement);\n    } else if (tn === $.HEAD) {\n        p._err(ERR.misplacedStartTagForHeadElement);\n    } else {\n        tokenAfterHead(p, token);\n    }\n}\n\nfunction endTagAfterHead(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.BODY || tn === $.HTML || tn === $.BR) {\n        tokenAfterHead(p, token);\n    } else if (tn === $.TEMPLATE) {\n        endTagInHead(p, token);\n    } else {\n        p._err(ERR.endTagWithoutMatchingOpenElement);\n    }\n}\n\nfunction tokenAfterHead(p, token) {\n    p._insertFakeElement($.BODY);\n    p.insertionMode = IN_BODY_MODE;\n    p._processToken(token);\n}\n\n// The \"in body\" insertion mode\n//------------------------------------------------------------------\nfunction whitespaceCharacterInBody(p, token) {\n    p._reconstructActiveFormattingElements();\n    p._insertCharacters(token);\n}\n\nfunction characterInBody(p, token) {\n    p._reconstructActiveFormattingElements();\n    p._insertCharacters(token);\n    p.framesetOk = false;\n}\n\nfunction htmlStartTagInBody(p, token) {\n    if (p.openElements.tmplCount === 0) {\n        p.treeAdapter.adoptAttributes(p.openElements.items[0], token.attrs);\n    }\n}\n\nfunction bodyStartTagInBody(p, token) {\n    const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();\n\n    if (bodyElement && p.openElements.tmplCount === 0) {\n        p.framesetOk = false;\n        p.treeAdapter.adoptAttributes(bodyElement, token.attrs);\n    }\n}\n\nfunction framesetStartTagInBody(p, token) {\n    const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();\n\n    if (p.framesetOk && bodyElement) {\n        p.treeAdapter.detachNode(bodyElement);\n        p.openElements.popAllUpToHtmlElement();\n        p._insertElement(token, NS.HTML);\n        p.insertionMode = IN_FRAMESET_MODE;\n    }\n}\n\nfunction addressStartTagInBody(p, token) {\n    if (p.openElements.hasInButtonScope($.P)) {\n        p._closePElement();\n    }\n\n    p._insertElement(token, NS.HTML);\n}\n\nfunction numberedHeaderStartTagInBody(p, token) {\n    if (p.openElements.hasInButtonScope($.P)) {\n        p._closePElement();\n    }\n\n    const tn = p.openElements.currentTagName;\n\n    if (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6) {\n        p.openElements.pop();\n    }\n\n    p._insertElement(token, NS.HTML);\n}\n\nfunction preStartTagInBody(p, token) {\n    if (p.openElements.hasInButtonScope($.P)) {\n        p._closePElement();\n    }\n\n    p._insertElement(token, NS.HTML);\n    //NOTE: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move\n    //on to the next one. (Newlines at the start of pre blocks are ignored as an authoring convenience.)\n    p.skipNextNewLine = true;\n    p.framesetOk = false;\n}\n\nfunction formStartTagInBody(p, token) {\n    const inTemplate = p.openElements.tmplCount > 0;\n\n    if (!p.formElement || inTemplate) {\n        if (p.openElements.hasInButtonScope($.P)) {\n            p._closePElement();\n        }\n\n        p._insertElement(token, NS.HTML);\n\n        if (!inTemplate) {\n            p.formElement = p.openElements.current;\n        }\n    }\n}\n\nfunction listItemStartTagInBody(p, token) {\n    p.framesetOk = false;\n\n    const tn = token.tagName;\n\n    for (let i = p.openElements.stackTop; i >= 0; i--) {\n        const element = p.openElements.items[i];\n        const elementTn = p.treeAdapter.getTagName(element);\n        let closeTn = null;\n\n        if (tn === $.LI && elementTn === $.LI) {\n            closeTn = $.LI;\n        } else if ((tn === $.DD || tn === $.DT) && (elementTn === $.DD || elementTn === $.DT)) {\n            closeTn = elementTn;\n        }\n\n        if (closeTn) {\n            p.openElements.generateImpliedEndTagsWithExclusion(closeTn);\n            p.openElements.popUntilTagNamePopped(closeTn);\n            break;\n        }\n\n        if (elementTn !== $.ADDRESS && elementTn !== $.DIV && elementTn !== $.P && p._isSpecialElement(element)) {\n            break;\n        }\n    }\n\n    if (p.openElements.hasInButtonScope($.P)) {\n        p._closePElement();\n    }\n\n    p._insertElement(token, NS.HTML);\n}\n\nfunction plaintextStartTagInBody(p, token) {\n    if (p.openElements.hasInButtonScope($.P)) {\n        p._closePElement();\n    }\n\n    p._insertElement(token, NS.HTML);\n    p.tokenizer.state = Tokenizer.MODE.PLAINTEXT;\n}\n\nfunction buttonStartTagInBody(p, token) {\n    if (p.openElements.hasInScope($.BUTTON)) {\n        p.openElements.generateImpliedEndTags();\n        p.openElements.popUntilTagNamePopped($.BUTTON);\n    }\n\n    p._reconstructActiveFormattingElements();\n    p._insertElement(token, NS.HTML);\n    p.framesetOk = false;\n}\n\nfunction aStartTagInBody(p, token) {\n    const activeElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName($.A);\n\n    if (activeElementEntry) {\n        callAdoptionAgency(p, token);\n        p.openElements.remove(activeElementEntry.element);\n        p.activeFormattingElements.removeEntry(activeElementEntry);\n    }\n\n    p._reconstructActiveFormattingElements();\n    p._insertElement(token, NS.HTML);\n    p.activeFormattingElements.pushElement(p.openElements.current, token);\n}\n\nfunction bStartTagInBody(p, token) {\n    p._reconstructActiveFormattingElements();\n    p._insertElement(token, NS.HTML);\n    p.activeFormattingElements.pushElement(p.openElements.current, token);\n}\n\nfunction nobrStartTagInBody(p, token) {\n    p._reconstructActiveFormattingElements();\n\n    if (p.openElements.hasInScope($.NOBR)) {\n        callAdoptionAgency(p, token);\n        p._reconstructActiveFormattingElements();\n    }\n\n    p._insertElement(token, NS.HTML);\n    p.activeFormattingElements.pushElement(p.openElements.current, token);\n}\n\nfunction appletStartTagInBody(p, token) {\n    p._reconstructActiveFormattingElements();\n    p._insertElement(token, NS.HTML);\n    p.activeFormattingElements.insertMarker();\n    p.framesetOk = false;\n}\n\nfunction tableStartTagInBody(p, token) {\n    if (\n        p.treeAdapter.getDocumentMode(p.document) !== HTML.DOCUMENT_MODE.QUIRKS &&\n        p.openElements.hasInButtonScope($.P)\n    ) {\n        p._closePElement();\n    }\n\n    p._insertElement(token, NS.HTML);\n    p.framesetOk = false;\n    p.insertionMode = IN_TABLE_MODE;\n}\n\nfunction areaStartTagInBody(p, token) {\n    p._reconstructActiveFormattingElements();\n    p._appendElement(token, NS.HTML);\n    p.framesetOk = false;\n    token.ackSelfClosing = true;\n}\n\nfunction inputStartTagInBody(p, token) {\n    p._reconstructActiveFormattingElements();\n    p._appendElement(token, NS.HTML);\n\n    const inputType = Tokenizer.getTokenAttr(token, ATTRS.TYPE);\n\n    if (!inputType || inputType.toLowerCase() !== HIDDEN_INPUT_TYPE) {\n        p.framesetOk = false;\n    }\n\n    token.ackSelfClosing = true;\n}\n\nfunction paramStartTagInBody(p, token) {\n    p._appendElement(token, NS.HTML);\n    token.ackSelfClosing = true;\n}\n\nfunction hrStartTagInBody(p, token) {\n    if (p.openElements.hasInButtonScope($.P)) {\n        p._closePElement();\n    }\n\n    p._appendElement(token, NS.HTML);\n    p.framesetOk = false;\n    token.ackSelfClosing = true;\n}\n\nfunction imageStartTagInBody(p, token) {\n    token.tagName = $.IMG;\n    areaStartTagInBody(p, token);\n}\n\nfunction textareaStartTagInBody(p, token) {\n    p._insertElement(token, NS.HTML);\n    //NOTE: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move\n    //on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n    p.skipNextNewLine = true;\n    p.tokenizer.state = Tokenizer.MODE.RCDATA;\n    p.originalInsertionMode = p.insertionMode;\n    p.framesetOk = false;\n    p.insertionMode = TEXT_MODE;\n}\n\nfunction xmpStartTagInBody(p, token) {\n    if (p.openElements.hasInButtonScope($.P)) {\n        p._closePElement();\n    }\n\n    p._reconstructActiveFormattingElements();\n    p.framesetOk = false;\n    p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);\n}\n\nfunction iframeStartTagInBody(p, token) {\n    p.framesetOk = false;\n    p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);\n}\n\n//NOTE: here we assume that we always act as an user agent with enabled plugins, so we parse\n//<noembed> as a rawtext.\nfunction noembedStartTagInBody(p, token) {\n    p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);\n}\n\nfunction selectStartTagInBody(p, token) {\n    p._reconstructActiveFormattingElements();\n    p._insertElement(token, NS.HTML);\n    p.framesetOk = false;\n\n    if (\n        p.insertionMode === IN_TABLE_MODE ||\n        p.insertionMode === IN_CAPTION_MODE ||\n        p.insertionMode === IN_TABLE_BODY_MODE ||\n        p.insertionMode === IN_ROW_MODE ||\n        p.insertionMode === IN_CELL_MODE\n    ) {\n        p.insertionMode = IN_SELECT_IN_TABLE_MODE;\n    } else {\n        p.insertionMode = IN_SELECT_MODE;\n    }\n}\n\nfunction optgroupStartTagInBody(p, token) {\n    if (p.openElements.currentTagName === $.OPTION) {\n        p.openElements.pop();\n    }\n\n    p._reconstructActiveFormattingElements();\n    p._insertElement(token, NS.HTML);\n}\n\nfunction rbStartTagInBody(p, token) {\n    if (p.openElements.hasInScope($.RUBY)) {\n        p.openElements.generateImpliedEndTags();\n    }\n\n    p._insertElement(token, NS.HTML);\n}\n\nfunction rtStartTagInBody(p, token) {\n    if (p.openElements.hasInScope($.RUBY)) {\n        p.openElements.generateImpliedEndTagsWithExclusion($.RTC);\n    }\n\n    p._insertElement(token, NS.HTML);\n}\n\nfunction menuStartTagInBody(p, token) {\n    if (p.openElements.hasInButtonScope($.P)) {\n        p._closePElement();\n    }\n\n    p._insertElement(token, NS.HTML);\n}\n\nfunction mathStartTagInBody(p, token) {\n    p._reconstructActiveFormattingElements();\n\n    foreignContent.adjustTokenMathMLAttrs(token);\n    foreignContent.adjustTokenXMLAttrs(token);\n\n    if (token.selfClosing) {\n        p._appendElement(token, NS.MATHML);\n    } else {\n        p._insertElement(token, NS.MATHML);\n    }\n\n    token.ackSelfClosing = true;\n}\n\nfunction svgStartTagInBody(p, token) {\n    p._reconstructActiveFormattingElements();\n\n    foreignContent.adjustTokenSVGAttrs(token);\n    foreignContent.adjustTokenXMLAttrs(token);\n\n    if (token.selfClosing) {\n        p._appendElement(token, NS.SVG);\n    } else {\n        p._insertElement(token, NS.SVG);\n    }\n\n    token.ackSelfClosing = true;\n}\n\nfunction genericStartTagInBody(p, token) {\n    p._reconstructActiveFormattingElements();\n    p._insertElement(token, NS.HTML);\n}\n\n//OPTIMIZATION: Integer comparisons are low-cost, so we can use very fast tag name length filters here.\n//It's faster than using dictionary.\nfunction startTagInBody(p, token) {\n    const tn = token.tagName;\n\n    switch (tn.length) {\n        case 1:\n            if (tn === $.I || tn === $.S || tn === $.B || tn === $.U) {\n                bStartTagInBody(p, token);\n            } else if (tn === $.P) {\n                addressStartTagInBody(p, token);\n            } else if (tn === $.A) {\n                aStartTagInBody(p, token);\n            } else {\n                genericStartTagInBody(p, token);\n            }\n\n            break;\n\n        case 2:\n            if (tn === $.DL || tn === $.OL || tn === $.UL) {\n                addressStartTagInBody(p, token);\n            } else if (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6) {\n                numberedHeaderStartTagInBody(p, token);\n            } else if (tn === $.LI || tn === $.DD || tn === $.DT) {\n                listItemStartTagInBody(p, token);\n            } else if (tn === $.EM || tn === $.TT) {\n                bStartTagInBody(p, token);\n            } else if (tn === $.BR) {\n                areaStartTagInBody(p, token);\n            } else if (tn === $.HR) {\n                hrStartTagInBody(p, token);\n            } else if (tn === $.RB) {\n                rbStartTagInBody(p, token);\n            } else if (tn === $.RT || tn === $.RP) {\n                rtStartTagInBody(p, token);\n            } else if (tn !== $.TH && tn !== $.TD && tn !== $.TR) {\n                genericStartTagInBody(p, token);\n            }\n\n            break;\n\n        case 3:\n            if (tn === $.DIV || tn === $.DIR || tn === $.NAV) {\n                addressStartTagInBody(p, token);\n            } else if (tn === $.PRE) {\n                preStartTagInBody(p, token);\n            } else if (tn === $.BIG) {\n                bStartTagInBody(p, token);\n            } else if (tn === $.IMG || tn === $.WBR) {\n                areaStartTagInBody(p, token);\n            } else if (tn === $.XMP) {\n                xmpStartTagInBody(p, token);\n            } else if (tn === $.SVG) {\n                svgStartTagInBody(p, token);\n            } else if (tn === $.RTC) {\n                rbStartTagInBody(p, token);\n            } else if (tn !== $.COL) {\n                genericStartTagInBody(p, token);\n            }\n\n            break;\n\n        case 4:\n            if (tn === $.HTML) {\n                htmlStartTagInBody(p, token);\n            } else if (tn === $.BASE || tn === $.LINK || tn === $.META) {\n                startTagInHead(p, token);\n            } else if (tn === $.BODY) {\n                bodyStartTagInBody(p, token);\n            } else if (tn === $.MAIN || tn === $.MENU) {\n                addressStartTagInBody(p, token);\n            } else if (tn === $.FORM) {\n                formStartTagInBody(p, token);\n            } else if (tn === $.CODE || tn === $.FONT) {\n                bStartTagInBody(p, token);\n            } else if (tn === $.NOBR) {\n                nobrStartTagInBody(p, token);\n            } else if (tn === $.AREA) {\n                areaStartTagInBody(p, token);\n            } else if (tn === $.MATH) {\n                mathStartTagInBody(p, token);\n            } else if (tn === $.MENU) {\n                menuStartTagInBody(p, token);\n            } else if (tn !== $.HEAD) {\n                genericStartTagInBody(p, token);\n            }\n\n            break;\n\n        case 5:\n            if (tn === $.STYLE || tn === $.TITLE) {\n                startTagInHead(p, token);\n            } else if (tn === $.ASIDE) {\n                addressStartTagInBody(p, token);\n            } else if (tn === $.SMALL) {\n                bStartTagInBody(p, token);\n            } else if (tn === $.TABLE) {\n                tableStartTagInBody(p, token);\n            } else if (tn === $.EMBED) {\n                areaStartTagInBody(p, token);\n            } else if (tn === $.INPUT) {\n                inputStartTagInBody(p, token);\n            } else if (tn === $.PARAM || tn === $.TRACK) {\n                paramStartTagInBody(p, token);\n            } else if (tn === $.IMAGE) {\n                imageStartTagInBody(p, token);\n            } else if (tn !== $.FRAME && tn !== $.TBODY && tn !== $.TFOOT && tn !== $.THEAD) {\n                genericStartTagInBody(p, token);\n            }\n\n            break;\n\n        case 6:\n            if (tn === $.SCRIPT) {\n                startTagInHead(p, token);\n            } else if (\n                tn === $.CENTER ||\n                tn === $.FIGURE ||\n                tn === $.FOOTER ||\n                tn === $.HEADER ||\n                tn === $.HGROUP ||\n                tn === $.DIALOG\n            ) {\n                addressStartTagInBody(p, token);\n            } else if (tn === $.BUTTON) {\n                buttonStartTagInBody(p, token);\n            } else if (tn === $.STRIKE || tn === $.STRONG) {\n                bStartTagInBody(p, token);\n            } else if (tn === $.APPLET || tn === $.OBJECT) {\n                appletStartTagInBody(p, token);\n            } else if (tn === $.KEYGEN) {\n                areaStartTagInBody(p, token);\n            } else if (tn === $.SOURCE) {\n                paramStartTagInBody(p, token);\n            } else if (tn === $.IFRAME) {\n                iframeStartTagInBody(p, token);\n            } else if (tn === $.SELECT) {\n                selectStartTagInBody(p, token);\n            } else if (tn === $.OPTION) {\n                optgroupStartTagInBody(p, token);\n            } else {\n                genericStartTagInBody(p, token);\n            }\n\n            break;\n\n        case 7:\n            if (tn === $.BGSOUND) {\n                startTagInHead(p, token);\n            } else if (\n                tn === $.DETAILS ||\n                tn === $.ADDRESS ||\n                tn === $.ARTICLE ||\n                tn === $.SECTION ||\n                tn === $.SUMMARY\n            ) {\n                addressStartTagInBody(p, token);\n            } else if (tn === $.LISTING) {\n                preStartTagInBody(p, token);\n            } else if (tn === $.MARQUEE) {\n                appletStartTagInBody(p, token);\n            } else if (tn === $.NOEMBED) {\n                noembedStartTagInBody(p, token);\n            } else if (tn !== $.CAPTION) {\n                genericStartTagInBody(p, token);\n            }\n\n            break;\n\n        case 8:\n            if (tn === $.BASEFONT) {\n                startTagInHead(p, token);\n            } else if (tn === $.FRAMESET) {\n                framesetStartTagInBody(p, token);\n            } else if (tn === $.FIELDSET) {\n                addressStartTagInBody(p, token);\n            } else if (tn === $.TEXTAREA) {\n                textareaStartTagInBody(p, token);\n            } else if (tn === $.TEMPLATE) {\n                startTagInHead(p, token);\n            } else if (tn === $.NOSCRIPT) {\n                if (p.options.scriptingEnabled) {\n                    noembedStartTagInBody(p, token);\n                } else {\n                    genericStartTagInBody(p, token);\n                }\n            } else if (tn === $.OPTGROUP) {\n                optgroupStartTagInBody(p, token);\n            } else if (tn !== $.COLGROUP) {\n                genericStartTagInBody(p, token);\n            }\n\n            break;\n\n        case 9:\n            if (tn === $.PLAINTEXT) {\n                plaintextStartTagInBody(p, token);\n            } else {\n                genericStartTagInBody(p, token);\n            }\n\n            break;\n\n        case 10:\n            if (tn === $.BLOCKQUOTE || tn === $.FIGCAPTION) {\n                addressStartTagInBody(p, token);\n            } else {\n                genericStartTagInBody(p, token);\n            }\n\n            break;\n\n        default:\n            genericStartTagInBody(p, token);\n    }\n}\n\nfunction bodyEndTagInBody(p) {\n    if (p.openElements.hasInScope($.BODY)) {\n        p.insertionMode = AFTER_BODY_MODE;\n    }\n}\n\nfunction htmlEndTagInBody(p, token) {\n    if (p.openElements.hasInScope($.BODY)) {\n        p.insertionMode = AFTER_BODY_MODE;\n        p._processToken(token);\n    }\n}\n\nfunction addressEndTagInBody(p, token) {\n    const tn = token.tagName;\n\n    if (p.openElements.hasInScope(tn)) {\n        p.openElements.generateImpliedEndTags();\n        p.openElements.popUntilTagNamePopped(tn);\n    }\n}\n\nfunction formEndTagInBody(p) {\n    const inTemplate = p.openElements.tmplCount > 0;\n    const formElement = p.formElement;\n\n    if (!inTemplate) {\n        p.formElement = null;\n    }\n\n    if ((formElement || inTemplate) && p.openElements.hasInScope($.FORM)) {\n        p.openElements.generateImpliedEndTags();\n\n        if (inTemplate) {\n            p.openElements.popUntilTagNamePopped($.FORM);\n        } else {\n            p.openElements.remove(formElement);\n        }\n    }\n}\n\nfunction pEndTagInBody(p) {\n    if (!p.openElements.hasInButtonScope($.P)) {\n        p._insertFakeElement($.P);\n    }\n\n    p._closePElement();\n}\n\nfunction liEndTagInBody(p) {\n    if (p.openElements.hasInListItemScope($.LI)) {\n        p.openElements.generateImpliedEndTagsWithExclusion($.LI);\n        p.openElements.popUntilTagNamePopped($.LI);\n    }\n}\n\nfunction ddEndTagInBody(p, token) {\n    const tn = token.tagName;\n\n    if (p.openElements.hasInScope(tn)) {\n        p.openElements.generateImpliedEndTagsWithExclusion(tn);\n        p.openElements.popUntilTagNamePopped(tn);\n    }\n}\n\nfunction numberedHeaderEndTagInBody(p) {\n    if (p.openElements.hasNumberedHeaderInScope()) {\n        p.openElements.generateImpliedEndTags();\n        p.openElements.popUntilNumberedHeaderPopped();\n    }\n}\n\nfunction appletEndTagInBody(p, token) {\n    const tn = token.tagName;\n\n    if (p.openElements.hasInScope(tn)) {\n        p.openElements.generateImpliedEndTags();\n        p.openElements.popUntilTagNamePopped(tn);\n        p.activeFormattingElements.clearToLastMarker();\n    }\n}\n\nfunction brEndTagInBody(p) {\n    p._reconstructActiveFormattingElements();\n    p._insertFakeElement($.BR);\n    p.openElements.pop();\n    p.framesetOk = false;\n}\n\nfunction genericEndTagInBody(p, token) {\n    const tn = token.tagName;\n\n    for (let i = p.openElements.stackTop; i > 0; i--) {\n        const element = p.openElements.items[i];\n\n        if (p.treeAdapter.getTagName(element) === tn) {\n            p.openElements.generateImpliedEndTagsWithExclusion(tn);\n            p.openElements.popUntilElementPopped(element);\n            break;\n        }\n\n        if (p._isSpecialElement(element)) {\n            break;\n        }\n    }\n}\n\n//OPTIMIZATION: Integer comparisons are low-cost, so we can use very fast tag name length filters here.\n//It's faster than using dictionary.\nfunction endTagInBody(p, token) {\n    const tn = token.tagName;\n\n    switch (tn.length) {\n        case 1:\n            if (tn === $.A || tn === $.B || tn === $.I || tn === $.S || tn === $.U) {\n                callAdoptionAgency(p, token);\n            } else if (tn === $.P) {\n                pEndTagInBody(p, token);\n            } else {\n                genericEndTagInBody(p, token);\n            }\n\n            break;\n\n        case 2:\n            if (tn === $.DL || tn === $.UL || tn === $.OL) {\n                addressEndTagInBody(p, token);\n            } else if (tn === $.LI) {\n                liEndTagInBody(p, token);\n            } else if (tn === $.DD || tn === $.DT) {\n                ddEndTagInBody(p, token);\n            } else if (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6) {\n                numberedHeaderEndTagInBody(p, token);\n            } else if (tn === $.BR) {\n                brEndTagInBody(p, token);\n            } else if (tn === $.EM || tn === $.TT) {\n                callAdoptionAgency(p, token);\n            } else {\n                genericEndTagInBody(p, token);\n            }\n\n            break;\n\n        case 3:\n            if (tn === $.BIG) {\n                callAdoptionAgency(p, token);\n            } else if (tn === $.DIR || tn === $.DIV || tn === $.NAV || tn === $.PRE) {\n                addressEndTagInBody(p, token);\n            } else {\n                genericEndTagInBody(p, token);\n            }\n\n            break;\n\n        case 4:\n            if (tn === $.BODY) {\n                bodyEndTagInBody(p, token);\n            } else if (tn === $.HTML) {\n                htmlEndTagInBody(p, token);\n            } else if (tn === $.FORM) {\n                formEndTagInBody(p, token);\n            } else if (tn === $.CODE || tn === $.FONT || tn === $.NOBR) {\n                callAdoptionAgency(p, token);\n            } else if (tn === $.MAIN || tn === $.MENU) {\n                addressEndTagInBody(p, token);\n            } else {\n                genericEndTagInBody(p, token);\n            }\n\n            break;\n\n        case 5:\n            if (tn === $.ASIDE) {\n                addressEndTagInBody(p, token);\n            } else if (tn === $.SMALL) {\n                callAdoptionAgency(p, token);\n            } else {\n                genericEndTagInBody(p, token);\n            }\n\n            break;\n\n        case 6:\n            if (\n                tn === $.CENTER ||\n                tn === $.FIGURE ||\n                tn === $.FOOTER ||\n                tn === $.HEADER ||\n                tn === $.HGROUP ||\n                tn === $.DIALOG\n            ) {\n                addressEndTagInBody(p, token);\n            } else if (tn === $.APPLET || tn === $.OBJECT) {\n                appletEndTagInBody(p, token);\n            } else if (tn === $.STRIKE || tn === $.STRONG) {\n                callAdoptionAgency(p, token);\n            } else {\n                genericEndTagInBody(p, token);\n            }\n\n            break;\n\n        case 7:\n            if (\n                tn === $.ADDRESS ||\n                tn === $.ARTICLE ||\n                tn === $.DETAILS ||\n                tn === $.SECTION ||\n                tn === $.SUMMARY ||\n                tn === $.LISTING\n            ) {\n                addressEndTagInBody(p, token);\n            } else if (tn === $.MARQUEE) {\n                appletEndTagInBody(p, token);\n            } else {\n                genericEndTagInBody(p, token);\n            }\n\n            break;\n\n        case 8:\n            if (tn === $.FIELDSET) {\n                addressEndTagInBody(p, token);\n            } else if (tn === $.TEMPLATE) {\n                endTagInHead(p, token);\n            } else {\n                genericEndTagInBody(p, token);\n            }\n\n            break;\n\n        case 10:\n            if (tn === $.BLOCKQUOTE || tn === $.FIGCAPTION) {\n                addressEndTagInBody(p, token);\n            } else {\n                genericEndTagInBody(p, token);\n            }\n\n            break;\n\n        default:\n            genericEndTagInBody(p, token);\n    }\n}\n\nfunction eofInBody(p, token) {\n    if (p.tmplInsertionModeStackTop > -1) {\n        eofInTemplate(p, token);\n    } else {\n        p.stopped = true;\n    }\n}\n\n// The \"text\" insertion mode\n//------------------------------------------------------------------\nfunction endTagInText(p, token) {\n    if (token.tagName === $.SCRIPT) {\n        p.pendingScript = p.openElements.current;\n    }\n\n    p.openElements.pop();\n    p.insertionMode = p.originalInsertionMode;\n}\n\nfunction eofInText(p, token) {\n    p._err(ERR.eofInElementThatCanContainOnlyText);\n    p.openElements.pop();\n    p.insertionMode = p.originalInsertionMode;\n    p._processToken(token);\n}\n\n// The \"in table\" insertion mode\n//------------------------------------------------------------------\nfunction characterInTable(p, token) {\n    const curTn = p.openElements.currentTagName;\n\n    if (curTn === $.TABLE || curTn === $.TBODY || curTn === $.TFOOT || curTn === $.THEAD || curTn === $.TR) {\n        p.pendingCharacterTokens = [];\n        p.hasNonWhitespacePendingCharacterToken = false;\n        p.originalInsertionMode = p.insertionMode;\n        p.insertionMode = IN_TABLE_TEXT_MODE;\n        p._processToken(token);\n    } else {\n        tokenInTable(p, token);\n    }\n}\n\nfunction captionStartTagInTable(p, token) {\n    p.openElements.clearBackToTableContext();\n    p.activeFormattingElements.insertMarker();\n    p._insertElement(token, NS.HTML);\n    p.insertionMode = IN_CAPTION_MODE;\n}\n\nfunction colgroupStartTagInTable(p, token) {\n    p.openElements.clearBackToTableContext();\n    p._insertElement(token, NS.HTML);\n    p.insertionMode = IN_COLUMN_GROUP_MODE;\n}\n\nfunction colStartTagInTable(p, token) {\n    p.openElements.clearBackToTableContext();\n    p._insertFakeElement($.COLGROUP);\n    p.insertionMode = IN_COLUMN_GROUP_MODE;\n    p._processToken(token);\n}\n\nfunction tbodyStartTagInTable(p, token) {\n    p.openElements.clearBackToTableContext();\n    p._insertElement(token, NS.HTML);\n    p.insertionMode = IN_TABLE_BODY_MODE;\n}\n\nfunction tdStartTagInTable(p, token) {\n    p.openElements.clearBackToTableContext();\n    p._insertFakeElement($.TBODY);\n    p.insertionMode = IN_TABLE_BODY_MODE;\n    p._processToken(token);\n}\n\nfunction tableStartTagInTable(p, token) {\n    if (p.openElements.hasInTableScope($.TABLE)) {\n        p.openElements.popUntilTagNamePopped($.TABLE);\n        p._resetInsertionMode();\n        p._processToken(token);\n    }\n}\n\nfunction inputStartTagInTable(p, token) {\n    const inputType = Tokenizer.getTokenAttr(token, ATTRS.TYPE);\n\n    if (inputType && inputType.toLowerCase() === HIDDEN_INPUT_TYPE) {\n        p._appendElement(token, NS.HTML);\n    } else {\n        tokenInTable(p, token);\n    }\n\n    token.ackSelfClosing = true;\n}\n\nfunction formStartTagInTable(p, token) {\n    if (!p.formElement && p.openElements.tmplCount === 0) {\n        p._insertElement(token, NS.HTML);\n        p.formElement = p.openElements.current;\n        p.openElements.pop();\n    }\n}\n\nfunction startTagInTable(p, token) {\n    const tn = token.tagName;\n\n    switch (tn.length) {\n        case 2:\n            if (tn === $.TD || tn === $.TH || tn === $.TR) {\n                tdStartTagInTable(p, token);\n            } else {\n                tokenInTable(p, token);\n            }\n\n            break;\n\n        case 3:\n            if (tn === $.COL) {\n                colStartTagInTable(p, token);\n            } else {\n                tokenInTable(p, token);\n            }\n\n            break;\n\n        case 4:\n            if (tn === $.FORM) {\n                formStartTagInTable(p, token);\n            } else {\n                tokenInTable(p, token);\n            }\n\n            break;\n\n        case 5:\n            if (tn === $.TABLE) {\n                tableStartTagInTable(p, token);\n            } else if (tn === $.STYLE) {\n                startTagInHead(p, token);\n            } else if (tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {\n                tbodyStartTagInTable(p, token);\n            } else if (tn === $.INPUT) {\n                inputStartTagInTable(p, token);\n            } else {\n                tokenInTable(p, token);\n            }\n\n            break;\n\n        case 6:\n            if (tn === $.SCRIPT) {\n                startTagInHead(p, token);\n            } else {\n                tokenInTable(p, token);\n            }\n\n            break;\n\n        case 7:\n            if (tn === $.CAPTION) {\n                captionStartTagInTable(p, token);\n            } else {\n                tokenInTable(p, token);\n            }\n\n            break;\n\n        case 8:\n            if (tn === $.COLGROUP) {\n                colgroupStartTagInTable(p, token);\n            } else if (tn === $.TEMPLATE) {\n                startTagInHead(p, token);\n            } else {\n                tokenInTable(p, token);\n            }\n\n            break;\n\n        default:\n            tokenInTable(p, token);\n    }\n}\n\nfunction endTagInTable(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.TABLE) {\n        if (p.openElements.hasInTableScope($.TABLE)) {\n            p.openElements.popUntilTagNamePopped($.TABLE);\n            p._resetInsertionMode();\n        }\n    } else if (tn === $.TEMPLATE) {\n        endTagInHead(p, token);\n    } else if (\n        tn !== $.BODY &&\n        tn !== $.CAPTION &&\n        tn !== $.COL &&\n        tn !== $.COLGROUP &&\n        tn !== $.HTML &&\n        tn !== $.TBODY &&\n        tn !== $.TD &&\n        tn !== $.TFOOT &&\n        tn !== $.TH &&\n        tn !== $.THEAD &&\n        tn !== $.TR\n    ) {\n        tokenInTable(p, token);\n    }\n}\n\nfunction tokenInTable(p, token) {\n    const savedFosterParentingState = p.fosterParentingEnabled;\n\n    p.fosterParentingEnabled = true;\n    p._processTokenInBodyMode(token);\n    p.fosterParentingEnabled = savedFosterParentingState;\n}\n\n// The \"in table text\" insertion mode\n//------------------------------------------------------------------\nfunction whitespaceCharacterInTableText(p, token) {\n    p.pendingCharacterTokens.push(token);\n}\n\nfunction characterInTableText(p, token) {\n    p.pendingCharacterTokens.push(token);\n    p.hasNonWhitespacePendingCharacterToken = true;\n}\n\nfunction tokenInTableText(p, token) {\n    let i = 0;\n\n    if (p.hasNonWhitespacePendingCharacterToken) {\n        for (; i < p.pendingCharacterTokens.length; i++) {\n            tokenInTable(p, p.pendingCharacterTokens[i]);\n        }\n    } else {\n        for (; i < p.pendingCharacterTokens.length; i++) {\n            p._insertCharacters(p.pendingCharacterTokens[i]);\n        }\n    }\n\n    p.insertionMode = p.originalInsertionMode;\n    p._processToken(token);\n}\n\n// The \"in caption\" insertion mode\n//------------------------------------------------------------------\nfunction startTagInCaption(p, token) {\n    const tn = token.tagName;\n\n    if (\n        tn === $.CAPTION ||\n        tn === $.COL ||\n        tn === $.COLGROUP ||\n        tn === $.TBODY ||\n        tn === $.TD ||\n        tn === $.TFOOT ||\n        tn === $.TH ||\n        tn === $.THEAD ||\n        tn === $.TR\n    ) {\n        if (p.openElements.hasInTableScope($.CAPTION)) {\n            p.openElements.generateImpliedEndTags();\n            p.openElements.popUntilTagNamePopped($.CAPTION);\n            p.activeFormattingElements.clearToLastMarker();\n            p.insertionMode = IN_TABLE_MODE;\n            p._processToken(token);\n        }\n    } else {\n        startTagInBody(p, token);\n    }\n}\n\nfunction endTagInCaption(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.CAPTION || tn === $.TABLE) {\n        if (p.openElements.hasInTableScope($.CAPTION)) {\n            p.openElements.generateImpliedEndTags();\n            p.openElements.popUntilTagNamePopped($.CAPTION);\n            p.activeFormattingElements.clearToLastMarker();\n            p.insertionMode = IN_TABLE_MODE;\n\n            if (tn === $.TABLE) {\n                p._processToken(token);\n            }\n        }\n    } else if (\n        tn !== $.BODY &&\n        tn !== $.COL &&\n        tn !== $.COLGROUP &&\n        tn !== $.HTML &&\n        tn !== $.TBODY &&\n        tn !== $.TD &&\n        tn !== $.TFOOT &&\n        tn !== $.TH &&\n        tn !== $.THEAD &&\n        tn !== $.TR\n    ) {\n        endTagInBody(p, token);\n    }\n}\n\n// The \"in column group\" insertion mode\n//------------------------------------------------------------------\nfunction startTagInColumnGroup(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.HTML) {\n        startTagInBody(p, token);\n    } else if (tn === $.COL) {\n        p._appendElement(token, NS.HTML);\n        token.ackSelfClosing = true;\n    } else if (tn === $.TEMPLATE) {\n        startTagInHead(p, token);\n    } else {\n        tokenInColumnGroup(p, token);\n    }\n}\n\nfunction endTagInColumnGroup(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.COLGROUP) {\n        if (p.openElements.currentTagName === $.COLGROUP) {\n            p.openElements.pop();\n            p.insertionMode = IN_TABLE_MODE;\n        }\n    } else if (tn === $.TEMPLATE) {\n        endTagInHead(p, token);\n    } else if (tn !== $.COL) {\n        tokenInColumnGroup(p, token);\n    }\n}\n\nfunction tokenInColumnGroup(p, token) {\n    if (p.openElements.currentTagName === $.COLGROUP) {\n        p.openElements.pop();\n        p.insertionMode = IN_TABLE_MODE;\n        p._processToken(token);\n    }\n}\n\n// The \"in table body\" insertion mode\n//------------------------------------------------------------------\nfunction startTagInTableBody(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.TR) {\n        p.openElements.clearBackToTableBodyContext();\n        p._insertElement(token, NS.HTML);\n        p.insertionMode = IN_ROW_MODE;\n    } else if (tn === $.TH || tn === $.TD) {\n        p.openElements.clearBackToTableBodyContext();\n        p._insertFakeElement($.TR);\n        p.insertionMode = IN_ROW_MODE;\n        p._processToken(token);\n    } else if (\n        tn === $.CAPTION ||\n        tn === $.COL ||\n        tn === $.COLGROUP ||\n        tn === $.TBODY ||\n        tn === $.TFOOT ||\n        tn === $.THEAD\n    ) {\n        if (p.openElements.hasTableBodyContextInTableScope()) {\n            p.openElements.clearBackToTableBodyContext();\n            p.openElements.pop();\n            p.insertionMode = IN_TABLE_MODE;\n            p._processToken(token);\n        }\n    } else {\n        startTagInTable(p, token);\n    }\n}\n\nfunction endTagInTableBody(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {\n        if (p.openElements.hasInTableScope(tn)) {\n            p.openElements.clearBackToTableBodyContext();\n            p.openElements.pop();\n            p.insertionMode = IN_TABLE_MODE;\n        }\n    } else if (tn === $.TABLE) {\n        if (p.openElements.hasTableBodyContextInTableScope()) {\n            p.openElements.clearBackToTableBodyContext();\n            p.openElements.pop();\n            p.insertionMode = IN_TABLE_MODE;\n            p._processToken(token);\n        }\n    } else if (\n        (tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP) ||\n        (tn !== $.HTML && tn !== $.TD && tn !== $.TH && tn !== $.TR)\n    ) {\n        endTagInTable(p, token);\n    }\n}\n\n// The \"in row\" insertion mode\n//------------------------------------------------------------------\nfunction startTagInRow(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.TH || tn === $.TD) {\n        p.openElements.clearBackToTableRowContext();\n        p._insertElement(token, NS.HTML);\n        p.insertionMode = IN_CELL_MODE;\n        p.activeFormattingElements.insertMarker();\n    } else if (\n        tn === $.CAPTION ||\n        tn === $.COL ||\n        tn === $.COLGROUP ||\n        tn === $.TBODY ||\n        tn === $.TFOOT ||\n        tn === $.THEAD ||\n        tn === $.TR\n    ) {\n        if (p.openElements.hasInTableScope($.TR)) {\n            p.openElements.clearBackToTableRowContext();\n            p.openElements.pop();\n            p.insertionMode = IN_TABLE_BODY_MODE;\n            p._processToken(token);\n        }\n    } else {\n        startTagInTable(p, token);\n    }\n}\n\nfunction endTagInRow(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.TR) {\n        if (p.openElements.hasInTableScope($.TR)) {\n            p.openElements.clearBackToTableRowContext();\n            p.openElements.pop();\n            p.insertionMode = IN_TABLE_BODY_MODE;\n        }\n    } else if (tn === $.TABLE) {\n        if (p.openElements.hasInTableScope($.TR)) {\n            p.openElements.clearBackToTableRowContext();\n            p.openElements.pop();\n            p.insertionMode = IN_TABLE_BODY_MODE;\n            p._processToken(token);\n        }\n    } else if (tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {\n        if (p.openElements.hasInTableScope(tn) || p.openElements.hasInTableScope($.TR)) {\n            p.openElements.clearBackToTableRowContext();\n            p.openElements.pop();\n            p.insertionMode = IN_TABLE_BODY_MODE;\n            p._processToken(token);\n        }\n    } else if (\n        (tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP) ||\n        (tn !== $.HTML && tn !== $.TD && tn !== $.TH)\n    ) {\n        endTagInTable(p, token);\n    }\n}\n\n// The \"in cell\" insertion mode\n//------------------------------------------------------------------\nfunction startTagInCell(p, token) {\n    const tn = token.tagName;\n\n    if (\n        tn === $.CAPTION ||\n        tn === $.COL ||\n        tn === $.COLGROUP ||\n        tn === $.TBODY ||\n        tn === $.TD ||\n        tn === $.TFOOT ||\n        tn === $.TH ||\n        tn === $.THEAD ||\n        tn === $.TR\n    ) {\n        if (p.openElements.hasInTableScope($.TD) || p.openElements.hasInTableScope($.TH)) {\n            p._closeTableCell();\n            p._processToken(token);\n        }\n    } else {\n        startTagInBody(p, token);\n    }\n}\n\nfunction endTagInCell(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.TD || tn === $.TH) {\n        if (p.openElements.hasInTableScope(tn)) {\n            p.openElements.generateImpliedEndTags();\n            p.openElements.popUntilTagNamePopped(tn);\n            p.activeFormattingElements.clearToLastMarker();\n            p.insertionMode = IN_ROW_MODE;\n        }\n    } else if (tn === $.TABLE || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD || tn === $.TR) {\n        if (p.openElements.hasInTableScope(tn)) {\n            p._closeTableCell();\n            p._processToken(token);\n        }\n    } else if (tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP && tn !== $.HTML) {\n        endTagInBody(p, token);\n    }\n}\n\n// The \"in select\" insertion mode\n//------------------------------------------------------------------\nfunction startTagInSelect(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.HTML) {\n        startTagInBody(p, token);\n    } else if (tn === $.OPTION) {\n        if (p.openElements.currentTagName === $.OPTION) {\n            p.openElements.pop();\n        }\n\n        p._insertElement(token, NS.HTML);\n    } else if (tn === $.OPTGROUP) {\n        if (p.openElements.currentTagName === $.OPTION) {\n            p.openElements.pop();\n        }\n\n        if (p.openElements.currentTagName === $.OPTGROUP) {\n            p.openElements.pop();\n        }\n\n        p._insertElement(token, NS.HTML);\n    } else if (tn === $.INPUT || tn === $.KEYGEN || tn === $.TEXTAREA || tn === $.SELECT) {\n        if (p.openElements.hasInSelectScope($.SELECT)) {\n            p.openElements.popUntilTagNamePopped($.SELECT);\n            p._resetInsertionMode();\n\n            if (tn !== $.SELECT) {\n                p._processToken(token);\n            }\n        }\n    } else if (tn === $.SCRIPT || tn === $.TEMPLATE) {\n        startTagInHead(p, token);\n    }\n}\n\nfunction endTagInSelect(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.OPTGROUP) {\n        const prevOpenElement = p.openElements.items[p.openElements.stackTop - 1];\n        const prevOpenElementTn = prevOpenElement && p.treeAdapter.getTagName(prevOpenElement);\n\n        if (p.openElements.currentTagName === $.OPTION && prevOpenElementTn === $.OPTGROUP) {\n            p.openElements.pop();\n        }\n\n        if (p.openElements.currentTagName === $.OPTGROUP) {\n            p.openElements.pop();\n        }\n    } else if (tn === $.OPTION) {\n        if (p.openElements.currentTagName === $.OPTION) {\n            p.openElements.pop();\n        }\n    } else if (tn === $.SELECT && p.openElements.hasInSelectScope($.SELECT)) {\n        p.openElements.popUntilTagNamePopped($.SELECT);\n        p._resetInsertionMode();\n    } else if (tn === $.TEMPLATE) {\n        endTagInHead(p, token);\n    }\n}\n\n//12.2.5.4.17 The \"in select in table\" insertion mode\n//------------------------------------------------------------------\nfunction startTagInSelectInTable(p, token) {\n    const tn = token.tagName;\n\n    if (\n        tn === $.CAPTION ||\n        tn === $.TABLE ||\n        tn === $.TBODY ||\n        tn === $.TFOOT ||\n        tn === $.THEAD ||\n        tn === $.TR ||\n        tn === $.TD ||\n        tn === $.TH\n    ) {\n        p.openElements.popUntilTagNamePopped($.SELECT);\n        p._resetInsertionMode();\n        p._processToken(token);\n    } else {\n        startTagInSelect(p, token);\n    }\n}\n\nfunction endTagInSelectInTable(p, token) {\n    const tn = token.tagName;\n\n    if (\n        tn === $.CAPTION ||\n        tn === $.TABLE ||\n        tn === $.TBODY ||\n        tn === $.TFOOT ||\n        tn === $.THEAD ||\n        tn === $.TR ||\n        tn === $.TD ||\n        tn === $.TH\n    ) {\n        if (p.openElements.hasInTableScope(tn)) {\n            p.openElements.popUntilTagNamePopped($.SELECT);\n            p._resetInsertionMode();\n            p._processToken(token);\n        }\n    } else {\n        endTagInSelect(p, token);\n    }\n}\n\n// The \"in template\" insertion mode\n//------------------------------------------------------------------\nfunction startTagInTemplate(p, token) {\n    const tn = token.tagName;\n\n    if (\n        tn === $.BASE ||\n        tn === $.BASEFONT ||\n        tn === $.BGSOUND ||\n        tn === $.LINK ||\n        tn === $.META ||\n        tn === $.NOFRAMES ||\n        tn === $.SCRIPT ||\n        tn === $.STYLE ||\n        tn === $.TEMPLATE ||\n        tn === $.TITLE\n    ) {\n        startTagInHead(p, token);\n    } else {\n        const newInsertionMode = TEMPLATE_INSERTION_MODE_SWITCH_MAP[tn] || IN_BODY_MODE;\n\n        p._popTmplInsertionMode();\n        p._pushTmplInsertionMode(newInsertionMode);\n        p.insertionMode = newInsertionMode;\n        p._processToken(token);\n    }\n}\n\nfunction endTagInTemplate(p, token) {\n    if (token.tagName === $.TEMPLATE) {\n        endTagInHead(p, token);\n    }\n}\n\nfunction eofInTemplate(p, token) {\n    if (p.openElements.tmplCount > 0) {\n        p.openElements.popUntilTagNamePopped($.TEMPLATE);\n        p.activeFormattingElements.clearToLastMarker();\n        p._popTmplInsertionMode();\n        p._resetInsertionMode();\n        p._processToken(token);\n    } else {\n        p.stopped = true;\n    }\n}\n\n// The \"after body\" insertion mode\n//------------------------------------------------------------------\nfunction startTagAfterBody(p, token) {\n    if (token.tagName === $.HTML) {\n        startTagInBody(p, token);\n    } else {\n        tokenAfterBody(p, token);\n    }\n}\n\nfunction endTagAfterBody(p, token) {\n    if (token.tagName === $.HTML) {\n        if (!p.fragmentContext) {\n            p.insertionMode = AFTER_AFTER_BODY_MODE;\n        }\n    } else {\n        tokenAfterBody(p, token);\n    }\n}\n\nfunction tokenAfterBody(p, token) {\n    p.insertionMode = IN_BODY_MODE;\n    p._processToken(token);\n}\n\n// The \"in frameset\" insertion mode\n//------------------------------------------------------------------\nfunction startTagInFrameset(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.HTML) {\n        startTagInBody(p, token);\n    } else if (tn === $.FRAMESET) {\n        p._insertElement(token, NS.HTML);\n    } else if (tn === $.FRAME) {\n        p._appendElement(token, NS.HTML);\n        token.ackSelfClosing = true;\n    } else if (tn === $.NOFRAMES) {\n        startTagInHead(p, token);\n    }\n}\n\nfunction endTagInFrameset(p, token) {\n    if (token.tagName === $.FRAMESET && !p.openElements.isRootHtmlElementCurrent()) {\n        p.openElements.pop();\n\n        if (!p.fragmentContext && p.openElements.currentTagName !== $.FRAMESET) {\n            p.insertionMode = AFTER_FRAMESET_MODE;\n        }\n    }\n}\n\n// The \"after frameset\" insertion mode\n//------------------------------------------------------------------\nfunction startTagAfterFrameset(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.HTML) {\n        startTagInBody(p, token);\n    } else if (tn === $.NOFRAMES) {\n        startTagInHead(p, token);\n    }\n}\n\nfunction endTagAfterFrameset(p, token) {\n    if (token.tagName === $.HTML) {\n        p.insertionMode = AFTER_AFTER_FRAMESET_MODE;\n    }\n}\n\n// The \"after after body\" insertion mode\n//------------------------------------------------------------------\nfunction startTagAfterAfterBody(p, token) {\n    if (token.tagName === $.HTML) {\n        startTagInBody(p, token);\n    } else {\n        tokenAfterAfterBody(p, token);\n    }\n}\n\nfunction tokenAfterAfterBody(p, token) {\n    p.insertionMode = IN_BODY_MODE;\n    p._processToken(token);\n}\n\n// The \"after after frameset\" insertion mode\n//------------------------------------------------------------------\nfunction startTagAfterAfterFrameset(p, token) {\n    const tn = token.tagName;\n\n    if (tn === $.HTML) {\n        startTagInBody(p, token);\n    } else if (tn === $.NOFRAMES) {\n        startTagInHead(p, token);\n    }\n}\n\n// The rules for parsing tokens in foreign content\n//------------------------------------------------------------------\nfunction nullCharacterInForeignContent(p, token) {\n    token.chars = unicode.REPLACEMENT_CHARACTER;\n    p._insertCharacters(token);\n}\n\nfunction characterInForeignContent(p, token) {\n    p._insertCharacters(token);\n    p.framesetOk = false;\n}\n\nfunction startTagInForeignContent(p, token) {\n    if (foreignContent.causesExit(token) && !p.fragmentContext) {\n        while (\n            p.treeAdapter.getNamespaceURI(p.openElements.current) !== NS.HTML &&\n            !p._isIntegrationPoint(p.openElements.current)\n        ) {\n            p.openElements.pop();\n        }\n\n        p._processToken(token);\n    } else {\n        const current = p._getAdjustedCurrentElement();\n        const currentNs = p.treeAdapter.getNamespaceURI(current);\n\n        if (currentNs === NS.MATHML) {\n            foreignContent.adjustTokenMathMLAttrs(token);\n        } else if (currentNs === NS.SVG) {\n            foreignContent.adjustTokenSVGTagName(token);\n            foreignContent.adjustTokenSVGAttrs(token);\n        }\n\n        foreignContent.adjustTokenXMLAttrs(token);\n\n        if (token.selfClosing) {\n            p._appendElement(token, currentNs);\n        } else {\n            p._insertElement(token, currentNs);\n        }\n\n        token.ackSelfClosing = true;\n    }\n}\n\nfunction endTagInForeignContent(p, token) {\n    for (let i = p.openElements.stackTop; i > 0; i--) {\n        const element = p.openElements.items[i];\n\n        if (p.treeAdapter.getNamespaceURI(element) === NS.HTML) {\n            p._processToken(token);\n            break;\n        }\n\n        if (p.treeAdapter.getTagName(element).toLowerCase() === token.tagName) {\n            p.openElements.popUntilElementPopped(element);\n            break;\n        }\n    }\n}\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/parse5/lib/parser/index.js?");

/***/ }),

/***/ "./src/node_modules/parse5/lib/parser/open-element-stack.js":
/*!******************************************************************!*\
  !*** ./src/node_modules/parse5/lib/parser/open-element-stack.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst HTML = __webpack_require__(/*! ../common/html */ \"./src/node_modules/parse5/lib/common/html.js\");\n\n//Aliases\nconst $ = HTML.TAG_NAMES;\nconst NS = HTML.NAMESPACES;\n\n//Element utils\n\n//OPTIMIZATION: Integer comparisons are low-cost, so we can use very fast tag name length filters here.\n//It's faster than using dictionary.\nfunction isImpliedEndTagRequired(tn) {\n    switch (tn.length) {\n        case 1:\n            return tn === $.P;\n\n        case 2:\n            return tn === $.RB || tn === $.RP || tn === $.RT || tn === $.DD || tn === $.DT || tn === $.LI;\n\n        case 3:\n            return tn === $.RTC;\n\n        case 6:\n            return tn === $.OPTION;\n\n        case 8:\n            return tn === $.OPTGROUP;\n    }\n\n    return false;\n}\n\nfunction isImpliedEndTagRequiredThoroughly(tn) {\n    switch (tn.length) {\n        case 1:\n            return tn === $.P;\n\n        case 2:\n            return (\n                tn === $.RB ||\n                tn === $.RP ||\n                tn === $.RT ||\n                tn === $.DD ||\n                tn === $.DT ||\n                tn === $.LI ||\n                tn === $.TD ||\n                tn === $.TH ||\n                tn === $.TR\n            );\n\n        case 3:\n            return tn === $.RTC;\n\n        case 5:\n            return tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD;\n\n        case 6:\n            return tn === $.OPTION;\n\n        case 7:\n            return tn === $.CAPTION;\n\n        case 8:\n            return tn === $.OPTGROUP || tn === $.COLGROUP;\n    }\n\n    return false;\n}\n\nfunction isScopingElement(tn, ns) {\n    switch (tn.length) {\n        case 2:\n            if (tn === $.TD || tn === $.TH) {\n                return ns === NS.HTML;\n            } else if (tn === $.MI || tn === $.MO || tn === $.MN || tn === $.MS) {\n                return ns === NS.MATHML;\n            }\n\n            break;\n\n        case 4:\n            if (tn === $.HTML) {\n                return ns === NS.HTML;\n            } else if (tn === $.DESC) {\n                return ns === NS.SVG;\n            }\n\n            break;\n\n        case 5:\n            if (tn === $.TABLE) {\n                return ns === NS.HTML;\n            } else if (tn === $.MTEXT) {\n                return ns === NS.MATHML;\n            } else if (tn === $.TITLE) {\n                return ns === NS.SVG;\n            }\n\n            break;\n\n        case 6:\n            return (tn === $.APPLET || tn === $.OBJECT) && ns === NS.HTML;\n\n        case 7:\n            return (tn === $.CAPTION || tn === $.MARQUEE) && ns === NS.HTML;\n\n        case 8:\n            return tn === $.TEMPLATE && ns === NS.HTML;\n\n        case 13:\n            return tn === $.FOREIGN_OBJECT && ns === NS.SVG;\n\n        case 14:\n            return tn === $.ANNOTATION_XML && ns === NS.MATHML;\n    }\n\n    return false;\n}\n\n//Stack of open elements\nclass OpenElementStack {\n    constructor(document, treeAdapter) {\n        this.stackTop = -1;\n        this.items = [];\n        this.current = document;\n        this.currentTagName = null;\n        this.currentTmplContent = null;\n        this.tmplCount = 0;\n        this.treeAdapter = treeAdapter;\n    }\n\n    //Index of element\n    _indexOf(element) {\n        let idx = -1;\n\n        for (let i = this.stackTop; i >= 0; i--) {\n            if (this.items[i] === element) {\n                idx = i;\n                break;\n            }\n        }\n        return idx;\n    }\n\n    //Update current element\n    _isInTemplate() {\n        return this.currentTagName === $.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === NS.HTML;\n    }\n\n    _updateCurrentElement() {\n        this.current = this.items[this.stackTop];\n        this.currentTagName = this.current && this.treeAdapter.getTagName(this.current);\n\n        this.currentTmplContent = this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : null;\n    }\n\n    //Mutations\n    push(element) {\n        this.items[++this.stackTop] = element;\n        this._updateCurrentElement();\n\n        if (this._isInTemplate()) {\n            this.tmplCount++;\n        }\n    }\n\n    pop() {\n        this.stackTop--;\n\n        if (this.tmplCount > 0 && this._isInTemplate()) {\n            this.tmplCount--;\n        }\n\n        this._updateCurrentElement();\n    }\n\n    replace(oldElement, newElement) {\n        const idx = this._indexOf(oldElement);\n\n        this.items[idx] = newElement;\n\n        if (idx === this.stackTop) {\n            this._updateCurrentElement();\n        }\n    }\n\n    insertAfter(referenceElement, newElement) {\n        const insertionIdx = this._indexOf(referenceElement) + 1;\n\n        this.items.splice(insertionIdx, 0, newElement);\n\n        if (insertionIdx === ++this.stackTop) {\n            this._updateCurrentElement();\n        }\n    }\n\n    popUntilTagNamePopped(tagName) {\n        while (this.stackTop > -1) {\n            const tn = this.currentTagName;\n            const ns = this.treeAdapter.getNamespaceURI(this.current);\n\n            this.pop();\n\n            if (tn === tagName && ns === NS.HTML) {\n                break;\n            }\n        }\n    }\n\n    popUntilElementPopped(element) {\n        while (this.stackTop > -1) {\n            const poppedElement = this.current;\n\n            this.pop();\n\n            if (poppedElement === element) {\n                break;\n            }\n        }\n    }\n\n    popUntilNumberedHeaderPopped() {\n        while (this.stackTop > -1) {\n            const tn = this.currentTagName;\n            const ns = this.treeAdapter.getNamespaceURI(this.current);\n\n            this.pop();\n\n            if (\n                tn === $.H1 ||\n                tn === $.H2 ||\n                tn === $.H3 ||\n                tn === $.H4 ||\n                tn === $.H5 ||\n                (tn === $.H6 && ns === NS.HTML)\n            ) {\n                break;\n            }\n        }\n    }\n\n    popUntilTableCellPopped() {\n        while (this.stackTop > -1) {\n            const tn = this.currentTagName;\n            const ns = this.treeAdapter.getNamespaceURI(this.current);\n\n            this.pop();\n\n            if (tn === $.TD || (tn === $.TH && ns === NS.HTML)) {\n                break;\n            }\n        }\n    }\n\n    popAllUpToHtmlElement() {\n        //NOTE: here we assume that root <html> element is always first in the open element stack, so\n        //we perform this fast stack clean up.\n        this.stackTop = 0;\n        this._updateCurrentElement();\n    }\n\n    clearBackToTableContext() {\n        while (\n            (this.currentTagName !== $.TABLE && this.currentTagName !== $.TEMPLATE && this.currentTagName !== $.HTML) ||\n            this.treeAdapter.getNamespaceURI(this.current) !== NS.HTML\n        ) {\n            this.pop();\n        }\n    }\n\n    clearBackToTableBodyContext() {\n        while (\n            (this.currentTagName !== $.TBODY &&\n                this.currentTagName !== $.TFOOT &&\n                this.currentTagName !== $.THEAD &&\n                this.currentTagName !== $.TEMPLATE &&\n                this.currentTagName !== $.HTML) ||\n            this.treeAdapter.getNamespaceURI(this.current) !== NS.HTML\n        ) {\n            this.pop();\n        }\n    }\n\n    clearBackToTableRowContext() {\n        while (\n            (this.currentTagName !== $.TR && this.currentTagName !== $.TEMPLATE && this.currentTagName !== $.HTML) ||\n            this.treeAdapter.getNamespaceURI(this.current) !== NS.HTML\n        ) {\n            this.pop();\n        }\n    }\n\n    remove(element) {\n        for (let i = this.stackTop; i >= 0; i--) {\n            if (this.items[i] === element) {\n                this.items.splice(i, 1);\n                this.stackTop--;\n                this._updateCurrentElement();\n                break;\n            }\n        }\n    }\n\n    //Search\n    tryPeekProperlyNestedBodyElement() {\n        //Properly nested <body> element (should be second element in stack).\n        const element = this.items[1];\n\n        return element && this.treeAdapter.getTagName(element) === $.BODY ? element : null;\n    }\n\n    contains(element) {\n        return this._indexOf(element) > -1;\n    }\n\n    getCommonAncestor(element) {\n        let elementIdx = this._indexOf(element);\n\n        return --elementIdx >= 0 ? this.items[elementIdx] : null;\n    }\n\n    isRootHtmlElementCurrent() {\n        return this.stackTop === 0 && this.currentTagName === $.HTML;\n    }\n\n    //Element in scope\n    hasInScope(tagName) {\n        for (let i = this.stackTop; i >= 0; i--) {\n            const tn = this.treeAdapter.getTagName(this.items[i]);\n            const ns = this.treeAdapter.getNamespaceURI(this.items[i]);\n\n            if (tn === tagName && ns === NS.HTML) {\n                return true;\n            }\n\n            if (isScopingElement(tn, ns)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    hasNumberedHeaderInScope() {\n        for (let i = this.stackTop; i >= 0; i--) {\n            const tn = this.treeAdapter.getTagName(this.items[i]);\n            const ns = this.treeAdapter.getNamespaceURI(this.items[i]);\n\n            if (\n                (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6) &&\n                ns === NS.HTML\n            ) {\n                return true;\n            }\n\n            if (isScopingElement(tn, ns)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    hasInListItemScope(tagName) {\n        for (let i = this.stackTop; i >= 0; i--) {\n            const tn = this.treeAdapter.getTagName(this.items[i]);\n            const ns = this.treeAdapter.getNamespaceURI(this.items[i]);\n\n            if (tn === tagName && ns === NS.HTML) {\n                return true;\n            }\n\n            if (((tn === $.UL || tn === $.OL) && ns === NS.HTML) || isScopingElement(tn, ns)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    hasInButtonScope(tagName) {\n        for (let i = this.stackTop; i >= 0; i--) {\n            const tn = this.treeAdapter.getTagName(this.items[i]);\n            const ns = this.treeAdapter.getNamespaceURI(this.items[i]);\n\n            if (tn === tagName && ns === NS.HTML) {\n                return true;\n            }\n\n            if ((tn === $.BUTTON && ns === NS.HTML) || isScopingElement(tn, ns)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    hasInTableScope(tagName) {\n        for (let i = this.stackTop; i >= 0; i--) {\n            const tn = this.treeAdapter.getTagName(this.items[i]);\n            const ns = this.treeAdapter.getNamespaceURI(this.items[i]);\n\n            if (ns !== NS.HTML) {\n                continue;\n            }\n\n            if (tn === tagName) {\n                return true;\n            }\n\n            if (tn === $.TABLE || tn === $.TEMPLATE || tn === $.HTML) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    hasTableBodyContextInTableScope() {\n        for (let i = this.stackTop; i >= 0; i--) {\n            const tn = this.treeAdapter.getTagName(this.items[i]);\n            const ns = this.treeAdapter.getNamespaceURI(this.items[i]);\n\n            if (ns !== NS.HTML) {\n                continue;\n            }\n\n            if (tn === $.TBODY || tn === $.THEAD || tn === $.TFOOT) {\n                return true;\n            }\n\n            if (tn === $.TABLE || tn === $.HTML) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    hasInSelectScope(tagName) {\n        for (let i = this.stackTop; i >= 0; i--) {\n            const tn = this.treeAdapter.getTagName(this.items[i]);\n            const ns = this.treeAdapter.getNamespaceURI(this.items[i]);\n\n            if (ns !== NS.HTML) {\n                continue;\n            }\n\n            if (tn === tagName) {\n                return true;\n            }\n\n            if (tn !== $.OPTION && tn !== $.OPTGROUP) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    //Implied end tags\n    generateImpliedEndTags() {\n        while (isImpliedEndTagRequired(this.currentTagName)) {\n            this.pop();\n        }\n    }\n\n    generateImpliedEndTagsThoroughly() {\n        while (isImpliedEndTagRequiredThoroughly(this.currentTagName)) {\n            this.pop();\n        }\n    }\n\n    generateImpliedEndTagsWithExclusion(exclusionTagName) {\n        while (isImpliedEndTagRequired(this.currentTagName) && this.currentTagName !== exclusionTagName) {\n            this.pop();\n        }\n    }\n}\n\nmodule.exports = OpenElementStack;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/parse5/lib/parser/open-element-stack.js?");

/***/ }),

/***/ "./src/node_modules/parse5/lib/serializer/index.js":
/*!*********************************************************!*\
  !*** ./src/node_modules/parse5/lib/serializer/index.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst defaultTreeAdapter = __webpack_require__(/*! ../tree-adapters/default */ \"./src/node_modules/parse5/lib/tree-adapters/default.js\");\nconst mergeOptions = __webpack_require__(/*! ../utils/merge-options */ \"./src/node_modules/parse5/lib/utils/merge-options.js\");\nconst doctype = __webpack_require__(/*! ../common/doctype */ \"./src/node_modules/parse5/lib/common/doctype.js\");\nconst HTML = __webpack_require__(/*! ../common/html */ \"./src/node_modules/parse5/lib/common/html.js\");\n\n//Aliases\nconst $ = HTML.TAG_NAMES;\nconst NS = HTML.NAMESPACES;\n\n//Default serializer options\nconst DEFAULT_OPTIONS = {\n    treeAdapter: defaultTreeAdapter\n};\n\n//Escaping regexes\nconst AMP_REGEX = /&/g;\nconst NBSP_REGEX = /\\u00a0/g;\nconst DOUBLE_QUOTE_REGEX = /\"/g;\nconst LT_REGEX = /</g;\nconst GT_REGEX = />/g;\n\n//Serializer\nclass Serializer {\n    constructor(node, options) {\n        this.options = mergeOptions(DEFAULT_OPTIONS, options);\n        this.treeAdapter = this.options.treeAdapter;\n\n        this.html = '';\n        this.startNode = node;\n    }\n\n    //API\n    serialize() {\n        this._serializeChildNodes(this.startNode);\n\n        return this.html;\n    }\n\n    //Internals\n    _serializeChildNodes(parentNode) {\n        const childNodes = this.treeAdapter.getChildNodes(parentNode);\n\n        if (childNodes) {\n            for (let i = 0, cnLength = childNodes.length; i < cnLength; i++) {\n                const currentNode = childNodes[i];\n\n                if (this.treeAdapter.isElementNode(currentNode)) {\n                    this._serializeElement(currentNode);\n                } else if (this.treeAdapter.isTextNode(currentNode)) {\n                    this._serializeTextNode(currentNode);\n                } else if (this.treeAdapter.isCommentNode(currentNode)) {\n                    this._serializeCommentNode(currentNode);\n                } else if (this.treeAdapter.isDocumentTypeNode(currentNode)) {\n                    this._serializeDocumentTypeNode(currentNode);\n                }\n            }\n        }\n    }\n\n    _serializeElement(node) {\n        const tn = this.treeAdapter.getTagName(node);\n        const ns = this.treeAdapter.getNamespaceURI(node);\n\n        this.html += '<' + tn;\n        this._serializeAttributes(node);\n        this.html += '>';\n\n        if (\n            tn !== $.AREA &&\n            tn !== $.BASE &&\n            tn !== $.BASEFONT &&\n            tn !== $.BGSOUND &&\n            tn !== $.BR &&\n            tn !== $.COL &&\n            tn !== $.EMBED &&\n            tn !== $.FRAME &&\n            tn !== $.HR &&\n            tn !== $.IMG &&\n            tn !== $.INPUT &&\n            tn !== $.KEYGEN &&\n            tn !== $.LINK &&\n            tn !== $.META &&\n            tn !== $.PARAM &&\n            tn !== $.SOURCE &&\n            tn !== $.TRACK &&\n            tn !== $.WBR\n        ) {\n            const childNodesHolder =\n                tn === $.TEMPLATE && ns === NS.HTML ? this.treeAdapter.getTemplateContent(node) : node;\n\n            this._serializeChildNodes(childNodesHolder);\n            this.html += '</' + tn + '>';\n        }\n    }\n\n    _serializeAttributes(node) {\n        const attrs = this.treeAdapter.getAttrList(node);\n\n        for (let i = 0, attrsLength = attrs.length; i < attrsLength; i++) {\n            const attr = attrs[i];\n            const value = Serializer.escapeString(attr.value, true);\n\n            this.html += ' ';\n\n            if (!attr.namespace) {\n                this.html += attr.name;\n            } else if (attr.namespace === NS.XML) {\n                this.html += 'xml:' + attr.name;\n            } else if (attr.namespace === NS.XMLNS) {\n                if (attr.name !== 'xmlns') {\n                    this.html += 'xmlns:';\n                }\n\n                this.html += attr.name;\n            } else if (attr.namespace === NS.XLINK) {\n                this.html += 'xlink:' + attr.name;\n            } else {\n                this.html += attr.prefix + ':' + attr.name;\n            }\n\n            this.html += '=\"' + value + '\"';\n        }\n    }\n\n    _serializeTextNode(node) {\n        const content = this.treeAdapter.getTextNodeContent(node);\n        const parent = this.treeAdapter.getParentNode(node);\n        let parentTn = void 0;\n\n        if (parent && this.treeAdapter.isElementNode(parent)) {\n            parentTn = this.treeAdapter.getTagName(parent);\n        }\n\n        if (\n            parentTn === $.STYLE ||\n            parentTn === $.SCRIPT ||\n            parentTn === $.XMP ||\n            parentTn === $.IFRAME ||\n            parentTn === $.NOEMBED ||\n            parentTn === $.NOFRAMES ||\n            parentTn === $.PLAINTEXT ||\n            parentTn === $.NOSCRIPT\n        ) {\n            this.html += content;\n        } else {\n            this.html += Serializer.escapeString(content, false);\n        }\n    }\n\n    _serializeCommentNode(node) {\n        this.html += '<!--' + this.treeAdapter.getCommentNodeContent(node) + '-->';\n    }\n\n    _serializeDocumentTypeNode(node) {\n        const name = this.treeAdapter.getDocumentTypeNodeName(node);\n\n        this.html += '<' + doctype.serializeContent(name, null, null) + '>';\n    }\n}\n\n// NOTE: used in tests and by rewriting stream\nSerializer.escapeString = function(str, attrMode) {\n    str = str.replace(AMP_REGEX, '&amp;').replace(NBSP_REGEX, '&nbsp;');\n\n    if (attrMode) {\n        str = str.replace(DOUBLE_QUOTE_REGEX, '&quot;');\n    } else {\n        str = str.replace(LT_REGEX, '&lt;').replace(GT_REGEX, '&gt;');\n    }\n\n    return str;\n};\n\nmodule.exports = Serializer;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/parse5/lib/serializer/index.js?");

/***/ }),

/***/ "./src/node_modules/parse5/lib/tokenizer/index.js":
/*!********************************************************!*\
  !*** ./src/node_modules/parse5/lib/tokenizer/index.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Preprocessor = __webpack_require__(/*! ./preprocessor */ \"./src/node_modules/parse5/lib/tokenizer/preprocessor.js\");\nconst unicode = __webpack_require__(/*! ../common/unicode */ \"./src/node_modules/parse5/lib/common/unicode.js\");\nconst neTree = __webpack_require__(/*! ./named-entity-data */ \"./src/node_modules/parse5/lib/tokenizer/named-entity-data.js\");\nconst ERR = __webpack_require__(/*! ../common/error-codes */ \"./src/node_modules/parse5/lib/common/error-codes.js\");\n\n//Aliases\nconst $ = unicode.CODE_POINTS;\nconst $$ = unicode.CODE_POINT_SEQUENCES;\n\n//C1 Unicode control character reference replacements\nconst C1_CONTROLS_REFERENCE_REPLACEMENTS = {\n    0x80: 0x20ac,\n    0x82: 0x201a,\n    0x83: 0x0192,\n    0x84: 0x201e,\n    0x85: 0x2026,\n    0x86: 0x2020,\n    0x87: 0x2021,\n    0x88: 0x02c6,\n    0x89: 0x2030,\n    0x8a: 0x0160,\n    0x8b: 0x2039,\n    0x8c: 0x0152,\n    0x8e: 0x017d,\n    0x91: 0x2018,\n    0x92: 0x2019,\n    0x93: 0x201c,\n    0x94: 0x201d,\n    0x95: 0x2022,\n    0x96: 0x2013,\n    0x97: 0x2014,\n    0x98: 0x02dc,\n    0x99: 0x2122,\n    0x9a: 0x0161,\n    0x9b: 0x203a,\n    0x9c: 0x0153,\n    0x9e: 0x017e,\n    0x9f: 0x0178\n};\n\n// Named entity tree flags\nconst HAS_DATA_FLAG = 1 << 0;\nconst DATA_DUPLET_FLAG = 1 << 1;\nconst HAS_BRANCHES_FLAG = 1 << 2;\nconst MAX_BRANCH_MARKER_VALUE = HAS_DATA_FLAG | DATA_DUPLET_FLAG | HAS_BRANCHES_FLAG;\n\n//States\nconst DATA_STATE = 'DATA_STATE';\nconst RCDATA_STATE = 'RCDATA_STATE';\nconst RAWTEXT_STATE = 'RAWTEXT_STATE';\nconst SCRIPT_DATA_STATE = 'SCRIPT_DATA_STATE';\nconst PLAINTEXT_STATE = 'PLAINTEXT_STATE';\nconst TAG_OPEN_STATE = 'TAG_OPEN_STATE';\nconst END_TAG_OPEN_STATE = 'END_TAG_OPEN_STATE';\nconst TAG_NAME_STATE = 'TAG_NAME_STATE';\nconst RCDATA_LESS_THAN_SIGN_STATE = 'RCDATA_LESS_THAN_SIGN_STATE';\nconst RCDATA_END_TAG_OPEN_STATE = 'RCDATA_END_TAG_OPEN_STATE';\nconst RCDATA_END_TAG_NAME_STATE = 'RCDATA_END_TAG_NAME_STATE';\nconst RAWTEXT_LESS_THAN_SIGN_STATE = 'RAWTEXT_LESS_THAN_SIGN_STATE';\nconst RAWTEXT_END_TAG_OPEN_STATE = 'RAWTEXT_END_TAG_OPEN_STATE';\nconst RAWTEXT_END_TAG_NAME_STATE = 'RAWTEXT_END_TAG_NAME_STATE';\nconst SCRIPT_DATA_LESS_THAN_SIGN_STATE = 'SCRIPT_DATA_LESS_THAN_SIGN_STATE';\nconst SCRIPT_DATA_END_TAG_OPEN_STATE = 'SCRIPT_DATA_END_TAG_OPEN_STATE';\nconst SCRIPT_DATA_END_TAG_NAME_STATE = 'SCRIPT_DATA_END_TAG_NAME_STATE';\nconst SCRIPT_DATA_ESCAPE_START_STATE = 'SCRIPT_DATA_ESCAPE_START_STATE';\nconst SCRIPT_DATA_ESCAPE_START_DASH_STATE = 'SCRIPT_DATA_ESCAPE_START_DASH_STATE';\nconst SCRIPT_DATA_ESCAPED_STATE = 'SCRIPT_DATA_ESCAPED_STATE';\nconst SCRIPT_DATA_ESCAPED_DASH_STATE = 'SCRIPT_DATA_ESCAPED_DASH_STATE';\nconst SCRIPT_DATA_ESCAPED_DASH_DASH_STATE = 'SCRIPT_DATA_ESCAPED_DASH_DASH_STATE';\nconst SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE = 'SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE';\nconst SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE = 'SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE';\nconst SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE = 'SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE';\nconst SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE';\nconst SCRIPT_DATA_DOUBLE_ESCAPED_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPED_STATE';\nconst SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE';\nconst SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE';\nconst SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE';\nconst SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE';\nconst BEFORE_ATTRIBUTE_NAME_STATE = 'BEFORE_ATTRIBUTE_NAME_STATE';\nconst ATTRIBUTE_NAME_STATE = 'ATTRIBUTE_NAME_STATE';\nconst AFTER_ATTRIBUTE_NAME_STATE = 'AFTER_ATTRIBUTE_NAME_STATE';\nconst BEFORE_ATTRIBUTE_VALUE_STATE = 'BEFORE_ATTRIBUTE_VALUE_STATE';\nconst ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE = 'ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE';\nconst ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE = 'ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE';\nconst ATTRIBUTE_VALUE_UNQUOTED_STATE = 'ATTRIBUTE_VALUE_UNQUOTED_STATE';\nconst AFTER_ATTRIBUTE_VALUE_QUOTED_STATE = 'AFTER_ATTRIBUTE_VALUE_QUOTED_STATE';\nconst SELF_CLOSING_START_TAG_STATE = 'SELF_CLOSING_START_TAG_STATE';\nconst BOGUS_COMMENT_STATE = 'BOGUS_COMMENT_STATE';\nconst MARKUP_DECLARATION_OPEN_STATE = 'MARKUP_DECLARATION_OPEN_STATE';\nconst COMMENT_START_STATE = 'COMMENT_START_STATE';\nconst COMMENT_START_DASH_STATE = 'COMMENT_START_DASH_STATE';\nconst COMMENT_STATE = 'COMMENT_STATE';\nconst COMMENT_LESS_THAN_SIGN_STATE = 'COMMENT_LESS_THAN_SIGN_STATE';\nconst COMMENT_LESS_THAN_SIGN_BANG_STATE = 'COMMENT_LESS_THAN_SIGN_BANG_STATE';\nconst COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE = 'COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE';\nconst COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE = 'COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE';\nconst COMMENT_END_DASH_STATE = 'COMMENT_END_DASH_STATE';\nconst COMMENT_END_STATE = 'COMMENT_END_STATE';\nconst COMMENT_END_BANG_STATE = 'COMMENT_END_BANG_STATE';\nconst DOCTYPE_STATE = 'DOCTYPE_STATE';\nconst BEFORE_DOCTYPE_NAME_STATE = 'BEFORE_DOCTYPE_NAME_STATE';\nconst DOCTYPE_NAME_STATE = 'DOCTYPE_NAME_STATE';\nconst AFTER_DOCTYPE_NAME_STATE = 'AFTER_DOCTYPE_NAME_STATE';\nconst AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE = 'AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE';\nconst BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE = 'BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE';\nconst DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE = 'DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE';\nconst DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE = 'DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE';\nconst AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE = 'AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE';\nconst BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE = 'BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE';\nconst AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE = 'AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE';\nconst BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE = 'BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE';\nconst DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE = 'DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE';\nconst DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE = 'DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE';\nconst AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE = 'AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE';\nconst BOGUS_DOCTYPE_STATE = 'BOGUS_DOCTYPE_STATE';\nconst CDATA_SECTION_STATE = 'CDATA_SECTION_STATE';\nconst CDATA_SECTION_BRACKET_STATE = 'CDATA_SECTION_BRACKET_STATE';\nconst CDATA_SECTION_END_STATE = 'CDATA_SECTION_END_STATE';\nconst CHARACTER_REFERENCE_STATE = 'CHARACTER_REFERENCE_STATE';\nconst NAMED_CHARACTER_REFERENCE_STATE = 'NAMED_CHARACTER_REFERENCE_STATE';\nconst AMBIGUOUS_AMPERSAND_STATE = 'AMBIGUOS_AMPERSAND_STATE';\nconst NUMERIC_CHARACTER_REFERENCE_STATE = 'NUMERIC_CHARACTER_REFERENCE_STATE';\nconst HEXADEMICAL_CHARACTER_REFERENCE_START_STATE = 'HEXADEMICAL_CHARACTER_REFERENCE_START_STATE';\nconst DECIMAL_CHARACTER_REFERENCE_START_STATE = 'DECIMAL_CHARACTER_REFERENCE_START_STATE';\nconst HEXADEMICAL_CHARACTER_REFERENCE_STATE = 'HEXADEMICAL_CHARACTER_REFERENCE_STATE';\nconst DECIMAL_CHARACTER_REFERENCE_STATE = 'DECIMAL_CHARACTER_REFERENCE_STATE';\nconst NUMERIC_CHARACTER_REFERENCE_END_STATE = 'NUMERIC_CHARACTER_REFERENCE_END_STATE';\n\n//Utils\n\n//OPTIMIZATION: these utility functions should not be moved out of this module. V8 Crankshaft will not inline\n//this functions if they will be situated in another module due to context switch.\n//Always perform inlining check before modifying this functions ('node --trace-inlining').\nfunction isWhitespace(cp) {\n    return cp === $.SPACE || cp === $.LINE_FEED || cp === $.TABULATION || cp === $.FORM_FEED;\n}\n\nfunction isAsciiDigit(cp) {\n    return cp >= $.DIGIT_0 && cp <= $.DIGIT_9;\n}\n\nfunction isAsciiUpper(cp) {\n    return cp >= $.LATIN_CAPITAL_A && cp <= $.LATIN_CAPITAL_Z;\n}\n\nfunction isAsciiLower(cp) {\n    return cp >= $.LATIN_SMALL_A && cp <= $.LATIN_SMALL_Z;\n}\n\nfunction isAsciiLetter(cp) {\n    return isAsciiLower(cp) || isAsciiUpper(cp);\n}\n\nfunction isAsciiAlphaNumeric(cp) {\n    return isAsciiLetter(cp) || isAsciiDigit(cp);\n}\n\nfunction isAsciiUpperHexDigit(cp) {\n    return cp >= $.LATIN_CAPITAL_A && cp <= $.LATIN_CAPITAL_F;\n}\n\nfunction isAsciiLowerHexDigit(cp) {\n    return cp >= $.LATIN_SMALL_A && cp <= $.LATIN_SMALL_F;\n}\n\nfunction isAsciiHexDigit(cp) {\n    return isAsciiDigit(cp) || isAsciiUpperHexDigit(cp) || isAsciiLowerHexDigit(cp);\n}\n\nfunction toAsciiLowerCodePoint(cp) {\n    return cp + 0x0020;\n}\n\n//NOTE: String.fromCharCode() function can handle only characters from BMP subset.\n//So, we need to workaround this manually.\n//(see: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/fromCharCode#Getting_it_to_work_with_higher_values)\nfunction toChar(cp) {\n    if (cp <= 0xffff) {\n        return String.fromCharCode(cp);\n    }\n\n    cp -= 0x10000;\n    return String.fromCharCode(((cp >>> 10) & 0x3ff) | 0xd800) + String.fromCharCode(0xdc00 | (cp & 0x3ff));\n}\n\nfunction toAsciiLowerChar(cp) {\n    return String.fromCharCode(toAsciiLowerCodePoint(cp));\n}\n\nfunction findNamedEntityTreeBranch(nodeIx, cp) {\n    const branchCount = neTree[++nodeIx];\n    let lo = ++nodeIx;\n    let hi = lo + branchCount - 1;\n\n    while (lo <= hi) {\n        const mid = (lo + hi) >>> 1;\n        const midCp = neTree[mid];\n\n        if (midCp < cp) {\n            lo = mid + 1;\n        } else if (midCp > cp) {\n            hi = mid - 1;\n        } else {\n            return neTree[mid + branchCount];\n        }\n    }\n\n    return -1;\n}\n\n//Tokenizer\nclass Tokenizer {\n    constructor() {\n        this.preprocessor = new Preprocessor();\n\n        this.tokenQueue = [];\n\n        this.allowCDATA = false;\n\n        this.state = DATA_STATE;\n        this.returnState = '';\n\n        this.charRefCode = -1;\n        this.tempBuff = [];\n        this.lastStartTagName = '';\n\n        this.consumedAfterSnapshot = -1;\n        this.active = false;\n\n        this.currentCharacterToken = null;\n        this.currentToken = null;\n        this.currentAttr = null;\n    }\n\n    //Errors\n    _err() {\n        // NOTE: err reporting is noop by default. Enabled by mixin.\n    }\n\n    _errOnNextCodePoint(err) {\n        this._consume();\n        this._err(err);\n        this._unconsume();\n    }\n\n    //API\n    getNextToken() {\n        while (!this.tokenQueue.length && this.active) {\n            this.consumedAfterSnapshot = 0;\n\n            const cp = this._consume();\n\n            if (!this._ensureHibernation()) {\n                this[this.state](cp);\n            }\n        }\n\n        return this.tokenQueue.shift();\n    }\n\n    write(chunk, isLastChunk) {\n        this.active = true;\n        this.preprocessor.write(chunk, isLastChunk);\n    }\n\n    insertHtmlAtCurrentPos(chunk) {\n        this.active = true;\n        this.preprocessor.insertHtmlAtCurrentPos(chunk);\n    }\n\n    //Hibernation\n    _ensureHibernation() {\n        if (this.preprocessor.endOfChunkHit) {\n            for (; this.consumedAfterSnapshot > 0; this.consumedAfterSnapshot--) {\n                this.preprocessor.retreat();\n            }\n\n            this.active = false;\n            this.tokenQueue.push({ type: Tokenizer.HIBERNATION_TOKEN });\n\n            return true;\n        }\n\n        return false;\n    }\n\n    //Consumption\n    _consume() {\n        this.consumedAfterSnapshot++;\n        return this.preprocessor.advance();\n    }\n\n    _unconsume() {\n        this.consumedAfterSnapshot--;\n        this.preprocessor.retreat();\n    }\n\n    _reconsumeInState(state) {\n        this.state = state;\n        this._unconsume();\n    }\n\n    _consumeSequenceIfMatch(pattern, startCp, caseSensitive) {\n        let consumedCount = 0;\n        let isMatch = true;\n        const patternLength = pattern.length;\n        let patternPos = 0;\n        let cp = startCp;\n        let patternCp = void 0;\n\n        for (; patternPos < patternLength; patternPos++) {\n            if (patternPos > 0) {\n                cp = this._consume();\n                consumedCount++;\n            }\n\n            if (cp === $.EOF) {\n                isMatch = false;\n                break;\n            }\n\n            patternCp = pattern[patternPos];\n\n            if (cp !== patternCp && (caseSensitive || cp !== toAsciiLowerCodePoint(patternCp))) {\n                isMatch = false;\n                break;\n            }\n        }\n\n        if (!isMatch) {\n            while (consumedCount--) {\n                this._unconsume();\n            }\n        }\n\n        return isMatch;\n    }\n\n    //Temp buffer\n    _isTempBufferEqualToScriptString() {\n        if (this.tempBuff.length !== $$.SCRIPT_STRING.length) {\n            return false;\n        }\n\n        for (let i = 0; i < this.tempBuff.length; i++) {\n            if (this.tempBuff[i] !== $$.SCRIPT_STRING[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    //Token creation\n    _createStartTagToken() {\n        this.currentToken = {\n            type: Tokenizer.START_TAG_TOKEN,\n            tagName: '',\n            selfClosing: false,\n            ackSelfClosing: false,\n            attrs: []\n        };\n    }\n\n    _createEndTagToken() {\n        this.currentToken = {\n            type: Tokenizer.END_TAG_TOKEN,\n            tagName: '',\n            selfClosing: false,\n            attrs: []\n        };\n    }\n\n    _createCommentToken() {\n        this.currentToken = {\n            type: Tokenizer.COMMENT_TOKEN,\n            data: ''\n        };\n    }\n\n    _createDoctypeToken(initialName) {\n        this.currentToken = {\n            type: Tokenizer.DOCTYPE_TOKEN,\n            name: initialName,\n            forceQuirks: false,\n            publicId: null,\n            systemId: null\n        };\n    }\n\n    _createCharacterToken(type, ch) {\n        this.currentCharacterToken = {\n            type: type,\n            chars: ch\n        };\n    }\n\n    _createEOFToken() {\n        this.currentToken = { type: Tokenizer.EOF_TOKEN };\n    }\n\n    //Tag attributes\n    _createAttr(attrNameFirstCh) {\n        this.currentAttr = {\n            name: attrNameFirstCh,\n            value: ''\n        };\n    }\n\n    _leaveAttrName(toState) {\n        if (Tokenizer.getTokenAttr(this.currentToken, this.currentAttr.name) === null) {\n            this.currentToken.attrs.push(this.currentAttr);\n        } else {\n            this._err(ERR.duplicateAttribute);\n        }\n\n        this.state = toState;\n    }\n\n    _leaveAttrValue(toState) {\n        this.state = toState;\n    }\n\n    //Token emission\n    _emitCurrentToken() {\n        this._emitCurrentCharacterToken();\n\n        const ct = this.currentToken;\n\n        this.currentToken = null;\n\n        //NOTE: store emited start tag's tagName to determine is the following end tag token is appropriate.\n        if (ct.type === Tokenizer.START_TAG_TOKEN) {\n            this.lastStartTagName = ct.tagName;\n        } else if (ct.type === Tokenizer.END_TAG_TOKEN) {\n            if (ct.attrs.length > 0) {\n                this._err(ERR.endTagWithAttributes);\n            }\n\n            if (ct.selfClosing) {\n                this._err(ERR.endTagWithTrailingSolidus);\n            }\n        }\n\n        this.tokenQueue.push(ct);\n    }\n\n    _emitCurrentCharacterToken() {\n        if (this.currentCharacterToken) {\n            this.tokenQueue.push(this.currentCharacterToken);\n            this.currentCharacterToken = null;\n        }\n    }\n\n    _emitEOFToken() {\n        this._createEOFToken();\n        this._emitCurrentToken();\n    }\n\n    //Characters emission\n\n    //OPTIMIZATION: specification uses only one type of character tokens (one token per character).\n    //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.\n    //If we have a sequence of characters that belong to the same group, parser can process it\n    //as a single solid character token.\n    //So, there are 3 types of character tokens in parse5:\n    //1)NULL_CHARACTER_TOKEN - \\u0000-character sequences (e.g. '\\u0000\\u0000\\u0000')\n    //2)WHITESPACE_CHARACTER_TOKEN - any whitespace/new-line character sequences (e.g. '\\n  \\r\\t   \\f')\n    //3)CHARACTER_TOKEN - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')\n    _appendCharToCurrentCharacterToken(type, ch) {\n        if (this.currentCharacterToken && this.currentCharacterToken.type !== type) {\n            this._emitCurrentCharacterToken();\n        }\n\n        if (this.currentCharacterToken) {\n            this.currentCharacterToken.chars += ch;\n        } else {\n            this._createCharacterToken(type, ch);\n        }\n    }\n\n    _emitCodePoint(cp) {\n        let type = Tokenizer.CHARACTER_TOKEN;\n\n        if (isWhitespace(cp)) {\n            type = Tokenizer.WHITESPACE_CHARACTER_TOKEN;\n        } else if (cp === $.NULL) {\n            type = Tokenizer.NULL_CHARACTER_TOKEN;\n        }\n\n        this._appendCharToCurrentCharacterToken(type, toChar(cp));\n    }\n\n    _emitSeveralCodePoints(codePoints) {\n        for (let i = 0; i < codePoints.length; i++) {\n            this._emitCodePoint(codePoints[i]);\n        }\n    }\n\n    //NOTE: used then we emit character explicitly. This is always a non-whitespace and a non-null character.\n    //So we can avoid additional checks here.\n    _emitChars(ch) {\n        this._appendCharToCurrentCharacterToken(Tokenizer.CHARACTER_TOKEN, ch);\n    }\n\n    // Character reference helpers\n    _matchNamedCharacterReference(startCp) {\n        let result = null;\n        let excess = 1;\n        let i = findNamedEntityTreeBranch(0, startCp);\n\n        this.tempBuff.push(startCp);\n\n        while (i > -1) {\n            const current = neTree[i];\n            const inNode = current < MAX_BRANCH_MARKER_VALUE;\n            const nodeWithData = inNode && current & HAS_DATA_FLAG;\n\n            if (nodeWithData) {\n                //NOTE: we use greedy search, so we continue lookup at this point\n                result = current & DATA_DUPLET_FLAG ? [neTree[++i], neTree[++i]] : [neTree[++i]];\n                excess = 0;\n            }\n\n            const cp = this._consume();\n\n            this.tempBuff.push(cp);\n            excess++;\n\n            if (cp === $.EOF) {\n                break;\n            }\n\n            if (inNode) {\n                i = current & HAS_BRANCHES_FLAG ? findNamedEntityTreeBranch(i, cp) : -1;\n            } else {\n                i = cp === current ? ++i : -1;\n            }\n        }\n\n        while (excess--) {\n            this.tempBuff.pop();\n            this._unconsume();\n        }\n\n        return result;\n    }\n\n    _isCharacterReferenceInAttribute() {\n        return (\n            this.returnState === ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE ||\n            this.returnState === ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE ||\n            this.returnState === ATTRIBUTE_VALUE_UNQUOTED_STATE\n        );\n    }\n\n    _isCharacterReferenceAttributeQuirk(withSemicolon) {\n        if (!withSemicolon && this._isCharacterReferenceInAttribute()) {\n            const nextCp = this._consume();\n\n            this._unconsume();\n\n            return nextCp === $.EQUALS_SIGN || isAsciiAlphaNumeric(nextCp);\n        }\n\n        return false;\n    }\n\n    _flushCodePointsConsumedAsCharacterReference() {\n        if (this._isCharacterReferenceInAttribute()) {\n            for (let i = 0; i < this.tempBuff.length; i++) {\n                this.currentAttr.value += toChar(this.tempBuff[i]);\n            }\n        } else {\n            this._emitSeveralCodePoints(this.tempBuff);\n        }\n\n        this.tempBuff = [];\n    }\n\n    // State machine\n\n    // Data state\n    //------------------------------------------------------------------\n    [DATA_STATE](cp) {\n        this.preprocessor.dropParsedChunk();\n\n        if (cp === $.LESS_THAN_SIGN) {\n            this.state = TAG_OPEN_STATE;\n        } else if (cp === $.AMPERSAND) {\n            this.returnState = DATA_STATE;\n            this.state = CHARACTER_REFERENCE_STATE;\n        } else if (cp === $.NULL) {\n            this._err(ERR.unexpectedNullCharacter);\n            this._emitCodePoint(cp);\n        } else if (cp === $.EOF) {\n            this._emitEOFToken();\n        } else {\n            this._emitCodePoint(cp);\n        }\n    }\n\n    //  RCDATA state\n    //------------------------------------------------------------------\n    [RCDATA_STATE](cp) {\n        this.preprocessor.dropParsedChunk();\n\n        if (cp === $.AMPERSAND) {\n            this.returnState = RCDATA_STATE;\n            this.state = CHARACTER_REFERENCE_STATE;\n        } else if (cp === $.LESS_THAN_SIGN) {\n            this.state = RCDATA_LESS_THAN_SIGN_STATE;\n        } else if (cp === $.NULL) {\n            this._err(ERR.unexpectedNullCharacter);\n            this._emitChars(unicode.REPLACEMENT_CHARACTER);\n        } else if (cp === $.EOF) {\n            this._emitEOFToken();\n        } else {\n            this._emitCodePoint(cp);\n        }\n    }\n\n    // RAWTEXT state\n    //------------------------------------------------------------------\n    [RAWTEXT_STATE](cp) {\n        this.preprocessor.dropParsedChunk();\n\n        if (cp === $.LESS_THAN_SIGN) {\n            this.state = RAWTEXT_LESS_THAN_SIGN_STATE;\n        } else if (cp === $.NULL) {\n            this._err(ERR.unexpectedNullCharacter);\n            this._emitChars(unicode.REPLACEMENT_CHARACTER);\n        } else if (cp === $.EOF) {\n            this._emitEOFToken();\n        } else {\n            this._emitCodePoint(cp);\n        }\n    }\n\n    // Script data state\n    //------------------------------------------------------------------\n    [SCRIPT_DATA_STATE](cp) {\n        this.preprocessor.dropParsedChunk();\n\n        if (cp === $.LESS_THAN_SIGN) {\n            this.state = SCRIPT_DATA_LESS_THAN_SIGN_STATE;\n        } else if (cp === $.NULL) {\n            this._err(ERR.unexpectedNullCharacter);\n            this._emitChars(unicode.REPLACEMENT_CHARACTER);\n        } else if (cp === $.EOF) {\n            this._emitEOFToken();\n        } else {\n            this._emitCodePoint(cp);\n        }\n    }\n\n    // PLAINTEXT state\n    //------------------------------------------------------------------\n    [PLAINTEXT_STATE](cp) {\n        this.preprocessor.dropParsedChunk();\n\n        if (cp === $.NULL) {\n            this._err(ERR.unexpectedNullCharacter);\n            this._emitChars(unicode.REPLACEMENT_CHARACTER);\n        } else if (cp === $.EOF) {\n            this._emitEOFToken();\n        } else {\n            this._emitCodePoint(cp);\n        }\n    }\n\n    // Tag open state\n    //------------------------------------------------------------------\n    [TAG_OPEN_STATE](cp) {\n        if (cp === $.EXCLAMATION_MARK) {\n            this.state = MARKUP_DECLARATION_OPEN_STATE;\n        } else if (cp === $.SOLIDUS) {\n            this.state = END_TAG_OPEN_STATE;\n        } else if (isAsciiLetter(cp)) {\n            this._createStartTagToken();\n            this._reconsumeInState(TAG_NAME_STATE);\n        } else if (cp === $.QUESTION_MARK) {\n            this._err(ERR.unexpectedQuestionMarkInsteadOfTagName);\n            this._createCommentToken();\n            this._reconsumeInState(BOGUS_COMMENT_STATE);\n        } else if (cp === $.EOF) {\n            this._err(ERR.eofBeforeTagName);\n            this._emitChars('<');\n            this._emitEOFToken();\n        } else {\n            this._err(ERR.invalidFirstCharacterOfTagName);\n            this._emitChars('<');\n            this._reconsumeInState(DATA_STATE);\n        }\n    }\n\n    // End tag open state\n    //------------------------------------------------------------------\n    [END_TAG_OPEN_STATE](cp) {\n        if (isAsciiLetter(cp)) {\n            this._createEndTagToken();\n            this._reconsumeInState(TAG_NAME_STATE);\n        } else if (cp === $.GREATER_THAN_SIGN) {\n            this._err(ERR.missingEndTagName);\n            this.state = DATA_STATE;\n        } else if (cp === $.EOF) {\n            this._err(ERR.eofBeforeTagName);\n            this._emitChars('</');\n            this._emitEOFToken();\n        } else {\n            this._err(ERR.invalidFirstCharacterOfTagName);\n            this._createCommentToken();\n            this._reconsumeInState(BOGUS_COMMENT_STATE);\n        }\n    }\n\n    // Tag name state\n    //------------------------------------------------------------------\n    [TAG_NAME_STATE](cp) {\n        if (isWhitespace(cp)) {\n            this.state = BEFORE_ATTRIBUTE_NAME_STATE;\n        } else if (cp === $.SOLIDUS) {\n            this.state = SELF_CLOSING_START_TAG_STATE;\n        } else if (cp === $.GREATER_THAN_SIGN) {\n            this.state = DATA_STATE;\n            this._emitCurrentToken();\n        } else if (isAsciiUpper(cp)) {\n            this.currentToken.tagName += toAsciiLowerChar(cp);\n        } else if (cp === $.NULL) {\n            this._err(ERR.unexpectedNullCharacter);\n            this.currentToken.tagName += unicode.REPLACEMENT_CHARACTER;\n        } else if (cp === $.EOF) {\n            this._err(ERR.eofInTag);\n            this._emitEOFToken();\n        } else {\n            this.currentToken.tagName += toChar(cp);\n        }\n    }\n\n    // RCDATA less-than sign state\n    //------------------------------------------------------------------\n    [RCDATA_LESS_THAN_SIGN_STATE](cp) {\n        if (cp === $.SOLIDUS) {\n            this.tempBuff = [];\n            this.state = RCDATA_END_TAG_OPEN_STATE;\n        } else {\n            this._emitChars('<');\n            this._reconsumeInState(RCDATA_STATE);\n        }\n    }\n\n    // RCDATA end tag open state\n    //------------------------------------------------------------------\n    [RCDATA_END_TAG_OPEN_STATE](cp) {\n        if (isAsciiLetter(cp)) {\n            this._createEndTagToken();\n            this._reconsumeInState(RCDATA_END_TAG_NAME_STATE);\n        } else {\n            this._emitChars('</');\n            this._reconsumeInState(RCDATA_STATE);\n        }\n    }\n\n    // RCDATA end tag name state\n    //------------------------------------------------------------------\n    [RCDATA_END_TAG_NAME_STATE](cp) {\n        if (isAsciiUpper(cp)) {\n            this.currentToken.tagName += toAsciiLowerChar(cp);\n            this.tempBuff.push(cp);\n        } else if (isAsciiLower(cp)) {\n            this.currentToken.tagName += toChar(cp);\n            this.tempBuff.push(cp);\n        } else {\n            if (this.lastStartTagName === this.currentToken.tagName) {\n                if (isWhitespace(cp)) {\n                    this.state = BEFORE_ATTRIBUTE_NAME_STATE;\n                    return;\n                }\n\n                if (cp === $.SOLIDUS) {\n                    this.state = SELF_CLOSING_START_TAG_STATE;\n                    return;\n                }\n\n                if (cp === $.GREATER_THAN_SIGN) {\n                    this.state = DATA_STATE;\n                    this._emitCurrentToken();\n                    return;\n                }\n            }\n\n            this._emitChars('</');\n            this._emitSeveralCodePoints(this.tempBuff);\n            this._reconsumeInState(RCDATA_STATE);\n        }\n    }\n\n    // RAWTEXT less-than sign state\n    //------------------------------------------------------------------\n    [RAWTEXT_LESS_THAN_SIGN_STATE](cp) {\n        if (cp === $.SOLIDUS) {\n            this.tempBuff = [];\n            this.state = RAWTEXT_END_TAG_OPEN_STATE;\n        } else {\n            this._emitChars('<');\n            this._reconsumeInState(RAWTEXT_STATE);\n        }\n    }\n\n    // RAWTEXT end tag open state\n    //------------------------------------------------------------------\n    [RAWTEXT_END_TAG_OPEN_STATE](cp) {\n        if (isAsciiLetter(cp)) {\n            this._createEndTagToken();\n            this._reconsumeInState(RAWTEXT_END_TAG_NAME_STATE);\n        } else {\n            this._emitChars('</');\n            this._reconsumeInState(RAWTEXT_STATE);\n        }\n    }\n\n    // RAWTEXT end tag name state\n    //------------------------------------------------------------------\n    [RAWTEXT_END_TAG_NAME_STATE](cp) {\n        if (isAsciiUpper(cp)) {\n            this.currentToken.tagName += toAsciiLowerChar(cp);\n            this.tempBuff.push(cp);\n        } else if (isAsciiLower(cp)) {\n            this.currentToken.tagName += toChar(cp);\n            this.tempBuff.push(cp);\n        } else {\n            if (this.lastStartTagName === this.currentToken.tagName) {\n                if (isWhitespace(cp)) {\n                    this.state = BEFORE_ATTRIBUTE_NAME_STATE;\n                    return;\n                }\n\n                if (cp === $.SOLIDUS) {\n                    this.state = SELF_CLOSING_START_TAG_STATE;\n                    return;\n                }\n\n                if (cp === $.GREATER_THAN_SIGN) {\n                    this._emitCurrentToken();\n                    this.state = DATA_STATE;\n                    return;\n                }\n            }\n\n            this._emitChars('</');\n            this._emitSeveralCodePoints(this.tempBuff);\n            this._reconsumeInState(RAWTEXT_STATE);\n        }\n    }\n\n    // Script data less-than sign state\n    //------------------------------------------------------------------\n    [SCRIPT_DATA_LESS_THAN_SIGN_STATE](cp) {\n        if (cp === $.SOLIDUS) {\n            this.tempBuff = [];\n            this.state = SCRIPT_DATA_END_TAG_OPEN_STATE;\n        } else if (cp === $.EXCLAMATION_MARK) {\n            this.state = SCRIPT_DATA_ESCAPE_START_STATE;\n            this._emitChars('<!');\n        } else {\n            this._emitChars('<');\n            this._reconsumeInState(SCRIPT_DATA_STATE);\n        }\n    }\n\n    // Script data end tag open state\n    //------------------------------------------------------------------\n    [SCRIPT_DATA_END_TAG_OPEN_STATE](cp) {\n        if (isAsciiLetter(cp)) {\n            this._createEndTagToken();\n            this._reconsumeInState(SCRIPT_DATA_END_TAG_NAME_STATE);\n        } else {\n            this._emitChars('</');\n            this._reconsumeInState(SCRIPT_DATA_STATE);\n        }\n    }\n\n    // Script data end tag name state\n    //------------------------------------------------------------------\n    [SCRIPT_DATA_END_TAG_NAME_STATE](cp) {\n        if (isAsciiUpper(cp)) {\n            this.currentToken.tagName += toAsciiLowerChar(cp);\n            this.tempBuff.push(cp);\n        } else if (isAsciiLower(cp)) {\n            this.currentToken.tagName += toChar(cp);\n            this.tempBuff.push(cp);\n        } else {\n            if (this.lastStartTagName === this.currentToken.tagName) {\n                if (isWhitespace(cp)) {\n                    this.state = BEFORE_ATTRIBUTE_NAME_STATE;\n                    return;\n                } else if (cp === $.SOLIDUS) {\n                    this.state = SELF_CLOSING_START_TAG_STATE;\n                    return;\n                } else if (cp === $.GREATER_THAN_SIGN) {\n                    this._emitCurrentToken();\n                    this.state = DATA_STATE;\n                    return;\n                }\n            }\n\n            this._emitChars('</');\n            this._emitSeveralCodePoints(this.tempBuff);\n            this._reconsumeInState(SCRIPT_DATA_STATE);\n        }\n    }\n\n    // Script data escape start state\n    //------------------------------------------------------------------\n    [SCRIPT_DATA_ESCAPE_START_STATE](cp) {\n        if (cp === $.HYPHEN_MINUS) {\n            this.state = SCRIPT_DATA_ESCAPE_START_DASH_STATE;\n            this._emitChars('-');\n        } else {\n            this._reconsumeInState(SCRIPT_DATA_STATE);\n        }\n    }\n\n    // Script data escape start dash state\n    //------------------------------------------------------------------\n    [SCRIPT_DATA_ESCAPE_START_DASH_STATE](cp) {\n        if (cp === $.HYPHEN_MINUS) {\n            this.state = SCRIPT_DATA_ESCAPED_DASH_DASH_STATE;\n            this._emitChars('-');\n        } else {\n            this._reconsumeInState(SCRIPT_DATA_STATE);\n        }\n    }\n\n    // Script data escaped state\n    //------------------------------------------------------------------\n    [SCRIPT_DATA_ESCAPED_STATE](cp) {\n        if (cp === $.HYPHEN_MINUS) {\n            this.state = SCRIPT_DATA_ESCAPED_DASH_STATE;\n            this._emitChars('-');\n        } else if (cp === $.LESS_THAN_SIGN) {\n            this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;\n        } else if (cp === $.NULL) {\n            this._err(ERR.unexpectedNullCharacter);\n            this._emitChars(unicode.REPLACEMENT_CHARACTER);\n        } else if (cp === $.EOF) {\n            this._err(ERR.eofInScriptHtmlCommentLikeText);\n            this._emitEOFToken();\n        } else {\n            this._emitCodePoint(cp);\n        }\n    }\n\n    // Script data escaped dash state\n    //------------------------------------------------------------------\n    [SCRIPT_DATA_ESCAPED_DASH_STATE](cp) {\n        if (cp === $.HYPHEN_MINUS) {\n            this.state = SCRIPT_DATA_ESCAPED_DASH_DASH_STATE;\n            this._emitChars('-');\n        } else if (cp === $.LESS_THAN_SIGN) {\n            this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;\n        } else if (cp === $.NULL) {\n            this._err(ERR.unexpectedNullCharacter);\n            this.state = SCRIPT_DATA_ESCAPED_STATE;\n            this._emitChars(unicode.REPLACEMENT_CHARACTER);\n        } else if (cp === $.EOF) {\n            this._err(ERR.eofInScriptHtmlCommentLikeText);\n            this._emitEOFToken();\n        } else {\n            this.state = SCRIPT_DATA_ESCAPED_STATE;\n            this._emitCodePoint(cp);\n        }\n    }\n\n    // Script data escaped dash dash state\n    //------------------------------------------------------------------\n    [SCRIPT_DATA_ESCAPED_DASH_DASH_STATE](cp) {\n        if (cp === $.HYPHEN_MINUS) {\n            this._emitChars('-');\n        } else if (cp === $.LESS_THAN_SIGN) {\n            this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;\n        } else if (cp === $.GREATER_THAN_SIGN) {\n            this.state = SCRIPT_DATA_STATE;\n            this._emitChars('>');\n        } else if (cp === $.NULL) {\n            this._err(ERR.unexpectedNullCharacter);\n            this.state = SCRIPT_DATA_ESCAPED_STATE;\n            this._emitChars(unicode.REPLACEMENT_CHARACTER);\n        } else if (cp === $.EOF) {\n            this._err(ERR.eofInScriptHtmlCommentLikeText);\n            this._emitEOFToken();\n        } else {\n            this.state = SCRIPT_DATA_ESCAPED_STATE;\n            this._emitCodePoint(cp);\n        }\n    }\n\n    // Script data escaped less-than sign state\n    //------------------------------------------------------------------\n    [SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE](cp) {\n        if (cp === $.SOLIDUS) {\n            this.tempBuff = [];\n            this.state = SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE;\n        } else if (isAsciiLetter(cp)) {\n            this.tempBuff = [];\n            this._emitChars('<');\n            this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE);\n        } else {\n            this._emitChars('<');\n            this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);\n        }\n    }\n\n    // Script data escaped end tag open state\n    //------------------------------------------------------------------\n    [SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE](cp) {\n        if (isAsciiLetter(cp)) {\n            this._createEndTagToken();\n            this._reconsumeInState(SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE);\n        } else {\n            this._emitChars('</');\n            this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);\n        }\n    }\n\n    // Script data escaped end tag name state\n    //------------------------------------------------------------------\n    [SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE](cp) {\n        if (isAsciiUpper(cp)) {\n            this.currentToken.tagName += toAsciiLowerChar(cp);\n            this.tempBuff.push(cp);\n        } else if (isAsciiLower(cp)) {\n            this.currentToken.tagName += toChar(cp);\n            this.tempBuff.push(cp);\n        } else {\n            if (this.lastStartTagName === this.currentToken.tagName) {\n                if (isWhitespace(cp)) {\n                    this.state = BEFORE_ATTRIBUTE_NAME_STATE;\n                    return;\n                }\n\n                if (cp === $.SOLIDUS) {\n                    this.state = SELF_CLOSING_START_TAG_STATE;\n                    return;\n                }\n\n                if (cp === $.GREATER_THAN_SIGN) {\n                    this._emitCurrentToken();\n                    this.state = DATA_STATE;\n                    return;\n                }\n            }\n\n            this._emitChars('</');\n            this._emitSeveralCodePoints(this.tempBuff);\n            this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);\n        }\n    }\n\n    // Script data double escape start state\n    //------------------------------------------------------------------\n    [SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE](cp) {\n        if (isWhitespace(cp) || cp === $.SOLIDUS || cp === $.GREATER_THAN_SIGN) {\n            this.state = this._isTempBufferEqualToScriptString()\n                ? SCRIPT_DATA_DOUBLE_ESCAPED_STATE\n                : SCRIPT_DATA_ESCAPED_STATE;\n            this._emitCodePoint(cp);\n        } else if (isAsciiUpper(cp)) {\n            this.tempBuff.push(toAsciiLowerCodePoint(cp));\n            this._emitCodePoint(cp);\n        } else if (isAsciiLower(cp)) {\n            this.tempBuff.push(cp);\n            this._emitCodePoint(cp);\n        } else {\n            this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);\n        }\n    }\n\n    // Script data double escaped state\n    //------------------------------------------------------------------\n    [SCRIPT_DATA_DOUBLE_ESCAPED_STATE](cp) {\n        if (cp === $.HYPHEN_MINUS) {\n            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE;\n            this._emitChars('-');\n        } else if (cp === $.LESS_THAN_SIGN) {\n            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;\n            this._emitChars('<');\n        } else if (cp === $.NULL) {\n            this._err(ERR.unexpectedNullCharacter);\n            this._emitChars(unicode.REPLACEMENT_CHARACTER);\n        } else if (cp === $.EOF) {\n            this._err(ERR.eofInScriptHtmlCommentLikeText);\n            this._emitEOFToken();\n        } else {\n            this._emitCodePoint(cp);\n        }\n    }\n\n    // Script data double escaped dash state\n    //------------------------------------------------------------------\n    [SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE](cp) {\n        if (cp === $.HYPHEN_MINUS) {\n            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE;\n            this._emitChars('-');\n        } else if (cp === $.LESS_THAN_SIGN) {\n            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;\n            this._emitChars('<');\n        } else if (cp === $.NULL) {\n            this._err(ERR.unexpectedNullCharacter);\n            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;\n            this._emitChars(unicode.REPLACEMENT_CHARACTER);\n        } else if (cp === $.EOF) {\n            this._err(ERR.eofInScriptHtmlCommentLikeText);\n            this._emitEOFToken();\n        } else {\n            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;\n            this._emitCodePoint(cp);\n        }\n    }\n\n    // Script data double escaped dash dash state\n    //------------------------------------------------------------------\n    [SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE](cp) {\n        if (cp === $.HYPHEN_MINUS) {\n            this._emitChars('-');\n        } else if (cp === $.LESS_THAN_SIGN) {\n            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;\n            this._emitChars('<');\n        } else if (cp === $.GREATER_THAN_SIGN) {\n            this.state = SCRIPT_DATA_STATE;\n            this._emitChars('>');\n        } else if (cp === $.NULL) {\n            this._err(ERR.unexpectedNullCharacter);\n            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;\n            this._emitChars(unicode.REPLACEMENT_CHARACTER);\n        } else if (cp === $.EOF) {\n            this._err(ERR.eofInScriptHtmlCommentLikeText);\n            this._emitEOFToken();\n        } else {\n            this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;\n            this._emitCodePoint(cp);\n        }\n    }\n\n    // Script data double escaped less-than sign state\n    //------------------------------------------------------------------\n    [SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE](cp) {\n        if (cp === $.SOLIDUS) {\n            this.tempBuff = [];\n            this.state = SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE;\n            this._emitChars('/');\n        } else {\n            this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPED_STATE);\n        }\n    }\n\n    // Script data double escape end state\n    //------------------------------------------------------------------\n    [SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE](cp) {\n        if (isWhitespace(cp) || cp === $.SOLIDUS || cp === $.GREATER_THAN_SIGN) {\n            this.state = this._isTempBufferEqualToScriptString()\n                ? SCRIPT_DATA_ESCAPED_STATE\n                : SCRIPT_DATA_DOUBLE_ESCAPED_STATE;\n\n            this._emitCodePoint(cp);\n        } else if (isAsciiUpper(cp)) {\n            this.tempBuff.push(toAsciiLowerCodePoint(cp));\n            this._emitCodePoint(cp);\n        } else if (isAsciiLower(cp)) {\n            this.tempBuff.push(cp);\n            this._emitCodePoint(cp);\n        } else {\n            this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPED_STATE);\n        }\n    }\n\n    // Before attribute name state\n    //------------------------------------------------------------------\n    [BEFORE_ATTRIBUTE_NAME_STATE](cp) {\n        if (isWhitespace(cp)) {\n            return;\n        }\n\n        if (cp === $.SOLIDUS || cp === $.GREATER_THAN_SIGN || cp === $.EOF) {\n            this._reconsumeInState(AFTER_ATTRIBUTE_NAME_STATE);\n        } else if (cp === $.EQUALS_SIGN) {\n            this._err(ERR.unexpectedEqualsSignBeforeAttributeName);\n            this._createAttr('=');\n            this.state = ATTRIBUTE_NAME_STATE;\n        } else {\n            this._createAttr('');\n            this._reconsumeInState(ATTRIBUTE_NAME_STATE);\n        }\n    }\n\n    // Attribute name state\n    //------------------------------------------------------------------\n    [ATTRIBUTE_NAME_STATE](cp) {\n        if (isWhitespace(cp) || cp === $.SOLIDUS || cp === $.GREATER_THAN_SIGN || cp === $.EOF) {\n            this._leaveAttrName(AFTER_ATTRIBUTE_NAME_STATE);\n            this._unconsume();\n        } else if (cp === $.EQUALS_SIGN) {\n            this._leaveAttrName(BEFORE_ATTRIBUTE_VALUE_STATE);\n        } else if (isAsciiUpper(cp)) {\n            this.currentAttr.name += toAsciiLowerChar(cp);\n        } else if (cp === $.QUOTATION_MARK || cp === $.APOSTROPHE || cp === $.LESS_THAN_SIGN) {\n            this._err(ERR.unexpectedCharacterInAttributeName);\n            this.currentAttr.name += toChar(cp);\n        } else if (cp === $.NULL) {\n            this._err(ERR.unexpectedNullCharacter);\n            this.currentAttr.name += unicode.REPLACEMENT_CHARACTER;\n        } else {\n            this.currentAttr.name += toChar(cp);\n        }\n    }\n\n    // After attribute name state\n    //------------------------------------------------------------------\n    [AFTER_ATTRIBUTE_NAME_STATE](cp) {\n        if (isWhitespace(cp)) {\n            return;\n        }\n\n        if (cp === $.SOLIDUS) {\n            this.state = SELF_CLOSING_START_TAG_STATE;\n        } else if (cp === $.EQUALS_SIGN) {\n            this.state = BEFORE_ATTRIBUTE_VALUE_STATE;\n        } else if (cp === $.GREATER_THAN_SIGN) {\n            this.state = DATA_STATE;\n            this._emitCurrentToken();\n        } else if (cp === $.EOF) {\n            this._err(ERR.eofInTag);\n            this._emitEOFToken();\n        } else {\n            this._createAttr('');\n            this._reconsumeInState(ATTRIBUTE_NAME_STATE);\n        }\n    }\n\n    // Before attribute value state\n    //------------------------------------------------------------------\n    [BEFORE_ATTRIBUTE_VALUE_STATE](cp) {\n        if (isWhitespace(cp)) {\n            return;\n        }\n\n        if (cp === $.QUOTATION_MARK) {\n            this.state = ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE;\n        } else if (cp === $.APOSTROPHE) {\n            this.state = ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE;\n        } else if (cp === $.GREATER_THAN_SIGN) {\n            this._err(ERR.missingAttributeValue);\n            this.state = DATA_STATE;\n            this._emitCurrentToken();\n        } else {\n            this._reconsumeInState(ATTRIBUTE_VALUE_UNQUOTED_STATE);\n        }\n    }\n\n    // Attribute value (double-quoted) state\n    //------------------------------------------------------------------\n    [ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE](cp) {\n        if (cp === $.QUOTATION_MARK) {\n            this.state = AFTER_ATTRIBUTE_VALUE_QUOTED_STATE;\n        } else if (cp === $.AMPERSAND) {\n            this.returnState = ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE;\n            this.state = CHARACTER_REFERENCE_STATE;\n        } else if (cp === $.NULL) {\n            this._err(ERR.unexpectedNullCharacter);\n            this.currentAttr.value += unicode.REPLACEMENT_CHARACTER;\n        } else if (cp === $.EOF) {\n            this._err(ERR.eofInTag);\n            this._emitEOFToken();\n        } else {\n            this.currentAttr.value += toChar(cp);\n        }\n    }\n\n    // Attribute value (single-quoted) state\n    //------------------------------------------------------------------\n    [ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE](cp) {\n        if (cp === $.APOSTROPHE) {\n            this.state = AFTER_ATTRIBUTE_VALUE_QUOTED_STATE;\n        } else if (cp === $.AMPERSAND) {\n            this.returnState = ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE;\n            this.state = CHARACTER_REFERENCE_STATE;\n        } else if (cp === $.NULL) {\n            this._err(ERR.unexpectedNullCharacter);\n            this.currentAttr.value += unicode.REPLACEMENT_CHARACTER;\n        } else if (cp === $.EOF) {\n            this._err(ERR.eofInTag);\n            this._emitEOFToken();\n        } else {\n            this.currentAttr.value += toChar(cp);\n        }\n    }\n\n    // Attribute value (unquoted) state\n    //------------------------------------------------------------------\n    [ATTRIBUTE_VALUE_UNQUOTED_STATE](cp) {\n        if (isWhitespace(cp)) {\n            this._leaveAttrValue(BEFORE_ATTRIBUTE_NAME_STATE);\n        } else if (cp === $.AMPERSAND) {\n            this.returnState = ATTRIBUTE_VALUE_UNQUOTED_STATE;\n            this.state = CHARACTER_REFERENCE_STATE;\n        } else if (cp === $.GREATER_THAN_SIGN) {\n            this._leaveAttrValue(DATA_STATE);\n            this._emitCurrentToken();\n        } else if (cp === $.NULL) {\n            this._err(ERR.unexpectedNullCharacter);\n            this.currentAttr.value += unicode.REPLACEMENT_CHARACTER;\n        } else if (\n            cp === $.QUOTATION_MARK ||\n            cp === $.APOSTROPHE ||\n            cp === $.LESS_THAN_SIGN ||\n            cp === $.EQUALS_SIGN ||\n            cp === $.GRAVE_ACCENT\n        ) {\n            this._err(ERR.unexpectedCharacterInUnquotedAttributeValue);\n            this.currentAttr.value += toChar(cp);\n        } else if (cp === $.EOF) {\n            this._err(ERR.eofInTag);\n            this._emitEOFToken();\n        } else {\n            this.currentAttr.value += toChar(cp);\n        }\n    }\n\n    // After attribute value (quoted) state\n    //------------------------------------------------------------------\n    [AFTER_ATTRIBUTE_VALUE_QUOTED_STATE](cp) {\n        if (isWhitespace(cp)) {\n            this._leaveAttrValue(BEFORE_ATTRIBUTE_NAME_STATE);\n        } else if (cp === $.SOLIDUS) {\n            this._leaveAttrValue(SELF_CLOSING_START_TAG_STATE);\n        } else if (cp === $.GREATER_THAN_SIGN) {\n            this._leaveAttrValue(DATA_STATE);\n            this._emitCurrentToken();\n        } else if (cp === $.EOF) {\n            this._err(ERR.eofInTag);\n            this._emitEOFToken();\n        } else {\n            this._err(ERR.missingWhitespaceBetweenAttributes);\n            this._reconsumeInState(BEFORE_ATTRIBUTE_NAME_STATE);\n        }\n    }\n\n    // Self-closing start tag state\n    //------------------------------------------------------------------\n    [SELF_CLOSING_START_TAG_STATE](cp) {\n        if (cp === $.GREATER_THAN_SIGN) {\n            this.currentToken.selfClosing = true;\n            this.state = DATA_STATE;\n            this._emitCurrentToken();\n        } else if (cp === $.EOF) {\n            this._err(ERR.eofInTag);\n            this._emitEOFToken();\n        } else {\n            this._err(ERR.unexpectedSolidusInTag);\n            this._reconsumeInState(BEFORE_ATTRIBUTE_NAME_STATE);\n        }\n    }\n\n    // Bogus comment state\n    //------------------------------------------------------------------\n    [BOGUS_COMMENT_STATE](cp) {\n        if (cp === $.GREATER_THAN_SIGN) {\n            this.state = DATA_STATE;\n            this._emitCurrentToken();\n        } else if (cp === $.EOF) {\n            this._emitCurrentToken();\n            this._emitEOFToken();\n        } else if (cp === $.NULL) {\n            this._err(ERR.unexpectedNullCharacter);\n            this.currentToken.data += unicode.REPLACEMENT_CHARACTER;\n        } else {\n            this.currentToken.data += toChar(cp);\n        }\n    }\n\n    // Markup declaration open state\n    //------------------------------------------------------------------\n    [MARKUP_DECLARATION_OPEN_STATE](cp) {\n        if (this._consumeSequenceIfMatch($$.DASH_DASH_STRING, cp, true)) {\n            this._createCommentToken();\n            this.state = COMMENT_START_STATE;\n        } else if (this._consumeSequenceIfMatch($$.DOCTYPE_STRING, cp, false)) {\n            this.state = DOCTYPE_STATE;\n        } else if (this._consumeSequenceIfMatch($$.CDATA_START_STRING, cp, true)) {\n            if (this.allowCDATA) {\n                this.state = CDATA_SECTION_STATE;\n            } else {\n                this._err(ERR.cdataInHtmlContent);\n                this._createCommentToken();\n                this.currentToken.data = '[CDATA[';\n                this.state = BOGUS_COMMENT_STATE;\n            }\n        }\n\n        //NOTE: sequence lookup can be abrupted by hibernation. In that case lookup\n        //results are no longer valid and we will need to start over.\n        else if (!this._ensureHibernation()) {\n            this._err(ERR.incorrectlyOpenedComment);\n            this._createCommentToken();\n            this._reconsumeInState(BOGUS_COMMENT_STATE);\n        }\n    }\n\n    // Comment start state\n    //------------------------------------------------------------------\n    [COMMENT_START_STATE](cp) {\n        if (cp === $.HYPHEN_MINUS) {\n            this.state = COMMENT_START_DASH_STATE;\n        } else if (cp === $.GREATER_THAN_SIGN) {\n            this._err(ERR.abruptClosingOfEmptyComment);\n            this.state = DATA_STATE;\n            this._emitCurrentToken();\n        } else {\n            this._reconsumeInState(COMMENT_STATE);\n        }\n    }\n\n    // Comment start dash state\n    //------------------------------------------------------------------\n    [COMMENT_START_DASH_STATE](cp) {\n        if (cp === $.HYPHEN_MINUS) {\n            this.state = COMMENT_END_STATE;\n        } else if (cp === $.GREATER_THAN_SIGN) {\n            this._err(ERR.abruptClosingOfEmptyComment);\n            this.state = DATA_STATE;\n            this._emitCurrentToken();\n        } else if (cp === $.EOF) {\n            this._err(ERR.eofInComment);\n            this._emitCurrentToken();\n            this._emitEOFToken();\n        } else {\n            this.currentToken.data += '-';\n            this._reconsumeInState(COMMENT_STATE);\n        }\n    }\n\n    // Comment state\n    //------------------------------------------------------------------\n    [COMMENT_STATE](cp) {\n        if (cp === $.HYPHEN_MINUS) {\n            this.state = COMMENT_END_DASH_STATE;\n        } else if (cp === $.LESS_THAN_SIGN) {\n            this.currentToken.data += '<';\n            this.state = COMMENT_LESS_THAN_SIGN_STATE;\n        } else if (cp === $.NULL) {\n            this._err(ERR.unexpectedNullCharacter);\n            this.currentToken.data += unicode.REPLACEMENT_CHARACTER;\n        } else if (cp === $.EOF) {\n            this._err(ERR.eofInComment);\n            this._emitCurrentToken();\n            this._emitEOFToken();\n        } else {\n            this.currentToken.data += toChar(cp);\n        }\n    }\n\n    // Comment less-than sign state\n    //------------------------------------------------------------------\n    [COMMENT_LESS_THAN_SIGN_STATE](cp) {\n        if (cp === $.EXCLAMATION_MARK) {\n            this.currentToken.data += '!';\n            this.state = COMMENT_LESS_THAN_SIGN_BANG_STATE;\n        } else if (cp === $.LESS_THAN_SIGN) {\n            this.currentToken.data += '!';\n        } else {\n            this._reconsumeInState(COMMENT_STATE);\n        }\n    }\n\n    // Comment less-than sign bang state\n    //------------------------------------------------------------------\n    [COMMENT_LESS_THAN_SIGN_BANG_STATE](cp) {\n        if (cp === $.HYPHEN_MINUS) {\n            this.state = COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE;\n        } else {\n            this._reconsumeInState(COMMENT_STATE);\n        }\n    }\n\n    // Comment less-than sign bang dash state\n    //------------------------------------------------------------------\n    [COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE](cp) {\n        if (cp === $.HYPHEN_MINUS) {\n            this.state = COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE;\n        } else {\n            this._reconsumeInState(COMMENT_END_DASH_STATE);\n        }\n    }\n\n    // Comment less-than sign bang dash dash state\n    //------------------------------------------------------------------\n    [COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE](cp) {\n        if (cp !== $.GREATER_THAN_SIGN && cp !== $.EOF) {\n            this._err(ERR.nestedComment);\n        }\n\n        this._reconsumeInState(COMMENT_END_STATE);\n    }\n\n    // Comment end dash state\n    //------------------------------------------------------------------\n    [COMMENT_END_DASH_STATE](cp) {\n        if (cp === $.HYPHEN_MINUS) {\n            this.state = COMMENT_END_STATE;\n        } else if (cp === $.EOF) {\n            this._err(ERR.eofInComment);\n            this._emitCurrentToken();\n            this._emitEOFToken();\n        } else {\n            this.currentToken.data += '-';\n            this._reconsumeInState(COMMENT_STATE);\n        }\n    }\n\n    // Comment end state\n    //------------------------------------------------------------------\n    [COMMENT_END_STATE](cp) {\n        if (cp === $.GREATER_THAN_SIGN) {\n            this.state = DATA_STATE;\n            this._emitCurrentToken();\n        } else if (cp === $.EXCLAMATION_MARK) {\n            this.state = COMMENT_END_BANG_STATE;\n        } else if (cp === $.HYPHEN_MINUS) {\n            this.currentToken.data += '-';\n        } else if (cp === $.EOF) {\n            this._err(ERR.eofInComment);\n            this._emitCurrentToken();\n            this._emitEOFToken();\n        } else {\n            this.currentToken.data += '--';\n            this._reconsumeInState(COMMENT_STATE);\n        }\n    }\n\n    // Comment end bang state\n    //------------------------------------------------------------------\n    [COMMENT_END_BANG_STATE](cp) {\n        if (cp === $.HYPHEN_MINUS) {\n            this.currentToken.data += '--!';\n            this.state = COMMENT_END_DASH_STATE;\n        } else if (cp === $.GREATER_THAN_SIGN) {\n            this._err(ERR.incorrectlyClosedComment);\n            this.state = DATA_STATE;\n            this._emitCurrentToken();\n        } else if (cp === $.EOF) {\n            this._err(ERR.eofInComment);\n            this._emitCurrentToken();\n            this._emitEOFToken();\n        } else {\n            this.currentToken.data += '--!';\n            this._reconsumeInState(COMMENT_STATE);\n        }\n    }\n\n    // DOCTYPE state\n    //------------------------------------------------------------------\n    [DOCTYPE_STATE](cp) {\n        if (isWhitespace(cp)) {\n            this.state = BEFORE_DOCTYPE_NAME_STATE;\n        } else if (cp === $.GREATER_THAN_SIGN) {\n            this._reconsumeInState(BEFORE_DOCTYPE_NAME_STATE);\n        } else if (cp === $.EOF) {\n            this._err(ERR.eofInDoctype);\n            this._createDoctypeToken(null);\n            this.currentToken.forceQuirks = true;\n            this._emitCurrentToken();\n            this._emitEOFToken();\n        } else {\n            this._err(ERR.missingWhitespaceBeforeDoctypeName);\n            this._reconsumeInState(BEFORE_DOCTYPE_NAME_STATE);\n        }\n    }\n\n    // Before DOCTYPE name state\n    //------------------------------------------------------------------\n    [BEFORE_DOCTYPE_NAME_STATE](cp) {\n        if (isWhitespace(cp)) {\n            return;\n        }\n\n        if (isAsciiUpper(cp)) {\n            this._createDoctypeToken(toAsciiLowerChar(cp));\n            this.state = DOCTYPE_NAME_STATE;\n        } else if (cp === $.NULL) {\n            this._err(ERR.unexpectedNullCharacter);\n            this._createDoctypeToken(unicode.REPLACEMENT_CHARACTER);\n            this.state = DOCTYPE_NAME_STATE;\n        } else if (cp === $.GREATER_THAN_SIGN) {\n            this._err(ERR.missingDoctypeName);\n            this._createDoctypeToken(null);\n            this.currentToken.forceQuirks = true;\n            this._emitCurrentToken();\n            this.state = DATA_STATE;\n        } else if (cp === $.EOF) {\n            this._err(ERR.eofInDoctype);\n            this._createDoctypeToken(null);\n            this.currentToken.forceQuirks = true;\n            this._emitCurrentToken();\n            this._emitEOFToken();\n        } else {\n            this._createDoctypeToken(toChar(cp));\n            this.state = DOCTYPE_NAME_STATE;\n        }\n    }\n\n    // DOCTYPE name state\n    //------------------------------------------------------------------\n    [DOCTYPE_NAME_STATE](cp) {\n        if (isWhitespace(cp)) {\n            this.state = AFTER_DOCTYPE_NAME_STATE;\n        } else if (cp === $.GREATER_THAN_SIGN) {\n            this.state = DATA_STATE;\n            this._emitCurrentToken();\n        } else if (isAsciiUpper(cp)) {\n            this.currentToken.name += toAsciiLowerChar(cp);\n        } else if (cp === $.NULL) {\n            this._err(ERR.unexpectedNullCharacter);\n            this.currentToken.name += unicode.REPLACEMENT_CHARACTER;\n        } else if (cp === $.EOF) {\n            this._err(ERR.eofInDoctype);\n            this.currentToken.forceQuirks = true;\n            this._emitCurrentToken();\n            this._emitEOFToken();\n        } else {\n            this.currentToken.name += toChar(cp);\n        }\n    }\n\n    // After DOCTYPE name state\n    //------------------------------------------------------------------\n    [AFTER_DOCTYPE_NAME_STATE](cp) {\n        if (isWhitespace(cp)) {\n            return;\n        }\n\n        if (cp === $.GREATER_THAN_SIGN) {\n            this.state = DATA_STATE;\n            this._emitCurrentToken();\n        } else if (cp === $.EOF) {\n            this._err(ERR.eofInDoctype);\n            this.currentToken.forceQuirks = true;\n            this._emitCurrentToken();\n            this._emitEOFToken();\n        } else if (this._consumeSequenceIfMatch($$.PUBLIC_STRING, cp, false)) {\n            this.state = AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE;\n        } else if (this._consumeSequenceIfMatch($$.SYSTEM_STRING, cp, false)) {\n            this.state = AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE;\n        }\n        //NOTE: sequence lookup can be abrupted by hibernation. In that case lookup\n        //results are no longer valid and we will need to start over.\n        else if (!this._ensureHibernation()) {\n            this._err(ERR.invalidCharacterSequenceAfterDoctypeName);\n            this.currentToken.forceQuirks = true;\n            this._reconsumeInState(BOGUS_DOCTYPE_STATE);\n        }\n    }\n\n    // After DOCTYPE public keyword state\n    //------------------------------------------------------------------\n    [AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE](cp) {\n        if (isWhitespace(cp)) {\n            this.state = BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE;\n        } else if (cp === $.QUOTATION_MARK) {\n            this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword);\n            this.currentToken.publicId = '';\n            this.state = DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE;\n        } else if (cp === $.APOSTROPHE) {\n            this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword);\n            this.currentToken.publicId = '';\n            this.state = DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE;\n        } else if (cp === $.GREATER_THAN_SIGN) {\n            this._err(ERR.missingDoctypePublicIdentifier);\n            this.currentToken.forceQuirks = true;\n            this.state = DATA_STATE;\n            this._emitCurrentToken();\n        } else if (cp === $.EOF) {\n            this._err(ERR.eofInDoctype);\n            this.currentToken.forceQuirks = true;\n            this._emitCurrentToken();\n            this._emitEOFToken();\n        } else {\n            this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier);\n            this.currentToken.forceQuirks = true;\n            this._reconsumeInState(BOGUS_DOCTYPE_STATE);\n        }\n    }\n\n    // Before DOCTYPE public identifier state\n    //------------------------------------------------------------------\n    [BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE](cp) {\n        if (isWhitespace(cp)) {\n            return;\n        }\n\n        if (cp === $.QUOTATION_MARK) {\n            this.currentToken.publicId = '';\n            this.state = DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE;\n        } else if (cp === $.APOSTROPHE) {\n            this.currentToken.publicId = '';\n            this.state = DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE;\n        } else if (cp === $.GREATER_THAN_SIGN) {\n            this._err(ERR.missingDoctypePublicIdentifier);\n            this.currentToken.forceQuirks = true;\n            this.state = DATA_STATE;\n            this._emitCurrentToken();\n        } else if (cp === $.EOF) {\n            this._err(ERR.eofInDoctype);\n            this.currentToken.forceQuirks = true;\n            this._emitCurrentToken();\n            this._emitEOFToken();\n        } else {\n            this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier);\n            this.currentToken.forceQuirks = true;\n            this._reconsumeInState(BOGUS_DOCTYPE_STATE);\n        }\n    }\n\n    // DOCTYPE public identifier (double-quoted) state\n    //------------------------------------------------------------------\n    [DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE](cp) {\n        if (cp === $.QUOTATION_MARK) {\n            this.state = AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE;\n        } else if (cp === $.NULL) {\n            this._err(ERR.unexpectedNullCharacter);\n            this.currentToken.publicId += unicode.REPLACEMENT_CHARACTER;\n        } else if (cp === $.GREATER_THAN_SIGN) {\n            this._err(ERR.abruptDoctypePublicIdentifier);\n            this.currentToken.forceQuirks = true;\n            this._emitCurrentToken();\n            this.state = DATA_STATE;\n        } else if (cp === $.EOF) {\n            this._err(ERR.eofInDoctype);\n            this.currentToken.forceQuirks = true;\n            this._emitCurrentToken();\n            this._emitEOFToken();\n        } else {\n            this.currentToken.publicId += toChar(cp);\n        }\n    }\n\n    // DOCTYPE public identifier (single-quoted) state\n    //------------------------------------------------------------------\n    [DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE](cp) {\n        if (cp === $.APOSTROPHE) {\n            this.state = AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE;\n        } else if (cp === $.NULL) {\n            this._err(ERR.unexpectedNullCharacter);\n            this.currentToken.publicId += unicode.REPLACEMENT_CHARACTER;\n        } else if (cp === $.GREATER_THAN_SIGN) {\n            this._err(ERR.abruptDoctypePublicIdentifier);\n            this.currentToken.forceQuirks = true;\n            this._emitCurrentToken();\n            this.state = DATA_STATE;\n        } else if (cp === $.EOF) {\n            this._err(ERR.eofInDoctype);\n            this.currentToken.forceQuirks = true;\n            this._emitCurrentToken();\n            this._emitEOFToken();\n        } else {\n            this.currentToken.publicId += toChar(cp);\n        }\n    }\n\n    // After DOCTYPE public identifier state\n    //------------------------------------------------------------------\n    [AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE](cp) {\n        if (isWhitespace(cp)) {\n            this.state = BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE;\n        } else if (cp === $.GREATER_THAN_SIGN) {\n            this.state = DATA_STATE;\n            this._emitCurrentToken();\n        } else if (cp === $.QUOTATION_MARK) {\n            this._err(ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);\n            this.currentToken.systemId = '';\n            this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;\n        } else if (cp === $.APOSTROPHE) {\n            this._err(ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);\n            this.currentToken.systemId = '';\n            this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;\n        } else if (cp === $.EOF) {\n            this._err(ERR.eofInDoctype);\n            this.currentToken.forceQuirks = true;\n            this._emitCurrentToken();\n            this._emitEOFToken();\n        } else {\n            this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);\n            this.currentToken.forceQuirks = true;\n            this._reconsumeInState(BOGUS_DOCTYPE_STATE);\n        }\n    }\n\n    // Between DOCTYPE public and system identifiers state\n    //------------------------------------------------------------------\n    [BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE](cp) {\n        if (isWhitespace(cp)) {\n            return;\n        }\n\n        if (cp === $.GREATER_THAN_SIGN) {\n            this._emitCurrentToken();\n            this.state = DATA_STATE;\n        } else if (cp === $.QUOTATION_MARK) {\n            this.currentToken.systemId = '';\n            this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;\n        } else if (cp === $.APOSTROPHE) {\n            this.currentToken.systemId = '';\n            this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;\n        } else if (cp === $.EOF) {\n            this._err(ERR.eofInDoctype);\n            this.currentToken.forceQuirks = true;\n            this._emitCurrentToken();\n            this._emitEOFToken();\n        } else {\n            this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);\n            this.currentToken.forceQuirks = true;\n            this._reconsumeInState(BOGUS_DOCTYPE_STATE);\n        }\n    }\n\n    // After DOCTYPE system keyword state\n    //------------------------------------------------------------------\n    [AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE](cp) {\n        if (isWhitespace(cp)) {\n            this.state = BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE;\n        } else if (cp === $.QUOTATION_MARK) {\n            this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword);\n            this.currentToken.systemId = '';\n            this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;\n        } else if (cp === $.APOSTROPHE) {\n            this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword);\n            this.currentToken.systemId = '';\n            this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;\n        } else if (cp === $.GREATER_THAN_SIGN) {\n            this._err(ERR.missingDoctypeSystemIdentifier);\n            this.currentToken.forceQuirks = true;\n            this.state = DATA_STATE;\n            this._emitCurrentToken();\n        } else if (cp === $.EOF) {\n            this._err(ERR.eofInDoctype);\n            this.currentToken.forceQuirks = true;\n            this._emitCurrentToken();\n            this._emitEOFToken();\n        } else {\n            this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);\n            this.currentToken.forceQuirks = true;\n            this._reconsumeInState(BOGUS_DOCTYPE_STATE);\n        }\n    }\n\n    // Before DOCTYPE system identifier state\n    //------------------------------------------------------------------\n    [BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE](cp) {\n        if (isWhitespace(cp)) {\n            return;\n        }\n\n        if (cp === $.QUOTATION_MARK) {\n            this.currentToken.systemId = '';\n            this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;\n        } else if (cp === $.APOSTROPHE) {\n            this.currentToken.systemId = '';\n            this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;\n        } else if (cp === $.GREATER_THAN_SIGN) {\n            this._err(ERR.missingDoctypeSystemIdentifier);\n            this.currentToken.forceQuirks = true;\n            this.state = DATA_STATE;\n            this._emitCurrentToken();\n        } else if (cp === $.EOF) {\n            this._err(ERR.eofInDoctype);\n            this.currentToken.forceQuirks = true;\n            this._emitCurrentToken();\n            this._emitEOFToken();\n        } else {\n            this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);\n            this.currentToken.forceQuirks = true;\n            this._reconsumeInState(BOGUS_DOCTYPE_STATE);\n        }\n    }\n\n    // DOCTYPE system identifier (double-quoted) state\n    //------------------------------------------------------------------\n    [DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE](cp) {\n        if (cp === $.QUOTATION_MARK) {\n            this.state = AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE;\n        } else if (cp === $.NULL) {\n            this._err(ERR.unexpectedNullCharacter);\n            this.currentToken.systemId += unicode.REPLACEMENT_CHARACTER;\n        } else if (cp === $.GREATER_THAN_SIGN) {\n            this._err(ERR.abruptDoctypeSystemIdentifier);\n            this.currentToken.forceQuirks = true;\n            this._emitCurrentToken();\n            this.state = DATA_STATE;\n        } else if (cp === $.EOF) {\n            this._err(ERR.eofInDoctype);\n            this.currentToken.forceQuirks = true;\n            this._emitCurrentToken();\n            this._emitEOFToken();\n        } else {\n            this.currentToken.systemId += toChar(cp);\n        }\n    }\n\n    // DOCTYPE system identifier (single-quoted) state\n    //------------------------------------------------------------------\n    [DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE](cp) {\n        if (cp === $.APOSTROPHE) {\n            this.state = AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE;\n        } else if (cp === $.NULL) {\n            this._err(ERR.unexpectedNullCharacter);\n            this.currentToken.systemId += unicode.REPLACEMENT_CHARACTER;\n        } else if (cp === $.GREATER_THAN_SIGN) {\n            this._err(ERR.abruptDoctypeSystemIdentifier);\n            this.currentToken.forceQuirks = true;\n            this._emitCurrentToken();\n            this.state = DATA_STATE;\n        } else if (cp === $.EOF) {\n            this._err(ERR.eofInDoctype);\n            this.currentToken.forceQuirks = true;\n            this._emitCurrentToken();\n            this._emitEOFToken();\n        } else {\n            this.currentToken.systemId += toChar(cp);\n        }\n    }\n\n    // After DOCTYPE system identifier state\n    //------------------------------------------------------------------\n    [AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE](cp) {\n        if (isWhitespace(cp)) {\n            return;\n        }\n\n        if (cp === $.GREATER_THAN_SIGN) {\n            this._emitCurrentToken();\n            this.state = DATA_STATE;\n        } else if (cp === $.EOF) {\n            this._err(ERR.eofInDoctype);\n            this.currentToken.forceQuirks = true;\n            this._emitCurrentToken();\n            this._emitEOFToken();\n        } else {\n            this._err(ERR.unexpectedCharacterAfterDoctypeSystemIdentifier);\n            this._reconsumeInState(BOGUS_DOCTYPE_STATE);\n        }\n    }\n\n    // Bogus DOCTYPE state\n    //------------------------------------------------------------------\n    [BOGUS_DOCTYPE_STATE](cp) {\n        if (cp === $.GREATER_THAN_SIGN) {\n            this._emitCurrentToken();\n            this.state = DATA_STATE;\n        } else if (cp === $.NULL) {\n            this._err(ERR.unexpectedNullCharacter);\n        } else if (cp === $.EOF) {\n            this._emitCurrentToken();\n            this._emitEOFToken();\n        }\n    }\n\n    // CDATA section state\n    //------------------------------------------------------------------\n    [CDATA_SECTION_STATE](cp) {\n        if (cp === $.RIGHT_SQUARE_BRACKET) {\n            this.state = CDATA_SECTION_BRACKET_STATE;\n        } else if (cp === $.EOF) {\n            this._err(ERR.eofInCdata);\n            this._emitEOFToken();\n        } else {\n            this._emitCodePoint(cp);\n        }\n    }\n\n    // CDATA section bracket state\n    //------------------------------------------------------------------\n    [CDATA_SECTION_BRACKET_STATE](cp) {\n        if (cp === $.RIGHT_SQUARE_BRACKET) {\n            this.state = CDATA_SECTION_END_STATE;\n        } else {\n            this._emitChars(']');\n            this._reconsumeInState(CDATA_SECTION_STATE);\n        }\n    }\n\n    // CDATA section end state\n    //------------------------------------------------------------------\n    [CDATA_SECTION_END_STATE](cp) {\n        if (cp === $.GREATER_THAN_SIGN) {\n            this.state = DATA_STATE;\n        } else if (cp === $.RIGHT_SQUARE_BRACKET) {\n            this._emitChars(']');\n        } else {\n            this._emitChars(']]');\n            this._reconsumeInState(CDATA_SECTION_STATE);\n        }\n    }\n\n    // Character reference state\n    //------------------------------------------------------------------\n    [CHARACTER_REFERENCE_STATE](cp) {\n        this.tempBuff = [$.AMPERSAND];\n\n        if (cp === $.NUMBER_SIGN) {\n            this.tempBuff.push(cp);\n            this.state = NUMERIC_CHARACTER_REFERENCE_STATE;\n        } else if (isAsciiAlphaNumeric(cp)) {\n            this._reconsumeInState(NAMED_CHARACTER_REFERENCE_STATE);\n        } else {\n            this._flushCodePointsConsumedAsCharacterReference();\n            this._reconsumeInState(this.returnState);\n        }\n    }\n\n    // Named character reference state\n    //------------------------------------------------------------------\n    [NAMED_CHARACTER_REFERENCE_STATE](cp) {\n        const matchResult = this._matchNamedCharacterReference(cp);\n\n        //NOTE: matching can be abrupted by hibernation. In that case match\n        //results are no longer valid and we will need to start over.\n        if (this._ensureHibernation()) {\n            this.tempBuff = [$.AMPERSAND];\n        } else if (matchResult) {\n            const withSemicolon = this.tempBuff[this.tempBuff.length - 1] === $.SEMICOLON;\n\n            if (!this._isCharacterReferenceAttributeQuirk(withSemicolon)) {\n                if (!withSemicolon) {\n                    this._errOnNextCodePoint(ERR.missingSemicolonAfterCharacterReference);\n                }\n\n                this.tempBuff = matchResult;\n            }\n\n            this._flushCodePointsConsumedAsCharacterReference();\n            this.state = this.returnState;\n        } else {\n            this._flushCodePointsConsumedAsCharacterReference();\n            this.state = AMBIGUOUS_AMPERSAND_STATE;\n        }\n    }\n\n    // Ambiguos ampersand state\n    //------------------------------------------------------------------\n    [AMBIGUOUS_AMPERSAND_STATE](cp) {\n        if (isAsciiAlphaNumeric(cp)) {\n            if (this._isCharacterReferenceInAttribute()) {\n                this.currentAttr.value += toChar(cp);\n            } else {\n                this._emitCodePoint(cp);\n            }\n        } else {\n            if (cp === $.SEMICOLON) {\n                this._err(ERR.unknownNamedCharacterReference);\n            }\n\n            this._reconsumeInState(this.returnState);\n        }\n    }\n\n    // Numeric character reference state\n    //------------------------------------------------------------------\n    [NUMERIC_CHARACTER_REFERENCE_STATE](cp) {\n        this.charRefCode = 0;\n\n        if (cp === $.LATIN_SMALL_X || cp === $.LATIN_CAPITAL_X) {\n            this.tempBuff.push(cp);\n            this.state = HEXADEMICAL_CHARACTER_REFERENCE_START_STATE;\n        } else {\n            this._reconsumeInState(DECIMAL_CHARACTER_REFERENCE_START_STATE);\n        }\n    }\n\n    // Hexademical character reference start state\n    //------------------------------------------------------------------\n    [HEXADEMICAL_CHARACTER_REFERENCE_START_STATE](cp) {\n        if (isAsciiHexDigit(cp)) {\n            this._reconsumeInState(HEXADEMICAL_CHARACTER_REFERENCE_STATE);\n        } else {\n            this._err(ERR.absenceOfDigitsInNumericCharacterReference);\n            this._flushCodePointsConsumedAsCharacterReference();\n            this._reconsumeInState(this.returnState);\n        }\n    }\n\n    // Decimal character reference start state\n    //------------------------------------------------------------------\n    [DECIMAL_CHARACTER_REFERENCE_START_STATE](cp) {\n        if (isAsciiDigit(cp)) {\n            this._reconsumeInState(DECIMAL_CHARACTER_REFERENCE_STATE);\n        } else {\n            this._err(ERR.absenceOfDigitsInNumericCharacterReference);\n            this._flushCodePointsConsumedAsCharacterReference();\n            this._reconsumeInState(this.returnState);\n        }\n    }\n\n    // Hexademical character reference state\n    //------------------------------------------------------------------\n    [HEXADEMICAL_CHARACTER_REFERENCE_STATE](cp) {\n        if (isAsciiUpperHexDigit(cp)) {\n            this.charRefCode = this.charRefCode * 16 + cp - 0x37;\n        } else if (isAsciiLowerHexDigit(cp)) {\n            this.charRefCode = this.charRefCode * 16 + cp - 0x57;\n        } else if (isAsciiDigit(cp)) {\n            this.charRefCode = this.charRefCode * 16 + cp - 0x30;\n        } else if (cp === $.SEMICOLON) {\n            this.state = NUMERIC_CHARACTER_REFERENCE_END_STATE;\n        } else {\n            this._err(ERR.missingSemicolonAfterCharacterReference);\n            this._reconsumeInState(NUMERIC_CHARACTER_REFERENCE_END_STATE);\n        }\n    }\n\n    // Decimal character reference state\n    //------------------------------------------------------------------\n    [DECIMAL_CHARACTER_REFERENCE_STATE](cp) {\n        if (isAsciiDigit(cp)) {\n            this.charRefCode = this.charRefCode * 10 + cp - 0x30;\n        } else if (cp === $.SEMICOLON) {\n            this.state = NUMERIC_CHARACTER_REFERENCE_END_STATE;\n        } else {\n            this._err(ERR.missingSemicolonAfterCharacterReference);\n            this._reconsumeInState(NUMERIC_CHARACTER_REFERENCE_END_STATE);\n        }\n    }\n\n    // Numeric character reference end state\n    //------------------------------------------------------------------\n    [NUMERIC_CHARACTER_REFERENCE_END_STATE]() {\n        if (this.charRefCode === $.NULL) {\n            this._err(ERR.nullCharacterReference);\n            this.charRefCode = $.REPLACEMENT_CHARACTER;\n        } else if (this.charRefCode > 0x10ffff) {\n            this._err(ERR.characterReferenceOutsideUnicodeRange);\n            this.charRefCode = $.REPLACEMENT_CHARACTER;\n        } else if (unicode.isSurrogate(this.charRefCode)) {\n            this._err(ERR.surrogateCharacterReference);\n            this.charRefCode = $.REPLACEMENT_CHARACTER;\n        } else if (unicode.isUndefinedCodePoint(this.charRefCode)) {\n            this._err(ERR.noncharacterCharacterReference);\n        } else if (unicode.isControlCodePoint(this.charRefCode) || this.charRefCode === $.CARRIAGE_RETURN) {\n            this._err(ERR.controlCharacterReference);\n\n            const replacement = C1_CONTROLS_REFERENCE_REPLACEMENTS[this.charRefCode];\n\n            if (replacement) {\n                this.charRefCode = replacement;\n            }\n        }\n\n        this.tempBuff = [this.charRefCode];\n\n        this._flushCodePointsConsumedAsCharacterReference();\n        this._reconsumeInState(this.returnState);\n    }\n}\n\n//Token types\nTokenizer.CHARACTER_TOKEN = 'CHARACTER_TOKEN';\nTokenizer.NULL_CHARACTER_TOKEN = 'NULL_CHARACTER_TOKEN';\nTokenizer.WHITESPACE_CHARACTER_TOKEN = 'WHITESPACE_CHARACTER_TOKEN';\nTokenizer.START_TAG_TOKEN = 'START_TAG_TOKEN';\nTokenizer.END_TAG_TOKEN = 'END_TAG_TOKEN';\nTokenizer.COMMENT_TOKEN = 'COMMENT_TOKEN';\nTokenizer.DOCTYPE_TOKEN = 'DOCTYPE_TOKEN';\nTokenizer.EOF_TOKEN = 'EOF_TOKEN';\nTokenizer.HIBERNATION_TOKEN = 'HIBERNATION_TOKEN';\n\n//Tokenizer initial states for different modes\nTokenizer.MODE = {\n    DATA: DATA_STATE,\n    RCDATA: RCDATA_STATE,\n    RAWTEXT: RAWTEXT_STATE,\n    SCRIPT_DATA: SCRIPT_DATA_STATE,\n    PLAINTEXT: PLAINTEXT_STATE\n};\n\n//Static\nTokenizer.getTokenAttr = function(token, attrName) {\n    for (let i = token.attrs.length - 1; i >= 0; i--) {\n        if (token.attrs[i].name === attrName) {\n            return token.attrs[i].value;\n        }\n    }\n\n    return null;\n};\n\nmodule.exports = Tokenizer;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/parse5/lib/tokenizer/index.js?");

/***/ }),

/***/ "./src/node_modules/parse5/lib/tokenizer/named-entity-data.js":
/*!********************************************************************!*\
  !*** ./src/node_modules/parse5/lib/tokenizer/named-entity-data.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n//NOTE: this file contains auto-generated array mapped radix tree that is used for the named entity references consumption\n//(details: https://github.com/inikulin/parse5/tree/master/scripts/generate-named-entity-data/README.md)\nmodule.exports = new Uint16Array([4,52,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,106,303,412,810,1432,1701,1796,1987,2114,2360,2420,2484,3170,3251,4140,4393,4575,4610,5106,5512,5728,6117,6274,6315,6345,6427,6516,7002,7910,8733,9323,9870,10170,10631,10893,11318,11386,11467,12773,13092,14474,14922,15448,15542,16419,17666,18166,18611,19004,19095,19298,19397,4,16,69,77,97,98,99,102,103,108,109,110,111,112,114,115,116,117,140,150,158,169,176,194,199,210,216,222,226,242,256,266,283,294,108,105,103,5,198,1,59,148,1,198,80,5,38,1,59,156,1,38,99,117,116,101,5,193,1,59,167,1,193,114,101,118,101,59,1,258,4,2,105,121,182,191,114,99,5,194,1,59,189,1,194,59,1,1040,114,59,3,55349,56580,114,97,118,101,5,192,1,59,208,1,192,112,104,97,59,1,913,97,99,114,59,1,256,100,59,1,10835,4,2,103,112,232,237,111,110,59,1,260,102,59,3,55349,56632,112,108,121,70,117,110,99,116,105,111,110,59,1,8289,105,110,103,5,197,1,59,264,1,197,4,2,99,115,272,277,114,59,3,55349,56476,105,103,110,59,1,8788,105,108,100,101,5,195,1,59,292,1,195,109,108,5,196,1,59,301,1,196,4,8,97,99,101,102,111,114,115,117,321,350,354,383,388,394,400,405,4,2,99,114,327,336,107,115,108,97,115,104,59,1,8726,4,2,118,119,342,345,59,1,10983,101,100,59,1,8966,121,59,1,1041,4,3,99,114,116,362,369,379,97,117,115,101,59,1,8757,110,111,117,108,108,105,115,59,1,8492,97,59,1,914,114,59,3,55349,56581,112,102,59,3,55349,56633,101,118,101,59,1,728,99,114,59,1,8492,109,112,101,113,59,1,8782,4,14,72,79,97,99,100,101,102,104,105,108,111,114,115,117,442,447,456,504,542,547,569,573,577,616,678,784,790,796,99,121,59,1,1063,80,89,5,169,1,59,454,1,169,4,3,99,112,121,464,470,497,117,116,101,59,1,262,4,2,59,105,476,478,1,8914,116,97,108,68,105,102,102,101,114,101,110,116,105,97,108,68,59,1,8517,108,101,121,115,59,1,8493,4,4,97,101,105,111,514,520,530,535,114,111,110,59,1,268,100,105,108,5,199,1,59,528,1,199,114,99,59,1,264,110,105,110,116,59,1,8752,111,116,59,1,266,4,2,100,110,553,560,105,108,108,97,59,1,184,116,101,114,68,111,116,59,1,183,114,59,1,8493,105,59,1,935,114,99,108,101,4,4,68,77,80,84,591,596,603,609,111,116,59,1,8857,105,110,117,115,59,1,8854,108,117,115,59,1,8853,105,109,101,115,59,1,8855,111,4,2,99,115,623,646,107,119,105,115,101,67,111,110,116,111,117,114,73,110,116,101,103,114,97,108,59,1,8754,101,67,117,114,108,121,4,2,68,81,658,671,111,117,98,108,101,81,117,111,116,101,59,1,8221,117,111,116,101,59,1,8217,4,4,108,110,112,117,688,701,736,753,111,110,4,2,59,101,696,698,1,8759,59,1,10868,4,3,103,105,116,709,717,722,114,117,101,110,116,59,1,8801,110,116,59,1,8751,111,117,114,73,110,116,101,103,114,97,108,59,1,8750,4,2,102,114,742,745,59,1,8450,111,100,117,99,116,59,1,8720,110,116,101,114,67,108,111,99,107,119,105,115,101,67,111,110,116,111,117,114,73,110,116,101,103,114,97,108,59,1,8755,111,115,115,59,1,10799,99,114,59,3,55349,56478,112,4,2,59,67,803,805,1,8915,97,112,59,1,8781,4,11,68,74,83,90,97,99,101,102,105,111,115,834,850,855,860,865,888,903,916,921,1011,1415,4,2,59,111,840,842,1,8517,116,114,97,104,100,59,1,10513,99,121,59,1,1026,99,121,59,1,1029,99,121,59,1,1039,4,3,103,114,115,873,879,883,103,101,114,59,1,8225,114,59,1,8609,104,118,59,1,10980,4,2,97,121,894,900,114,111,110,59,1,270,59,1,1044,108,4,2,59,116,910,912,1,8711,97,59,1,916,114,59,3,55349,56583,4,2,97,102,927,998,4,2,99,109,933,992,114,105,116,105,99,97,108,4,4,65,68,71,84,950,957,978,985,99,117,116,101,59,1,180,111,4,2,116,117,964,967,59,1,729,98,108,101,65,99,117,116,101,59,1,733,114,97,118,101,59,1,96,105,108,100,101,59,1,732,111,110,100,59,1,8900,102,101,114,101,110,116,105,97,108,68,59,1,8518,4,4,112,116,117,119,1021,1026,1048,1249,102,59,3,55349,56635,4,3,59,68,69,1034,1036,1041,1,168,111,116,59,1,8412,113,117,97,108,59,1,8784,98,108,101,4,6,67,68,76,82,85,86,1065,1082,1101,1189,1211,1236,111,110,116,111,117,114,73,110,116,101,103,114,97,108,59,1,8751,111,4,2,116,119,1089,1092,59,1,168,110,65,114,114,111,119,59,1,8659,4,2,101,111,1107,1141,102,116,4,3,65,82,84,1117,1124,1136,114,114,111,119,59,1,8656,105,103,104,116,65,114,114,111,119,59,1,8660,101,101,59,1,10980,110,103,4,2,76,82,1149,1177,101,102,116,4,2,65,82,1158,1165,114,114,111,119,59,1,10232,105,103,104,116,65,114,114,111,119,59,1,10234,105,103,104,116,65,114,114,111,119,59,1,10233,105,103,104,116,4,2,65,84,1199,1206,114,114,111,119,59,1,8658,101,101,59,1,8872,112,4,2,65,68,1218,1225,114,114,111,119,59,1,8657,111,119,110,65,114,114,111,119,59,1,8661,101,114,116,105,99,97,108,66,97,114,59,1,8741,110,4,6,65,66,76,82,84,97,1264,1292,1299,1352,1391,1408,114,114,111,119,4,3,59,66,85,1276,1278,1283,1,8595,97,114,59,1,10515,112,65,114,114,111,119,59,1,8693,114,101,118,101,59,1,785,101,102,116,4,3,82,84,86,1310,1323,1334,105,103,104,116,86,101,99,116,111,114,59,1,10576,101,101,86,101,99,116,111,114,59,1,10590,101,99,116,111,114,4,2,59,66,1345,1347,1,8637,97,114,59,1,10582,105,103,104,116,4,2,84,86,1362,1373,101,101,86,101,99,116,111,114,59,1,10591,101,99,116,111,114,4,2,59,66,1384,1386,1,8641,97,114,59,1,10583,101,101,4,2,59,65,1399,1401,1,8868,114,114,111,119,59,1,8615,114,114,111,119,59,1,8659,4,2,99,116,1421,1426,114,59,3,55349,56479,114,111,107,59,1,272,4,16,78,84,97,99,100,102,103,108,109,111,112,113,115,116,117,120,1466,1470,1478,1489,1515,1520,1525,1536,1544,1593,1609,1617,1650,1664,1668,1677,71,59,1,330,72,5,208,1,59,1476,1,208,99,117,116,101,5,201,1,59,1487,1,201,4,3,97,105,121,1497,1503,1512,114,111,110,59,1,282,114,99,5,202,1,59,1510,1,202,59,1,1069,111,116,59,1,278,114,59,3,55349,56584,114,97,118,101,5,200,1,59,1534,1,200,101,109,101,110,116,59,1,8712,4,2,97,112,1550,1555,99,114,59,1,274,116,121,4,2,83,86,1563,1576,109,97,108,108,83,113,117,97,114,101,59,1,9723,101,114,121,83,109,97,108,108,83,113,117,97,114,101,59,1,9643,4,2,103,112,1599,1604,111,110,59,1,280,102,59,3,55349,56636,115,105,108,111,110,59,1,917,117,4,2,97,105,1624,1640,108,4,2,59,84,1631,1633,1,10869,105,108,100,101,59,1,8770,108,105,98,114,105,117,109,59,1,8652,4,2,99,105,1656,1660,114,59,1,8496,109,59,1,10867,97,59,1,919,109,108,5,203,1,59,1675,1,203,4,2,105,112,1683,1689,115,116,115,59,1,8707,111,110,101,110,116,105,97,108,69,59,1,8519,4,5,99,102,105,111,115,1713,1717,1722,1762,1791,121,59,1,1060,114,59,3,55349,56585,108,108,101,100,4,2,83,86,1732,1745,109,97,108,108,83,113,117,97,114,101,59,1,9724,101,114,121,83,109,97,108,108,83,113,117,97,114,101,59,1,9642,4,3,112,114,117,1770,1775,1781,102,59,3,55349,56637,65,108,108,59,1,8704,114,105,101,114,116,114,102,59,1,8497,99,114,59,1,8497,4,12,74,84,97,98,99,100,102,103,111,114,115,116,1822,1827,1834,1848,1855,1877,1882,1887,1890,1896,1978,1984,99,121,59,1,1027,5,62,1,59,1832,1,62,109,109,97,4,2,59,100,1843,1845,1,915,59,1,988,114,101,118,101,59,1,286,4,3,101,105,121,1863,1869,1874,100,105,108,59,1,290,114,99,59,1,284,59,1,1043,111,116,59,1,288,114,59,3,55349,56586,59,1,8921,112,102,59,3,55349,56638,101,97,116,101,114,4,6,69,70,71,76,83,84,1915,1933,1944,1953,1959,1971,113,117,97,108,4,2,59,76,1925,1927,1,8805,101,115,115,59,1,8923,117,108,108,69,113,117,97,108,59,1,8807,114,101,97,116,101,114,59,1,10914,101,115,115,59,1,8823,108,97,110,116,69,113,117,97,108,59,1,10878,105,108,100,101,59,1,8819,99,114,59,3,55349,56482,59,1,8811,4,8,65,97,99,102,105,111,115,117,2005,2012,2026,2032,2036,2049,2073,2089,82,68,99,121,59,1,1066,4,2,99,116,2018,2023,101,107,59,1,711,59,1,94,105,114,99,59,1,292,114,59,1,8460,108,98,101,114,116,83,112,97,99,101,59,1,8459,4,2,112,114,2055,2059,102,59,1,8461,105,122,111,110,116,97,108,76,105,110,101,59,1,9472,4,2,99,116,2079,2083,114,59,1,8459,114,111,107,59,1,294,109,112,4,2,68,69,2097,2107,111,119,110,72,117,109,112,59,1,8782,113,117,97,108,59,1,8783,4,14,69,74,79,97,99,100,102,103,109,110,111,115,116,117,2144,2149,2155,2160,2171,2189,2194,2198,2209,2245,2307,2329,2334,2341,99,121,59,1,1045,108,105,103,59,1,306,99,121,59,1,1025,99,117,116,101,5,205,1,59,2169,1,205,4,2,105,121,2177,2186,114,99,5,206,1,59,2184,1,206,59,1,1048,111,116,59,1,304,114,59,1,8465,114,97,118,101,5,204,1,59,2207,1,204,4,3,59,97,112,2217,2219,2238,1,8465,4,2,99,103,2225,2229,114,59,1,298,105,110,97,114,121,73,59,1,8520,108,105,101,115,59,1,8658,4,2,116,118,2251,2281,4,2,59,101,2257,2259,1,8748,4,2,103,114,2265,2271,114,97,108,59,1,8747,115,101,99,116,105,111,110,59,1,8898,105,115,105,98,108,101,4,2,67,84,2293,2300,111,109,109,97,59,1,8291,105,109,101,115,59,1,8290,4,3,103,112,116,2315,2320,2325,111,110,59,1,302,102,59,3,55349,56640,97,59,1,921,99,114,59,1,8464,105,108,100,101,59,1,296,4,2,107,109,2347,2352,99,121,59,1,1030,108,5,207,1,59,2358,1,207,4,5,99,102,111,115,117,2372,2386,2391,2397,2414,4,2,105,121,2378,2383,114,99,59,1,308,59,1,1049,114,59,3,55349,56589,112,102,59,3,55349,56641,4,2,99,101,2403,2408,114,59,3,55349,56485,114,99,121,59,1,1032,107,99,121,59,1,1028,4,7,72,74,97,99,102,111,115,2436,2441,2446,2452,2467,2472,2478,99,121,59,1,1061,99,121,59,1,1036,112,112,97,59,1,922,4,2,101,121,2458,2464,100,105,108,59,1,310,59,1,1050,114,59,3,55349,56590,112,102,59,3,55349,56642,99,114,59,3,55349,56486,4,11,74,84,97,99,101,102,108,109,111,115,116,2508,2513,2520,2562,2585,2981,2986,3004,3011,3146,3167,99,121,59,1,1033,5,60,1,59,2518,1,60,4,5,99,109,110,112,114,2532,2538,2544,2548,2558,117,116,101,59,1,313,98,100,97,59,1,923,103,59,1,10218,108,97,99,101,116,114,102,59,1,8466,114,59,1,8606,4,3,97,101,121,2570,2576,2582,114,111,110,59,1,317,100,105,108,59,1,315,59,1,1051,4,2,102,115,2591,2907,116,4,10,65,67,68,70,82,84,85,86,97,114,2614,2663,2672,2728,2735,2760,2820,2870,2888,2895,4,2,110,114,2620,2633,103,108,101,66,114,97,99,107,101,116,59,1,10216,114,111,119,4,3,59,66,82,2644,2646,2651,1,8592,97,114,59,1,8676,105,103,104,116,65,114,114,111,119,59,1,8646,101,105,108,105,110,103,59,1,8968,111,4,2,117,119,2679,2692,98,108,101,66,114,97,99,107,101,116,59,1,10214,110,4,2,84,86,2699,2710,101,101,86,101,99,116,111,114,59,1,10593,101,99,116,111,114,4,2,59,66,2721,2723,1,8643,97,114,59,1,10585,108,111,111,114,59,1,8970,105,103,104,116,4,2,65,86,2745,2752,114,114,111,119,59,1,8596,101,99,116,111,114,59,1,10574,4,2,101,114,2766,2792,101,4,3,59,65,86,2775,2777,2784,1,8867,114,114,111,119,59,1,8612,101,99,116,111,114,59,1,10586,105,97,110,103,108,101,4,3,59,66,69,2806,2808,2813,1,8882,97,114,59,1,10703,113,117,97,108,59,1,8884,112,4,3,68,84,86,2829,2841,2852,111,119,110,86,101,99,116,111,114,59,1,10577,101,101,86,101,99,116,111,114,59,1,10592,101,99,116,111,114,4,2,59,66,2863,2865,1,8639,97,114,59,1,10584,101,99,116,111,114,4,2,59,66,2881,2883,1,8636,97,114,59,1,10578,114,114,111,119,59,1,8656,105,103,104,116,97,114,114,111,119,59,1,8660,115,4,6,69,70,71,76,83,84,2922,2936,2947,2956,2962,2974,113,117,97,108,71,114,101,97,116,101,114,59,1,8922,117,108,108,69,113,117,97,108,59,1,8806,114,101,97,116,101,114,59,1,8822,101,115,115,59,1,10913,108,97,110,116,69,113,117,97,108,59,1,10877,105,108,100,101,59,1,8818,114,59,3,55349,56591,4,2,59,101,2992,2994,1,8920,102,116,97,114,114,111,119,59,1,8666,105,100,111,116,59,1,319,4,3,110,112,119,3019,3110,3115,103,4,4,76,82,108,114,3030,3058,3070,3098,101,102,116,4,2,65,82,3039,3046,114,114,111,119,59,1,10229,105,103,104,116,65,114,114,111,119,59,1,10231,105,103,104,116,65,114,114,111,119,59,1,10230,101,102,116,4,2,97,114,3079,3086,114,114,111,119,59,1,10232,105,103,104,116,97,114,114,111,119,59,1,10234,105,103,104,116,97,114,114,111,119,59,1,10233,102,59,3,55349,56643,101,114,4,2,76,82,3123,3134,101,102,116,65,114,114,111,119,59,1,8601,105,103,104,116,65,114,114,111,119,59,1,8600,4,3,99,104,116,3154,3158,3161,114,59,1,8466,59,1,8624,114,111,107,59,1,321,59,1,8810,4,8,97,99,101,102,105,111,115,117,3188,3192,3196,3222,3227,3237,3243,3248,112,59,1,10501,121,59,1,1052,4,2,100,108,3202,3213,105,117,109,83,112,97,99,101,59,1,8287,108,105,110,116,114,102,59,1,8499,114,59,3,55349,56592,110,117,115,80,108,117,115,59,1,8723,112,102,59,3,55349,56644,99,114,59,1,8499,59,1,924,4,9,74,97,99,101,102,111,115,116,117,3271,3276,3283,3306,3422,3427,4120,4126,4137,99,121,59,1,1034,99,117,116,101,59,1,323,4,3,97,101,121,3291,3297,3303,114,111,110,59,1,327,100,105,108,59,1,325,59,1,1053,4,3,103,115,119,3314,3380,3415,97,116,105,118,101,4,3,77,84,86,3327,3340,3365,101,100,105,117,109,83,112,97,99,101,59,1,8203,104,105,4,2,99,110,3348,3357,107,83,112,97,99,101,59,1,8203,83,112,97,99,101,59,1,8203,101,114,121,84,104,105,110,83,112,97,99,101,59,1,8203,116,101,100,4,2,71,76,3389,3405,114,101,97,116,101,114,71,114,101,97,116,101,114,59,1,8811,101,115,115,76,101,115,115,59,1,8810,76,105,110,101,59,1,10,114,59,3,55349,56593,4,4,66,110,112,116,3437,3444,3460,3464,114,101,97,107,59,1,8288,66,114,101,97,107,105,110,103,83,112,97,99,101,59,1,160,102,59,1,8469,4,13,59,67,68,69,71,72,76,78,80,82,83,84,86,3492,3494,3517,3536,3578,3657,3685,3784,3823,3860,3915,4066,4107,1,10988,4,2,111,117,3500,3510,110,103,114,117,101,110,116,59,1,8802,112,67,97,112,59,1,8813,111,117,98,108,101,86,101,114,116,105,99,97,108,66,97,114,59,1,8742,4,3,108,113,120,3544,3552,3571,101,109,101,110,116,59,1,8713,117,97,108,4,2,59,84,3561,3563,1,8800,105,108,100,101,59,3,8770,824,105,115,116,115,59,1,8708,114,101,97,116,101,114,4,7,59,69,70,71,76,83,84,3600,3602,3609,3621,3631,3637,3650,1,8815,113,117,97,108,59,1,8817,117,108,108,69,113,117,97,108,59,3,8807,824,114,101,97,116,101,114,59,3,8811,824,101,115,115,59,1,8825,108,97,110,116,69,113,117,97,108,59,3,10878,824,105,108,100,101,59,1,8821,117,109,112,4,2,68,69,3666,3677,111,119,110,72,117,109,112,59,3,8782,824,113,117,97,108,59,3,8783,824,101,4,2,102,115,3692,3724,116,84,114,105,97,110,103,108,101,4,3,59,66,69,3709,3711,3717,1,8938,97,114,59,3,10703,824,113,117,97,108,59,1,8940,115,4,6,59,69,71,76,83,84,3739,3741,3748,3757,3764,3777,1,8814,113,117,97,108,59,1,8816,114,101,97,116,101,114,59,1,8824,101,115,115,59,3,8810,824,108,97,110,116,69,113,117,97,108,59,3,10877,824,105,108,100,101,59,1,8820,101,115,116,101,100,4,2,71,76,3795,3812,114,101,97,116,101,114,71,114,101,97,116,101,114,59,3,10914,824,101,115,115,76,101,115,115,59,3,10913,824,114,101,99,101,100,101,115,4,3,59,69,83,3838,3840,3848,1,8832,113,117,97,108,59,3,10927,824,108,97,110,116,69,113,117,97,108,59,1,8928,4,2,101,105,3866,3881,118,101,114,115,101,69,108,101,109,101,110,116,59,1,8716,103,104,116,84,114,105,97,110,103,108,101,4,3,59,66,69,3900,3902,3908,1,8939,97,114,59,3,10704,824,113,117,97,108,59,1,8941,4,2,113,117,3921,3973,117,97,114,101,83,117,4,2,98,112,3933,3952,115,101,116,4,2,59,69,3942,3945,3,8847,824,113,117,97,108,59,1,8930,101,114,115,101,116,4,2,59,69,3963,3966,3,8848,824,113,117,97,108,59,1,8931,4,3,98,99,112,3981,4000,4045,115,101,116,4,2,59,69,3990,3993,3,8834,8402,113,117,97,108,59,1,8840,99,101,101,100,115,4,4,59,69,83,84,4015,4017,4025,4037,1,8833,113,117,97,108,59,3,10928,824,108,97,110,116,69,113,117,97,108,59,1,8929,105,108,100,101,59,3,8831,824,101,114,115,101,116,4,2,59,69,4056,4059,3,8835,8402,113,117,97,108,59,1,8841,105,108,100,101,4,4,59,69,70,84,4080,4082,4089,4100,1,8769,113,117,97,108,59,1,8772,117,108,108,69,113,117,97,108,59,1,8775,105,108,100,101,59,1,8777,101,114,116,105,99,97,108,66,97,114,59,1,8740,99,114,59,3,55349,56489,105,108,100,101,5,209,1,59,4135,1,209,59,1,925,4,14,69,97,99,100,102,103,109,111,112,114,115,116,117,118,4170,4176,4187,4205,4212,4217,4228,4253,4259,4292,4295,4316,4337,4346,108,105,103,59,1,338,99,117,116,101,5,211,1,59,4185,1,211,4,2,105,121,4193,4202,114,99,5,212,1,59,4200,1,212,59,1,1054,98,108,97,99,59,1,336,114,59,3,55349,56594,114,97,118,101,5,210,1,59,4226,1,210,4,3,97,101,105,4236,4241,4246,99,114,59,1,332,103,97,59,1,937,99,114,111,110,59,1,927,112,102,59,3,55349,56646,101,110,67,117,114,108,121,4,2,68,81,4272,4285,111,117,98,108,101,81,117,111,116,101,59,1,8220,117,111,116,101,59,1,8216,59,1,10836,4,2,99,108,4301,4306,114,59,3,55349,56490,97,115,104,5,216,1,59,4314,1,216,105,4,2,108,109,4323,4332,100,101,5,213,1,59,4330,1,213,101,115,59,1,10807,109,108,5,214,1,59,4344,1,214,101,114,4,2,66,80,4354,4380,4,2,97,114,4360,4364,114,59,1,8254,97,99,4,2,101,107,4372,4375,59,1,9182,101,116,59,1,9140,97,114,101,110,116,104,101,115,105,115,59,1,9180,4,9,97,99,102,104,105,108,111,114,115,4413,4422,4426,4431,4435,4438,4448,4471,4561,114,116,105,97,108,68,59,1,8706,121,59,1,1055,114,59,3,55349,56595,105,59,1,934,59,1,928,117,115,77,105,110,117,115,59,1,177,4,2,105,112,4454,4467,110,99,97,114,101,112,108,97,110,101,59,1,8460,102,59,1,8473,4,4,59,101,105,111,4481,4483,4526,4531,1,10939,99,101,100,101,115,4,4,59,69,83,84,4498,4500,4507,4519,1,8826,113,117,97,108,59,1,10927,108,97,110,116,69,113,117,97,108,59,1,8828,105,108,100,101,59,1,8830,109,101,59,1,8243,4,2,100,112,4537,4543,117,99,116,59,1,8719,111,114,116,105,111,110,4,2,59,97,4555,4557,1,8759,108,59,1,8733,4,2,99,105,4567,4572,114,59,3,55349,56491,59,1,936,4,4,85,102,111,115,4585,4594,4599,4604,79,84,5,34,1,59,4592,1,34,114,59,3,55349,56596,112,102,59,1,8474,99,114,59,3,55349,56492,4,12,66,69,97,99,101,102,104,105,111,114,115,117,4636,4642,4650,4681,4704,4763,4767,4771,5047,5069,5081,5094,97,114,114,59,1,10512,71,5,174,1,59,4648,1,174,4,3,99,110,114,4658,4664,4668,117,116,101,59,1,340,103,59,1,10219,114,4,2,59,116,4675,4677,1,8608,108,59,1,10518,4,3,97,101,121,4689,4695,4701,114,111,110,59,1,344,100,105,108,59,1,342,59,1,1056,4,2,59,118,4710,4712,1,8476,101,114,115,101,4,2,69,85,4722,4748,4,2,108,113,4728,4736,101,109,101,110,116,59,1,8715,117,105,108,105,98,114,105,117,109,59,1,8651,112,69,113,117,105,108,105,98,114,105,117,109,59,1,10607,114,59,1,8476,111,59,1,929,103,104,116,4,8,65,67,68,70,84,85,86,97,4792,4840,4849,4905,4912,4972,5022,5040,4,2,110,114,4798,4811,103,108,101,66,114,97,99,107,101,116,59,1,10217,114,111,119,4,3,59,66,76,4822,4824,4829,1,8594,97,114,59,1,8677,101,102,116,65,114,114,111,119,59,1,8644,101,105,108,105,110,103,59,1,8969,111,4,2,117,119,4856,4869,98,108,101,66,114,97,99,107,101,116,59,1,10215,110,4,2,84,86,4876,4887,101,101,86,101,99,116,111,114,59,1,10589,101,99,116,111,114,4,2,59,66,4898,4900,1,8642,97,114,59,1,10581,108,111,111,114,59,1,8971,4,2,101,114,4918,4944,101,4,3,59,65,86,4927,4929,4936,1,8866,114,114,111,119,59,1,8614,101,99,116,111,114,59,1,10587,105,97,110,103,108,101,4,3,59,66,69,4958,4960,4965,1,8883,97,114,59,1,10704,113,117,97,108,59,1,8885,112,4,3,68,84,86,4981,4993,5004,111,119,110,86,101,99,116,111,114,59,1,10575,101,101,86,101,99,116,111,114,59,1,10588,101,99,116,111,114,4,2,59,66,5015,5017,1,8638,97,114,59,1,10580,101,99,116,111,114,4,2,59,66,5033,5035,1,8640,97,114,59,1,10579,114,114,111,119,59,1,8658,4,2,112,117,5053,5057,102,59,1,8477,110,100,73,109,112,108,105,101,115,59,1,10608,105,103,104,116,97,114,114,111,119,59,1,8667,4,2,99,104,5087,5091,114,59,1,8475,59,1,8625,108,101,68,101,108,97,121,101,100,59,1,10740,4,13,72,79,97,99,102,104,105,109,111,113,115,116,117,5134,5150,5157,5164,5198,5203,5259,5265,5277,5283,5374,5380,5385,4,2,67,99,5140,5146,72,99,121,59,1,1065,121,59,1,1064,70,84,99,121,59,1,1068,99,117,116,101,59,1,346,4,5,59,97,101,105,121,5176,5178,5184,5190,5195,1,10940,114,111,110,59,1,352,100,105,108,59,1,350,114,99,59,1,348,59,1,1057,114,59,3,55349,56598,111,114,116,4,4,68,76,82,85,5216,5227,5238,5250,111,119,110,65,114,114,111,119,59,1,8595,101,102,116,65,114,114,111,119,59,1,8592,105,103,104,116,65,114,114,111,119,59,1,8594,112,65,114,114,111,119,59,1,8593,103,109,97,59,1,931,97,108,108,67,105,114,99,108,101,59,1,8728,112,102,59,3,55349,56650,4,2,114,117,5289,5293,116,59,1,8730,97,114,101,4,4,59,73,83,85,5306,5308,5322,5367,1,9633,110,116,101,114,115,101,99,116,105,111,110,59,1,8851,117,4,2,98,112,5329,5347,115,101,116,4,2,59,69,5338,5340,1,8847,113,117,97,108,59,1,8849,101,114,115,101,116,4,2,59,69,5358,5360,1,8848,113,117,97,108,59,1,8850,110,105,111,110,59,1,8852,99,114,59,3,55349,56494,97,114,59,1,8902,4,4,98,99,109,112,5395,5420,5475,5478,4,2,59,115,5401,5403,1,8912,101,116,4,2,59,69,5411,5413,1,8912,113,117,97,108,59,1,8838,4,2,99,104,5426,5468,101,101,100,115,4,4,59,69,83,84,5440,5442,5449,5461,1,8827,113,117,97,108,59,1,10928,108,97,110,116,69,113,117,97,108,59,1,8829,105,108,100,101,59,1,8831,84,104,97,116,59,1,8715,59,1,8721,4,3,59,101,115,5486,5488,5507,1,8913,114,115,101,116,4,2,59,69,5498,5500,1,8835,113,117,97,108,59,1,8839,101,116,59,1,8913,4,11,72,82,83,97,99,102,104,105,111,114,115,5536,5546,5552,5567,5579,5602,5607,5655,5695,5701,5711,79,82,78,5,222,1,59,5544,1,222,65,68,69,59,1,8482,4,2,72,99,5558,5563,99,121,59,1,1035,121,59,1,1062,4,2,98,117,5573,5576,59,1,9,59,1,932,4,3,97,101,121,5587,5593,5599,114,111,110,59,1,356,100,105,108,59,1,354,59,1,1058,114,59,3,55349,56599,4,2,101,105,5613,5631,4,2,114,116,5619,5627,101,102,111,114,101,59,1,8756,97,59,1,920,4,2,99,110,5637,5647,107,83,112,97,99,101,59,3,8287,8202,83,112,97,99,101,59,1,8201,108,100,101,4,4,59,69,70,84,5668,5670,5677,5688,1,8764,113,117,97,108,59,1,8771,117,108,108,69,113,117,97,108,59,1,8773,105,108,100,101,59,1,8776,112,102,59,3,55349,56651,105,112,108,101,68,111,116,59,1,8411,4,2,99,116,5717,5722,114,59,3,55349,56495,114,111,107,59,1,358,4,14,97,98,99,100,102,103,109,110,111,112,114,115,116,117,5758,5789,5805,5823,5830,5835,5846,5852,5921,5937,6089,6095,6101,6108,4,2,99,114,5764,5774,117,116,101,5,218,1,59,5772,1,218,114,4,2,59,111,5781,5783,1,8607,99,105,114,59,1,10569,114,4,2,99,101,5796,5800,121,59,1,1038,118,101,59,1,364,4,2,105,121,5811,5820,114,99,5,219,1,59,5818,1,219,59,1,1059,98,108,97,99,59,1,368,114,59,3,55349,56600,114,97,118,101,5,217,1,59,5844,1,217,97,99,114,59,1,362,4,2,100,105,5858,5905,101,114,4,2,66,80,5866,5892,4,2,97,114,5872,5876,114,59,1,95,97,99,4,2,101,107,5884,5887,59,1,9183,101,116,59,1,9141,97,114,101,110,116,104,101,115,105,115,59,1,9181,111,110,4,2,59,80,5913,5915,1,8899,108,117,115,59,1,8846,4,2,103,112,5927,5932,111,110,59,1,370,102,59,3,55349,56652,4,8,65,68,69,84,97,100,112,115,5955,5985,5996,6009,6026,6033,6044,6075,114,114,111,119,4,3,59,66,68,5967,5969,5974,1,8593,97,114,59,1,10514,111,119,110,65,114,114,111,119,59,1,8645,111,119,110,65,114,114,111,119,59,1,8597,113,117,105,108,105,98,114,105,117,109,59,1,10606,101,101,4,2,59,65,6017,6019,1,8869,114,114,111,119,59,1,8613,114,114,111,119,59,1,8657,111,119,110,97,114,114,111,119,59,1,8661,101,114,4,2,76,82,6052,6063,101,102,116,65,114,114,111,119,59,1,8598,105,103,104,116,65,114,114,111,119,59,1,8599,105,4,2,59,108,6082,6084,1,978,111,110,59,1,933,105,110,103,59,1,366,99,114,59,3,55349,56496,105,108,100,101,59,1,360,109,108,5,220,1,59,6115,1,220,4,9,68,98,99,100,101,102,111,115,118,6137,6143,6148,6152,6166,6250,6255,6261,6267,97,115,104,59,1,8875,97,114,59,1,10987,121,59,1,1042,97,115,104,4,2,59,108,6161,6163,1,8873,59,1,10982,4,2,101,114,6172,6175,59,1,8897,4,3,98,116,121,6183,6188,6238,97,114,59,1,8214,4,2,59,105,6194,6196,1,8214,99,97,108,4,4,66,76,83,84,6209,6214,6220,6231,97,114,59,1,8739,105,110,101,59,1,124,101,112,97,114,97,116,111,114,59,1,10072,105,108,100,101,59,1,8768,84,104,105,110,83,112,97,99,101,59,1,8202,114,59,3,55349,56601,112,102,59,3,55349,56653,99,114,59,3,55349,56497,100,97,115,104,59,1,8874,4,5,99,101,102,111,115,6286,6292,6298,6303,6309,105,114,99,59,1,372,100,103,101,59,1,8896,114,59,3,55349,56602,112,102,59,3,55349,56654,99,114,59,3,55349,56498,4,4,102,105,111,115,6325,6330,6333,6339,114,59,3,55349,56603,59,1,926,112,102,59,3,55349,56655,99,114,59,3,55349,56499,4,9,65,73,85,97,99,102,111,115,117,6365,6370,6375,6380,6391,6405,6410,6416,6422,99,121,59,1,1071,99,121,59,1,1031,99,121,59,1,1070,99,117,116,101,5,221,1,59,6389,1,221,4,2,105,121,6397,6402,114,99,59,1,374,59,1,1067,114,59,3,55349,56604,112,102,59,3,55349,56656,99,114,59,3,55349,56500,109,108,59,1,376,4,8,72,97,99,100,101,102,111,115,6445,6450,6457,6472,6477,6501,6505,6510,99,121,59,1,1046,99,117,116,101,59,1,377,4,2,97,121,6463,6469,114,111,110,59,1,381,59,1,1047,111,116,59,1,379,4,2,114,116,6483,6497,111,87,105,100,116,104,83,112,97,99,101,59,1,8203,97,59,1,918,114,59,1,8488,112,102,59,1,8484,99,114,59,3,55349,56501,4,16,97,98,99,101,102,103,108,109,110,111,112,114,115,116,117,119,6550,6561,6568,6612,6622,6634,6645,6672,6699,6854,6870,6923,6933,6963,6974,6983,99,117,116,101,5,225,1,59,6559,1,225,114,101,118,101,59,1,259,4,6,59,69,100,105,117,121,6582,6584,6588,6591,6600,6609,1,8766,59,3,8766,819,59,1,8767,114,99,5,226,1,59,6598,1,226,116,101,5,180,1,59,6607,1,180,59,1,1072,108,105,103,5,230,1,59,6620,1,230,4,2,59,114,6628,6630,1,8289,59,3,55349,56606,114,97,118,101,5,224,1,59,6643,1,224,4,2,101,112,6651,6667,4,2,102,112,6657,6663,115,121,109,59,1,8501,104,59,1,8501,104,97,59,1,945,4,2,97,112,6678,6692,4,2,99,108,6684,6688,114,59,1,257,103,59,1,10815,5,38,1,59,6697,1,38,4,2,100,103,6705,6737,4,5,59,97,100,115,118,6717,6719,6724,6727,6734,1,8743,110,100,59,1,10837,59,1,10844,108,111,112,101,59,1,10840,59,1,10842,4,7,59,101,108,109,114,115,122,6753,6755,6758,6762,6814,6835,6848,1,8736,59,1,10660,101,59,1,8736,115,100,4,2,59,97,6770,6772,1,8737,4,8,97,98,99,100,101,102,103,104,6790,6793,6796,6799,6802,6805,6808,6811,59,1,10664,59,1,10665,59,1,10666,59,1,10667,59,1,10668,59,1,10669,59,1,10670,59,1,10671,116,4,2,59,118,6821,6823,1,8735,98,4,2,59,100,6830,6832,1,8894,59,1,10653,4,2,112,116,6841,6845,104,59,1,8738,59,1,197,97,114,114,59,1,9084,4,2,103,112,6860,6865,111,110,59,1,261,102,59,3,55349,56658,4,7,59,69,97,101,105,111,112,6886,6888,6891,6897,6900,6904,6908,1,8776,59,1,10864,99,105,114,59,1,10863,59,1,8778,100,59,1,8779,115,59,1,39,114,111,120,4,2,59,101,6917,6919,1,8776,113,59,1,8778,105,110,103,5,229,1,59,6931,1,229,4,3,99,116,121,6941,6946,6949,114,59,3,55349,56502,59,1,42,109,112,4,2,59,101,6957,6959,1,8776,113,59,1,8781,105,108,100,101,5,227,1,59,6972,1,227,109,108,5,228,1,59,6981,1,228,4,2,99,105,6989,6997,111,110,105,110,116,59,1,8755,110,116,59,1,10769,4,16,78,97,98,99,100,101,102,105,107,108,110,111,112,114,115,117,7036,7041,7119,7135,7149,7155,7219,7224,7347,7354,7463,7489,7786,7793,7814,7866,111,116,59,1,10989,4,2,99,114,7047,7094,107,4,4,99,101,112,115,7058,7064,7073,7080,111,110,103,59,1,8780,112,115,105,108,111,110,59,1,1014,114,105,109,101,59,1,8245,105,109,4,2,59,101,7088,7090,1,8765,113,59,1,8909,4,2,118,119,7100,7105,101,101,59,1,8893,101,100,4,2,59,103,7113,7115,1,8965,101,59,1,8965,114,107,4,2,59,116,7127,7129,1,9141,98,114,107,59,1,9142,4,2,111,121,7141,7146,110,103,59,1,8780,59,1,1073,113,117,111,59,1,8222,4,5,99,109,112,114,116,7167,7181,7188,7193,7199,97,117,115,4,2,59,101,7176,7178,1,8757,59,1,8757,112,116,121,118,59,1,10672,115,105,59,1,1014,110,111,117,59,1,8492,4,3,97,104,119,7207,7210,7213,59,1,946,59,1,8502,101,101,110,59,1,8812,114,59,3,55349,56607,103,4,7,99,111,115,116,117,118,119,7241,7262,7288,7305,7328,7335,7340,4,3,97,105,117,7249,7253,7258,112,59,1,8898,114,99,59,1,9711,112,59,1,8899,4,3,100,112,116,7270,7275,7281,111,116,59,1,10752,108,117,115,59,1,10753,105,109,101,115,59,1,10754,4,2,113,116,7294,7300,99,117,112,59,1,10758,97,114,59,1,9733,114,105,97,110,103,108,101,4,2,100,117,7318,7324,111,119,110,59,1,9661,112,59,1,9651,112,108,117,115,59,1,10756,101,101,59,1,8897,101,100,103,101,59,1,8896,97,114,111,119,59,1,10509,4,3,97,107,111,7362,7436,7458,4,2,99,110,7368,7432,107,4,3,108,115,116,7377,7386,7394,111,122,101,110,103,101,59,1,10731,113,117,97,114,101,59,1,9642,114,105,97,110,103,108,101,4,4,59,100,108,114,7411,7413,7419,7425,1,9652,111,119,110,59,1,9662,101,102,116,59,1,9666,105,103,104,116,59,1,9656,107,59,1,9251,4,2,49,51,7442,7454,4,2,50,52,7448,7451,59,1,9618,59,1,9617,52,59,1,9619,99,107,59,1,9608,4,2,101,111,7469,7485,4,2,59,113,7475,7478,3,61,8421,117,105,118,59,3,8801,8421,116,59,1,8976,4,4,112,116,119,120,7499,7504,7517,7523,102,59,3,55349,56659,4,2,59,116,7510,7512,1,8869,111,109,59,1,8869,116,105,101,59,1,8904,4,12,68,72,85,86,98,100,104,109,112,116,117,118,7549,7571,7597,7619,7655,7660,7682,7708,7715,7721,7728,7750,4,4,76,82,108,114,7559,7562,7565,7568,59,1,9559,59,1,9556,59,1,9558,59,1,9555,4,5,59,68,85,100,117,7583,7585,7588,7591,7594,1,9552,59,1,9574,59,1,9577,59,1,9572,59,1,9575,4,4,76,82,108,114,7607,7610,7613,7616,59,1,9565,59,1,9562,59,1,9564,59,1,9561,4,7,59,72,76,82,104,108,114,7635,7637,7640,7643,7646,7649,7652,1,9553,59,1,9580,59,1,9571,59,1,9568,59,1,9579,59,1,9570,59,1,9567,111,120,59,1,10697,4,4,76,82,108,114,7670,7673,7676,7679,59,1,9557,59,1,9554,59,1,9488,59,1,9484,4,5,59,68,85,100,117,7694,7696,7699,7702,7705,1,9472,59,1,9573,59,1,9576,59,1,9516,59,1,9524,105,110,117,115,59,1,8863,108,117,115,59,1,8862,105,109,101,115,59,1,8864,4,4,76,82,108,114,7738,7741,7744,7747,59,1,9563,59,1,9560,59,1,9496,59,1,9492,4,7,59,72,76,82,104,108,114,7766,7768,7771,7774,7777,7780,7783,1,9474,59,1,9578,59,1,9569,59,1,9566,59,1,9532,59,1,9508,59,1,9500,114,105,109,101,59,1,8245,4,2,101,118,7799,7804,118,101,59,1,728,98,97,114,5,166,1,59,7812,1,166,4,4,99,101,105,111,7824,7829,7834,7846,114,59,3,55349,56503,109,105,59,1,8271,109,4,2,59,101,7841,7843,1,8765,59,1,8909,108,4,3,59,98,104,7855,7857,7860,1,92,59,1,10693,115,117,98,59,1,10184,4,2,108,109,7872,7885,108,4,2,59,101,7879,7881,1,8226,116,59,1,8226,112,4,3,59,69,101,7894,7896,7899,1,8782,59,1,10926,4,2,59,113,7905,7907,1,8783,59,1,8783,4,15,97,99,100,101,102,104,105,108,111,114,115,116,117,119,121,7942,8021,8075,8080,8121,8126,8157,8279,8295,8430,8446,8485,8491,8707,8726,4,3,99,112,114,7950,7956,8007,117,116,101,59,1,263,4,6,59,97,98,99,100,115,7970,7972,7977,7984,7998,8003,1,8745,110,100,59,1,10820,114,99,117,112,59,1,10825,4,2,97,117,7990,7994,112,59,1,10827,112,59,1,10823,111,116,59,1,10816,59,3,8745,65024,4,2,101,111,8013,8017,116,59,1,8257,110,59,1,711,4,4,97,101,105,117,8031,8046,8056,8061,4,2,112,114,8037,8041,115,59,1,10829,111,110,59,1,269,100,105,108,5,231,1,59,8054,1,231,114,99,59,1,265,112,115,4,2,59,115,8069,8071,1,10828,109,59,1,10832,111,116,59,1,267,4,3,100,109,110,8088,8097,8104,105,108,5,184,1,59,8095,1,184,112,116,121,118,59,1,10674,116,5,162,2,59,101,8112,8114,1,162,114,100,111,116,59,1,183,114,59,3,55349,56608,4,3,99,101,105,8134,8138,8154,121,59,1,1095,99,107,4,2,59,109,8146,8148,1,10003,97,114,107,59,1,10003,59,1,967,114,4,7,59,69,99,101,102,109,115,8174,8176,8179,8258,8261,8268,8273,1,9675,59,1,10691,4,3,59,101,108,8187,8189,8193,1,710,113,59,1,8791,101,4,2,97,100,8200,8223,114,114,111,119,4,2,108,114,8210,8216,101,102,116,59,1,8634,105,103,104,116,59,1,8635,4,5,82,83,97,99,100,8235,8238,8241,8246,8252,59,1,174,59,1,9416,115,116,59,1,8859,105,114,99,59,1,8858,97,115,104,59,1,8861,59,1,8791,110,105,110,116,59,1,10768,105,100,59,1,10991,99,105,114,59,1,10690,117,98,115,4,2,59,117,8288,8290,1,9827,105,116,59,1,9827,4,4,108,109,110,112,8305,8326,8376,8400,111,110,4,2,59,101,8313,8315,1,58,4,2,59,113,8321,8323,1,8788,59,1,8788,4,2,109,112,8332,8344,97,4,2,59,116,8339,8341,1,44,59,1,64,4,3,59,102,108,8352,8354,8358,1,8705,110,59,1,8728,101,4,2,109,120,8365,8371,101,110,116,59,1,8705,101,115,59,1,8450,4,2,103,105,8382,8395,4,2,59,100,8388,8390,1,8773,111,116,59,1,10861,110,116,59,1,8750,4,3,102,114,121,8408,8412,8417,59,3,55349,56660,111,100,59,1,8720,5,169,2,59,115,8424,8426,1,169,114,59,1,8471,4,2,97,111,8436,8441,114,114,59,1,8629,115,115,59,1,10007,4,2,99,117,8452,8457,114,59,3,55349,56504,4,2,98,112,8463,8474,4,2,59,101,8469,8471,1,10959,59,1,10961,4,2,59,101,8480,8482,1,10960,59,1,10962,100,111,116,59,1,8943,4,7,100,101,108,112,114,118,119,8507,8522,8536,8550,8600,8697,8702,97,114,114,4,2,108,114,8516,8519,59,1,10552,59,1,10549,4,2,112,115,8528,8532,114,59,1,8926,99,59,1,8927,97,114,114,4,2,59,112,8545,8547,1,8630,59,1,10557,4,6,59,98,99,100,111,115,8564,8566,8573,8587,8592,8596,1,8746,114,99,97,112,59,1,10824,4,2,97,117,8579,8583,112,59,1,10822,112,59,1,10826,111,116,59,1,8845,114,59,1,10821,59,3,8746,65024,4,4,97,108,114,118,8610,8623,8663,8672,114,114,4,2,59,109,8618,8620,1,8631,59,1,10556,121,4,3,101,118,119,8632,8651,8656,113,4,2,112,115,8639,8645,114,101,99,59,1,8926,117,99,99,59,1,8927,101,101,59,1,8910,101,100,103,101,59,1,8911,101,110,5,164,1,59,8670,1,164,101,97,114,114,111,119,4,2,108,114,8684,8690,101,102,116,59,1,8630,105,103,104,116,59,1,8631,101,101,59,1,8910,101,100,59,1,8911,4,2,99,105,8713,8721,111,110,105,110,116,59,1,8754,110,116,59,1,8753,108,99,116,121,59,1,9005,4,19,65,72,97,98,99,100,101,102,104,105,106,108,111,114,115,116,117,119,122,8773,8778,8783,8821,8839,8854,8887,8914,8930,8944,9036,9041,9058,9197,9227,9258,9281,9297,9305,114,114,59,1,8659,97,114,59,1,10597,4,4,103,108,114,115,8793,8799,8805,8809,103,101,114,59,1,8224,101,116,104,59,1,8504,114,59,1,8595,104,4,2,59,118,8816,8818,1,8208,59,1,8867,4,2,107,108,8827,8834,97,114,111,119,59,1,10511,97,99,59,1,733,4,2,97,121,8845,8851,114,111,110,59,1,271,59,1,1076,4,3,59,97,111,8862,8864,8880,1,8518,4,2,103,114,8870,8876,103,101,114,59,1,8225,114,59,1,8650,116,115,101,113,59,1,10871,4,3,103,108,109,8895,8902,8907,5,176,1,59,8900,1,176,116,97,59,1,948,112,116,121,118,59,1,10673,4,2,105,114,8920,8926,115,104,116,59,1,10623,59,3,55349,56609,97,114,4,2,108,114,8938,8941,59,1,8643,59,1,8642,4,5,97,101,103,115,118,8956,8986,8989,8996,9001,109,4,3,59,111,115,8965,8967,8983,1,8900,110,100,4,2,59,115,8975,8977,1,8900,117,105,116,59,1,9830,59,1,9830,59,1,168,97,109,109,97,59,1,989,105,110,59,1,8946,4,3,59,105,111,9009,9011,9031,1,247,100,101,5,247,2,59,111,9020,9022,1,247,110,116,105,109,101,115,59,1,8903,110,120,59,1,8903,99,121,59,1,1106,99,4,2,111,114,9048,9053,114,110,59,1,8990,111,112,59,1,8973,4,5,108,112,116,117,119,9070,9076,9081,9130,9144,108,97,114,59,1,36,102,59,3,55349,56661,4,5,59,101,109,112,115,9093,9095,9109,9116,9122,1,729,113,4,2,59,100,9102,9104,1,8784,111,116,59,1,8785,105,110,117,115,59,1,8760,108,117,115,59,1,8724,113,117,97,114,101,59,1,8865,98,108,101,98,97,114,119,101,100,103,101,59,1,8966,110,4,3,97,100,104,9153,9160,9172,114,114,111,119,59,1,8595,111,119,110,97,114,114,111,119,115,59,1,8650,97,114,112,111,111,110,4,2,108,114,9184,9190,101,102,116,59,1,8643,105,103,104,116,59,1,8642,4,2,98,99,9203,9211,107,97,114,111,119,59,1,10512,4,2,111,114,9217,9222,114,110,59,1,8991,111,112,59,1,8972,4,3,99,111,116,9235,9248,9252,4,2,114,121,9241,9245,59,3,55349,56505,59,1,1109,108,59,1,10742,114,111,107,59,1,273,4,2,100,114,9264,9269,111,116,59,1,8945,105,4,2,59,102,9276,9278,1,9663,59,1,9662,4,2,97,104,9287,9292,114,114,59,1,8693,97,114,59,1,10607,97,110,103,108,101,59,1,10662,4,2,99,105,9311,9315,121,59,1,1119,103,114,97,114,114,59,1,10239,4,18,68,97,99,100,101,102,103,108,109,110,111,112,113,114,115,116,117,120,9361,9376,9398,9439,9444,9447,9462,9495,9531,9585,9598,9614,9659,9755,9771,9792,9808,9826,4,2,68,111,9367,9372,111,116,59,1,10871,116,59,1,8785,4,2,99,115,9382,9392,117,116,101,5,233,1,59,9390,1,233,116,101,114,59,1,10862,4,4,97,105,111,121,9408,9414,9430,9436,114,111,110,59,1,283,114,4,2,59,99,9421,9423,1,8790,5,234,1,59,9428,1,234,108,111,110,59,1,8789,59,1,1101,111,116,59,1,279,59,1,8519,4,2,68,114,9453,9458,111,116,59,1,8786,59,3,55349,56610,4,3,59,114,115,9470,9472,9482,1,10906,97,118,101,5,232,1,59,9480,1,232,4,2,59,100,9488,9490,1,10902,111,116,59,1,10904,4,4,59,105,108,115,9505,9507,9515,9518,1,10905,110,116,101,114,115,59,1,9191,59,1,8467,4,2,59,100,9524,9526,1,10901,111,116,59,1,10903,4,3,97,112,115,9539,9544,9564,99,114,59,1,275,116,121,4,3,59,115,118,9554,9556,9561,1,8709,101,116,59,1,8709,59,1,8709,112,4,2,49,59,9571,9583,4,2,51,52,9577,9580,59,1,8196,59,1,8197,1,8195,4,2,103,115,9591,9594,59,1,331,112,59,1,8194,4,2,103,112,9604,9609,111,110,59,1,281,102,59,3,55349,56662,4,3,97,108,115,9622,9635,9640,114,4,2,59,115,9629,9631,1,8917,108,59,1,10723,117,115,59,1,10865,105,4,3,59,108,118,9649,9651,9656,1,949,111,110,59,1,949,59,1,1013,4,4,99,115,117,118,9669,9686,9716,9747,4,2,105,111,9675,9680,114,99,59,1,8790,108,111,110,59,1,8789,4,2,105,108,9692,9696,109,59,1,8770,97,110,116,4,2,103,108,9705,9710,116,114,59,1,10902,101,115,115,59,1,10901,4,3,97,101,105,9724,9729,9734,108,115,59,1,61,115,116,59,1,8799,118,4,2,59,68,9741,9743,1,8801,68,59,1,10872,112,97,114,115,108,59,1,10725,4,2,68,97,9761,9766,111,116,59,1,8787,114,114,59,1,10609,4,3,99,100,105,9779,9783,9788,114,59,1,8495,111,116,59,1,8784,109,59,1,8770,4,2,97,104,9798,9801,59,1,951,5,240,1,59,9806,1,240,4,2,109,114,9814,9822,108,5,235,1,59,9820,1,235,111,59,1,8364,4,3,99,105,112,9834,9838,9843,108,59,1,33,115,116,59,1,8707,4,2,101,111,9849,9859,99,116,97,116,105,111,110,59,1,8496,110,101,110,116,105,97,108,101,59,1,8519,4,12,97,99,101,102,105,106,108,110,111,112,114,115,9896,9910,9914,9921,9954,9960,9967,9989,9994,10027,10036,10164,108,108,105,110,103,100,111,116,115,101,113,59,1,8786,121,59,1,1092,109,97,108,101,59,1,9792,4,3,105,108,114,9929,9935,9950,108,105,103,59,1,64259,4,2,105,108,9941,9945,103,59,1,64256,105,103,59,1,64260,59,3,55349,56611,108,105,103,59,1,64257,108,105,103,59,3,102,106,4,3,97,108,116,9975,9979,9984,116,59,1,9837,105,103,59,1,64258,110,115,59,1,9649,111,102,59,1,402,4,2,112,114,10000,10005,102,59,3,55349,56663,4,2,97,107,10011,10016,108,108,59,1,8704,4,2,59,118,10022,10024,1,8916,59,1,10969,97,114,116,105,110,116,59,1,10765,4,2,97,111,10042,10159,4,2,99,115,10048,10155,4,6,49,50,51,52,53,55,10062,10102,10114,10135,10139,10151,4,6,50,51,52,53,54,56,10076,10083,10086,10093,10096,10099,5,189,1,59,10081,1,189,59,1,8531,5,188,1,59,10091,1,188,59,1,8533,59,1,8537,59,1,8539,4,2,51,53,10108,10111,59,1,8532,59,1,8534,4,3,52,53,56,10122,10129,10132,5,190,1,59,10127,1,190,59,1,8535,59,1,8540,53,59,1,8536,4,2,54,56,10145,10148,59,1,8538,59,1,8541,56,59,1,8542,108,59,1,8260,119,110,59,1,8994,99,114,59,3,55349,56507,4,17,69,97,98,99,100,101,102,103,105,106,108,110,111,114,115,116,118,10206,10217,10247,10254,10268,10273,10358,10363,10374,10380,10385,10406,10458,10464,10470,10497,10610,4,2,59,108,10212,10214,1,8807,59,1,10892,4,3,99,109,112,10225,10231,10244,117,116,101,59,1,501,109,97,4,2,59,100,10239,10241,1,947,59,1,989,59,1,10886,114,101,118,101,59,1,287,4,2,105,121,10260,10265,114,99,59,1,285,59,1,1075,111,116,59,1,289,4,4,59,108,113,115,10283,10285,10288,10308,1,8805,59,1,8923,4,3,59,113,115,10296,10298,10301,1,8805,59,1,8807,108,97,110,116,59,1,10878,4,4,59,99,100,108,10318,10320,10324,10345,1,10878,99,59,1,10921,111,116,4,2,59,111,10332,10334,1,10880,4,2,59,108,10340,10342,1,10882,59,1,10884,4,2,59,101,10351,10354,3,8923,65024,115,59,1,10900,114,59,3,55349,56612,4,2,59,103,10369,10371,1,8811,59,1,8921,109,101,108,59,1,8503,99,121,59,1,1107,4,4,59,69,97,106,10395,10397,10400,10403,1,8823,59,1,10898,59,1,10917,59,1,10916,4,4,69,97,101,115,10416,10419,10434,10453,59,1,8809,112,4,2,59,112,10426,10428,1,10890,114,111,120,59,1,10890,4,2,59,113,10440,10442,1,10888,4,2,59,113,10448,10450,1,10888,59,1,8809,105,109,59,1,8935,112,102,59,3,55349,56664,97,118,101,59,1,96,4,2,99,105,10476,10480,114,59,1,8458,109,4,3,59,101,108,10489,10491,10494,1,8819,59,1,10894,59,1,10896,5,62,6,59,99,100,108,113,114,10512,10514,10527,10532,10538,10545,1,62,4,2,99,105,10520,10523,59,1,10919,114,59,1,10874,111,116,59,1,8919,80,97,114,59,1,10645,117,101,115,116,59,1,10876,4,5,97,100,101,108,115,10557,10574,10579,10599,10605,4,2,112,114,10563,10570,112,114,111,120,59,1,10886,114,59,1,10616,111,116,59,1,8919,113,4,2,108,113,10586,10592,101,115,115,59,1,8923,108,101,115,115,59,1,10892,101,115,115,59,1,8823,105,109,59,1,8819,4,2,101,110,10616,10626,114,116,110,101,113,113,59,3,8809,65024,69,59,3,8809,65024,4,10,65,97,98,99,101,102,107,111,115,121,10653,10658,10713,10718,10724,10760,10765,10786,10850,10875,114,114,59,1,8660,4,4,105,108,109,114,10668,10674,10678,10684,114,115,112,59,1,8202,102,59,1,189,105,108,116,59,1,8459,4,2,100,114,10690,10695,99,121,59,1,1098,4,3,59,99,119,10703,10705,10710,1,8596,105,114,59,1,10568,59,1,8621,97,114,59,1,8463,105,114,99,59,1,293,4,3,97,108,114,10732,10748,10754,114,116,115,4,2,59,117,10741,10743,1,9829,105,116,59,1,9829,108,105,112,59,1,8230,99,111,110,59,1,8889,114,59,3,55349,56613,115,4,2,101,119,10772,10779,97,114,111,119,59,1,10533,97,114,111,119,59,1,10534,4,5,97,109,111,112,114,10798,10803,10809,10839,10844,114,114,59,1,8703,116,104,116,59,1,8763,107,4,2,108,114,10816,10827,101,102,116,97,114,114,111,119,59,1,8617,105,103,104,116,97,114,114,111,119,59,1,8618,102,59,3,55349,56665,98,97,114,59,1,8213,4,3,99,108,116,10858,10863,10869,114,59,3,55349,56509,97,115,104,59,1,8463,114,111,107,59,1,295,4,2,98,112,10881,10887,117,108,108,59,1,8259,104,101,110,59,1,8208,4,15,97,99,101,102,103,105,106,109,110,111,112,113,115,116,117,10925,10936,10958,10977,10990,11001,11039,11045,11101,11192,11220,11226,11237,11285,11299,99,117,116,101,5,237,1,59,10934,1,237,4,3,59,105,121,10944,10946,10955,1,8291,114,99,5,238,1,59,10953,1,238,59,1,1080,4,2,99,120,10964,10968,121,59,1,1077,99,108,5,161,1,59,10975,1,161,4,2,102,114,10983,10986,59,1,8660,59,3,55349,56614,114,97,118,101,5,236,1,59,10999,1,236,4,4,59,105,110,111,11011,11013,11028,11034,1,8520,4,2,105,110,11019,11024,110,116,59,1,10764,116,59,1,8749,102,105,110,59,1,10716,116,97,59,1,8489,108,105,103,59,1,307,4,3,97,111,112,11053,11092,11096,4,3,99,103,116,11061,11065,11088,114,59,1,299,4,3,101,108,112,11073,11076,11082,59,1,8465,105,110,101,59,1,8464,97,114,116,59,1,8465,104,59,1,305,102,59,1,8887,101,100,59,1,437,4,5,59,99,102,111,116,11113,11115,11121,11136,11142,1,8712,97,114,101,59,1,8453,105,110,4,2,59,116,11129,11131,1,8734,105,101,59,1,10717,100,111,116,59,1,305,4,5,59,99,101,108,112,11154,11156,11161,11179,11186,1,8747,97,108,59,1,8890,4,2,103,114,11167,11173,101,114,115,59,1,8484,99,97,108,59,1,8890,97,114,104,107,59,1,10775,114,111,100,59,1,10812,4,4,99,103,112,116,11202,11206,11211,11216,121,59,1,1105,111,110,59,1,303,102,59,3,55349,56666,97,59,1,953,114,111,100,59,1,10812,117,101,115,116,5,191,1,59,11235,1,191,4,2,99,105,11243,11248,114,59,3,55349,56510,110,4,5,59,69,100,115,118,11261,11263,11266,11271,11282,1,8712,59,1,8953,111,116,59,1,8949,4,2,59,118,11277,11279,1,8948,59,1,8947,59,1,8712,4,2,59,105,11291,11293,1,8290,108,100,101,59,1,297,4,2,107,109,11305,11310,99,121,59,1,1110,108,5,239,1,59,11316,1,239,4,6,99,102,109,111,115,117,11332,11346,11351,11357,11363,11380,4,2,105,121,11338,11343,114,99,59,1,309,59,1,1081,114,59,3,55349,56615,97,116,104,59,1,567,112,102,59,3,55349,56667,4,2,99,101,11369,11374,114,59,3,55349,56511,114,99,121,59,1,1112,107,99,121,59,1,1108,4,8,97,99,102,103,104,106,111,115,11404,11418,11433,11438,11445,11450,11455,11461,112,112,97,4,2,59,118,11413,11415,1,954,59,1,1008,4,2,101,121,11424,11430,100,105,108,59,1,311,59,1,1082,114,59,3,55349,56616,114,101,101,110,59,1,312,99,121,59,1,1093,99,121,59,1,1116,112,102,59,3,55349,56668,99,114,59,3,55349,56512,4,23,65,66,69,72,97,98,99,100,101,102,103,104,106,108,109,110,111,112,114,115,116,117,118,11515,11538,11544,11555,11560,11721,11780,11818,11868,12136,12160,12171,12203,12208,12246,12275,12327,12509,12523,12569,12641,12732,12752,4,3,97,114,116,11523,11528,11532,114,114,59,1,8666,114,59,1,8656,97,105,108,59,1,10523,97,114,114,59,1,10510,4,2,59,103,11550,11552,1,8806,59,1,10891,97,114,59,1,10594,4,9,99,101,103,109,110,112,113,114,116,11580,11586,11594,11600,11606,11624,11627,11636,11694,117,116,101,59,1,314,109,112,116,121,118,59,1,10676,114,97,110,59,1,8466,98,100,97,59,1,955,103,4,3,59,100,108,11615,11617,11620,1,10216,59,1,10641,101,59,1,10216,59,1,10885,117,111,5,171,1,59,11634,1,171,114,4,8,59,98,102,104,108,112,115,116,11655,11657,11669,11673,11677,11681,11685,11690,1,8592,4,2,59,102,11663,11665,1,8676,115,59,1,10527,115,59,1,10525,107,59,1,8617,112,59,1,8619,108,59,1,10553,105,109,59,1,10611,108,59,1,8610,4,3,59,97,101,11702,11704,11709,1,10923,105,108,59,1,10521,4,2,59,115,11715,11717,1,10925,59,3,10925,65024,4,3,97,98,114,11729,11734,11739,114,114,59,1,10508,114,107,59,1,10098,4,2,97,107,11745,11758,99,4,2,101,107,11752,11755,59,1,123,59,1,91,4,2,101,115,11764,11767,59,1,10635,108,4,2,100,117,11774,11777,59,1,10639,59,1,10637,4,4,97,101,117,121,11790,11796,11811,11815,114,111,110,59,1,318,4,2,100,105,11802,11807,105,108,59,1,316,108,59,1,8968,98,59,1,123,59,1,1083,4,4,99,113,114,115,11828,11832,11845,11864,97,59,1,10550,117,111,4,2,59,114,11840,11842,1,8220,59,1,8222,4,2,100,117,11851,11857,104,97,114,59,1,10599,115,104,97,114,59,1,10571,104,59,1,8626,4,5,59,102,103,113,115,11880,11882,12008,12011,12031,1,8804,116,4,5,97,104,108,114,116,11895,11913,11935,11947,11996,114,114,111,119,4,2,59,116,11905,11907,1,8592,97,105,108,59,1,8610,97,114,112,111,111,110,4,2,100,117,11925,11931,111,119,110,59,1,8637,112,59,1,8636,101,102,116,97,114,114,111,119,115,59,1,8647,105,103,104,116,4,3,97,104,115,11959,11974,11984,114,114,111,119,4,2,59,115,11969,11971,1,8596,59,1,8646,97,114,112,111,111,110,115,59,1,8651,113,117,105,103,97,114,114,111,119,59,1,8621,104,114,101,101,116,105,109,101,115,59,1,8907,59,1,8922,4,3,59,113,115,12019,12021,12024,1,8804,59,1,8806,108,97,110,116,59,1,10877,4,5,59,99,100,103,115,12043,12045,12049,12070,12083,1,10877,99,59,1,10920,111,116,4,2,59,111,12057,12059,1,10879,4,2,59,114,12065,12067,1,10881,59,1,10883,4,2,59,101,12076,12079,3,8922,65024,115,59,1,10899,4,5,97,100,101,103,115,12095,12103,12108,12126,12131,112,112,114,111,120,59,1,10885,111,116,59,1,8918,113,4,2,103,113,12115,12120,116,114,59,1,8922,103,116,114,59,1,10891,116,114,59,1,8822,105,109,59,1,8818,4,3,105,108,114,12144,12150,12156,115,104,116,59,1,10620,111,111,114,59,1,8970,59,3,55349,56617,4,2,59,69,12166,12168,1,8822,59,1,10897,4,2,97,98,12177,12198,114,4,2,100,117,12184,12187,59,1,8637,4,2,59,108,12193,12195,1,8636,59,1,10602,108,107,59,1,9604,99,121,59,1,1113,4,5,59,97,99,104,116,12220,12222,12227,12235,12241,1,8810,114,114,59,1,8647,111,114,110,101,114,59,1,8990,97,114,100,59,1,10603,114,105,59,1,9722,4,2,105,111,12252,12258,100,111,116,59,1,320,117,115,116,4,2,59,97,12267,12269,1,9136,99,104,101,59,1,9136,4,4,69,97,101,115,12285,12288,12303,12322,59,1,8808,112,4,2,59,112,12295,12297,1,10889,114,111,120,59,1,10889,4,2,59,113,12309,12311,1,10887,4,2,59,113,12317,12319,1,10887,59,1,8808,105,109,59,1,8934,4,8,97,98,110,111,112,116,119,122,12345,12359,12364,12421,12446,12467,12474,12490,4,2,110,114,12351,12355,103,59,1,10220,114,59,1,8701,114,107,59,1,10214,103,4,3,108,109,114,12373,12401,12409,101,102,116,4,2,97,114,12382,12389,114,114,111,119,59,1,10229,105,103,104,116,97,114,114,111,119,59,1,10231,97,112,115,116,111,59,1,10236,105,103,104,116,97,114,114,111,119,59,1,10230,112,97,114,114,111,119,4,2,108,114,12433,12439,101,102,116,59,1,8619,105,103,104,116,59,1,8620,4,3,97,102,108,12454,12458,12462,114,59,1,10629,59,3,55349,56669,117,115,59,1,10797,105,109,101,115,59,1,10804,4,2,97,98,12480,12485,115,116,59,1,8727,97,114,59,1,95,4,3,59,101,102,12498,12500,12506,1,9674,110,103,101,59,1,9674,59,1,10731,97,114,4,2,59,108,12517,12519,1,40,116,59,1,10643,4,5,97,99,104,109,116,12535,12540,12548,12561,12564,114,114,59,1,8646,111,114,110,101,114,59,1,8991,97,114,4,2,59,100,12556,12558,1,8651,59,1,10605,59,1,8206,114,105,59,1,8895,4,6,97,99,104,105,113,116,12583,12589,12594,12597,12614,12635,113,117,111,59,1,8249,114,59,3,55349,56513,59,1,8624,109,4,3,59,101,103,12606,12608,12611,1,8818,59,1,10893,59,1,10895,4,2,98,117,12620,12623,59,1,91,111,4,2,59,114,12630,12632,1,8216,59,1,8218,114,111,107,59,1,322,5,60,8,59,99,100,104,105,108,113,114,12660,12662,12675,12680,12686,12692,12698,12705,1,60,4,2,99,105,12668,12671,59,1,10918,114,59,1,10873,111,116,59,1,8918,114,101,101,59,1,8907,109,101,115,59,1,8905,97,114,114,59,1,10614,117,101,115,116,59,1,10875,4,2,80,105,12711,12716,97,114,59,1,10646,4,3,59,101,102,12724,12726,12729,1,9667,59,1,8884,59,1,9666,114,4,2,100,117,12739,12746,115,104,97,114,59,1,10570,104,97,114,59,1,10598,4,2,101,110,12758,12768,114,116,110,101,113,113,59,3,8808,65024,69,59,3,8808,65024,4,14,68,97,99,100,101,102,104,105,108,110,111,112,115,117,12803,12809,12893,12908,12914,12928,12933,12937,13011,13025,13032,13049,13052,13069,68,111,116,59,1,8762,4,4,99,108,112,114,12819,12827,12849,12887,114,5,175,1,59,12825,1,175,4,2,101,116,12833,12836,59,1,9794,4,2,59,101,12842,12844,1,10016,115,101,59,1,10016,4,2,59,115,12855,12857,1,8614,116,111,4,4,59,100,108,117,12869,12871,12877,12883,1,8614,111,119,110,59,1,8615,101,102,116,59,1,8612,112,59,1,8613,107,101,114,59,1,9646,4,2,111,121,12899,12905,109,109,97,59,1,10793,59,1,1084,97,115,104,59,1,8212,97,115,117,114,101,100,97,110,103,108,101,59,1,8737,114,59,3,55349,56618,111,59,1,8487,4,3,99,100,110,12945,12954,12985,114,111,5,181,1,59,12952,1,181,4,4,59,97,99,100,12964,12966,12971,12976,1,8739,115,116,59,1,42,105,114,59,1,10992,111,116,5,183,1,59,12983,1,183,117,115,4,3,59,98,100,12995,12997,13000,1,8722,59,1,8863,4,2,59,117,13006,13008,1,8760,59,1,10794,4,2,99,100,13017,13021,112,59,1,10971,114,59,1,8230,112,108,117,115,59,1,8723,4,2,100,112,13038,13044,101,108,115,59,1,8871,102,59,3,55349,56670,59,1,8723,4,2,99,116,13058,13063,114,59,3,55349,56514,112,111,115,59,1,8766,4,3,59,108,109,13077,13079,13087,1,956,116,105,109,97,112,59,1,8888,97,112,59,1,8888,4,24,71,76,82,86,97,98,99,100,101,102,103,104,105,106,108,109,111,112,114,115,116,117,118,119,13142,13165,13217,13229,13247,13330,13359,13414,13420,13508,13513,13579,13602,13626,13631,13762,13767,13855,13936,13995,14214,14285,14312,14432,4,2,103,116,13148,13152,59,3,8921,824,4,2,59,118,13158,13161,3,8811,8402,59,3,8811,824,4,3,101,108,116,13173,13200,13204,102,116,4,2,97,114,13181,13188,114,114,111,119,59,1,8653,105,103,104,116,97,114,114,111,119,59,1,8654,59,3,8920,824,4,2,59,118,13210,13213,3,8810,8402,59,3,8810,824,105,103,104,116,97,114,114,111,119,59,1,8655,4,2,68,100,13235,13241,97,115,104,59,1,8879,97,115,104,59,1,8878,4,5,98,99,110,112,116,13259,13264,13270,13275,13308,108,97,59,1,8711,117,116,101,59,1,324,103,59,3,8736,8402,4,5,59,69,105,111,112,13287,13289,13293,13298,13302,1,8777,59,3,10864,824,100,59,3,8779,824,115,59,1,329,114,111,120,59,1,8777,117,114,4,2,59,97,13316,13318,1,9838,108,4,2,59,115,13325,13327,1,9838,59,1,8469,4,2,115,117,13336,13344,112,5,160,1,59,13342,1,160,109,112,4,2,59,101,13352,13355,3,8782,824,59,3,8783,824,4,5,97,101,111,117,121,13371,13385,13391,13407,13411,4,2,112,114,13377,13380,59,1,10819,111,110,59,1,328,100,105,108,59,1,326,110,103,4,2,59,100,13399,13401,1,8775,111,116,59,3,10861,824,112,59,1,10818,59,1,1085,97,115,104,59,1,8211,4,7,59,65,97,100,113,115,120,13436,13438,13443,13466,13472,13478,13494,1,8800,114,114,59,1,8663,114,4,2,104,114,13450,13454,107,59,1,10532,4,2,59,111,13460,13462,1,8599,119,59,1,8599,111,116,59,3,8784,824,117,105,118,59,1,8802,4,2,101,105,13484,13489,97,114,59,1,10536,109,59,3,8770,824,105,115,116,4,2,59,115,13503,13505,1,8708,59,1,8708,114,59,3,55349,56619,4,4,69,101,115,116,13523,13527,13563,13568,59,3,8807,824,4,3,59,113,115,13535,13537,13559,1,8817,4,3,59,113,115,13545,13547,13551,1,8817,59,3,8807,824,108,97,110,116,59,3,10878,824,59,3,10878,824,105,109,59,1,8821,4,2,59,114,13574,13576,1,8815,59,1,8815,4,3,65,97,112,13587,13592,13597,114,114,59,1,8654,114,114,59,1,8622,97,114,59,1,10994,4,3,59,115,118,13610,13612,13623,1,8715,4,2,59,100,13618,13620,1,8956,59,1,8954,59,1,8715,99,121,59,1,1114,4,7,65,69,97,100,101,115,116,13647,13652,13656,13661,13665,13737,13742,114,114,59,1,8653,59,3,8806,824,114,114,59,1,8602,114,59,1,8229,4,4,59,102,113,115,13675,13677,13703,13725,1,8816,116,4,2,97,114,13684,13691,114,114,111,119,59,1,8602,105,103,104,116,97,114,114,111,119,59,1,8622,4,3,59,113,115,13711,13713,13717,1,8816,59,3,8806,824,108,97,110,116,59,3,10877,824,4,2,59,115,13731,13734,3,10877,824,59,1,8814,105,109,59,1,8820,4,2,59,114,13748,13750,1,8814,105,4,2,59,101,13757,13759,1,8938,59,1,8940,105,100,59,1,8740,4,2,112,116,13773,13778,102,59,3,55349,56671,5,172,3,59,105,110,13787,13789,13829,1,172,110,4,4,59,69,100,118,13800,13802,13806,13812,1,8713,59,3,8953,824,111,116,59,3,8949,824,4,3,97,98,99,13820,13823,13826,59,1,8713,59,1,8951,59,1,8950,105,4,2,59,118,13836,13838,1,8716,4,3,97,98,99,13846,13849,13852,59,1,8716,59,1,8958,59,1,8957,4,3,97,111,114,13863,13892,13899,114,4,4,59,97,115,116,13874,13876,13883,13888,1,8742,108,108,101,108,59,1,8742,108,59,3,11005,8421,59,3,8706,824,108,105,110,116,59,1,10772,4,3,59,99,101,13907,13909,13914,1,8832,117,101,59,1,8928,4,2,59,99,13920,13923,3,10927,824,4,2,59,101,13929,13931,1,8832,113,59,3,10927,824,4,4,65,97,105,116,13946,13951,13971,13982,114,114,59,1,8655,114,114,4,3,59,99,119,13961,13963,13967,1,8603,59,3,10547,824,59,3,8605,824,103,104,116,97,114,114,111,119,59,1,8603,114,105,4,2,59,101,13990,13992,1,8939,59,1,8941,4,7,99,104,105,109,112,113,117,14011,14036,14060,14080,14085,14090,14106,4,4,59,99,101,114,14021,14023,14028,14032,1,8833,117,101,59,1,8929,59,3,10928,824,59,3,55349,56515,111,114,116,4,2,109,112,14045,14050,105,100,59,1,8740,97,114,97,108,108,101,108,59,1,8742,109,4,2,59,101,14067,14069,1,8769,4,2,59,113,14075,14077,1,8772,59,1,8772,105,100,59,1,8740,97,114,59,1,8742,115,117,4,2,98,112,14098,14102,101,59,1,8930,101,59,1,8931,4,3,98,99,112,14114,14157,14171,4,4,59,69,101,115,14124,14126,14130,14133,1,8836,59,3,10949,824,59,1,8840,101,116,4,2,59,101,14141,14144,3,8834,8402,113,4,2,59,113,14151,14153,1,8840,59,3,10949,824,99,4,2,59,101,14164,14166,1,8833,113,59,3,10928,824,4,4,59,69,101,115,14181,14183,14187,14190,1,8837,59,3,10950,824,59,1,8841,101,116,4,2,59,101,14198,14201,3,8835,8402,113,4,2,59,113,14208,14210,1,8841,59,3,10950,824,4,4,103,105,108,114,14224,14228,14238,14242,108,59,1,8825,108,100,101,5,241,1,59,14236,1,241,103,59,1,8824,105,97,110,103,108,101,4,2,108,114,14254,14269,101,102,116,4,2,59,101,14263,14265,1,8938,113,59,1,8940,105,103,104,116,4,2,59,101,14279,14281,1,8939,113,59,1,8941,4,2,59,109,14291,14293,1,957,4,3,59,101,115,14301,14303,14308,1,35,114,111,59,1,8470,112,59,1,8199,4,9,68,72,97,100,103,105,108,114,115,14332,14338,14344,14349,14355,14369,14376,14408,14426,97,115,104,59,1,8877,97,114,114,59,1,10500,112,59,3,8781,8402,97,115,104,59,1,8876,4,2,101,116,14361,14365,59,3,8805,8402,59,3,62,8402,110,102,105,110,59,1,10718,4,3,65,101,116,14384,14389,14393,114,114,59,1,10498,59,3,8804,8402,4,2,59,114,14399,14402,3,60,8402,105,101,59,3,8884,8402,4,2,65,116,14414,14419,114,114,59,1,10499,114,105,101,59,3,8885,8402,105,109,59,3,8764,8402,4,3,65,97,110,14440,14445,14468,114,114,59,1,8662,114,4,2,104,114,14452,14456,107,59,1,10531,4,2,59,111,14462,14464,1,8598,119,59,1,8598,101,97,114,59,1,10535,4,18,83,97,99,100,101,102,103,104,105,108,109,111,112,114,115,116,117,118,14512,14515,14535,14560,14597,14603,14618,14643,14657,14662,14701,14741,14747,14769,14851,14877,14907,14916,59,1,9416,4,2,99,115,14521,14531,117,116,101,5,243,1,59,14529,1,243,116,59,1,8859,4,2,105,121,14541,14557,114,4,2,59,99,14548,14550,1,8858,5,244,1,59,14555,1,244,59,1,1086,4,5,97,98,105,111,115,14572,14577,14583,14587,14591,115,104,59,1,8861,108,97,99,59,1,337,118,59,1,10808,116,59,1,8857,111,108,100,59,1,10684,108,105,103,59,1,339,4,2,99,114,14609,14614,105,114,59,1,10687,59,3,55349,56620,4,3,111,114,116,14626,14630,14640,110,59,1,731,97,118,101,5,242,1,59,14638,1,242,59,1,10689,4,2,98,109,14649,14654,97,114,59,1,10677,59,1,937,110,116,59,1,8750,4,4,97,99,105,116,14672,14677,14693,14698,114,114,59,1,8634,4,2,105,114,14683,14687,114,59,1,10686,111,115,115,59,1,10683,110,101,59,1,8254,59,1,10688,4,3,97,101,105,14709,14714,14719,99,114,59,1,333,103,97,59,1,969,4,3,99,100,110,14727,14733,14736,114,111,110,59,1,959,59,1,10678,117,115,59,1,8854,112,102,59,3,55349,56672,4,3,97,101,108,14755,14759,14764,114,59,1,10679,114,112,59,1,10681,117,115,59,1,8853,4,7,59,97,100,105,111,115,118,14785,14787,14792,14831,14837,14841,14848,1,8744,114,114,59,1,8635,4,4,59,101,102,109,14802,14804,14817,14824,1,10845,114,4,2,59,111,14811,14813,1,8500,102,59,1,8500,5,170,1,59,14822,1,170,5,186,1,59,14829,1,186,103,111,102,59,1,8886,114,59,1,10838,108,111,112,101,59,1,10839,59,1,10843,4,3,99,108,111,14859,14863,14873,114,59,1,8500,97,115,104,5,248,1,59,14871,1,248,108,59,1,8856,105,4,2,108,109,14884,14893,100,101,5,245,1,59,14891,1,245,101,115,4,2,59,97,14901,14903,1,8855,115,59,1,10806,109,108,5,246,1,59,14914,1,246,98,97,114,59,1,9021,4,12,97,99,101,102,104,105,108,109,111,114,115,117,14948,14992,14996,15033,15038,15068,15090,15189,15192,15222,15427,15441,114,4,4,59,97,115,116,14959,14961,14976,14989,1,8741,5,182,2,59,108,14968,14970,1,182,108,101,108,59,1,8741,4,2,105,108,14982,14986,109,59,1,10995,59,1,11005,59,1,8706,121,59,1,1087,114,4,5,99,105,109,112,116,15009,15014,15019,15024,15027,110,116,59,1,37,111,100,59,1,46,105,108,59,1,8240,59,1,8869,101,110,107,59,1,8241,114,59,3,55349,56621,4,3,105,109,111,15046,15057,15063,4,2,59,118,15052,15054,1,966,59,1,981,109,97,116,59,1,8499,110,101,59,1,9742,4,3,59,116,118,15076,15078,15087,1,960,99,104,102,111,114,107,59,1,8916,59,1,982,4,2,97,117,15096,15119,110,4,2,99,107,15103,15115,107,4,2,59,104,15110,15112,1,8463,59,1,8462,118,59,1,8463,115,4,9,59,97,98,99,100,101,109,115,116,15140,15142,15148,15151,15156,15168,15171,15179,15184,1,43,99,105,114,59,1,10787,59,1,8862,105,114,59,1,10786,4,2,111,117,15162,15165,59,1,8724,59,1,10789,59,1,10866,110,5,177,1,59,15177,1,177,105,109,59,1,10790,119,111,59,1,10791,59,1,177,4,3,105,112,117,15200,15208,15213,110,116,105,110,116,59,1,10773,102,59,3,55349,56673,110,100,5,163,1,59,15220,1,163,4,10,59,69,97,99,101,105,110,111,115,117,15244,15246,15249,15253,15258,15334,15347,15367,15416,15421,1,8826,59,1,10931,112,59,1,10935,117,101,59,1,8828,4,2,59,99,15264,15266,1,10927,4,6,59,97,99,101,110,115,15280,15282,15290,15299,15303,15329,1,8826,112,112,114,111,120,59,1,10935,117,114,108,121,101,113,59,1,8828,113,59,1,10927,4,3,97,101,115,15311,15319,15324,112,112,114,111,120,59,1,10937,113,113,59,1,10933,105,109,59,1,8936,105,109,59,1,8830,109,101,4,2,59,115,15342,15344,1,8242,59,1,8473,4,3,69,97,115,15355,15358,15362,59,1,10933,112,59,1,10937,105,109,59,1,8936,4,3,100,102,112,15375,15378,15404,59,1,8719,4,3,97,108,115,15386,15392,15398,108,97,114,59,1,9006,105,110,101,59,1,8978,117,114,102,59,1,8979,4,2,59,116,15410,15412,1,8733,111,59,1,8733,105,109,59,1,8830,114,101,108,59,1,8880,4,2,99,105,15433,15438,114,59,3,55349,56517,59,1,968,110,99,115,112,59,1,8200,4,6,102,105,111,112,115,117,15462,15467,15472,15478,15485,15491,114,59,3,55349,56622,110,116,59,1,10764,112,102,59,3,55349,56674,114,105,109,101,59,1,8279,99,114,59,3,55349,56518,4,3,97,101,111,15499,15520,15534,116,4,2,101,105,15506,15515,114,110,105,111,110,115,59,1,8461,110,116,59,1,10774,115,116,4,2,59,101,15528,15530,1,63,113,59,1,8799,116,5,34,1,59,15540,1,34,4,21,65,66,72,97,98,99,100,101,102,104,105,108,109,110,111,112,114,115,116,117,120,15586,15609,15615,15620,15796,15855,15893,15931,15977,16001,16039,16183,16204,16222,16228,16285,16312,16318,16363,16408,16416,4,3,97,114,116,15594,15599,15603,114,114,59,1,8667,114,59,1,8658,97,105,108,59,1,10524,97,114,114,59,1,10511,97,114,59,1,10596,4,7,99,100,101,110,113,114,116,15636,15651,15656,15664,15687,15696,15770,4,2,101,117,15642,15646,59,3,8765,817,116,101,59,1,341,105,99,59,1,8730,109,112,116,121,118,59,1,10675,103,4,4,59,100,101,108,15675,15677,15680,15683,1,10217,59,1,10642,59,1,10661,101,59,1,10217,117,111,5,187,1,59,15694,1,187,114,4,11,59,97,98,99,102,104,108,112,115,116,119,15721,15723,15727,15739,15742,15746,15750,15754,15758,15763,15767,1,8594,112,59,1,10613,4,2,59,102,15733,15735,1,8677,115,59,1,10528,59,1,10547,115,59,1,10526,107,59,1,8618,112,59,1,8620,108,59,1,10565,105,109,59,1,10612,108,59,1,8611,59,1,8605,4,2,97,105,15776,15781,105,108,59,1,10522,111,4,2,59,110,15788,15790,1,8758,97,108,115,59,1,8474,4,3,97,98,114,15804,15809,15814,114,114,59,1,10509,114,107,59,1,10099,4,2,97,107,15820,15833,99,4,2,101,107,15827,15830,59,1,125,59,1,93,4,2,101,115,15839,15842,59,1,10636,108,4,2,100,117,15849,15852,59,1,10638,59,1,10640,4,4,97,101,117,121,15865,15871,15886,15890,114,111,110,59,1,345,4,2,100,105,15877,15882,105,108,59,1,343,108,59,1,8969,98,59,1,125,59,1,1088,4,4,99,108,113,115,15903,15907,15914,15927,97,59,1,10551,100,104,97,114,59,1,10601,117,111,4,2,59,114,15922,15924,1,8221,59,1,8221,104,59,1,8627,4,3,97,99,103,15939,15966,15970,108,4,4,59,105,112,115,15950,15952,15957,15963,1,8476,110,101,59,1,8475,97,114,116,59,1,8476,59,1,8477,116,59,1,9645,5,174,1,59,15975,1,174,4,3,105,108,114,15985,15991,15997,115,104,116,59,1,10621,111,111,114,59,1,8971,59,3,55349,56623,4,2,97,111,16007,16028,114,4,2,100,117,16014,16017,59,1,8641,4,2,59,108,16023,16025,1,8640,59,1,10604,4,2,59,118,16034,16036,1,961,59,1,1009,4,3,103,110,115,16047,16167,16171,104,116,4,6,97,104,108,114,115,116,16063,16081,16103,16130,16143,16155,114,114,111,119,4,2,59,116,16073,16075,1,8594,97,105,108,59,1,8611,97,114,112,111,111,110,4,2,100,117,16093,16099,111,119,110,59,1,8641,112,59,1,8640,101,102,116,4,2,97,104,16112,16120,114,114,111,119,115,59,1,8644,97,114,112,111,111,110,115,59,1,8652,105,103,104,116,97,114,114,111,119,115,59,1,8649,113,117,105,103,97,114,114,111,119,59,1,8605,104,114,101,101,116,105,109,101,115,59,1,8908,103,59,1,730,105,110,103,100,111,116,115,101,113,59,1,8787,4,3,97,104,109,16191,16196,16201,114,114,59,1,8644,97,114,59,1,8652,59,1,8207,111,117,115,116,4,2,59,97,16214,16216,1,9137,99,104,101,59,1,9137,109,105,100,59,1,10990,4,4,97,98,112,116,16238,16252,16257,16278,4,2,110,114,16244,16248,103,59,1,10221,114,59,1,8702,114,107,59,1,10215,4,3,97,102,108,16265,16269,16273,114,59,1,10630,59,3,55349,56675,117,115,59,1,10798,105,109,101,115,59,1,10805,4,2,97,112,16291,16304,114,4,2,59,103,16298,16300,1,41,116,59,1,10644,111,108,105,110,116,59,1,10770,97,114,114,59,1,8649,4,4,97,99,104,113,16328,16334,16339,16342,113,117,111,59,1,8250,114,59,3,55349,56519,59,1,8625,4,2,98,117,16348,16351,59,1,93,111,4,2,59,114,16358,16360,1,8217,59,1,8217,4,3,104,105,114,16371,16377,16383,114,101,101,59,1,8908,109,101,115,59,1,8906,105,4,4,59,101,102,108,16394,16396,16399,16402,1,9657,59,1,8885,59,1,9656,116,114,105,59,1,10702,108,117,104,97,114,59,1,10600,59,1,8478,4,19,97,98,99,100,101,102,104,105,108,109,111,112,113,114,115,116,117,119,122,16459,16466,16472,16572,16590,16672,16687,16746,16844,16850,16924,16963,16988,17115,17121,17154,17206,17614,17656,99,117,116,101,59,1,347,113,117,111,59,1,8218,4,10,59,69,97,99,101,105,110,112,115,121,16494,16496,16499,16513,16518,16531,16536,16556,16564,16569,1,8827,59,1,10932,4,2,112,114,16505,16508,59,1,10936,111,110,59,1,353,117,101,59,1,8829,4,2,59,100,16524,16526,1,10928,105,108,59,1,351,114,99,59,1,349,4,3,69,97,115,16544,16547,16551,59,1,10934,112,59,1,10938,105,109,59,1,8937,111,108,105,110,116,59,1,10771,105,109,59,1,8831,59,1,1089,111,116,4,3,59,98,101,16582,16584,16587,1,8901,59,1,8865,59,1,10854,4,7,65,97,99,109,115,116,120,16606,16611,16634,16642,16646,16652,16668,114,114,59,1,8664,114,4,2,104,114,16618,16622,107,59,1,10533,4,2,59,111,16628,16630,1,8600,119,59,1,8600,116,5,167,1,59,16640,1,167,105,59,1,59,119,97,114,59,1,10537,109,4,2,105,110,16659,16665,110,117,115,59,1,8726,59,1,8726,116,59,1,10038,114,4,2,59,111,16679,16682,3,55349,56624,119,110,59,1,8994,4,4,97,99,111,121,16697,16702,16716,16739,114,112,59,1,9839,4,2,104,121,16708,16713,99,121,59,1,1097,59,1,1096,114,116,4,2,109,112,16724,16729,105,100,59,1,8739,97,114,97,108,108,101,108,59,1,8741,5,173,1,59,16744,1,173,4,2,103,109,16752,16770,109,97,4,3,59,102,118,16762,16764,16767,1,963,59,1,962,59,1,962,4,8,59,100,101,103,108,110,112,114,16788,16790,16795,16806,16817,16828,16832,16838,1,8764,111,116,59,1,10858,4,2,59,113,16801,16803,1,8771,59,1,8771,4,2,59,69,16812,16814,1,10910,59,1,10912,4,2,59,69,16823,16825,1,10909,59,1,10911,101,59,1,8774,108,117,115,59,1,10788,97,114,114,59,1,10610,97,114,114,59,1,8592,4,4,97,101,105,116,16860,16883,16891,16904,4,2,108,115,16866,16878,108,115,101,116,109,105,110,117,115,59,1,8726,104,112,59,1,10803,112,97,114,115,108,59,1,10724,4,2,100,108,16897,16900,59,1,8739,101,59,1,8995,4,2,59,101,16910,16912,1,10922,4,2,59,115,16918,16920,1,10924,59,3,10924,65024,4,3,102,108,112,16932,16938,16958,116,99,121,59,1,1100,4,2,59,98,16944,16946,1,47,4,2,59,97,16952,16954,1,10692,114,59,1,9023,102,59,3,55349,56676,97,4,2,100,114,16970,16985,101,115,4,2,59,117,16978,16980,1,9824,105,116,59,1,9824,59,1,8741,4,3,99,115,117,16996,17028,17089,4,2,97,117,17002,17015,112,4,2,59,115,17009,17011,1,8851,59,3,8851,65024,112,4,2,59,115,17022,17024,1,8852,59,3,8852,65024,117,4,2,98,112,17035,17062,4,3,59,101,115,17043,17045,17048,1,8847,59,1,8849,101,116,4,2,59,101,17056,17058,1,8847,113,59,1,8849,4,3,59,101,115,17070,17072,17075,1,8848,59,1,8850,101,116,4,2,59,101,17083,17085,1,8848,113,59,1,8850,4,3,59,97,102,17097,17099,17112,1,9633,114,4,2,101,102,17106,17109,59,1,9633,59,1,9642,59,1,9642,97,114,114,59,1,8594,4,4,99,101,109,116,17131,17136,17142,17148,114,59,3,55349,56520,116,109,110,59,1,8726,105,108,101,59,1,8995,97,114,102,59,1,8902,4,2,97,114,17160,17172,114,4,2,59,102,17167,17169,1,9734,59,1,9733,4,2,97,110,17178,17202,105,103,104,116,4,2,101,112,17188,17197,112,115,105,108,111,110,59,1,1013,104,105,59,1,981,115,59,1,175,4,5,98,99,109,110,112,17218,17351,17420,17423,17427,4,9,59,69,100,101,109,110,112,114,115,17238,17240,17243,17248,17261,17267,17279,17285,17291,1,8834,59,1,10949,111,116,59,1,10941,4,2,59,100,17254,17256,1,8838,111,116,59,1,10947,117,108,116,59,1,10945,4,2,69,101,17273,17276,59,1,10955,59,1,8842,108,117,115,59,1,10943,97,114,114,59,1,10617,4,3,101,105,117,17299,17335,17339,116,4,3,59,101,110,17308,17310,17322,1,8834,113,4,2,59,113,17317,17319,1,8838,59,1,10949,101,113,4,2,59,113,17330,17332,1,8842,59,1,10955,109,59,1,10951,4,2,98,112,17345,17348,59,1,10965,59,1,10963,99,4,6,59,97,99,101,110,115,17366,17368,17376,17385,17389,17415,1,8827,112,112,114,111,120,59,1,10936,117,114,108,121,101,113,59,1,8829,113,59,1,10928,4,3,97,101,115,17397,17405,17410,112,112,114,111,120,59,1,10938,113,113,59,1,10934,105,109,59,1,8937,105,109,59,1,8831,59,1,8721,103,59,1,9834,4,13,49,50,51,59,69,100,101,104,108,109,110,112,115,17455,17462,17469,17476,17478,17481,17496,17509,17524,17530,17536,17548,17554,5,185,1,59,17460,1,185,5,178,1,59,17467,1,178,5,179,1,59,17474,1,179,1,8835,59,1,10950,4,2,111,115,17487,17491,116,59,1,10942,117,98,59,1,10968,4,2,59,100,17502,17504,1,8839,111,116,59,1,10948,115,4,2,111,117,17516,17520,108,59,1,10185,98,59,1,10967,97,114,114,59,1,10619,117,108,116,59,1,10946,4,2,69,101,17542,17545,59,1,10956,59,1,8843,108,117,115,59,1,10944,4,3,101,105,117,17562,17598,17602,116,4,3,59,101,110,17571,17573,17585,1,8835,113,4,2,59,113,17580,17582,1,8839,59,1,10950,101,113,4,2,59,113,17593,17595,1,8843,59,1,10956,109,59,1,10952,4,2,98,112,17608,17611,59,1,10964,59,1,10966,4,3,65,97,110,17622,17627,17650,114,114,59,1,8665,114,4,2,104,114,17634,17638,107,59,1,10534,4,2,59,111,17644,17646,1,8601,119,59,1,8601,119,97,114,59,1,10538,108,105,103,5,223,1,59,17664,1,223,4,13,97,98,99,100,101,102,104,105,111,112,114,115,119,17694,17709,17714,17737,17742,17749,17754,17860,17905,17957,17964,18090,18122,4,2,114,117,17700,17706,103,101,116,59,1,8982,59,1,964,114,107,59,1,9140,4,3,97,101,121,17722,17728,17734,114,111,110,59,1,357,100,105,108,59,1,355,59,1,1090,111,116,59,1,8411,108,114,101,99,59,1,8981,114,59,3,55349,56625,4,4,101,105,107,111,17764,17805,17836,17851,4,2,114,116,17770,17786,101,4,2,52,102,17777,17780,59,1,8756,111,114,101,59,1,8756,97,4,3,59,115,118,17795,17797,17802,1,952,121,109,59,1,977,59,1,977,4,2,99,110,17811,17831,107,4,2,97,115,17818,17826,112,112,114,111,120,59,1,8776,105,109,59,1,8764,115,112,59,1,8201,4,2,97,115,17842,17846,112,59,1,8776,105,109,59,1,8764,114,110,5,254,1,59,17858,1,254,4,3,108,109,110,17868,17873,17901,100,101,59,1,732,101,115,5,215,3,59,98,100,17884,17886,17898,1,215,4,2,59,97,17892,17894,1,8864,114,59,1,10801,59,1,10800,116,59,1,8749,4,3,101,112,115,17913,17917,17953,97,59,1,10536,4,4,59,98,99,102,17927,17929,17934,17939,1,8868,111,116,59,1,9014,105,114,59,1,10993,4,2,59,111,17945,17948,3,55349,56677,114,107,59,1,10970,97,59,1,10537,114,105,109,101,59,1,8244,4,3,97,105,112,17972,17977,18082,100,101,59,1,8482,4,7,97,100,101,109,112,115,116,17993,18051,18056,18059,18066,18072,18076,110,103,108,101,4,5,59,100,108,113,114,18009,18011,18017,18032,18035,1,9653,111,119,110,59,1,9663,101,102,116,4,2,59,101,18026,18028,1,9667,113,59,1,8884,59,1,8796,105,103,104,116,4,2,59,101,18045,18047,1,9657,113,59,1,8885,111,116,59,1,9708,59,1,8796,105,110,117,115,59,1,10810,108,117,115,59,1,10809,98,59,1,10701,105,109,101,59,1,10811,101,122,105,117,109,59,1,9186,4,3,99,104,116,18098,18111,18116,4,2,114,121,18104,18108,59,3,55349,56521,59,1,1094,99,121,59,1,1115,114,111,107,59,1,359,4,2,105,111,18128,18133,120,116,59,1,8812,104,101,97,100,4,2,108,114,18143,18154,101,102,116,97,114,114,111,119,59,1,8606,105,103,104,116,97,114,114,111,119,59,1,8608,4,18,65,72,97,98,99,100,102,103,104,108,109,111,112,114,115,116,117,119,18204,18209,18214,18234,18250,18268,18292,18308,18319,18343,18379,18397,18413,18504,18547,18553,18584,18603,114,114,59,1,8657,97,114,59,1,10595,4,2,99,114,18220,18230,117,116,101,5,250,1,59,18228,1,250,114,59,1,8593,114,4,2,99,101,18241,18245,121,59,1,1118,118,101,59,1,365,4,2,105,121,18256,18265,114,99,5,251,1,59,18263,1,251,59,1,1091,4,3,97,98,104,18276,18281,18287,114,114,59,1,8645,108,97,99,59,1,369,97,114,59,1,10606,4,2,105,114,18298,18304,115,104,116,59,1,10622,59,3,55349,56626,114,97,118,101,5,249,1,59,18317,1,249,4,2,97,98,18325,18338,114,4,2,108,114,18332,18335,59,1,8639,59,1,8638,108,107,59,1,9600,4,2,99,116,18349,18374,4,2,111,114,18355,18369,114,110,4,2,59,101,18363,18365,1,8988,114,59,1,8988,111,112,59,1,8975,114,105,59,1,9720,4,2,97,108,18385,18390,99,114,59,1,363,5,168,1,59,18395,1,168,4,2,103,112,18403,18408,111,110,59,1,371,102,59,3,55349,56678,4,6,97,100,104,108,115,117,18427,18434,18445,18470,18475,18494,114,114,111,119,59,1,8593,111,119,110,97,114,114,111,119,59,1,8597,97,114,112,111,111,110,4,2,108,114,18457,18463,101,102,116,59,1,8639,105,103,104,116,59,1,8638,117,115,59,1,8846,105,4,3,59,104,108,18484,18486,18489,1,965,59,1,978,111,110,59,1,965,112,97,114,114,111,119,115,59,1,8648,4,3,99,105,116,18512,18537,18542,4,2,111,114,18518,18532,114,110,4,2,59,101,18526,18528,1,8989,114,59,1,8989,111,112,59,1,8974,110,103,59,1,367,114,105,59,1,9721,99,114,59,3,55349,56522,4,3,100,105,114,18561,18566,18572,111,116,59,1,8944,108,100,101,59,1,361,105,4,2,59,102,18579,18581,1,9653,59,1,9652,4,2,97,109,18590,18595,114,114,59,1,8648,108,5,252,1,59,18601,1,252,97,110,103,108,101,59,1,10663,4,15,65,66,68,97,99,100,101,102,108,110,111,112,114,115,122,18643,18648,18661,18667,18847,18851,18857,18904,18909,18915,18931,18937,18943,18949,18996,114,114,59,1,8661,97,114,4,2,59,118,18656,18658,1,10984,59,1,10985,97,115,104,59,1,8872,4,2,110,114,18673,18679,103,114,116,59,1,10652,4,7,101,107,110,112,114,115,116,18695,18704,18711,18720,18742,18754,18810,112,115,105,108,111,110,59,1,1013,97,112,112,97,59,1,1008,111,116,104,105,110,103,59,1,8709,4,3,104,105,114,18728,18732,18735,105,59,1,981,59,1,982,111,112,116,111,59,1,8733,4,2,59,104,18748,18750,1,8597,111,59,1,1009,4,2,105,117,18760,18766,103,109,97,59,1,962,4,2,98,112,18772,18791,115,101,116,110,101,113,4,2,59,113,18784,18787,3,8842,65024,59,3,10955,65024,115,101,116,110,101,113,4,2,59,113,18803,18806,3,8843,65024,59,3,10956,65024,4,2,104,114,18816,18822,101,116,97,59,1,977,105,97,110,103,108,101,4,2,108,114,18834,18840,101,102,116,59,1,8882,105,103,104,116,59,1,8883,121,59,1,1074,97,115,104,59,1,8866,4,3,101,108,114,18865,18884,18890,4,3,59,98,101,18873,18875,18880,1,8744,97,114,59,1,8891,113,59,1,8794,108,105,112,59,1,8942,4,2,98,116,18896,18901,97,114,59,1,124,59,1,124,114,59,3,55349,56627,116,114,105,59,1,8882,115,117,4,2,98,112,18923,18927,59,3,8834,8402,59,3,8835,8402,112,102,59,3,55349,56679,114,111,112,59,1,8733,116,114,105,59,1,8883,4,2,99,117,18955,18960,114,59,3,55349,56523,4,2,98,112,18966,18981,110,4,2,69,101,18973,18977,59,3,10955,65024,59,3,8842,65024,110,4,2,69,101,18988,18992,59,3,10956,65024,59,3,8843,65024,105,103,122,97,103,59,1,10650,4,7,99,101,102,111,112,114,115,19020,19026,19061,19066,19072,19075,19089,105,114,99,59,1,373,4,2,100,105,19032,19055,4,2,98,103,19038,19043,97,114,59,1,10847,101,4,2,59,113,19050,19052,1,8743,59,1,8793,101,114,112,59,1,8472,114,59,3,55349,56628,112,102,59,3,55349,56680,59,1,8472,4,2,59,101,19081,19083,1,8768,97,116,104,59,1,8768,99,114,59,3,55349,56524,4,14,99,100,102,104,105,108,109,110,111,114,115,117,118,119,19125,19146,19152,19157,19173,19176,19192,19197,19202,19236,19252,19269,19286,19291,4,3,97,105,117,19133,19137,19142,112,59,1,8898,114,99,59,1,9711,112,59,1,8899,116,114,105,59,1,9661,114,59,3,55349,56629,4,2,65,97,19163,19168,114,114,59,1,10234,114,114,59,1,10231,59,1,958,4,2,65,97,19182,19187,114,114,59,1,10232,114,114,59,1,10229,97,112,59,1,10236,105,115,59,1,8955,4,3,100,112,116,19210,19215,19230,111,116,59,1,10752,4,2,102,108,19221,19225,59,3,55349,56681,117,115,59,1,10753,105,109,101,59,1,10754,4,2,65,97,19242,19247,114,114,59,1,10233,114,114,59,1,10230,4,2,99,113,19258,19263,114,59,3,55349,56525,99,117,112,59,1,10758,4,2,112,116,19275,19281,108,117,115,59,1,10756,114,105,59,1,9651,101,101,59,1,8897,101,100,103,101,59,1,8896,4,8,97,99,101,102,105,111,115,117,19316,19335,19349,19357,19362,19367,19373,19379,99,4,2,117,121,19323,19332,116,101,5,253,1,59,19330,1,253,59,1,1103,4,2,105,121,19341,19346,114,99,59,1,375,59,1,1099,110,5,165,1,59,19355,1,165,114,59,3,55349,56630,99,121,59,1,1111,112,102,59,3,55349,56682,99,114,59,3,55349,56526,4,2,99,109,19385,19389,121,59,1,1102,108,5,255,1,59,19395,1,255,4,10,97,99,100,101,102,104,105,111,115,119,19419,19426,19441,19446,19462,19467,19472,19480,19486,19492,99,117,116,101,59,1,378,4,2,97,121,19432,19438,114,111,110,59,1,382,59,1,1079,111,116,59,1,380,4,2,101,116,19452,19458,116,114,102,59,1,8488,97,59,1,950,114,59,3,55349,56631,99,121,59,1,1078,103,114,97,114,114,59,1,8669,112,102,59,3,55349,56683,99,114,59,3,55349,56527,4,2,106,110,19498,19501,59,1,8205,106,59,1,8204]);\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/parse5/lib/tokenizer/named-entity-data.js?");

/***/ }),

/***/ "./src/node_modules/parse5/lib/tokenizer/preprocessor.js":
/*!***************************************************************!*\
  !*** ./src/node_modules/parse5/lib/tokenizer/preprocessor.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst unicode = __webpack_require__(/*! ../common/unicode */ \"./src/node_modules/parse5/lib/common/unicode.js\");\nconst ERR = __webpack_require__(/*! ../common/error-codes */ \"./src/node_modules/parse5/lib/common/error-codes.js\");\n\n//Aliases\nconst $ = unicode.CODE_POINTS;\n\n//Const\nconst DEFAULT_BUFFER_WATERLINE = 1 << 16;\n\n//Preprocessor\n//NOTE: HTML input preprocessing\n//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#preprocessing-the-input-stream)\nclass Preprocessor {\n    constructor() {\n        this.html = null;\n\n        this.pos = -1;\n        this.lastGapPos = -1;\n        this.lastCharPos = -1;\n\n        this.gapStack = [];\n\n        this.skipNextNewLine = false;\n\n        this.lastChunkWritten = false;\n        this.endOfChunkHit = false;\n        this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;\n    }\n\n    _err() {\n        // NOTE: err reporting is noop by default. Enabled by mixin.\n    }\n\n    _addGap() {\n        this.gapStack.push(this.lastGapPos);\n        this.lastGapPos = this.pos;\n    }\n\n    _processSurrogate(cp) {\n        //NOTE: try to peek a surrogate pair\n        if (this.pos !== this.lastCharPos) {\n            const nextCp = this.html.charCodeAt(this.pos + 1);\n\n            if (unicode.isSurrogatePair(nextCp)) {\n                //NOTE: we have a surrogate pair. Peek pair character and recalculate code point.\n                this.pos++;\n\n                //NOTE: add gap that should be avoided during retreat\n                this._addGap();\n\n                return unicode.getSurrogatePairCodePoint(cp, nextCp);\n            }\n        }\n\n        //NOTE: we are at the end of a chunk, therefore we can't infer surrogate pair yet.\n        else if (!this.lastChunkWritten) {\n            this.endOfChunkHit = true;\n            return $.EOF;\n        }\n\n        //NOTE: isolated surrogate\n        this._err(ERR.surrogateInInputStream);\n\n        return cp;\n    }\n\n    dropParsedChunk() {\n        if (this.pos > this.bufferWaterline) {\n            this.lastCharPos -= this.pos;\n            this.html = this.html.substring(this.pos);\n            this.pos = 0;\n            this.lastGapPos = -1;\n            this.gapStack = [];\n        }\n    }\n\n    write(chunk, isLastChunk) {\n        if (this.html) {\n            this.html += chunk;\n        } else {\n            this.html = chunk;\n        }\n\n        this.lastCharPos = this.html.length - 1;\n        this.endOfChunkHit = false;\n        this.lastChunkWritten = isLastChunk;\n    }\n\n    insertHtmlAtCurrentPos(chunk) {\n        this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1, this.html.length);\n\n        this.lastCharPos = this.html.length - 1;\n        this.endOfChunkHit = false;\n    }\n\n    advance() {\n        this.pos++;\n\n        if (this.pos > this.lastCharPos) {\n            this.endOfChunkHit = !this.lastChunkWritten;\n            return $.EOF;\n        }\n\n        let cp = this.html.charCodeAt(this.pos);\n\n        //NOTE: any U+000A LINE FEED (LF) characters that immediately follow a U+000D CARRIAGE RETURN (CR) character\n        //must be ignored.\n        if (this.skipNextNewLine && cp === $.LINE_FEED) {\n            this.skipNextNewLine = false;\n            this._addGap();\n            return this.advance();\n        }\n\n        //NOTE: all U+000D CARRIAGE RETURN (CR) characters must be converted to U+000A LINE FEED (LF) characters\n        if (cp === $.CARRIAGE_RETURN) {\n            this.skipNextNewLine = true;\n            return $.LINE_FEED;\n        }\n\n        this.skipNextNewLine = false;\n\n        if (unicode.isSurrogate(cp)) {\n            cp = this._processSurrogate(cp);\n        }\n\n        //OPTIMIZATION: first check if code point is in the common allowed\n        //range (ASCII alphanumeric, whitespaces, big chunk of BMP)\n        //before going into detailed performance cost validation.\n        const isCommonValidRange =\n            (cp > 0x1f && cp < 0x7f) || cp === $.LINE_FEED || cp === $.CARRIAGE_RETURN || (cp > 0x9f && cp < 0xfdd0);\n\n        if (!isCommonValidRange) {\n            this._checkForProblematicCharacters(cp);\n        }\n\n        return cp;\n    }\n\n    _checkForProblematicCharacters(cp) {\n        if (unicode.isControlCodePoint(cp)) {\n            this._err(ERR.controlCharacterInInputStream);\n        } else if (unicode.isUndefinedCodePoint(cp)) {\n            this._err(ERR.noncharacterInInputStream);\n        }\n    }\n\n    retreat() {\n        if (this.pos === this.lastGapPos) {\n            this.lastGapPos = this.gapStack.pop();\n            this.pos--;\n        }\n\n        this.pos--;\n    }\n}\n\nmodule.exports = Preprocessor;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/parse5/lib/tokenizer/preprocessor.js?");

/***/ }),

/***/ "./src/node_modules/parse5/lib/tree-adapters/default.js":
/*!**************************************************************!*\
  !*** ./src/node_modules/parse5/lib/tree-adapters/default.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { DOCUMENT_MODE } = __webpack_require__(/*! ../common/html */ \"./src/node_modules/parse5/lib/common/html.js\");\n\n//Node construction\nexports.createDocument = function() {\n    return {\n        nodeName: '#document',\n        mode: DOCUMENT_MODE.NO_QUIRKS,\n        childNodes: []\n    };\n};\n\nexports.createDocumentFragment = function() {\n    return {\n        nodeName: '#document-fragment',\n        childNodes: []\n    };\n};\n\nexports.createElement = function(tagName, namespaceURI, attrs) {\n    return {\n        nodeName: tagName,\n        tagName: tagName,\n        attrs: attrs,\n        namespaceURI: namespaceURI,\n        childNodes: [],\n        parentNode: null\n    };\n};\n\nexports.createCommentNode = function(data) {\n    return {\n        nodeName: '#comment',\n        data: data,\n        parentNode: null\n    };\n};\n\nconst createTextNode = function(value) {\n    return {\n        nodeName: '#text',\n        value: value,\n        parentNode: null\n    };\n};\n\n//Tree mutation\nconst appendChild = (exports.appendChild = function(parentNode, newNode) {\n    parentNode.childNodes.push(newNode);\n    newNode.parentNode = parentNode;\n});\n\nconst insertBefore = (exports.insertBefore = function(parentNode, newNode, referenceNode) {\n    const insertionIdx = parentNode.childNodes.indexOf(referenceNode);\n\n    parentNode.childNodes.splice(insertionIdx, 0, newNode);\n    newNode.parentNode = parentNode;\n});\n\nexports.setTemplateContent = function(templateElement, contentElement) {\n    templateElement.content = contentElement;\n};\n\nexports.getTemplateContent = function(templateElement) {\n    return templateElement.content;\n};\n\nexports.setDocumentType = function(document, name, publicId, systemId) {\n    let doctypeNode = null;\n\n    for (let i = 0; i < document.childNodes.length; i++) {\n        if (document.childNodes[i].nodeName === '#documentType') {\n            doctypeNode = document.childNodes[i];\n            break;\n        }\n    }\n\n    if (doctypeNode) {\n        doctypeNode.name = name;\n        doctypeNode.publicId = publicId;\n        doctypeNode.systemId = systemId;\n    } else {\n        appendChild(document, {\n            nodeName: '#documentType',\n            name: name,\n            publicId: publicId,\n            systemId: systemId\n        });\n    }\n};\n\nexports.setDocumentMode = function(document, mode) {\n    document.mode = mode;\n};\n\nexports.getDocumentMode = function(document) {\n    return document.mode;\n};\n\nexports.detachNode = function(node) {\n    if (node.parentNode) {\n        const idx = node.parentNode.childNodes.indexOf(node);\n\n        node.parentNode.childNodes.splice(idx, 1);\n        node.parentNode = null;\n    }\n};\n\nexports.insertText = function(parentNode, text) {\n    if (parentNode.childNodes.length) {\n        const prevNode = parentNode.childNodes[parentNode.childNodes.length - 1];\n\n        if (prevNode.nodeName === '#text') {\n            prevNode.value += text;\n            return;\n        }\n    }\n\n    appendChild(parentNode, createTextNode(text));\n};\n\nexports.insertTextBefore = function(parentNode, text, referenceNode) {\n    const prevNode = parentNode.childNodes[parentNode.childNodes.indexOf(referenceNode) - 1];\n\n    if (prevNode && prevNode.nodeName === '#text') {\n        prevNode.value += text;\n    } else {\n        insertBefore(parentNode, createTextNode(text), referenceNode);\n    }\n};\n\nexports.adoptAttributes = function(recipient, attrs) {\n    const recipientAttrsMap = [];\n\n    for (let i = 0; i < recipient.attrs.length; i++) {\n        recipientAttrsMap.push(recipient.attrs[i].name);\n    }\n\n    for (let j = 0; j < attrs.length; j++) {\n        if (recipientAttrsMap.indexOf(attrs[j].name) === -1) {\n            recipient.attrs.push(attrs[j]);\n        }\n    }\n};\n\n//Tree traversing\nexports.getFirstChild = function(node) {\n    return node.childNodes[0];\n};\n\nexports.getChildNodes = function(node) {\n    return node.childNodes;\n};\n\nexports.getParentNode = function(node) {\n    return node.parentNode;\n};\n\nexports.getAttrList = function(element) {\n    return element.attrs;\n};\n\n//Node data\nexports.getTagName = function(element) {\n    return element.tagName;\n};\n\nexports.getNamespaceURI = function(element) {\n    return element.namespaceURI;\n};\n\nexports.getTextNodeContent = function(textNode) {\n    return textNode.value;\n};\n\nexports.getCommentNodeContent = function(commentNode) {\n    return commentNode.data;\n};\n\nexports.getDocumentTypeNodeName = function(doctypeNode) {\n    return doctypeNode.name;\n};\n\nexports.getDocumentTypeNodePublicId = function(doctypeNode) {\n    return doctypeNode.publicId;\n};\n\nexports.getDocumentTypeNodeSystemId = function(doctypeNode) {\n    return doctypeNode.systemId;\n};\n\n//Node types\nexports.isTextNode = function(node) {\n    return node.nodeName === '#text';\n};\n\nexports.isCommentNode = function(node) {\n    return node.nodeName === '#comment';\n};\n\nexports.isDocumentTypeNode = function(node) {\n    return node.nodeName === '#documentType';\n};\n\nexports.isElementNode = function(node) {\n    return !!node.tagName;\n};\n\n// Source code location\nexports.setNodeSourceCodeLocation = function(node, location) {\n    node.sourceCodeLocation = location;\n};\n\nexports.getNodeSourceCodeLocation = function(node) {\n    return node.sourceCodeLocation;\n};\n\nexports.updateNodeSourceCodeLocation = function(node, endLocation) {\n    node.sourceCodeLocation = Object.assign(node.sourceCodeLocation, endLocation);\n};\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/parse5/lib/tree-adapters/default.js?");

/***/ }),

/***/ "./src/node_modules/parse5/lib/utils/merge-options.js":
/*!************************************************************!*\
  !*** ./src/node_modules/parse5/lib/utils/merge-options.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function mergeOptions(defaults, options) {\n    options = options || Object.create(null);\n\n    return [defaults, options].reduce((merged, optObj) => {\n        Object.keys(optObj).forEach(key => {\n            merged[key] = optObj[key];\n        });\n\n        return merged;\n    }, Object.create(null));\n};\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/parse5/lib/utils/merge-options.js?");

/***/ }),

/***/ "./src/node_modules/parse5/lib/utils/mixin.js":
/*!****************************************************!*\
  !*** ./src/node_modules/parse5/lib/utils/mixin.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nclass Mixin {\n    constructor(host) {\n        const originalMethods = {};\n        const overriddenMethods = this._getOverriddenMethods(this, originalMethods);\n\n        for (const key of Object.keys(overriddenMethods)) {\n            if (typeof overriddenMethods[key] === 'function') {\n                originalMethods[key] = host[key];\n                host[key] = overriddenMethods[key];\n            }\n        }\n    }\n\n    _getOverriddenMethods() {\n        throw new Error('Not implemented');\n    }\n}\n\nMixin.install = function(host, Ctor, opts) {\n    if (!host.__mixins) {\n        host.__mixins = [];\n    }\n\n    for (let i = 0; i < host.__mixins.length; i++) {\n        if (host.__mixins[i].constructor === Ctor) {\n            return host.__mixins[i];\n        }\n    }\n\n    const mixin = new Ctor(host, opts);\n\n    host.__mixins.push(mixin);\n\n    return mixin;\n};\n\nmodule.exports = Mixin;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/parse5/lib/utils/mixin.js?");

/***/ }),

/***/ "./src/node_modules/regexp.prototype.flags/implementation.js":
/*!*******************************************************************!*\
  !*** ./src/node_modules/regexp.prototype.flags/implementation.js ***!
  \*******************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar $Object = Object;\nvar $TypeError = TypeError;\n\nmodule.exports = function flags() {\n\tif (this != null && this !== $Object(this)) {\n\t\tthrow new $TypeError('RegExp.prototype.flags getter called on non-object');\n\t}\n\tvar result = '';\n\tif (this.global) {\n\t\tresult += 'g';\n\t}\n\tif (this.ignoreCase) {\n\t\tresult += 'i';\n\t}\n\tif (this.multiline) {\n\t\tresult += 'm';\n\t}\n\tif (this.dotAll) {\n\t\tresult += 's';\n\t}\n\tif (this.unicode) {\n\t\tresult += 'u';\n\t}\n\tif (this.sticky) {\n\t\tresult += 'y';\n\t}\n\treturn result;\n};\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/regexp.prototype.flags/implementation.js?");

/***/ }),

/***/ "./src/node_modules/regexp.prototype.flags/index.js":
/*!**********************************************************!*\
  !*** ./src/node_modules/regexp.prototype.flags/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar define = __webpack_require__(/*! define-properties */ \"define-properties\");\nvar callBind = __webpack_require__(/*! call-bind */ \"call-bind\");\n\nvar implementation = __webpack_require__(/*! ./implementation */ \"./src/node_modules/regexp.prototype.flags/implementation.js\");\nvar getPolyfill = __webpack_require__(/*! ./polyfill */ \"./src/node_modules/regexp.prototype.flags/polyfill.js\");\nvar shim = __webpack_require__(/*! ./shim */ \"./src/node_modules/regexp.prototype.flags/shim.js\");\n\nvar flagsBound = callBind(implementation);\n\ndefine(flagsBound, {\n\tgetPolyfill: getPolyfill,\n\timplementation: implementation,\n\tshim: shim\n});\n\nmodule.exports = flagsBound;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/regexp.prototype.flags/index.js?");

/***/ }),

/***/ "./src/node_modules/regexp.prototype.flags/polyfill.js":
/*!*************************************************************!*\
  !*** ./src/node_modules/regexp.prototype.flags/polyfill.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar implementation = __webpack_require__(/*! ./implementation */ \"./src/node_modules/regexp.prototype.flags/implementation.js\");\n\nvar supportsDescriptors = __webpack_require__(/*! define-properties */ \"define-properties\").supportsDescriptors;\nvar $gOPD = Object.getOwnPropertyDescriptor;\nvar $TypeError = TypeError;\n\nmodule.exports = function getPolyfill() {\n\tif (!supportsDescriptors) {\n\t\tthrow new $TypeError('RegExp.prototype.flags requires a true ES5 environment that supports property descriptors');\n\t}\n\tif ((/a/mig).flags === 'gim') {\n\t\tvar descriptor = $gOPD(RegExp.prototype, 'flags');\n\t\tif (descriptor && typeof descriptor.get === 'function' && typeof (/a/).dotAll === 'boolean') {\n\t\t\treturn descriptor.get;\n\t\t}\n\t}\n\treturn implementation;\n};\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/regexp.prototype.flags/polyfill.js?");

/***/ }),

/***/ "./src/node_modules/regexp.prototype.flags/shim.js":
/*!*********************************************************!*\
  !*** ./src/node_modules/regexp.prototype.flags/shim.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar supportsDescriptors = __webpack_require__(/*! define-properties */ \"define-properties\").supportsDescriptors;\nvar getPolyfill = __webpack_require__(/*! ./polyfill */ \"./src/node_modules/regexp.prototype.flags/polyfill.js\");\nvar gOPD = Object.getOwnPropertyDescriptor;\nvar defineProperty = Object.defineProperty;\nvar TypeErr = TypeError;\nvar getProto = Object.getPrototypeOf;\nvar regex = /a/;\n\nmodule.exports = function shimFlags() {\n\tif (!supportsDescriptors || !getProto) {\n\t\tthrow new TypeErr('RegExp.prototype.flags requires a true ES5 environment that supports property descriptors');\n\t}\n\tvar polyfill = getPolyfill();\n\tvar proto = getProto(regex);\n\tvar descriptor = gOPD(proto, 'flags');\n\tif (!descriptor || descriptor.get !== polyfill) {\n\t\tdefineProperty(proto, 'flags', {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\tget: polyfill\n\t\t});\n\t}\n\treturn polyfill;\n};\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/regexp.prototype.flags/shim.js?");

/***/ }),

/***/ "./src/node_modules/snakeize/index.js":
/*!********************************************!*\
  !*** ./src/node_modules/snakeize/index.js ***!
  \********************************************/
/***/ ((module) => {

eval("module.exports = function walk (obj) {\n    if (!obj || typeof obj !== 'object') return obj;\n    if (isDate(obj) || isRegex(obj)) return obj;\n    if (Array.isArray(obj)) return obj.map(walk);\n    return Object.keys(obj).reduce(function (acc, key) {\n        var camel = key[0].toLowerCase() + key.slice(1).replace(/([A-Z]+)/g, function (m, x) {\n            return '_' + x.toLowerCase();\n        });\n        acc[camel] = walk(obj[key]);\n        return acc;\n    }, {});\n};\n\nvar isDate = function (obj) {\n    return Object.prototype.toString.call(obj) === '[object Date]';\n};\n\nvar isRegex = function (obj) {\n    return Object.prototype.toString.call(obj) === '[object RegExp]';\n};\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/snakeize/index.js?");

/***/ }),

/***/ "./src/node_modules/stream-events/index.js":
/*!*************************************************!*\
  !*** ./src/node_modules/stream-events/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar stubs = __webpack_require__(/*! stubs */ \"./src/node_modules/stubs/index.js\")\n\n/*\n * StreamEvents can be used 2 ways:\n *\n * 1:\n * function MyStream() {\n *   require('stream-events').call(this)\n * }\n *\n * 2:\n * require('stream-events')(myStream)\n */\nfunction StreamEvents(stream) {\n  stream = stream || this\n\n  var cfg = {\n    callthrough: true,\n    calls: 1\n  }\n\n  stubs(stream, '_read', cfg, stream.emit.bind(stream, 'reading'))\n  stubs(stream, '_write', cfg, stream.emit.bind(stream, 'writing'))\n\n  return stream\n}\n\nmodule.exports = StreamEvents\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/stream-events/index.js?");

/***/ }),

/***/ "./src/node_modules/streamsearch/lib/sbmh.js":
/*!***************************************************!*\
  !*** ./src/node_modules/streamsearch/lib/sbmh.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n  Based heavily on the Streaming Boyer-Moore-Horspool C++ implementation\n  by Hongli Lai at: https://github.com/FooBarWidget/boyer-moore-horspool\n*/\nvar EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter,\n    inherits = __webpack_require__(/*! util */ \"util\").inherits;\n\nfunction jsmemcmp(buf1, pos1, buf2, pos2, num) {\n  for (var i = 0; i < num; ++i, ++pos1, ++pos2)\n    if (buf1[pos1] !== buf2[pos2])\n      return false;\n  return true;\n}\n\nfunction SBMH(needle) {\n  if (typeof needle === 'string')\n    needle = new Buffer(needle);\n  var i, j, needle_len = needle.length;\n\n  this.maxMatches = Infinity;\n  this.matches = 0;\n\n  this._occ = new Array(256);\n  this._lookbehind_size = 0;\n  this._needle = needle;\n  this._bufpos = 0;\n\n  this._lookbehind = new Buffer(needle_len);\n\n  // Initialize occurrence table.\n  for (j = 0; j < 256; ++j)\n    this._occ[j] = needle_len;\n\n  // Populate occurrence table with analysis of the needle,\n  // ignoring last letter.\n  if (needle_len >= 1) {\n    for (i = 0; i < needle_len - 1; ++i)\n      this._occ[needle[i]] = needle_len - 1 - i;\n  }\n}\ninherits(SBMH, EventEmitter);\n\nSBMH.prototype.reset = function() {\n  this._lookbehind_size = 0;\n  this.matches = 0;\n  this._bufpos = 0;\n};\n\nSBMH.prototype.push = function(chunk, pos) {\n  var r, chlen;\n  if (!Buffer.isBuffer(chunk))\n    chunk = new Buffer(chunk, 'binary');\n  chlen = chunk.length;\n  this._bufpos = pos || 0;\n  while (r !== chlen && this.matches < this.maxMatches)\n    r = this._sbmh_feed(chunk);\n  return r;\n};\n\nSBMH.prototype._sbmh_feed = function(data) {\n  var len = data.length, needle = this._needle, needle_len = needle.length;\n\n  // Positive: points to a position in `data`\n  //           pos == 3 points to data[3]\n  // Negative: points to a position in the lookbehind buffer\n  //           pos == -2 points to lookbehind[lookbehind_size - 2]\n  var pos = -this._lookbehind_size,\n      last_needle_char = needle[needle_len - 1],\n      occ = this._occ,\n      lookbehind = this._lookbehind;\n\n  if (pos < 0) {\n    // Lookbehind buffer is not empty. Perform Boyer-Moore-Horspool\n    // search with character lookup code that considers both the\n    // lookbehind buffer and the current round's haystack data.\n    //\n    // Loop until\n    //   there is a match.\n    // or until\n    //   we've moved past the position that requires the\n    //   lookbehind buffer. In this case we switch to the\n    //   optimized loop.\n    // or until\n    //   the character to look at lies outside the haystack.\n    while (pos < 0 && pos <= len - needle_len) {\n       var ch = this._sbmh_lookup_char(data, pos + needle_len - 1);\n\n      if (ch === last_needle_char\n          && this._sbmh_memcmp(data, pos, needle_len - 1)) {\n        this._lookbehind_size = 0;\n        ++this.matches;\n        if (pos > -this._lookbehind_size)\n          this.emit('info', true, lookbehind, 0, this._lookbehind_size + pos);\n        else\n          this.emit('info', true);\n\n        this._bufpos = pos + needle_len;\n        return pos + needle_len;\n      } else\n        pos += occ[ch];\n    }\n\n    // No match.\n\n    if (pos < 0) {\n      // There's too few data for Boyer-Moore-Horspool to run,\n      // so let's use a different algorithm to skip as much as\n      // we can.\n      // Forward pos until\n      //   the trailing part of lookbehind + data\n      //   looks like the beginning of the needle\n      // or until\n      //   pos == 0\n      while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos))\n        pos++;\n    }\n\n    if (pos >= 0) {\n      // Discard lookbehind buffer.\n      this.emit('info', false, lookbehind, 0, this._lookbehind_size);\n      this._lookbehind_size = 0;\n    } else {\n      // Cut off part of the lookbehind buffer that has\n      // been processed and append the entire haystack\n      // into it.\n      var bytesToCutOff = this._lookbehind_size + pos;\n\n      if (bytesToCutOff > 0) {\n        // The cut off data is guaranteed not to contain the needle.\n        this.emit('info', false, lookbehind, 0, bytesToCutOff);\n      }\n\n      lookbehind.copy(lookbehind, 0, bytesToCutOff,\n                      this._lookbehind_size - bytesToCutOff);\n      this._lookbehind_size -= bytesToCutOff;\n\n      data.copy(lookbehind, this._lookbehind_size);\n      this._lookbehind_size += len;\n\n      this._bufpos = len;\n      return len;\n    }\n  }\n\n  if (pos >= 0)\n    pos += this._bufpos;\n\n  // Lookbehind buffer is now empty. Perform Boyer-Moore-Horspool\n  // search with optimized character lookup code that only considers\n  // the current round's haystack data.\n  while (pos <= len - needle_len) {\n    var ch = data[pos + needle_len - 1];\n\n    if (ch === last_needle_char\n        && data[pos] === needle[0]\n        && jsmemcmp(needle, 0, data, pos, needle_len - 1)) {\n      ++this.matches;\n      if (pos > 0)\n        this.emit('info', true, data, this._bufpos, pos);\n      else\n        this.emit('info', true);\n\n      this._bufpos = pos + needle_len;\n      return pos + needle_len;\n    } else\n      pos += occ[ch];\n  }\n\n  // There was no match. If there's trailing haystack data that we cannot\n  // match yet using the Boyer-Moore-Horspool algorithm (because the trailing\n  // data is less than the needle size) then match using a modified\n  // algorithm that starts matching from the beginning instead of the end.\n  // Whatever trailing data is left after running this algorithm is added to\n  // the lookbehind buffer.\n  if (pos < len) {\n    while (pos < len && (data[pos] !== needle[0]\n                         || !jsmemcmp(data, pos, needle, 0, len - pos))) {\n      ++pos;\n    }\n    if (pos < len) {\n      data.copy(lookbehind, 0, pos, pos + (len - pos));\n      this._lookbehind_size = len - pos;\n    }\n  }\n\n  // Everything until pos is guaranteed not to contain needle data.\n  if (pos > 0)\n    this.emit('info', false, data, this._bufpos, pos < len ? pos : len);\n\n  this._bufpos = len;\n  return len;\n};\n\nSBMH.prototype._sbmh_lookup_char = function(data, pos) {\n  if (pos < 0)\n    return this._lookbehind[this._lookbehind_size + pos];\n  else\n    return data[pos];\n}\n\nSBMH.prototype._sbmh_memcmp = function(data, pos, len) {\n  var i = 0;\n\n  while (i < len) {\n    if (this._sbmh_lookup_char(data, pos + i) === this._needle[i])\n      ++i;\n    else\n      return false;\n  }\n  return true;\n}\n\nmodule.exports = SBMH;\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/streamsearch/lib/sbmh.js?");

/***/ }),

/***/ "./src/node_modules/stubs/index.js":
/*!*****************************************!*\
  !*** ./src/node_modules/stubs/index.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function stubs(obj, method, cfg, stub) {\n  if (!obj || !method || !obj[method])\n    throw new Error('You must provide an object and a key for an existing method')\n\n  if (!stub) {\n    stub = cfg\n    cfg = {}\n  }\n\n  stub = stub || function() {}\n\n  cfg.callthrough = cfg.callthrough || false\n  cfg.calls = cfg.calls || 0\n\n  var norevert = cfg.calls === 0\n\n  var cached = obj[method].bind(obj)\n\n  obj[method] = function() {\n    var args = [].slice.call(arguments)\n    var returnVal\n\n    if (cfg.callthrough)\n      returnVal = cached.apply(obj, args)\n\n    returnVal = stub.apply(obj, args) || returnVal\n\n    if (!norevert && --cfg.calls === 0)\n      obj[method] = cached\n\n    return returnVal\n  }\n}\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/stubs/index.js?");

/***/ }),

/***/ "./src/node_modules/teeny-request/build/src/agents.js":
/*!************************************************************!*\
  !*** ./src/node_modules/teeny-request/build/src/agents.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar http_1 = __webpack_require__(/*! http */ \"http\");\nvar https_1 = __webpack_require__(/*! https */ \"https\");\nvar pool = new Map();\n/**\n * Returns a custom request Agent if one is found, otherwise returns undefined\n * which will result in the global http(s) Agent being used.\n * @private\n * @param {string} uri The request uri\n * @param {object} reqOpts The request options\n * @returns {Agent|undefined}\n */\nfunction getAgent(uri, reqOpts) {\n    var isHttp = uri.startsWith('http://');\n    var proxy = reqOpts.proxy ||\n        process.env.HTTP_PROXY ||\n        process.env.http_proxy ||\n        process.env.HTTPS_PROXY ||\n        process.env.https_proxy;\n    if (proxy) {\n        // tslint:disable-next-line variable-name\n        var Agent = isHttp\n            ? __webpack_require__(/*! http-proxy-agent */ \"http-proxy-agent\")\n            : __webpack_require__(/*! https-proxy-agent */ \"https-proxy-agent\");\n        return new Agent(proxy);\n    }\n    var key = isHttp ? 'http' : 'https';\n    if (reqOpts.forever) {\n        key += ':forever';\n        if (!pool.has(key)) {\n            // tslint:disable-next-line variable-name\n            var Agent = isHttp ? http_1.Agent : https_1.Agent;\n            pool.set(key, new Agent({ keepAlive: true }));\n        }\n    }\n    return pool.get(key);\n}\nexports.getAgent = getAgent;\n//# sourceMappingURL=agents.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/teeny-request/build/src/agents.js?");

/***/ }),

/***/ "./src/node_modules/teeny-request/build/src/index.js":
/*!***********************************************************!*\
  !*** ./src/node_modules/teeny-request/build/src/index.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n/*!\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar node_fetch_1 = __webpack_require__(/*! node-fetch */ \"node-fetch\");\nvar stream_1 = __webpack_require__(/*! stream */ \"stream\");\nvar uuid = __webpack_require__(/*! uuid */ \"uuid\");\nvar agents_1 = __webpack_require__(/*! ./agents */ \"./src/node_modules/teeny-request/build/src/agents.js\");\nvar streamEvents = __webpack_require__(/*! stream-events */ \"./src/node_modules/stream-events/index.js\");\nvar RequestError = /** @class */ (function (_super) {\n    __extends(RequestError, _super);\n    function RequestError() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return RequestError;\n}(Error));\nexports.RequestError = RequestError;\n/**\n * Convert options from Request to Fetch format\n * @private\n * @param reqOpts Request options\n */\nfunction requestToFetchOptions(reqOpts) {\n    var options = __assign(__assign({ method: reqOpts.method || 'GET' }, (reqOpts.timeout && { timeout: reqOpts.timeout })), (typeof reqOpts.gzip === 'boolean' && { compress: reqOpts.gzip }));\n    if (typeof reqOpts.json === 'object') {\n        // Add Content-type: application/json header\n        reqOpts.headers = reqOpts.headers || {};\n        reqOpts.headers['Content-Type'] = 'application/json';\n        // Set body to JSON representation of value\n        options.body = JSON.stringify(reqOpts.json);\n    }\n    else {\n        if (typeof reqOpts.body !== 'string') {\n            options.body = JSON.stringify(reqOpts.body);\n        }\n        else {\n            options.body = reqOpts.body;\n        }\n    }\n    // tslint:disable-next-line no-any\n    options.headers = reqOpts.headers;\n    var uri = (reqOpts.uri ||\n        reqOpts.url);\n    if (reqOpts.useQuerystring === true || typeof reqOpts.qs === 'object') {\n        var qs = __webpack_require__(/*! querystring */ \"querystring\");\n        var params = qs.stringify(reqOpts.qs);\n        uri = uri + '?' + params;\n    }\n    options.agent = agents_1.getAgent(uri, reqOpts);\n    return { uri: uri, options: options };\n}\n/**\n * Convert a response from `fetch` to `request` format.\n * @private\n * @param opts The `request` options used to create the request.\n * @param res The Fetch response\n * @returns A `request` response object\n */\nfunction fetchToRequestResponse(opts, res) {\n    var request = {};\n    request.agent = opts.agent || false;\n    request.headers = (opts.headers || {});\n    request.href = res.url;\n    // headers need to be converted from a map to an obj\n    var resHeaders = {};\n    res.headers.forEach(function (value, key) { return (resHeaders[key] = value); });\n    var response = Object.assign(res.body, {\n        statusCode: res.status,\n        statusMessage: res.statusText,\n        request: request,\n        body: res.body,\n        headers: resHeaders,\n        toJSON: function () { return ({ headers: resHeaders }); },\n    });\n    return response;\n}\n/**\n * Create POST body from two parts as multipart/related content-type\n * @private\n * @param boundary\n * @param multipart\n */\nfunction createMultipartStream(boundary, multipart) {\n    var finale = \"--\" + boundary + \"--\";\n    var stream = new stream_1.PassThrough();\n    for (var _i = 0, multipart_1 = multipart; _i < multipart_1.length; _i++) {\n        var part = multipart_1[_i];\n        var preamble = \"--\" + boundary + \"\\r\\nContent-Type: \" + part['Content-Type'] + \"\\r\\n\\r\\n\";\n        stream.write(preamble);\n        if (typeof part.body === 'string') {\n            stream.write(part.body);\n            stream.write('\\r\\n');\n        }\n        else {\n            part.body.pipe(stream, { end: false });\n            part.body.on('end', function () {\n                stream.write('\\r\\n');\n                stream.write(finale);\n                stream.end();\n            });\n        }\n    }\n    return stream;\n}\nfunction teenyRequest(reqOpts, callback) {\n    var _a = requestToFetchOptions(reqOpts), uri = _a.uri, options = _a.options;\n    var multipart = reqOpts.multipart;\n    if (reqOpts.multipart && multipart.length === 2) {\n        if (!callback) {\n            // TODO: add support for multipart uploads through streaming\n            throw new Error('Multipart without callback is not implemented.');\n        }\n        var boundary = uuid.v4();\n        options.headers['Content-Type'] = \"multipart/related; boundary=\" + boundary;\n        options.body = createMultipartStream(boundary, multipart);\n        // Multipart upload\n        node_fetch_1.default(uri, options).then(function (res) {\n            var header = res.headers.get('content-type');\n            var response = fetchToRequestResponse(options, res);\n            var body = response.body;\n            if (header === 'application/json' ||\n                header === 'application/json; charset=utf-8') {\n                res.json().then(function (json) {\n                    response.body = json;\n                    callback(null, response, json);\n                }, function (err) {\n                    callback(err, response, body);\n                });\n                return;\n            }\n            res.text().then(function (text) {\n                response.body = text;\n                callback(null, response, text);\n            }, function (err) {\n                callback(err, response, body);\n            });\n        }, function (err) {\n            callback(err, null, null);\n        });\n        return;\n    }\n    if (callback === undefined) {\n        // Stream mode\n        var requestStream_1 = streamEvents(new stream_1.PassThrough());\n        // tslint:disable-next-line no-any\n        var responseStream_1;\n        requestStream_1.once('reading', function () {\n            if (responseStream_1) {\n                responseStream_1.pipe(requestStream_1);\n            }\n            else {\n                requestStream_1.once('response', function () {\n                    responseStream_1.pipe(requestStream_1);\n                });\n            }\n        });\n        options.compress = false;\n        node_fetch_1.default(uri, options).then(function (res) {\n            responseStream_1 = res.body;\n            responseStream_1.on('error', function (err) {\n                requestStream_1.emit('error', err);\n            });\n            var response = fetchToRequestResponse(options, res);\n            requestStream_1.emit('response', response);\n        }, function (err) {\n            requestStream_1.emit('error', err);\n        });\n        // fetch doesn't supply the raw HTTP stream, instead it\n        // returns a PassThrough piped from the HTTP response\n        // stream.\n        return requestStream_1;\n    }\n    // GET or POST with callback\n    node_fetch_1.default(uri, options).then(function (res) {\n        var header = res.headers.get('content-type');\n        var response = fetchToRequestResponse(options, res);\n        var body = response.body;\n        if (header === 'application/json' ||\n            header === 'application/json; charset=utf-8') {\n            if (response.statusCode === 204) {\n                // Probably a DELETE\n                callback(null, response, body);\n                return;\n            }\n            res.json().then(function (json) {\n                response.body = json;\n                callback(null, response, json);\n            }, function (err) {\n                callback(err, response, body);\n            });\n            return;\n        }\n        res.text().then(function (text) {\n            var response = fetchToRequestResponse(options, res);\n            response.body = text;\n            callback(null, response, text);\n        }, function (err) {\n            callback(err, response, body);\n        });\n    }, function (err) {\n        callback(err, null, null);\n    });\n    return;\n}\nexports.teenyRequest = teenyRequest;\nteenyRequest.defaults = function (defaults) {\n    return function (reqOpts, callback) {\n        var opts = __assign(__assign({}, defaults), reqOpts);\n        if (callback === undefined) {\n            return teenyRequest(opts);\n        }\n        teenyRequest(opts, callback);\n    };\n};\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/teeny-request/build/src/index.js?");

/***/ }),

/***/ "./src/node_modules/which-boxed-primitive/index.js":
/*!*********************************************************!*\
  !*** ./src/node_modules/which-boxed-primitive/index.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar isString = __webpack_require__(/*! is-string */ \"./src/node_modules/is-string/index.js\");\nvar isNumber = __webpack_require__(/*! is-number-object */ \"./src/node_modules/is-number-object/index.js\");\nvar isBoolean = __webpack_require__(/*! is-boolean-object */ \"./src/node_modules/is-boolean-object/index.js\");\nvar isSymbol = __webpack_require__(/*! is-symbol */ \"./src/node_modules/is-symbol/index.js\");\nvar isBigInt = __webpack_require__(/*! is-bigint */ \"./src/node_modules/is-bigint/index.js\");\n\n// eslint-disable-next-line consistent-return\nmodule.exports = function whichBoxedPrimitive(value) {\n\t// eslint-disable-next-line eqeqeq\n\tif (value == null || (typeof value !== 'object' && typeof value !== 'function')) {\n\t\treturn null;\n\t}\n\tif (isString(value)) {\n\t\treturn 'String';\n\t}\n\tif (isNumber(value)) {\n\t\treturn 'Number';\n\t}\n\tif (isBoolean(value)) {\n\t\treturn 'Boolean';\n\t}\n\tif (isSymbol(value)) {\n\t\treturn 'Symbol';\n\t}\n\tif (isBigInt(value)) {\n\t\treturn 'BigInt';\n\t}\n};\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/which-boxed-primitive/index.js?");

/***/ }),

/***/ "./src/node_modules/which-collection/index.js":
/*!****************************************************!*\
  !*** ./src/node_modules/which-collection/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar isMap = __webpack_require__(/*! is-map */ \"./src/node_modules/is-map/index.js\");\nvar isSet = __webpack_require__(/*! is-set */ \"./src/node_modules/is-set/index.js\");\nvar isWeakMap = __webpack_require__(/*! is-weakmap */ \"./src/node_modules/is-weakmap/index.js\");\nvar isWeakSet = __webpack_require__(/*! is-weakset */ \"./src/node_modules/is-weakset/index.js\");\n\nmodule.exports = function whichCollection(value) {\n\tif (value && typeof value === 'object') {\n\t\tif (isMap(value)) {\n\t\t\treturn 'Map';\n\t\t}\n\t\tif (isSet(value)) {\n\t\t\treturn 'Set';\n\t\t}\n\t\tif (isWeakMap(value)) {\n\t\t\treturn 'WeakMap';\n\t\t}\n\t\tif (isWeakSet(value)) {\n\t\t\treturn 'WeakSet';\n\t\t}\n\t}\n\treturn false;\n};\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/which-collection/index.js?");

/***/ }),

/***/ "./src/node_modules/which-typed-array/index.js":
/*!*****************************************************!*\
  !*** ./src/node_modules/which-typed-array/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar forEach = __webpack_require__(/*! foreach */ \"./src/node_modules/foreach/index.js\");\nvar availableTypedArrays = __webpack_require__(/*! available-typed-arrays */ \"./src/node_modules/available-typed-arrays/index.js\");\nvar callBound = __webpack_require__(/*! call-bind/callBound */ \"call-bind/callBound\");\n\nvar $toString = callBound('Object.prototype.toString');\nvar hasSymbols = __webpack_require__(/*! has-symbols */ \"has-symbols\")();\nvar hasToStringTag = hasSymbols && typeof Symbol.toStringTag === 'symbol';\n\nvar typedArrays = availableTypedArrays();\n\nvar $slice = callBound('String.prototype.slice');\nvar toStrTags = {};\nvar gOPD = __webpack_require__(/*! es-abstract/helpers/getOwnPropertyDescriptor */ \"./src/node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js\");\nvar getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');\nif (hasToStringTag && gOPD && getPrototypeOf) {\n\tforEach(typedArrays, function (typedArray) {\n\t\tif (typeof global[typedArray] === 'function') {\n\t\t\tvar arr = new global[typedArray]();\n\t\t\tif (!(Symbol.toStringTag in arr)) {\n\t\t\t\tthrow new EvalError('this engine has support for Symbol.toStringTag, but ' + typedArray + ' does not have the property! Please report this.');\n\t\t\t}\n\t\t\tvar proto = getPrototypeOf(arr);\n\t\t\tvar descriptor = gOPD(proto, Symbol.toStringTag);\n\t\t\tif (!descriptor) {\n\t\t\t\tvar superProto = getPrototypeOf(proto);\n\t\t\t\tdescriptor = gOPD(superProto, Symbol.toStringTag);\n\t\t\t}\n\t\t\ttoStrTags[typedArray] = descriptor.get;\n\t\t}\n\t});\n}\n\nvar tryTypedArrays = function tryAllTypedArrays(value) {\n\tvar foundName = false;\n\tforEach(toStrTags, function (getter, typedArray) {\n\t\tif (!foundName) {\n\t\t\ttry {\n\t\t\t\tvar name = getter.call(value);\n\t\t\t\tif (name === typedArray) {\n\t\t\t\t\tfoundName = name;\n\t\t\t\t}\n\t\t\t} catch (e) {}\n\t\t}\n\t});\n\treturn foundName;\n};\n\nvar isTypedArray = __webpack_require__(/*! is-typed-array */ \"./src/node_modules/is-typed-array/index.js\");\n\nmodule.exports = function whichTypedArray(value) {\n\tif (!isTypedArray(value)) { return false; }\n\tif (!hasToStringTag) { return $slice($toString(value), 8, -1); }\n\treturn tryTypedArrays(value);\n};\n\n\n//# sourceURL=webpack://shorter.recipes/./src/node_modules/which-typed-array/index.js?");

/***/ }),

/***/ "@google-cloud/paginator":
/*!******************************************!*\
  !*** external "@google-cloud/paginator" ***!
  \******************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@google-cloud/paginator");

/***/ }),

/***/ "@google-cloud/projectify":
/*!*******************************************!*\
  !*** external "@google-cloud/projectify" ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@google-cloud/projectify");

/***/ }),

/***/ "@google-cloud/promisify":
/*!******************************************!*\
  !*** external "@google-cloud/promisify" ***!
  \******************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@google-cloud/promisify");

/***/ }),

/***/ "@grpc/grpc-js":
/*!********************************!*\
  !*** external "@grpc/grpc-js" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = require("@grpc/grpc-js");

/***/ }),

/***/ "abort-controller":
/*!***********************************!*\
  !*** external "abort-controller" ***!
  \***********************************/
/***/ ((module) => {

"use strict";
module.exports = require("abort-controller");

/***/ }),

/***/ "arrify":
/*!*************************!*\
  !*** external "arrify" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("arrify");

/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),

/***/ "call-bind":
/*!****************************!*\
  !*** external "call-bind" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("call-bind");

/***/ }),

/***/ "call-bind/callBound":
/*!**************************************!*\
  !*** external "call-bind/callBound" ***!
  \**************************************/
/***/ ((module) => {

"use strict";
module.exports = require("call-bind/callBound");

/***/ }),

/***/ "compressible":
/*!*******************************!*\
  !*** external "compressible" ***!
  \*******************************/
/***/ ((module) => {

"use strict";
module.exports = require("compressible");

/***/ }),

/***/ "concat-stream":
/*!********************************!*\
  !*** external "concat-stream" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = require("concat-stream");

/***/ }),

/***/ "configstore":
/*!******************************!*\
  !*** external "configstore" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("configstore");

/***/ }),

/***/ "cors":
/*!***********************!*\
  !*** external "cors" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("cors");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "define-properties":
/*!************************************!*\
  !*** external "define-properties" ***!
  \************************************/
/***/ ((module) => {

"use strict";
module.exports = require("define-properties");

/***/ }),

/***/ "duplexify":
/*!****************************!*\
  !*** external "duplexify" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("duplexify");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ "extend":
/*!*************************!*\
  !*** external "extend" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("extend");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "gaxios":
/*!*************************!*\
  !*** external "gaxios" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("gaxios");

/***/ }),

/***/ "get-intrinsic":
/*!********************************!*\
  !*** external "get-intrinsic" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = require("get-intrinsic");

/***/ }),

/***/ "google-auth-library":
/*!**************************************!*\
  !*** external "google-auth-library" ***!
  \**************************************/
/***/ ((module) => {

"use strict";
module.exports = require("google-auth-library");

/***/ }),

/***/ "google-gax":
/*!*****************************!*\
  !*** external "google-gax" ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = require("google-gax");

/***/ }),

/***/ "has-symbols":
/*!******************************!*\
  !*** external "has-symbols" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("has-symbols");

/***/ }),

/***/ "has-symbols/shams":
/*!************************************!*\
  !*** external "has-symbols/shams" ***!
  \************************************/
/***/ ((module) => {

"use strict";
module.exports = require("has-symbols/shams");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ "http-proxy-agent":
/*!***********************************!*\
  !*** external "http-proxy-agent" ***!
  \***********************************/
/***/ ((module) => {

"use strict";
module.exports = require("http-proxy-agent");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ "https-proxy-agent":
/*!************************************!*\
  !*** external "https-proxy-agent" ***!
  \************************************/
/***/ ((module) => {

"use strict";
module.exports = require("https-proxy-agent");

/***/ }),

/***/ "isarray":
/*!**************************!*\
  !*** external "isarray" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("isarray");

/***/ }),

/***/ "jsonwebtoken":
/*!*******************************!*\
  !*** external "jsonwebtoken" ***!
  \*******************************/
/***/ ((module) => {

"use strict";
module.exports = require("jsonwebtoken");

/***/ }),

/***/ "lodash":
/*!*************************!*\
  !*** external "lodash" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("lodash");

/***/ }),

/***/ "mime":
/*!***********************!*\
  !*** external "mime" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("mime");

/***/ }),

/***/ "mime-types":
/*!*****************************!*\
  !*** external "mime-types" ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = require("mime-types");

/***/ }),

/***/ "node-fetch":
/*!*****************************!*\
  !*** external "node-fetch" ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = require("node-fetch");

/***/ }),

/***/ "node-forge":
/*!*****************************!*\
  !*** external "node-forge" ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = require("node-forge");

/***/ }),

/***/ "object-keys":
/*!******************************!*\
  !*** external "object-keys" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("object-keys");

/***/ }),

/***/ "object.assign":
/*!********************************!*\
  !*** external "object.assign" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = require("object.assign");

/***/ }),

/***/ "onetime":
/*!**************************!*\
  !*** external "onetime" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("onetime");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ "p-limit":
/*!**************************!*\
  !*** external "p-limit" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("p-limit");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "pumpify":
/*!**************************!*\
  !*** external "pumpify" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("pumpify");

/***/ }),

/***/ "punycode":
/*!***************************!*\
  !*** external "punycode" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("punycode");

/***/ }),

/***/ "querystring":
/*!******************************!*\
  !*** external "querystring" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("querystring");

/***/ }),

/***/ "retry-request":
/*!********************************!*\
  !*** external "retry-request" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = require("retry-request");

/***/ }),

/***/ "side-channel":
/*!*******************************!*\
  !*** external "side-channel" ***!
  \*******************************/
/***/ ((module) => {

"use strict";
module.exports = require("side-channel");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ "through2":
/*!***************************!*\
  !*** external "through2" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("through2");

/***/ }),

/***/ "tslib":
/*!************************!*\
  !*** external "tslib" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("tslib");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ "uuid":
/*!***********************!*\
  !*** external "uuid" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("uuid");

/***/ }),

/***/ "xdg-basedir":
/*!******************************!*\
  !*** external "xdg-basedir" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("xdg-basedir");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/harmony module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.hmd = (module) => {
/******/ 			module = Object.create(module);
/******/ 			if (!module.children) module.children = [];
/******/ 			Object.defineProperty(module, 'exports', {
/******/ 				enumerable: true,
/******/ 				set: () => {
/******/ 					throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);
/******/ 				}
/******/ 			});
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;